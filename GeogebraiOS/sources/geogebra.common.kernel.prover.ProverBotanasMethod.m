//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/prover/ProverBotanasMethod.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/cas/GeoGebraCAS.h"
#include "geogebra/common/cas/singularws/SingularWebService.h"
#include "geogebra/common/kernel/CASGenericInterface.h"
#include "geogebra/common/kernel/GeoGebraCasInterface.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoCircleThreePoints.h"
#include "geogebra/common/kernel/algos/AlgoCircleTwoPoints.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/SymbolicParametersBotanaAlgo.h"
#include "geogebra/common/kernel/algos/SymbolicParametersBotanaAlgoAre.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/prover/NDGDetector.h"
#include "geogebra/common/kernel/prover/NoSymbolicParametersException.h"
#include "geogebra/common/kernel/prover/ProverBotanasMethod.h"
#include "geogebra/common/kernel/prover/polynomial/Polynomial.h"
#include "geogebra/common/kernel/prover/polynomial/Variable.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/ProverSettings.h"
#include "geogebra/common/util/Prover.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "java/lang/Integer.h"
#include "java/lang/Throwable.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/Set.h"
#include "java/util/TreeSet.h"

@interface GeogebraCommonKernelProverProverBotanasMethod ()

+ (void)updateBotanaVarsInvWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)statement;

+ (id<JavaUtilList>)getCircleCentersWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)statement;

+ (IOSObjectArray *)create3FreePointsNeverCollinearNDGWithGeogebraCommonUtilProver:(GeogebraCommonUtilProver *)prover;

@end

static JavaUtilHashMap *GeogebraCommonKernelProverProverBotanasMethod_botanaVarsInv_;
J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelProverProverBotanasMethod, botanaVarsInv_, JavaUtilHashMap *)
J2OBJC_STATIC_FIELD_SETTER(GeogebraCommonKernelProverProverBotanasMethod, botanaVarsInv_, JavaUtilHashMap *)

__attribute__((unused)) static void GeogebraCommonKernelProverProverBotanasMethod_updateBotanaVarsInvWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoElement *statement);

__attribute__((unused)) static id<JavaUtilList> GeogebraCommonKernelProverProverBotanasMethod_getCircleCentersWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoElement *statement);

__attribute__((unused)) static IOSObjectArray *GeogebraCommonKernelProverProverBotanasMethod_create3FreePointsNeverCollinearNDGWithGeogebraCommonUtilProver_(GeogebraCommonUtilProver *prover);

@implementation GeogebraCommonKernelProverProverBotanasMethod

+ (void)updateBotanaVarsInvWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)statement {
  GeogebraCommonKernelProverProverBotanasMethod_updateBotanaVarsInvWithGeogebraCommonKernelGeosGeoElement_(statement);
}

+ (id<JavaUtilList>)getFreePointsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)statement {
  return GeogebraCommonKernelProverProverBotanasMethod_getFreePointsWithGeogebraCommonKernelGeosGeoElement_(statement);
}

+ (id<JavaUtilList>)getCircleCentersWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)statement {
  return GeogebraCommonKernelProverProverBotanasMethod_getCircleCentersWithGeogebraCommonKernelGeosGeoElement_(statement);
}

+ (IOSObjectArray *)create3FreePointsNeverCollinearNDGWithGeogebraCommonUtilProver:(GeogebraCommonUtilProver *)prover {
  return GeogebraCommonKernelProverProverBotanasMethod_create3FreePointsNeverCollinearNDGWithGeogebraCommonUtilProver_(prover);
}

+ (JavaUtilHashMap *)fixValuesWithGeogebraCommonUtilProver:(GeogebraCommonUtilProver *)prover
                                                   withInt:(jint)coords {
  return GeogebraCommonKernelProverProverBotanasMethod_fixValuesWithGeogebraCommonUtilProver_withInt_(prover, coords);
}

+ (GeogebraCommonUtilProver_ProofResultEnum *)proveWithGeogebraCommonUtilProver:(GeogebraCommonUtilProver *)prover {
  return GeogebraCommonKernelProverProverBotanasMethod_proveWithGeogebraCommonUtilProver_(prover);
}

- (instancetype)init {
  GeogebraCommonKernelProverProverBotanasMethod_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "updateBotanaVarsInvWithGeogebraCommonKernelGeosGeoElement:", "updateBotanaVarsInv", "V", 0xa, NULL, NULL },
    { "getFreePointsWithGeogebraCommonKernelGeosGeoElement:", "getFreePoints", "Ljava.util.List;", 0xc, NULL, NULL },
    { "getCircleCentersWithGeogebraCommonKernelGeosGeoElement:", "getCircleCenters", "Ljava.util.List;", 0xa, NULL, NULL },
    { "create3FreePointsNeverCollinearNDGWithGeogebraCommonUtilProver:", "create3FreePointsNeverCollinearNDG", "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0xa, NULL, NULL },
    { "fixValuesWithGeogebraCommonUtilProver:withInt:", "fixValues", "Ljava.util.HashMap;", 0x8, NULL, NULL },
    { "proveWithGeogebraCommonUtilProver:", "prove", "Lgeogebra.common.util.Prover$ProofResult;", 0x9, NULL, NULL },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "botanaVarsInv_", NULL, 0xa, "Ljava.util.HashMap;", &GeogebraCommonKernelProverProverBotanasMethod_botanaVarsInv_, "Ljava/util/HashMap<Ljava/util/List<Lgeogebra/common/kernel/prover/polynomial/Variable;>;Lgeogebra/common/kernel/geos/GeoElement;>;",  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelProverProverBotanasMethod = { 2, "ProverBotanasMethod", "geogebra.common.kernel.prover", NULL, 0x1, 7, methods, 1, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelProverProverBotanasMethod;
}

@end

void GeogebraCommonKernelProverProverBotanasMethod_updateBotanaVarsInvWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoElement *statement) {
  GeogebraCommonKernelProverProverBotanasMethod_initialize();
  if (GeogebraCommonKernelProverProverBotanasMethod_botanaVarsInv_ == nil) JreStrongAssignAndConsume(&GeogebraCommonKernelProverProverBotanasMethod_botanaVarsInv_, nil, new_JavaUtilHashMap_init());
  id<JavaUtilIterator> it = [((JavaUtilTreeSet *) nil_chk([((GeogebraCommonKernelGeosGeoElement *) nil_chk(statement)) getAllPredecessors])) iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    GeogebraCommonKernelGeosGeoElement *geo = [it next];
    IOSObjectArray *vars = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) nil_chk(((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
    if (vars != nil) {
      id<JavaUtilList> varsList = JavaUtilArrays_asListWithNSObjectArray_(vars);
      [((JavaUtilHashMap *) nil_chk(GeogebraCommonKernelProverProverBotanasMethod_botanaVarsInv_)) putWithId:varsList withId:geo];
    }
  }
}

id<JavaUtilList> GeogebraCommonKernelProverProverBotanasMethod_getFreePointsWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoElement *statement) {
  GeogebraCommonKernelProverProverBotanasMethod_initialize();
  id<JavaUtilList> freePoints = [new_JavaUtilArrayList_init() autorelease];
  id<JavaUtilIterator> it = [((JavaUtilTreeSet *) nil_chk([((GeogebraCommonKernelGeosGeoElement *) nil_chk(statement)) getAllPredecessors])) iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    GeogebraCommonKernelGeosGeoElement *geo = [it next];
    if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoPoint] && [geo getParentAlgorithm] == nil) {
      [freePoints addWithId:geo];
    }
  }
  return freePoints;
}

id<JavaUtilList> GeogebraCommonKernelProverProverBotanasMethod_getCircleCentersWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoElement *statement) {
  GeogebraCommonKernelProverProverBotanasMethod_initialize();
  id<JavaUtilList> circleCenters = [new_JavaUtilArrayList_init() autorelease];
  id<JavaUtilIterator> it = [((JavaUtilTreeSet *) nil_chk([((GeogebraCommonKernelGeosGeoElement *) nil_chk(statement)) getAllPredecessors])) iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    GeogebraCommonKernelGeosGeoElement *geo = [it next];
    if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoConic]) {
      if ([[geo getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoCircleTwoPoints class]] || [[geo getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoCircleThreePoints class]]) {
        IOSObjectArray *vars = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
        IOSObjectArray *center = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
        IOSObjectArray_Set(center, 0, IOSObjectArray_Get(nil_chk(vars), 0));
        IOSObjectArray_Set(center, 1, IOSObjectArray_Get(vars, 1));
        GeogebraCommonKernelGeosGeoElement *centerGeo = [((JavaUtilHashMap *) nil_chk(GeogebraCommonKernelProverProverBotanasMethod_botanaVarsInv_)) getWithId:JavaUtilArrays_asListWithNSObjectArray_(center)];
        if (centerGeo != nil) [circleCenters addWithId:centerGeo];
      }
    }
  }
  return circleCenters;
}

IOSObjectArray *GeogebraCommonKernelProverProverBotanasMethod_create3FreePointsNeverCollinearNDGWithGeogebraCommonUtilProver_(GeogebraCommonUtilProver *prover) {
  GeogebraCommonKernelProverProverBotanasMethod_initialize();
  id<JavaUtilList> freePoints = GeogebraCommonKernelProverProverBotanasMethod_getFreePointsWithGeogebraCommonKernelGeosGeoElement_([((GeogebraCommonUtilProver *) nil_chk(prover)) getStatement]);
  jint setSize = [((id<JavaUtilList>) nil_chk(freePoints)) size];
  GeogebraCommonUtilProver_NDGCondition *ndgc = [new_GeogebraCommonUtilProver_NDGCondition_init() autorelease];
  if (setSize > 3) [ndgc setConditionWithNSString:@"DegeneratePolygon"];
  else [ndgc setConditionWithNSString:@"AreCollinear"];
  IOSObjectArray *geos = [IOSObjectArray arrayWithLength:setSize type:GeogebraCommonKernelGeosGeoElement_class_()];
  jint i = 0;
  id<JavaUtilIterator> it = [freePoints iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    IOSObjectArray_Set(geos, i++, [it next]);
  }
  [ndgc setGeosWithGeogebraCommonKernelGeosGeoElementArray:geos];
  JavaUtilArrays_sortWithNSObjectArray_([ndgc getGeos]);
  [prover addNDGconditionWithGeogebraCommonUtilProver_NDGCondition:ndgc];
  IOSObjectArray *ret = [IOSObjectArray arrayWithLength:setSize * (setSize - 1) * (setSize - 2) / 6 type:GeogebraCommonKernelProverPolynomialPolynomial_class_()];
  i = 0;
  JavaUtilHashSet *triplets = [new_JavaUtilHashSet_init() autorelease];
  id<JavaUtilIterator> it1 = [freePoints iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it1)) hasNext]) {
    GeogebraCommonKernelGeosGeoElement *geo1 = [it1 next];
    id<JavaUtilIterator> it2 = [freePoints iterator];
    while ([((id<JavaUtilIterator>) nil_chk(it2)) hasNext]) {
      GeogebraCommonKernelGeosGeoElement *geo2 = [it2 next];
      if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo1)) isEqualWithGeogebraCommonKernelGeosGeoElement:geo2]) {
        id<JavaUtilIterator> it3 = [freePoints iterator];
        while ([((id<JavaUtilIterator>) nil_chk(it3)) hasNext]) {
          GeogebraCommonKernelGeosGeoElement *geo3 = [it3 next];
          if (![geo1 isEqualWithGeogebraCommonKernelGeosGeoElement:geo3] && ![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo2)) isEqualWithGeogebraCommonKernelGeosGeoElement:geo3]) {
            JavaUtilHashSet *triplet = [new_JavaUtilHashSet_init() autorelease];
            [triplet addWithId:geo1];
            [triplet addWithId:geo2];
            [triplet addWithId:geo3];
            if (![triplets containsWithId:triplet]) {
              [triplets addWithId:triplet];
              IOSObjectArray *fv1 = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo1, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo1];
              IOSObjectArray *fv2 = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo2, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo2];
              IOSObjectArray *fv3 = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) nil_chk(((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo3, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo3];
              GeogebraCommonKernelProverPolynomialPolynomial *p = GeogebraCommonKernelProverPolynomialPolynomial_collinearWithGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_(IOSObjectArray_Get(nil_chk(fv1), 0), IOSObjectArray_Get(fv1, 1), IOSObjectArray_Get(nil_chk(fv2), 0), IOSObjectArray_Get(fv2, 1), IOSObjectArray_Get(nil_chk(fv3), 0), IOSObjectArray_Get(fv3, 1));
              GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$$$$$", @"Forcing non-collinearity for points ", [geo1 getLabelSimple], @", ", [geo2 getLabelSimple], @" and ", [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo3)) getLabelSimple]));
              IOSObjectArray_Set(ret, i, [((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(p)) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:[new_GeogebraCommonKernelProverPolynomialPolynomial_initWithGeogebraCommonKernelProverPolynomialVariable_([new_GeogebraCommonKernelProverPolynomialVariable_init() autorelease]) autorelease]])) subtractWithGeogebraCommonKernelProverPolynomialPolynomial:[new_GeogebraCommonKernelProverPolynomialPolynomial_initWithInt_(1) autorelease]]);
              i++;
            }
          }
        }
      }
    }
  }
  return ret;
}

JavaUtilHashMap *GeogebraCommonKernelProverProverBotanasMethod_fixValuesWithGeogebraCommonUtilProver_withInt_(GeogebraCommonUtilProver *prover, jint coords) {
  GeogebraCommonKernelProverProverBotanasMethod_initialize();
  IOSIntArray *fixCoords = [IOSIntArray arrayWithInts:(jint[]){ 0, 0, 0, 1 } count:4];
  GeogebraCommonKernelGeosGeoElement *statement = [((GeogebraCommonUtilProver *) nil_chk(prover)) getStatement];
  id<JavaUtilList> freePoints = GeogebraCommonKernelProverProverBotanasMethod_getFreePointsWithGeogebraCommonKernelGeosGeoElement_(statement);
  id<JavaUtilList> fixedPoints = [new_JavaUtilArrayList_init() autorelease];
  for (GeogebraCommonKernelGeosGeoElement * __strong ge in nil_chk(freePoints)) {
    [fixedPoints addWithId:ge];
  }
  JavaUtilHashMap *ret = [new_JavaUtilHashMap_init() autorelease];
  id<JavaUtilIterator> it = [fixedPoints iterator];
  IOSObjectArray *geos = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelGeosGeoElement_class_()];
  jint i = 0, j = 0;
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext] && i < 2 && j < coords) {
    GeogebraCommonKernelGeosGeoElement *geo = [it next];
    IOSObjectArray *fv = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) nil_chk(((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
    IOSObjectArray_Set(geos, i, geo);
    [ret putWithId:IOSObjectArray_Get(nil_chk(fv), 0) withId:JavaLangInteger_valueOfWithInt_(IOSIntArray_Get(fixCoords, j))];
    ++j;
    if (j < coords) {
      [ret putWithId:IOSObjectArray_Get(fv, 1) withId:JavaLangInteger_valueOfWithInt_(IOSIntArray_Get(fixCoords, j))];
      ++i;
      ++j;
    }
  }
  if (i == 2 && [prover isReturnExtraNDGs]) {
    GeogebraCommonUtilProver_NDGCondition *ndgc = [new_GeogebraCommonUtilProver_NDGCondition_init() autorelease];
    [ndgc setConditionWithNSString:@"AreEqual"];
    [ndgc setGeosWithGeogebraCommonKernelGeosGeoElementArray:geos];
    JavaUtilArrays_sortWithNSObjectArray_([ndgc getGeos]);
    [prover addNDGconditionWithGeogebraCommonUtilProver_NDGCondition:ndgc];
  }
  return ret;
}

GeogebraCommonUtilProver_ProofResultEnum *GeogebraCommonKernelProverProverBotanasMethod_proveWithGeogebraCommonUtilProver_(GeogebraCommonUtilProver *prover) {
  GeogebraCommonKernelProverProverBotanasMethod_initialize();
  GeogebraCommonKernelGeosGeoElement *statement = [((GeogebraCommonUtilProver *) nil_chk(prover)) getStatement];
  if (GeogebraCommonMainApp_get_singularWS_() == nil || (![GeogebraCommonMainApp_get_singularWS_() isAvailable])) {
    *GeogebraCommonMainProverSettings_getRef_transcext_() = NO;
    GeogebraCommonMainApp_debugWithNSString_(@"Testing local CAS connection");
    GeogebraCommonCasGeoGebraCAS *cas = (GeogebraCommonCasGeoGebraCAS *) check_class_cast([((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonKernelGeosGeoElement *) nil_chk(statement)) getKernel])) getGeoGebraCAS], [GeogebraCommonCasGeoGebraCAS class]);
    @try {
      NSString *output = [((id<GeogebraCommonKernelCASGenericInterface>) nil_chk([((GeogebraCommonCasGeoGebraCAS *) nil_chk(cas)) getCurrentCAS])) evaluateRawWithNSString:@"1"];
      GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$", @"Local CAS evaluates 1 to ", output));
      if (!([((NSString *) nil_chk(output)) isEqual:@"1"])) {
        GeogebraCommonMainApp_debugWithNSString_(@"Switching to PROCESSING mode");
        return GeogebraCommonUtilProver_ProofResultEnum_get_PROCESSING();
      }
    }
    @catch (JavaLangThrowable *e) {
      GeogebraCommonMainApp_debugWithNSString_(@"Exception, switching to PROCESSING mode");
      return GeogebraCommonUtilProver_ProofResultEnum_get_PROCESSING();
    }
  }
  IOSObjectArray *hypotheses = nil;
  id<JavaUtilIterator> it = [((JavaUtilTreeSet *) nil_chk([((GeogebraCommonKernelGeosGeoElement *) nil_chk(statement)) getAllPredecessors])) iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    GeogebraCommonKernelGeosGeoElement *geo = [it next];
    if ([GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo_class_() isInstance:geo]) {
      @try {
        GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$$", @"/* PROCESSING OBJECT ", [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getLabelSimple], @" */"));
        if (GeogebraCommonMainProverSettings_get_captionAlgebra_()) {
          [geo setCaptionWithNSString:nil];
        }
        NSString *command = [geo getCommandDescriptionWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()];
        if (!([@"" isEqual:command])) {
          GeogebraCommonMainApp_debugWithNSString_(@"/* Command definition */");
          GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$$$$$", [geo getLabelSimple], @" = ", [geo getCommandDescriptionWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()], @" /* ", [geo getDefinitionDescriptionWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()], @" */"));
        }
        else {
          NSString *description_ = [geo getAlgebraDescriptionDefault];
          if (![((NSString *) nil_chk(description_)) hasPrefix:@"xOyPlane"]) {
            GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$", description_, @" /* free point */"));
            IOSObjectArray *v = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
            v = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
            if (GeogebraCommonMainProverSettings_get_captionAlgebra_()) {
              [geo setCaptionBotanaVarsWithNSString:JreStrcat("C$C$C", '(', [((GeogebraCommonKernelProverPolynomialVariable *) nil_chk(IOSObjectArray_Get(nil_chk(v), 0))) toTeX], ',', [((GeogebraCommonKernelProverPolynomialVariable *) nil_chk(IOSObjectArray_Get(v, 1))) toTeX], ')')];
            }
          }
        }
        IOSObjectArray *geoPolys = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))) getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:geo];
        if (geoPolys != nil) {
          if ([geo isKindOfClass:[GeogebraCommonKernelGeosGeoPoint class]]) {
            IOSObjectArray *v = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
            v = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
            GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$C@C@C", @"Constrained point ", [geo getLabelSimple], '(', IOSObjectArray_Get(nil_chk(v), 0), ',', IOSObjectArray_Get(v, 1), ')'));
            if (GeogebraCommonMainProverSettings_get_captionAlgebra_()) {
              [geo setCaptionBotanaVarsWithNSString:JreStrcat("C$C$C", '(', [((GeogebraCommonKernelProverPolynomialVariable *) nil_chk(IOSObjectArray_Get(v, 0))) toTeX], ',', [((GeogebraCommonKernelProverPolynomialVariable *) nil_chk(IOSObjectArray_Get(v, 1))) toTeX], ')')];
            }
          }
          jint nHypotheses = 0;
          if (hypotheses != nil) nHypotheses = hypotheses->size_;
          IOSObjectArray *allPolys = [IOSObjectArray arrayWithLength:nHypotheses + geoPolys->size_ type:GeogebraCommonKernelProverPolynomialPolynomial_class_()];
          for (jint i = 0; i < nHypotheses; ++i) {
            IOSObjectArray_Set(allPolys, i, IOSObjectArray_Get(nil_chk(hypotheses), i));
          }
          GeogebraCommonMainApp_debugWithNSString_(@"Hypotheses:");
          for (jint i = 0; i < geoPolys->size_; ++i) {
            GeogebraCommonMainApp_debugWithNSString_(JreStrcat("I$@", (nHypotheses + i + 1), @". ", IOSObjectArray_Get(geoPolys, i)));
            IOSObjectArray_Set(allPolys, nHypotheses + i, IOSObjectArray_Get(geoPolys, i));
            if (GeogebraCommonMainProverSettings_get_captionAlgebra_()) {
              [geo addCaptionBotanaPolynomialWithNSString:[((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(IOSObjectArray_Get(geoPolys, i))) toTeX]];
            }
          }
          hypotheses = allPolys;
        }
      }
      @catch (GeogebraCommonKernelProverNoSymbolicParametersException *e) {
        GeogebraCommonMainApp_debugWithNSString_(JreStrcat("@$", [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getParentAlgorithm], @" is not fully implemented"));
        return GeogebraCommonUtilProver_ProofResultEnum_get_UNKNOWN();
      }
    }
    else {
      GeogebraCommonMainApp_debugWithNSString_(JreStrcat("@$", [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getParentAlgorithm], @" unimplemented"));
      return GeogebraCommonUtilProver_ProofResultEnum_get_UNKNOWN();
    }
  }
  GeogebraCommonKernelProverProverBotanasMethod_updateBotanaVarsInvWithGeogebraCommonKernelGeosGeoElement_(statement);
  @try {
    if (!([GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgoAre_class_() isInstance:[statement getParentAlgorithm]])) {
      GeogebraCommonMainApp_debugWithNSString_(JreStrcat("@$", [statement getParentAlgorithm], @" unimplemented"));
      return GeogebraCommonUtilProver_ProofResultEnum_get_UNKNOWN();
    }
    IOSObjectArray *statements = [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgoAre>) nil_chk(((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgoAre>) check_protocol_cast([statement getParentAlgorithm], @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgoAre))))) getBotanaPolynomials];
    IOSObjectArray *ndgConditions = nil;
    if (GeogebraCommonMainProverSettings_get_freePointsNeverCollinear_() == nil) {
      if (GeogebraCommonMainApp_get_singularWS_() != nil && [GeogebraCommonMainApp_get_singularWS_() isAvailable]) {
        GeogebraCommonMainProverSettings_set_freePointsNeverCollinear_(JavaLangBoolean_valueOfWithBoolean_(NO));
      }
      else {
        GeogebraCommonMainProverSettings_set_freePointsNeverCollinear_(JavaLangBoolean_valueOfWithBoolean_(YES));
      }
    }
    if ([((JavaLangBoolean *) nil_chk(GeogebraCommonMainProverSettings_get_freePointsNeverCollinear_())) booleanValue] && !([prover isReturnExtraNDGs])) {
      ndgConditions = GeogebraCommonKernelProverProverBotanasMethod_create3FreePointsNeverCollinearNDGWithGeogebraCommonUtilProver_(prover);
    }
    JavaUtilHashMap *substitutions = nil;
    jint fixcoords = 0;
    if ([prover isReturnExtraNDGs]) fixcoords = GeogebraCommonMainProverSettings_get_useFixCoordinatesProveDetails_();
    else fixcoords = GeogebraCommonMainProverSettings_get_useFixCoordinatesProve_();
    if (fixcoords > 0) {
      substitutions = GeogebraCommonKernelProverProverBotanasMethod_fixValuesWithGeogebraCommonUtilProver_withInt_(prover, fixcoords);
      GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$@", @"substitutions: ", substitutions));
    }
    jint nHypotheses = 0;
    jint nNdgConditions = 0;
    jint nStatements = 0;
    if (hypotheses != nil) nHypotheses = hypotheses->size_;
    if (ndgConditions != nil) nNdgConditions = ndgConditions->size_;
    if (statements != nil) nStatements = statements->size_;
    jboolean ans = YES;
    for (jint i = 0; i < nStatements && ans; ++i) {
      jint nPolysStatement = ((IOSObjectArray *) nil_chk(IOSObjectArray_Get(nil_chk(statements), i)))->size_;
      IOSObjectArray *eqSystem = [IOSObjectArray arrayWithLength:nHypotheses + nNdgConditions + nPolysStatement type:GeogebraCommonKernelProverPolynomialPolynomial_class_()];
      for (jint j = 0; j < nHypotheses; ++j) IOSObjectArray_Set(eqSystem, j, IOSObjectArray_Get(nil_chk(hypotheses), j));
      if (nNdgConditions > 0) GeogebraCommonMainApp_debugWithNSString_(@"Extra NDGs:");
      for (jint j = 0; j < nNdgConditions; ++j) {
        GeogebraCommonMainApp_debugWithNSString_(JreStrcat("I$@", (j + nHypotheses + 1), @". ", IOSObjectArray_Get(nil_chk(ndgConditions), j)));
        IOSObjectArray_Set(eqSystem, j + nHypotheses, IOSObjectArray_Get(ndgConditions, j));
      }
      if (nPolysStatement > 1) GeogebraCommonMainApp_debugWithNSString_(@"Statement equations (non-denied parts):");
      for (jint j = 0; j < nPolysStatement - 1; ++j) {
        GeogebraCommonMainApp_debugWithNSString_(JreStrcat("I$@", (j + nHypotheses + nNdgConditions + 1), @". ", IOSObjectArray_Get(nil_chk(IOSObjectArray_Get(statements, i)), j)));
        IOSObjectArray_Set(eqSystem, j + nHypotheses + nNdgConditions, IOSObjectArray_Get(nil_chk(IOSObjectArray_Get(statements, i)), j));
      }
      GeogebraCommonKernelProverPolynomialPolynomial *spoly = [((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(IOSObjectArray_Get(nil_chk(IOSObjectArray_Get(statements, i)), nPolysStatement - 1))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:[new_GeogebraCommonKernelProverPolynomialPolynomial_initWithGeogebraCommonKernelProverPolynomialVariable_([new_GeogebraCommonKernelProverPolynomialVariable_init() autorelease]) autorelease]])) subtractWithGeogebraCommonKernelProverPolynomialPolynomial:[new_GeogebraCommonKernelProverPolynomialPolynomial_initWithInt_(1) autorelease]];
      GeogebraCommonMainApp_debugWithNSString_(@"Thesis reductio ad absurdum (denied statement):");
      IOSObjectArray_Set(eqSystem, nHypotheses + nNdgConditions + nPolysStatement - 1, spoly);
      GeogebraCommonMainApp_debugWithNSString_(JreStrcat("I$@", (nHypotheses + nNdgConditions + nPolysStatement), @". ", spoly));
      if ([prover isReturnExtraNDGs]) {
        IOSObjectArray_Set(eqSystem, nHypotheses + nPolysStatement - 1, spoly);
        id<JavaUtilSet> eliminationIdeal;
        GeogebraCommonKernelProverNDGDetector *ndgd = [new_GeogebraCommonKernelProverNDGDetector_initWithGeogebraCommonUtilProver_withJavaUtilHashMap_(prover, substitutions) autorelease];
        jboolean found = NO;
        jint permutation = 0;
        jint MAX_PERMUTATIONS = 1;
        if (GeogebraCommonMainApp_get_singularWS_() != nil && [GeogebraCommonMainApp_get_singularWS_() isAvailable]) {
          MAX_PERMUTATIONS = 8;
        }
        while (!found && permutation < MAX_PERMUTATIONS) {
          eliminationIdeal = GeogebraCommonKernelProverPolynomialPolynomial_eliminateWithGeogebraCommonKernelProverPolynomialPolynomialArray_withJavaUtilHashMap_withGeogebraCommonKernelKernel_withInt_(eqSystem, substitutions, [statement getKernel], permutation++);
          if (eliminationIdeal == nil) {
            return GeogebraCommonUtilProver_ProofResultEnum_get_UNKNOWN();
          }
          id<JavaUtilIterator> ndgSet = [((id<JavaUtilSet>) nil_chk(eliminationIdeal)) iterator];
          id<JavaUtilList> xEqualSet = [new_JavaUtilArrayList_initWithJavaUtilCollection_([new_JavaUtilHashSet_init() autorelease]) autorelease];
          id<JavaUtilList> yEqualSet = [new_JavaUtilArrayList_initWithJavaUtilCollection_([new_JavaUtilHashSet_init() autorelease]) autorelease];
          jboolean xyRewrite = [eliminationIdeal size] == 2;
          id<JavaUtilList> bestNdgSet = [new_JavaUtilArrayList_init() autorelease];
          jdouble bestScore = JavaLangDouble_POSITIVE_INFINITY;
          jint ndgI = 0;
          while ([((id<JavaUtilIterator>) nil_chk(ndgSet)) hasNext]) {
            ndgI++;
            GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$I$", @"Considering NDG ", ndgI, @"..."));
            id<JavaUtilList> ndgcl = [new_JavaUtilArrayList_init() autorelease];
            jdouble score = 0.0;
            jboolean readable = YES;
            id<JavaUtilSet> thisNdgSet = [ndgSet next];
            id<JavaUtilIterator> ndg = [((id<JavaUtilSet>) nil_chk(thisNdgSet)) iterator];
            while ([((id<JavaUtilIterator>) nil_chk(ndg)) hasNext] && readable) {
              GeogebraCommonKernelProverPolynomialPolynomial *poly = [ndg next];
              if ([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(poly)) isZero]) return GeogebraCommonUtilProver_ProofResultEnum_get_FALSE();
              if (![poly isConstant]) {
                GeogebraCommonUtilProver_NDGCondition *ndgc = [ndgd detectWithGeogebraCommonKernelProverPolynomialPolynomial:poly];
                if (ndgc == nil) readable = NO;
                else {
                  xyRewrite = (xyRewrite && [thisNdgSet size] == 1);
                  if (xyRewrite) {
                    if ([((NSString *) nil_chk([ndgc getCondition])) isEqual:@"xAreEqual"]) {
                      id<JavaUtilSet> points = [new_JavaUtilHashSet_init() autorelease];
                      [points addWithId:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk([ndgc getGeos]), 0), [GeogebraCommonKernelGeosGeoPoint class])];
                      [points addWithId:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk([ndgc getGeos]), 1), [GeogebraCommonKernelGeosGeoPoint class])];
                      [xEqualSet addWithId:points];
                    }
                    if ([((NSString *) nil_chk([ndgc getCondition])) isEqual:@"yAreEqual"]) {
                      id<JavaUtilSet> points = [new_JavaUtilHashSet_init() autorelease];
                      [points addWithId:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk([ndgc getGeos]), 0), [GeogebraCommonKernelGeosGeoPoint class])];
                      [points addWithId:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk([ndgc getGeos]), 1), [GeogebraCommonKernelGeosGeoPoint class])];
                      [yEqualSet addWithId:points];
                    }
                    if ([xEqualSet size] == 1 && [xEqualSet isEqual:yEqualSet]) {
                      [ndgc setConditionWithNSString:@"AreEqual"];
                      [ndgc setReadabilityWithDouble:0.5];
                    }
                  }
                  [ndgcl addWithId:ndgc];
                  score += [ndgc getReadability];
                }
              }
            }
            if (readable && score < bestScore) {
              GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$D$D", @"Found a better NDG score (", score, @") than ", bestScore));
              bestScore = score;
              bestNdgSet = ndgcl;
              found = YES;
            }
            else {
              if (readable) {
                GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$D$D", @"Not better than previous NDG score (", bestScore, @"), this is ", score));
              }
              else {
                GeogebraCommonMainApp_debugWithNSString_(@"...unreadable");
              }
            }
          }
          if (found) {
            id<JavaUtilIterator> ndgc = [bestNdgSet iterator];
            while ([((id<JavaUtilIterator>) nil_chk(ndgc)) hasNext]) {
              [prover addNDGconditionWithGeogebraCommonUtilProver_NDGCondition:[ndgc next]];
            }
          }
        }
        if (!found) return GeogebraCommonUtilProver_ProofResultEnum_get_TRUE_NDG_UNREADABLE();
      }
      else {
        JavaLangBoolean *solvable = GeogebraCommonKernelProverPolynomialPolynomial_solvableWithGeogebraCommonKernelProverPolynomialPolynomialArray_withJavaUtilHashMap_withGeogebraCommonKernelKernel_withBoolean_(eqSystem, substitutions, [statement getKernel], GeogebraCommonMainProverSettings_get_transcext_());
        if (solvable == nil) {
          return GeogebraCommonUtilProver_ProofResultEnum_get_UNKNOWN();
        }
        if ([((JavaLangBoolean *) nil_chk(solvable)) booleanValue]) {
          if (!GeogebraCommonMainProverSettings_get_transcext_()) {
            return GeogebraCommonUtilProver_ProofResultEnum_get_UNKNOWN();
          }
          ans = NO;
        }
      }
    }
    if (ans) return GeogebraCommonUtilProver_ProofResultEnum_get_TRUE();
    return GeogebraCommonUtilProver_ProofResultEnum_get_FALSE();
  }
  @catch (GeogebraCommonKernelProverNoSymbolicParametersException *e) {
    return GeogebraCommonUtilProver_ProofResultEnum_get_UNKNOWN();
  }
}

void GeogebraCommonKernelProverProverBotanasMethod_init(GeogebraCommonKernelProverProverBotanasMethod *self) {
  NSObject_init(self);
}

GeogebraCommonKernelProverProverBotanasMethod *new_GeogebraCommonKernelProverProverBotanasMethod_init() {
  GeogebraCommonKernelProverProverBotanasMethod *self = [GeogebraCommonKernelProverProverBotanasMethod alloc];
  GeogebraCommonKernelProverProverBotanasMethod_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelProverProverBotanasMethod)
