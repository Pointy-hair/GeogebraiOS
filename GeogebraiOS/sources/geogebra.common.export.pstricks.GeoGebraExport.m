//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/export/pstricks/GeoGebraExport.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GColor.h"
#include "geogebra/common/awt/GGraphics2D.h"
#include "geogebra/common/awt/GRectangle.h"
#include "geogebra/common/euclidian/DrawableND.h"
#include "geogebra/common/euclidian/EuclidianView.h"
#include "geogebra/common/euclidian/EuclidianViewInterfaceCommon.h"
#include "geogebra/common/euclidian/draw/DrawAngle.h"
#include "geogebra/common/euclidian/draw/DrawInequality.h"
#include "geogebra/common/euclidian/draw/DrawLine.h"
#include "geogebra/common/euclidian/draw/DrawPoint.h"
#include "geogebra/common/euclidian/plot/CurvePlotter.h"
#include "geogebra/common/export/pstricks/ExportSettings.h"
#include "geogebra/common/export/pstricks/GeoGebraExport.h"
#include "geogebra/common/factories/AwtFactory.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoBarChart.h"
#include "geogebra/common/kernel/algos/AlgoBoxPlot.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoFunctionAreaSums.h"
#include "geogebra/common/kernel/algos/AlgoIntegralFunctions.h"
#include "geogebra/common/kernel/algos/AlgoSlope.h"
#include "geogebra/common/kernel/algos/AlgoSumLeft.h"
#include "geogebra/common/kernel/algos/AlgoSumLower.h"
#include "geogebra/common/kernel/algos/AlgoSumRectangle.h"
#include "geogebra/common/kernel/algos/AlgoSumTrapezoidal.h"
#include "geogebra/common/kernel/algos/AlgoSumUpper.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionNVar.h"
#include "geogebra/common/kernel/arithmetic/FunctionalNVar.h"
#include "geogebra/common/kernel/arithmetic/IneqTree.h"
#include "geogebra/common/kernel/arithmetic/Inequality.h"
#include "geogebra/common/kernel/cas/AlgoIntegralDefinite.h"
#include "geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "geogebra/common/kernel/geos/GeoAngle.h"
#include "geogebra/common/kernel/geos/GeoConic.h"
#include "geogebra/common/kernel/geos/GeoConicPart.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoFunctionNVar.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoList.h"
#include "geogebra/common/kernel/geos/GeoLocus.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoPolyLine.h"
#include "geogebra/common/kernel/geos/GeoPolygon.h"
#include "geogebra/common/kernel/geos/GeoRay.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/geos/GeoText.h"
#include "geogebra/common/kernel/geos/GeoTransferFunction.h"
#include "geogebra/common/kernel/geos/GeoVector.h"
#include "geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/statistics/AlgoHistogram.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/util/MyMath.h"
#include "geogebra/common/util/StringUtil.h"
#include "java/lang/Double.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/util/HashMap.h"
#include "java/util/List.h"

@interface GeogebraCommonExportPstricksGeoGebraExport () {
 @public
  GeogebraCommonMainApp *app_;
  GeogebraCommonKernelStringTemplate *tpl_;
}

- (void)initBounds OBJC_METHOD_FAMILY_NONE;

- (void)drawCurveCartesianWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonExportPstricksGeoGebraExport, app_, GeogebraCommonMainApp *)
J2OBJC_FIELD_SETTER(GeogebraCommonExportPstricksGeoGebraExport, tpl_, GeogebraCommonKernelStringTemplate *)

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraExport_initBounds(GeogebraCommonExportPstricksGeoGebraExport *self);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraExport_drawCurveCartesianWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonExportPstricksGeoGebraExport *self, GeogebraCommonKernelGeosGeoElement *geo);

@interface GeogebraCommonExportPstricksGeoGebraExport_Info () {
 @public
  jfloat alpha_;
  jint y_;
  jdouble angle_;
  GeogebraCommonKernelGeosGeoElement_FillTypeEnum *fillType_;
  GeogebraCommonAwtGColor *linecolor_;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonExportPstricksGeoGebraExport_Info, fillType_, GeogebraCommonKernelGeosGeoElement_FillTypeEnum *)
J2OBJC_FIELD_SETTER(GeogebraCommonExportPstricksGeoGebraExport_Info, linecolor_, GeogebraCommonAwtGColor *)

@implementation GeogebraCommonExportPstricksGeoGebraExport

- (instancetype)initWithGeogebraCommonMainApp:(GeogebraCommonMainApp *)app {
  GeogebraCommonExportPstricksGeoGebraExport_initWithGeogebraCommonMainApp_(self, app);
  return self;
}

- (GeogebraCommonMainApp *)getApp {
  return app_;
}

- (NSString *)formatWithDouble:(jdouble)d {
  NSString *ret = [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatWithDouble:GeogebraCommonKernelKernel_checkDecimalFractionWithDouble_(d) withGeogebraCommonKernelStringTemplate:tpl_];
  ret = GeogebraCommonUtilStringUtil_cannonicNumber2WithNSString_(ret);
  return ret;
}

- (void)refreshSelectionRectangle {
  jint x1 = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordXWithDouble:xmin_];
  jint x2 = [euclidianView_ toScreenCoordXWithDouble:xmax_];
  jint y1 = [euclidianView_ toScreenCoordYWithDouble:ymin_];
  jint y2 = [euclidianView_ toScreenCoordYWithDouble:ymax_];
  id<GeogebraCommonAwtGRectangle> rec = [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newRectangleWithInt:x1 withInt:y2 withInt:x2 - x1 withInt:y1 - y2];
  [euclidianView_ setSelectionRectangleWithGeogebraCommonAwtGRectangle:rec];
  [euclidianView_ repaint];
}

- (void)setxminWithDouble:(jdouble)xmin {
  self->xmin_ = xmin;
  [self refreshSelectionRectangle];
}

- (void)setxmaxWithDouble:(jdouble)xmax {
  self->xmax_ = xmax;
  [self refreshSelectionRectangle];
}

- (void)setyminWithDouble:(jdouble)ymin {
  self->ymin_ = ymin;
  [self refreshSelectionRectangle];
}

- (void)setymaxWithDouble:(jdouble)ymax {
  self->ymax_ = ymax;
  [self refreshSelectionRectangle];
}

- (jdouble)getxmin {
  return self->xmin_;
}

- (jdouble)getxmax {
  return self->xmax_;
}

- (jdouble)getymin {
  return self->ymin_;
}

- (jdouble)getymax {
  return self->ymax_;
}

- (void)initBounds {
  GeogebraCommonExportPstricksGeoGebraExport_initBounds(self);
}

- (void)setBeamerWithBoolean:(jboolean)beamer {
  isBeamer_ = beamer;
}

- (NSString *)sci2decWithDouble:(jdouble)d {
  NSString *s = GeogebraCommonUtilStringUtil_toLowerCaseWithNSString_(NSString_valueOfDouble_(d));
  JavaLangStringBuilder *number;
  jint posE = [((NSString *) nil_chk(s)) indexOfString:@"e"];
  if (posE == -1) return s;
  NSString *token1 = [s substring:0 endIndex:posE];
  NSString *token2 = [s substring:posE + 1];
  number = [new_JavaLangStringBuilder_initWithNSString_(token1) autorelease];
  jint exp = JavaLangInteger_parseIntWithNSString_(token2);
  if (exp > 0) {
    jint id_point = [number indexOfWithNSString:@"."];
    if (id_point == -1) {
      for (jint i = 0; i < exp; i++) [number appendWithNSString:@"0"];
    }
    else {
      [number deleteCharAtWithInt:id_point];
      jint zeros = exp - ([number length] - id_point);
      for (jint i = 0; i < zeros; i++) [number appendWithNSString:@"0"];
    }
  }
  else {
    exp = -exp;
    jint id_point = [number indexOfWithNSString:@"."];
    [number deleteCharAtWithInt:id_point];
    for (jint i = 0; i < exp - 1; i++) [number insertWithInt:0 withNSString:@"0"];
    [number insertWithInt:0 withNSString:@"0."];
  }
  return [number description];
}

- (NSString *)createCustomColorWithInt:(jint)red
                               withInt:(jint)green
                               withInt:(jint)blue {
  NSString *suff = @"qrstuvwxyzabcdef";
  IOSIntArray *nb = [IOSIntArray arrayWithInts:(jint[]){ red, green, blue } count:3];
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  for (jint i = 0; i < nb->size_; i++) {
    jint quot = IOSIntArray_Get(nb, i) / 16;
    jint reste = IOSIntArray_Get(nb, i) % 16;
    [sb appendWithChar:[suff charAtWithInt:quot]];
    [sb appendWithChar:[suff charAtWithInt:reste]];
  }
  return [NSString stringWithJavaLangStringBuilder:sb];
}

- (void)drawGeoElementWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)g
                                                 withBoolean:(jboolean)fromGeoList
                                                 withBoolean:(jboolean)trimmedInter {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(g)) isGeoList]) {
    GeogebraCommonKernelGeosGeoList *geo = ((GeogebraCommonKernelGeosGeoList *) check_class_cast(g, [GeogebraCommonKernelGeosGeoList class]));
    for (jint i = 0; i < [geo size]; i++) {
      [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:[geo getWithInt:i] withBoolean:YES withBoolean:NO];
    }
  }
  else if ([g isEuclidianVisible] || trimmedInter) {
    if ([g isGeoPoint]) {
      [self drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(g, [GeogebraCommonKernelGeosGeoPoint class])];
      [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isGeoSegment]) {
      [self drawGeoSegmentWithGeogebraCommonKernelGeosGeoSegment:(GeogebraCommonKernelGeosGeoSegment *) check_class_cast(g, [GeogebraCommonKernelGeosGeoSegment class])];
      [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isGeoRay]) {
      [self drawGeoRayWithGeogebraCommonKernelGeosGeoRay:(GeogebraCommonKernelGeosGeoRay *) check_class_cast(g, [GeogebraCommonKernelGeosGeoRay class])];
      [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isKindOfClass:[GeogebraCommonKernelGeosGeoPolyLine class]]) {
      [self drawPolyLineWithGeogebraCommonKernelGeosGeoPolyLine:(GeogebraCommonKernelGeosGeoPolyLine *) check_class_cast(g, [GeogebraCommonKernelGeosGeoPolyLine class])];
    }
    else if ([g isGeoLine]) {
      [self drawGeoLineWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *) check_class_cast(g, [GeogebraCommonKernelGeosGeoLine class])];
      [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isGeoPolygon]) {
      [self drawPolygonWithGeogebraCommonKernelGeosGeoPolygon:(GeogebraCommonKernelGeosGeoPolygon *) check_class_cast(g, [GeogebraCommonKernelGeosGeoPolygon class])];
      [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isGeoAngle]) {
      if ([g isIndependent]) {
        [self drawSliderWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
      }
      else {
        [self drawAngleWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *) check_class_cast(g, [GeogebraCommonKernelGeosGeoAngle class])];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:[((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getDrawableForWithGeogebraCommonKernelGeosGeoElement:g]];
      }
    }
    else if ([g isGeoImplicitPoly]) {
      [self drawImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:(GeogebraCommonKernelImplicitGeoImplicitPoly *) check_class_cast(g, [GeogebraCommonKernelImplicitGeoImplicitPoly class])];
    }
    else if ([((NSString *) nil_chk([g getTypeString])) isEqual:@"Inequality"]) {
      if ([g isGeoFunctionBoolean]) {
        [self drawGeoInequalitiesWithGeogebraCommonKernelGeosGeoFunctionNVar:nil withGeogebraCommonKernelGeosGeoElement:g];
      }
      else {
        [self drawGeoInequalitiesWithGeogebraCommonKernelGeosGeoFunctionNVar:(GeogebraCommonKernelGeosGeoFunctionNVar *) check_class_cast(g, [GeogebraCommonKernelGeosGeoFunctionNVar class]) withGeogebraCommonKernelGeosGeoElement:nil];
      }
    }
    else if ([g isGeoNumeric]) {
      GeogebraCommonKernelAlgosAlgoElement *algo = [g getParentAlgorithm];
      if (algo == nil) {
        [self drawSliderWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
      }
      else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoSlope class]]) {
        [self drawSlopeWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
      }
      else if ([algo isKindOfClass:[GeogebraCommonKernelCasAlgoIntegralDefinite class]]) {
        [self drawIntegralWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
      }
      else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoIntegralFunctions class]]) {
        [self drawIntegralFunctionsWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
      }
      else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoBoxPlot class]]) {
        [self drawBoxPlotWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
      }
      else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoFunctionAreaSums class]]) {
        if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoSumTrapezoidal class]]) [self drawSumTrapezoidalWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
        else if ([algo isKindOfClass:[GeogebraCommonKernelStatisticsAlgoHistogram class]]) [self drawBarChartOrHistogramWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
        else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoSumUpper class]] || [algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoSumLower class]] || [algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoSumLeft class]] || [algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoSumRectangle class]]) [self drawSumUpperLowerWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
      }
      else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoBarChart class]]) {
        [self drawBarChartOrHistogramWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *) check_class_cast(g, [GeogebraCommonKernelGeosGeoNumeric class])];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
      }
    }
    else if ([g isGeoVector]) {
      [self drawGeoVectorWithGeogebraCommonKernelGeosGeoVector:(GeogebraCommonKernelGeosGeoVector *) check_class_cast(g, [GeogebraCommonKernelGeosGeoVector class])];
      [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isGeoConicPart]) {
      GeogebraCommonKernelGeosGeoConicPart *geo = (GeogebraCommonKernelGeosGeoConicPart *) check_class_cast(g, [GeogebraCommonKernelGeosGeoConicPart class]);
      [self drawGeoConicPartWithGeogebraCommonKernelGeosGeoConicPart:geo];
      if ([geo getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC || [geo getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR) [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isGeoConic]) {
      if ([self isSinglePointConicWithGeogebraCommonKernelGeosGeoElement:g]) {
        GeogebraCommonKernelGeosGeoConic *geo = (GeogebraCommonKernelGeosGeoConic *) check_class_cast(g, [GeogebraCommonKernelGeosGeoConic class]);
        GeogebraCommonKernelGeosGeoPoint *point = [geo getSinglePoint];
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(point)) copyLabelWithGeogebraCommonKernelGeosGeoElement:geo];
        [point setObjColorWithGeogebraCommonAwtGColor:[geo getObjectColor]];
        [point setLabelColorWithGeogebraCommonAwtGColor:[geo getLabelColor]];
        [point setPointSizeWithInt:geo->lineThickness_];
        [point setLabelOffsetWithInt:geo->labelOffsetX_ withInt:geo->labelOffsetY_];
        GeogebraCommonEuclidianDrawDrawPoint *drawPoint = [new_GeogebraCommonEuclidianDrawDrawPoint_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelKernelNDGeoPointND_(euclidianView_, point) autorelease];
        [drawPoint setGeoElementWithGeogebraCommonKernelGeosGeoElement:geo];
        [self drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:point];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:point withGeogebraCommonEuclidianDrawableND:drawPoint];
      }
      else if ([self isDoubleLineConicWithGeogebraCommonKernelGeosGeoElement:g]) {
        GeogebraCommonKernelGeosGeoConic *geo = (GeogebraCommonKernelGeosGeoConic *) check_class_cast(g, [GeogebraCommonKernelGeosGeoConic class]);
        IOSObjectArray *lines = [geo getLines];
        IOSObjectArray *drawLines = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonEuclidianDrawDrawLine_class_()];
        for (jint i = 0; i < 2; i++) {
          [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines), i))) copyLabelWithGeogebraCommonKernelGeosGeoElement:geo];
          [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines, i))) setObjColorWithGeogebraCommonAwtGColor:[geo getObjectColor]];
          [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines, i))) setLabelColorWithGeogebraCommonAwtGColor:[geo getLabelColor]];
          ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines, i)))->lineThickness_ = geo->lineThickness_;
          ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines, i)))->lineType_ = geo->lineType_;
        }
        IOSObjectArray_SetAndConsume(drawLines, 0, new_GeogebraCommonEuclidianDrawDrawLine_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelKernelNDGeoLineND_(euclidianView_, IOSObjectArray_Get(nil_chk(lines), 0)));
        IOSObjectArray_SetAndConsume(drawLines, 1, new_GeogebraCommonEuclidianDrawDrawLine_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelKernelNDGeoLineND_(euclidianView_, IOSObjectArray_Get(lines, 1)));
        [((GeogebraCommonEuclidianDrawDrawLine *) nil_chk(IOSObjectArray_Get(drawLines, 0))) setGeoElementWithGeogebraCommonKernelGeosGeoElement:geo];
        [((GeogebraCommonEuclidianDrawDrawLine *) nil_chk(IOSObjectArray_Get(drawLines, 1))) setGeoElementWithGeogebraCommonKernelGeosGeoElement:geo];
        [self drawGeoLineWithGeogebraCommonKernelGeosGeoLine:IOSObjectArray_Get(lines, 0)];
        [self drawGeoLineWithGeogebraCommonKernelGeosGeoLine:IOSObjectArray_Get(lines, 1)];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(lines, 0) withGeogebraCommonEuclidianDrawableND:IOSObjectArray_Get(drawLines, 0)];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(lines, 1) withGeogebraCommonEuclidianDrawableND:IOSObjectArray_Get(drawLines, 1)];
      }
      else if ([self isEmptyWithGeogebraCommonKernelGeosGeoElement:g]) {
      }
      else {
        [self drawGeoConicWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *) check_class_cast(g, [GeogebraCommonKernelGeosGeoConic class])];
        [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
      }
    }
    else if ([g isGeoFunction]) {
      [self drawFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *) check_class_cast(g, [GeogebraCommonKernelGeosGeoFunction class])];
      [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isGeoCurveCartesian]) {
      GeogebraCommonExportPstricksGeoGebraExport_drawCurveCartesianWithGeogebraCommonKernelGeosGeoElement_(self, g);
      [self drawLabelWithGeogebraCommonKernelGeosGeoElement:g withGeogebraCommonEuclidianDrawableND:nil];
    }
    else if ([g isGeoText]) {
      [self drawTextWithGeogebraCommonKernelGeosGeoText:(GeogebraCommonKernelGeosGeoText *) check_class_cast(g, [GeogebraCommonKernelGeosGeoText class])];
    }
    else if ([g isGeoImage]) {
    }
    else if ([g isGeoLocus]) {
      [self drawLocusWithGeogebraCommonKernelGeosGeoLocus:(GeogebraCommonKernelGeosGeoLocus *) check_class_cast(g, [GeogebraCommonKernelGeosGeoLocus class])];
    }
    else if ([g isKindOfClass:[GeogebraCommonKernelGeosGeoTransferFunction class]]) {
      [self drawNyquistWithGeogebraCommonKernelGeosGeoTransferFunction:(GeogebraCommonKernelGeosGeoTransferFunction *) check_class_cast(g, [GeogebraCommonKernelGeosGeoTransferFunction class])];
    }
  }
}

- (void)drawBarChartOrHistogramWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)g {
  if ([[((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(g)) getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoFunctionAreaSums class]]) {
    GeogebraCommonKernelAlgosAlgoFunctionAreaSums *algo = (GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) check_class_cast([g getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoFunctionAreaSums class]);
    [self drawHistogramOrBarChartBoxWithDoubleArray:[((GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) nil_chk(algo)) getValues] withDoubleArray:[algo getLeftBorder] withInt:((IOSDoubleArray *) nil_chk([algo getValues]))->size_ - 1 withDouble:0 withGeogebraCommonKernelGeosGeoNumeric:g];
  }
  else {
    GeogebraCommonKernelAlgosAlgoBarChart *algo = nil;
    if ([[g getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoBarChart class]]) algo = (GeogebraCommonKernelAlgosAlgoBarChart *) check_class_cast([g getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoBarChart class]);
    [self drawHistogramOrBarChartBoxWithDoubleArray:[((GeogebraCommonKernelAlgosAlgoBarChart *) nil_chk(algo)) getValues] withDoubleArray:[algo getLeftBorder] withInt:((IOSDoubleArray *) nil_chk([algo getValues]))->size_ withDouble:[algo getWidth] withGeogebraCommonKernelGeosGeoNumeric:g];
  }
}

- (jboolean)isSinglePointConicWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoConic]) {
    if ([((GeogebraCommonKernelGeosGeoConic *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoConic class])) getType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT) return YES;
  }
  return NO;
}

- (jboolean)isDoubleLineConicWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoConic]) {
    if ([((GeogebraCommonKernelGeosGeoConic *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoConic class])) getType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE || [((GeogebraCommonKernelGeosGeoConic *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoConic class])) getType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES || [((GeogebraCommonKernelGeosGeoConic *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoConic class])) getType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES) return YES;
  }
  return NO;
}

- (jboolean)isEmptyWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoConic]) {
    if ([((GeogebraCommonKernelGeosGeoConic *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoConic class])) getType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY) return YES;
  }
  return NO;
}

- (jint)resizePtWithInt:(jint)size {
  jdouble height_geogebra = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getHeight] / 30;
  jdouble height_latex = [((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) getLatexHeight];
  jdouble ratio = height_latex / height_geogebra;
  jint tmp = (jint) JavaLangMath_roundWithDouble_(ratio * size);
  if (tmp != 0) return tmp;
  return 1;
}

- (void)drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawGeoLineWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawGeoRayWithGeogebraCommonKernelGeosGeoRay:(GeogebraCommonKernelGeosGeoRay *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawGeoSegmentWithGeogebraCommonKernelGeosGeoSegment:(GeogebraCommonKernelGeosGeoSegment *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawPolygonWithGeogebraCommonKernelGeosGeoPolygon:(GeogebraCommonKernelGeosGeoPolygon *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawSliderWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawSlopeWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawIntegralWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawIntegralFunctionsWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawSumUpperLowerWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawSumTrapezoidalWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawBoxPlotWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawAngleWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawGeoVectorWithGeogebraCommonKernelGeosGeoVector:(GeogebraCommonKernelGeosGeoVector *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawGeoConicWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawGeoConicPartWithGeogebraCommonKernelGeosGeoConicPart:(GeogebraCommonKernelGeosGeoConicPart *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawLabelWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo
                  withGeogebraCommonEuclidianDrawableND:(GeogebraCommonEuclidianDrawableND *)drawGeo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:(GeogebraCommonKernelImplicitGeoImplicitPoly *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)geo
                                                                  withBoolean:(jboolean)trasparency {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawTextWithGeogebraCommonKernelGeosGeoText:(GeogebraCommonKernelGeosGeoText *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawLocusWithGeogebraCommonKernelGeosGeoLocus:(GeogebraCommonKernelGeosGeoLocus *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawLineWithDouble:(jdouble)x1
                withDouble:(jdouble)y1
                withDouble:(jdouble)x2
                withDouble:(jdouble)y2
withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawArcWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                    withDoubleArray:(IOSDoubleArray *)vertex
                                         withDouble:(jdouble)angSt
                                         withDouble:(jdouble)angEnd
                                         withDouble:(jdouble)r {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawTickWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                     withDoubleArray:(IOSDoubleArray *)vertex
                                          withDouble:(jdouble)angleTick {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawArrowArcWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                         withDoubleArray:(IOSDoubleArray *)vertex
                                              withDouble:(jdouble)angSt
                                              withDouble:(jdouble)angEnd
                                              withDouble:(jdouble)r
                                             withBoolean:(jboolean)clockwise {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)setFrameWithGeogebraCommonExportPstricksExportSettings:(id<GeogebraCommonExportPstricksExportSettings>)settingsFrame {
  GeogebraCommonExportPstricksGeoGebraExport_set_frame_(self, settingsFrame);
}

- (void)generateAllCode {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)ColorCodeWithGeogebraCommonAwtGColor:(GeogebraCommonAwtGColor *)color
                   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawPolyLineWithGeogebraCommonKernelGeosGeoPolyLine:(GeogebraCommonKernelGeosGeoPolyLine *)geo {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawHistogramOrBarChartBoxWithDoubleArray:(IOSDoubleArray *)values
                                  withDoubleArray:(IOSDoubleArray *)leftBorder
                                          withInt:(jint)length
                                       withDouble:(jdouble)width
           withGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)g {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (void)drawGeoInequalitiesWithGeogebraCommonKernelGeosGeoFunctionNVar:(GeogebraCommonKernelGeosGeoFunctionNVar *)geo
                                withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)e {
  id<GeogebraCommonKernelArithmeticFunctionalNVar> ef = nil;
  if (geo == nil) {
    ef = (id<GeogebraCommonKernelArithmeticFunctionalNVar>) check_protocol_cast(e, @protocol(GeogebraCommonKernelArithmeticFunctionalNVar));
  }
  else {
    ef = geo;
  }
  GeogebraCommonEuclidianDrawDrawInequality *drawable = [new_GeogebraCommonEuclidianDrawDrawInequality_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelArithmeticFunctionalNVar_(euclidianView_, ef) autorelease];
  id<GeogebraCommonAwtGGraphics2D> g = nil;
  GeogebraCommonKernelArithmeticIneqTree *tree = [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(ef)) getFunction])) getIneqs];
  if ([((GeogebraCommonKernelArithmeticIneqTree *) nil_chk(tree)) getLeft] != nil) {
    for (jint i = 0; i < [((GeogebraCommonKernelArithmeticIneqTree *) nil_chk([tree getLeft])) getSize]; i++) {
      g = [self createGraphicsWithGeogebraCommonKernelArithmeticFunctionalNVar:ef withGeogebraCommonKernelArithmeticInequality:[((GeogebraCommonKernelArithmeticIneqTree *) nil_chk([tree getLeft])) getWithInt:i] withGeogebraCommonEuclidianEuclidianView:euclidianView_];
      [drawable drawWithGeogebraCommonAwtGGraphics2D:g];
    }
  }
  if ([tree getRight] != nil) {
    for (jint i = 0; i < [((GeogebraCommonKernelArithmeticIneqTree *) nil_chk([tree getLeft])) getSize]; i++) {
      g = [self createGraphicsWithGeogebraCommonKernelArithmeticFunctionalNVar:ef withGeogebraCommonKernelArithmeticInequality:[((GeogebraCommonKernelArithmeticIneqTree *) nil_chk([tree getRight])) getWithInt:i] withGeogebraCommonEuclidianEuclidianView:euclidianView_];
      [drawable drawWithGeogebraCommonAwtGGraphics2D:g];
    }
  }
  if ([tree getIneq] != nil) {
    g = [self createGraphicsWithGeogebraCommonKernelArithmeticFunctionalNVar:ef withGeogebraCommonKernelArithmeticInequality:[tree getIneq] withGeogebraCommonEuclidianEuclidianView:euclidianView_];
    [drawable drawWithGeogebraCommonAwtGGraphics2D:g];
  }
}

- (void)drawNyquistWithGeogebraCommonKernelGeosGeoTransferFunction:(GeogebraCommonKernelGeosGeoTransferFunction *)g {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
}

- (id<GeogebraCommonAwtGGraphics2D>)createGraphicsWithGeogebraCommonKernelArithmeticFunctionalNVar:(id<GeogebraCommonKernelArithmeticFunctionalNVar>)ef
                                                      withGeogebraCommonKernelArithmeticInequality:(GeogebraCommonKernelArithmeticInequality *)inequality
                                                          withGeogebraCommonEuclidianEuclidianView:(GeogebraCommonEuclidianEuclidianView *)euclidianView2 {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jboolean)fillSplineWithGeogebraCommonKernelGeosGeoCurveCartesianArray:(IOSObjectArray *)curves {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jdouble)getXmin {
  return xmin_;
}

- (void)setXminWithDouble:(jdouble)xmin {
  self->xmin_ = xmin;
}

- (jdouble)getXmax {
  return xmax_;
}

- (void)setXmaxWithDouble:(jdouble)xmax {
  self->xmax_ = xmax;
}

- (jdouble)getYmin {
  return ymin_;
}

- (void)setYminWithDouble:(jdouble)ymin {
  self->ymin_ = ymin;
}

- (jdouble)getYmax {
  return ymax_;
}

- (void)setYmaxWithDouble:(jdouble)ymax {
  self->ymax_ = ymax;
}

- (jdouble)getXunit {
  return xunit_;
}

- (void)setXunitWithDouble:(jdouble)xunit {
  self->xunit_ = xunit;
}

- (jdouble)getYunit {
  return yunit_;
}

- (void)setYunitWithDouble:(jdouble)yunit {
  self->yunit_ = yunit;
}

- (void)markWithDoubleArray:(IOSDoubleArray *)A
            withDoubleArray:(IOSDoubleArray *)B
                    withInt:(jint)deco
withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordsWithDoubleArray:A];
  [euclidianView_ toScreenCoordsWithDoubleArray:B];
  jdouble midX = (IOSDoubleArray_Get(nil_chk(A), 0) + IOSDoubleArray_Get(nil_chk(B), 0)) / 2.0;
  jdouble midY = (IOSDoubleArray_Get(A, 1) + IOSDoubleArray_Get(B, 1)) / 2.0;
  jdouble nx = IOSDoubleArray_Get(A, 1) - IOSDoubleArray_Get(B, 1);
  jdouble ny = IOSDoubleArray_Get(B, 0) - IOSDoubleArray_Get(A, 0);
  jdouble nLength = GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_(nx, ny);
  jdouble tickSpacing = 2.5 + ((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo))->lineThickness_ / 2.0;
  jdouble tickLength = tickSpacing + 1;
  jdouble arrowlength = 1.5;
  jdouble vx, vy, factor, x1, x2, y1, y2;
  switch (deco) {
    case GeogebraCommonKernelGeosGeoElement_DECORATION_SEGMENT_ONE_TICK:
    factor = tickLength / nLength;
    nx *= factor / xunit_;
    ny *= factor / yunit_;
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - nx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - ny];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX + nx];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY + ny];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    break;
    case GeogebraCommonKernelGeosGeoElement_DECORATION_SEGMENT_TWO_TICKS:
    factor = tickSpacing / (2 * nLength);
    vx = -ny * factor;
    vy = nx * factor;
    factor = tickLength / nLength;
    nx *= factor;
    ny *= factor;
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX + vx - nx];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX + vx + nx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY + vy - ny];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY + vy + ny];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - vx - nx];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - vx + nx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - vy - ny];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - vy + ny];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    break;
    case GeogebraCommonKernelGeosGeoElement_DECORATION_SEGMENT_THREE_TICKS:
    factor = tickSpacing / nLength;
    vx = -ny * factor;
    vy = nx * factor;
    factor = tickLength / nLength;
    nx *= factor;
    ny *= factor;
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX + vx - nx];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX + vx + nx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY + vy - ny];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY + vy + ny];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - nx];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX + nx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - ny];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY + ny];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - vx - nx];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - vx + nx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - vy - ny];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - vy + ny];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    break;
    case GeogebraCommonKernelGeosGeoElement_DECORATION_SEGMENT_ONE_ARROW:
    factor = tickSpacing / (nLength);
    vx = -ny * factor;
    vy = nx * factor;
    factor = tickLength / nLength;
    nx *= factor;
    ny *= factor;
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - arrowlength * vx + arrowlength * (nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - arrowlength * vy + arrowlength * (ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - arrowlength * vx + arrowlength * (-nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - arrowlength * vy + arrowlength * (-ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    break;
    case GeogebraCommonKernelGeosGeoElement_DECORATION_SEGMENT_TWO_ARROWS:
    factor = tickSpacing / (nLength);
    vx = -ny * factor;
    vy = nx * factor;
    factor = tickLength / nLength;
    nx *= factor;
    ny *= factor;
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - 2 * arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - 2 * arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - 2 * arrowlength * vx + arrowlength * (nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - 2 * arrowlength * vy + arrowlength * (ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - 2 * arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - 2 * arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - 2 * arrowlength * vx + arrowlength * (-nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - 2 * arrowlength * vy + arrowlength * (-ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX + arrowlength * (nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY + arrowlength * (ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX + arrowlength * (-nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY + arrowlength * (-ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    break;
    case GeogebraCommonKernelGeosGeoElement_DECORATION_SEGMENT_THREE_ARROWS:
    factor = tickSpacing / nLength;
    vx = -ny * factor;
    vy = nx * factor;
    factor = tickLength / nLength;
    nx *= factor;
    ny *= factor;
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - arrowlength * vx + arrowlength * (nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - arrowlength * vy + arrowlength * (ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - arrowlength * vx + arrowlength * (-nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - arrowlength * vy + arrowlength * (-ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX + arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY + arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX + arrowlength * vx + arrowlength * (nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY + arrowlength * vy + arrowlength * (ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX + arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY + arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX + arrowlength * vx + arrowlength * (-nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY + arrowlength * vy + arrowlength * (-ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - 3 * arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - 3 * arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - 3 * arrowlength * vx + arrowlength * (nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - 3 * arrowlength * vy + arrowlength * (ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    x1 = [euclidianView_ toRealWorldCoordXWithDouble:midX - 3 * arrowlength * vx];
    y1 = [euclidianView_ toRealWorldCoordYWithDouble:midY - 3 * arrowlength * vy];
    x2 = [euclidianView_ toRealWorldCoordXWithDouble:midX - 3 * arrowlength * vx + arrowlength * (-nx + vx)];
    y2 = [euclidianView_ toRealWorldCoordYWithDouble:midY - 3 * arrowlength * vy + arrowlength * (-ny + vy)];
    [self drawLineWithDouble:x1 withDouble:y1 withDouble:x2 withDouble:y2 withGeogebraCommonKernelGeosGeoElement:geo];
    break;
  }
}

- (void)markAngleWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                           withDouble:(jdouble)r
                                      withDoubleArray:(IOSDoubleArray *)vertex
                                           withDouble:(jdouble)angSt
                                           withDouble:(jdouble)angEnd {
  jdouble rdiff;
  {
    IOSDoubleArray *angleTick;
    switch (((GeogebraCommonKernelGeosGeoAngle *) nil_chk(geo))->decorationType_) {
      case GeogebraCommonKernelGeosGeoElement_DECORATION_ANGLE_TWO_ARCS:
      rdiff = 4 + geo->lineThickness_ / 2.0;
      [self drawArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r];
      r -= rdiff / [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXscale];
      [self drawArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r];
      break;
      case GeogebraCommonKernelGeosGeoElement_DECORATION_ANGLE_THREE_ARCS:
      rdiff = 4 + geo->lineThickness_ / 2.0;
      [self drawArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r];
      r -= rdiff / [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXscale];
      [self drawArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r];
      r -= rdiff / [euclidianView_ getXscale];
      [self drawArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r];
      break;
      case GeogebraCommonKernelGeosGeoElement_DECORATION_ANGLE_ONE_TICK:
      [self drawArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r];
      [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordsWithDoubleArray:vertex];
      [self drawTickWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:(angSt + angEnd) / 2];
      break;
      case GeogebraCommonKernelGeosGeoElement_DECORATION_ANGLE_TWO_TICKS:
      [self drawArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r];
      [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordsWithDoubleArray:vertex];
      angleTick = [IOSDoubleArray arrayWithLength:2];
      *IOSDoubleArray_GetRef(angleTick, 0) = (2 * angSt + 3 * angEnd) / 5;
      *IOSDoubleArray_GetRef(angleTick, 1) = (3 * angSt + 2 * angEnd) / 5;
      if (JavaLangMath_absWithDouble_(IOSDoubleArray_Get(angleTick, 1) - IOSDoubleArray_Get(angleTick, 0)) > GeogebraCommonEuclidianDrawDrawAngle_get_MAX_TICK_DISTANCE_()) {
        *IOSDoubleArray_GetRef(angleTick, 0) = (angSt + angEnd) / 2 - GeogebraCommonEuclidianDrawDrawAngle_get_MAX_TICK_DISTANCE_() / 2;
        *IOSDoubleArray_GetRef(angleTick, 1) = (angSt + angEnd) / 2 + GeogebraCommonEuclidianDrawDrawAngle_get_MAX_TICK_DISTANCE_() / 2;
      }
      [self drawTickWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:IOSDoubleArray_Get(angleTick, 0)];
      [self drawTickWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:IOSDoubleArray_Get(angleTick, 1)];
      break;
      case GeogebraCommonKernelGeosGeoElement_DECORATION_ANGLE_THREE_TICKS:
      [self drawArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r];
      [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordsWithDoubleArray:vertex];
      angleTick = [IOSDoubleArray arrayWithLength:2];
      *IOSDoubleArray_GetRef(angleTick, 0) = (5 * angSt + 3 * angEnd) / 8;
      *IOSDoubleArray_GetRef(angleTick, 1) = (3 * angSt + 5 * angEnd) / 8;
      if (JavaLangMath_absWithDouble_(IOSDoubleArray_Get(angleTick, 1) - IOSDoubleArray_Get(angleTick, 0)) > GeogebraCommonEuclidianDrawDrawAngle_get_MAX_TICK_DISTANCE_()) {
        *IOSDoubleArray_GetRef(angleTick, 0) = (angSt + angEnd) / 2 - GeogebraCommonEuclidianDrawDrawAngle_get_MAX_TICK_DISTANCE_() / 2;
        *IOSDoubleArray_GetRef(angleTick, 1) = (angSt + angEnd) / 2 + GeogebraCommonEuclidianDrawDrawAngle_get_MAX_TICK_DISTANCE_() / 2;
      }
      [self drawTickWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:(angSt + angEnd) / 2];
      [self drawTickWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:IOSDoubleArray_Get(angleTick, 0)];
      [self drawTickWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:IOSDoubleArray_Get(angleTick, 1)];
      break;
      case GeogebraCommonKernelGeosGeoElement_DECORATION_ANGLE_ARROW_CLOCKWISE:
      [self drawArrowArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r withBoolean:NO];
      break;
      case GeogebraCommonKernelGeosGeoElement_DECORATION_ANGLE_ARROW_ANTICLOCKWISE:
      [self drawArrowArcWithGeogebraCommonKernelGeosGeoAngle:geo withDoubleArray:vertex withDouble:angSt withDouble:angEnd withDouble:r withBoolean:YES];
      break;
    }
  }
}

- (void)drawAllElements {
  jboolean increment = ([((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getShowGrid] || [euclidianView_ getShowXaxis] || [euclidianView_ getShowYaxis]);
  for (jint step = 0; step < [((GeogebraCommonKernelConstruction *) nil_chk(construction_)) steps]; step++) {
    if (increment) beamerSlideNumber_ = step + 2;
    else beamerSlideNumber_ = step + 1;
    IOSObjectArray *geos = [((GeogebraCommonKernelAlgosConstructionElement *) nil_chk([construction_ getConstructionElementWithInt:step])) getGeoElements];
    for (jint j = 0; j < ((IOSObjectArray *) nil_chk(geos))->size_; j++) {
      GeogebraCommonKernelGeosGeoElement *g = IOSObjectArray_Get(geos, j);
      [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:g withBoolean:NO withBoolean:NO];
    }
  }
}

- (void)startBeamerWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  if (isBeamer_) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:JreStrcat("$I$", @"\\onslide<", beamerSlideNumber_, @"->{\n  ")];
}

- (void)endBeamerWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  if (isBeamer_) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"}\n"];
}

- (void)resizeFontWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  jint ggbSize = [((GeogebraCommonMainApp *) nil_chk(app_)) getGUIFontSize];
  jdouble ggbYUnit = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getYscale];
  jdouble fontUnits = ggbSize / ggbYUnit;
  jdouble yunit = [((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) getYUnit];
  jdouble sizeCM = fontUnits * yunit;
  jint sizept = J2ObjCFpToInt((sizeCM / 2.54 * 72.27 + 0.5));
  jint texSize = [frame_ getFontSize];
  if (texSize == 10) {
    if (sizept <= 5) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\tiny{"];
    else if (sizept <= 7) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\scriptsize{"];
    else if (sizept == 8) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\footnotesize{"];
    else if (sizept == 9) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\small{"];
    else if (sizept == 10) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\normalsize{"];
    else if (sizept <= 12) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\large{"];
    else if (sizept <= 14) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\Large{"];
    else if (sizept <= 17) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\LARGE{"];
    else if (sizept <= 20) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\huge{"];
    else [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\Huge{"];
  }
  else if (texSize == 11) {
    if (sizept <= 6) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\tiny{"];
    else if (sizept <= 8) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\scriptsize{"];
    else if (sizept == 9) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\footnotesize{"];
    else if (sizept == 10) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\small{"];
    else if (sizept == 11) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\normalsize{"];
    else if (sizept == 12) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\large{"];
    else if (sizept <= 14) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\Large{"];
    else if (sizept <= 17) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\LARGE{"];
    else if (sizept <= 20) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\huge{"];
    else [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\Huge{"];
  }
  else if (texSize == 12) {
    if (sizept <= 6) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\tiny{"];
    else if (sizept <= 8) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\scriptsize{"];
    else if (sizept <= 10) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\footnotesize{"];
    else if (sizept == 11) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\small{"];
    else if (sizept == 12) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\normalsize{"];
    else if (sizept <= 14) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\large{"];
    else if (sizept <= 17) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\Large{"];
    else if (sizept <= 20) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\LARGE{"];
    else if (sizept <= 25) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\huge{"];
    else [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\Huge{"];
  }
}

- (NSString *)getImplicitExprWithGeogebraCommonKernelImplicitGeoImplicitPoly:(GeogebraCommonKernelImplicitGeoImplicitPoly *)geo {
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  IOSObjectArray *coeff = [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(geo)) getCoeff];
  jboolean first = YES;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(coeff))->size_; i++) {
    for (jint j = 0; j < ((IOSDoubleArray *) nil_chk(IOSObjectArray_Get(coeff, i)))->size_; j++) {
      jdouble tmp = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(coeff, i)), j);
      if (tmp != 0) {
        if (tmp > 0) {
          if (!first) [sb appendWithNSString:@"+"];
        }
        [sb appendWithDouble:tmp];
        if (i == 0) {
          if (j != 0) {
            [sb appendWithNSString:@"*y^"];
            [sb appendWithInt:j];
          }
        }
        else {
          [sb appendWithNSString:@"*x^"];
          [sb appendWithInt:i];
          if (j != 0) {
            [sb appendWithNSString:@"*y^"];
            [sb appendWithInt:j];
          }
        }
        first = NO;
      }
    }
  }
  return [NSString stringWithJavaLangStringBuilder:sb];
}

- (GeogebraCommonKernelStringTemplate *)getStringTemplate {
  return tpl_;
}

- (JavaLangStringBuilder *)drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                                                           withDouble:(jdouble)xrangemax
                                                                           withDouble:(jdouble)xrangemin
                                                                              withInt:(jint)point
                                                                         withNSString:(NSString *)template_ {
  GeogebraCommonKernelGeosGeoCurveCartesian *curve = [new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_([((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonMainApp *) nil_chk(app_)) getKernel])) getConstruction]) autorelease];
  [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(geo)) toGeoCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:curve];
  JavaLangStringBuilder *lineBuilder = [new_JavaLangStringBuilder_init() autorelease];
  jdouble y = [geo evaluateWithDouble:xrangemin];
  jdouble yprec = y;
  if (JavaLangMath_absWithDouble_(y) < 0.001) y = yprec = 0;
  jdouble step = (xrangemax - xrangemin) / point;
  jdouble xprec = xrangemin;
  jdouble x = xprec;
  for (; x <= xrangemax; x += step) {
    y = [geo evaluateWithDouble:x];
    if (JavaLangMath_absWithDouble_(y) < 0.001) y = 0;
    if (JavaLangMath_absWithDouble_(x) < 0.001) x = 0;
    if (JavaLangMath_absWithDouble_(yprec - y) < (ymax_ - ymin_)) {
      if (GeogebraCommonEuclidianPlotCurvePlotter_isContinuousWithGeogebraCommonKernelKernelNDCurveEvaluable_withDouble_withDouble_withInt_(curve, xprec, x, 8)) {
        [lineBuilder appendWithId:GeogebraCommonUtilStringUtil_formatWithNSString_withDouble_withDouble_withDouble_withDouble_(template_, xprec, yprec, x, y)];
      }
    }
    yprec = y;
    xprec = x;
  }
  return lineBuilder;
}

- (JavaLangStringBuilder *)drawNyquistDiagramWithGeogebraCommonKernelGeosGeoTransferFunction:(GeogebraCommonKernelGeosGeoTransferFunction *)geo
                                                                                withNSString:(NSString *)template_
                                                                                withNSString:(NSString *)arrowMark
                                                                                withNSString:(NSString *)arrowCommand
                                                                                withNSString:(NSString *)reverseArrowCommand {
  NSString *t = template_;
  NSString *sub;
  jboolean flag = YES;
  JavaLangStringBuilder *lineBuilder = [new_JavaLangStringBuilder_init() autorelease];
  id<JavaUtilList> coordsList = [((GeogebraCommonKernelGeosGeoTransferFunction *) nil_chk(geo)) getCoordsList];
  GeogebraCommonKernelMatrixCoords *p = [((id<JavaUtilList>) nil_chk(coordsList)) getWithInt:0];
  jdouble xprec = [((GeogebraCommonKernelMatrixCoords *) nil_chk(p)) getX];
  jdouble yprec = [p getY];
  jdouble x;
  jdouble y;
  for (jint i = 1; i < [coordsList size] - 10; i += 10) {
    p = [coordsList getWithInt:i];
    x = [((GeogebraCommonKernelMatrixCoords *) nil_chk(p)) getX];
    y = [p getY];
    if (flag && i > [coordsList size] / 2.3) {
      sub = [((NSString *) nil_chk(t)) replaceAll:arrowMark withReplacement:arrowCommand];
      flag = NO;
    }
    else {
      sub = [((NSString *) nil_chk(t)) replaceAll:arrowMark withReplacement:@""];
    }
    [lineBuilder appendWithId:GeogebraCommonUtilStringUtil_formatWithNSString_withDouble_withDouble_withDouble_withDouble_(sub, xprec, yprec, x, y)];
    xprec = x;
    yprec = y;
  }
  flag = YES;
  p = [coordsList getWithInt:0];
  xprec = [((GeogebraCommonKernelMatrixCoords *) nil_chk(p)) getX];
  yprec = -[p getY];
  for (jint i = 1; i < [coordsList size]; i += 4) {
    p = [coordsList getWithInt:i];
    x = [((GeogebraCommonKernelMatrixCoords *) nil_chk(p)) getX];
    y = -[p getY];
    if (flag && i > [coordsList size] / 2.3) {
      sub = [((NSString *) nil_chk(t)) replaceAll:arrowMark withReplacement:reverseArrowCommand];
      flag = NO;
    }
    else {
      sub = [((NSString *) nil_chk(t)) replaceAll:arrowMark withReplacement:@""];
    }
    [lineBuilder appendWithId:GeogebraCommonUtilStringUtil_formatWithNSString_withDouble_withDouble_withDouble_withDouble_(sub, xprec, yprec, x, y)];
    xprec = x;
    yprec = y;
  }
  return lineBuilder;
}

- (jboolean)isLatexFunctionWithNSString:(NSString *)s {
  return ![((NSString *) nil_chk([((NSString *) nil_chk(s)) lowercaseString])) contains:@"erf("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"gamma("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"gammaRegularized("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"cbrt("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"csc("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"csch("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"sec("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"cot("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"coth("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"sech("] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"if"] && ![((NSString *) nil_chk([s lowercaseString])) contains:@"\u212f^"];
}

- (void)addTextPackage {
  JavaLangStringBuilder *packages = [new_JavaLangStringBuilder_init() autorelease];
  if ([((JavaLangStringBuilder *) nil_chk(codePreamble_)) indexOfWithNSString:@"amssymb"] == -1) {
    [packages appendWithNSString:@"amssymb,"];
  }
  if ([codePreamble_ indexOfWithNSString:@"fancyhdr"] == -1) {
    [packages appendWithNSString:@"fancyhdr,"];
  }
  if ([codePreamble_ indexOfWithNSString:@"txfonts"] == -1) {
    [packages appendWithNSString:@"txfonts,"];
  }
  if ([codePreamble_ indexOfWithNSString:@"pxfonts"] == -1) {
    [packages appendWithNSString:@"pxfonts,"];
  }
  if ([packages length] != 0) {
    [packages delete__WithInt:[packages length] - 1 withInt:[packages length]];
    [codePreamble_ appendWithNSString:JreStrcat("$$$", @"\\usepackage{", [packages description], @"}\n")];
  }
}

- (void)drawCurveCartesianWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  GeogebraCommonExportPstricksGeoGebraExport_drawCurveCartesianWithGeogebraCommonKernelGeosGeoElement_(self, geo);
}

- (void)dealloc {
  RELEASE_(code_);
  RELEASE_(codePoint_);
  RELEASE_(codePreamble_);
  RELEASE_(codeFilledObject_);
  RELEASE_(codeBeginDoc_);
  RELEASE_(app_);
  RELEASE_(kernel_);
  RELEASE_(construction_);
  RELEASE_(euclidianView_);
  RELEASE_(frame_);
  RELEASE_(CustomColor_);
  RELEASE_(tpl_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonMainApp:", "GeoGebraExport", NULL, 0x1, NULL, NULL },
    { "getApp", NULL, "Lgeogebra.common.main.App;", 0x1, NULL, NULL },
    { "formatWithDouble:", "format", "Ljava.lang.String;", 0x4, NULL, NULL },
    { "refreshSelectionRectangle", NULL, "V", 0x1, NULL, NULL },
    { "setxminWithDouble:", "setxmin", "V", 0x1, NULL, NULL },
    { "setxmaxWithDouble:", "setxmax", "V", 0x1, NULL, NULL },
    { "setyminWithDouble:", "setymin", "V", 0x1, NULL, NULL },
    { "setymaxWithDouble:", "setymax", "V", 0x1, NULL, NULL },
    { "getxmin", NULL, "D", 0x1, NULL, NULL },
    { "getxmax", NULL, "D", 0x1, NULL, NULL },
    { "getymin", NULL, "D", 0x1, NULL, NULL },
    { "getymax", NULL, "D", 0x1, NULL, NULL },
    { "initBounds", NULL, "V", 0x2, NULL, NULL },
    { "setBeamerWithBoolean:", "setBeamer", "V", 0x1, NULL, NULL },
    { "sci2decWithDouble:", "sci2dec", "Ljava.lang.String;", 0x4, NULL, NULL },
    { "createCustomColorWithInt:withInt:withInt:", "createCustomColor", "Ljava.lang.String;", 0x4, NULL, NULL },
    { "drawGeoElementWithGeogebraCommonKernelGeosGeoElement:withBoolean:withBoolean:", "drawGeoElement", "V", 0x4, NULL, NULL },
    { "drawBarChartOrHistogramWithGeogebraCommonKernelGeosGeoNumeric:", "drawBarChartOrHistogram", "V", 0x4, NULL, NULL },
    { "isSinglePointConicWithGeogebraCommonKernelGeosGeoElement:", "isSinglePointConic", "Z", 0x4, NULL, NULL },
    { "isDoubleLineConicWithGeogebraCommonKernelGeosGeoElement:", "isDoubleLineConic", "Z", 0x4, NULL, NULL },
    { "isEmptyWithGeogebraCommonKernelGeosGeoElement:", "isEmpty", "Z", 0x4, NULL, NULL },
    { "resizePtWithInt:", "resizePt", "I", 0x4, NULL, NULL },
    { "drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:", "drawGeoPoint", "V", 0x404, NULL, NULL },
    { "drawGeoLineWithGeogebraCommonKernelGeosGeoLine:", "drawGeoLine", "V", 0x404, NULL, NULL },
    { "drawGeoRayWithGeogebraCommonKernelGeosGeoRay:", "drawGeoRay", "V", 0x404, NULL, NULL },
    { "drawGeoSegmentWithGeogebraCommonKernelGeosGeoSegment:", "drawGeoSegment", "V", 0x404, NULL, NULL },
    { "drawPolygonWithGeogebraCommonKernelGeosGeoPolygon:", "drawPolygon", "V", 0x404, NULL, NULL },
    { "drawSliderWithGeogebraCommonKernelGeosGeoNumeric:", "drawSlider", "V", 0x404, NULL, NULL },
    { "drawSlopeWithGeogebraCommonKernelGeosGeoNumeric:", "drawSlope", "V", 0x404, NULL, NULL },
    { "drawIntegralWithGeogebraCommonKernelGeosGeoNumeric:", "drawIntegral", "V", 0x404, NULL, NULL },
    { "drawIntegralFunctionsWithGeogebraCommonKernelGeosGeoNumeric:", "drawIntegralFunctions", "V", 0x404, NULL, NULL },
    { "drawSumUpperLowerWithGeogebraCommonKernelGeosGeoNumeric:", "drawSumUpperLower", "V", 0x404, NULL, NULL },
    { "drawSumTrapezoidalWithGeogebraCommonKernelGeosGeoNumeric:", "drawSumTrapezoidal", "V", 0x404, NULL, NULL },
    { "drawBoxPlotWithGeogebraCommonKernelGeosGeoNumeric:", "drawBoxPlot", "V", 0x404, NULL, NULL },
    { "drawAngleWithGeogebraCommonKernelGeosGeoAngle:", "drawAngle", "V", 0x404, NULL, NULL },
    { "drawGeoVectorWithGeogebraCommonKernelGeosGeoVector:", "drawGeoVector", "V", 0x404, NULL, NULL },
    { "drawGeoConicWithGeogebraCommonKernelGeosGeoConic:", "drawGeoConic", "V", 0x404, NULL, NULL },
    { "drawGeoConicPartWithGeogebraCommonKernelGeosGeoConicPart:", "drawGeoConicPart", "V", 0x404, NULL, NULL },
    { "drawLabelWithGeogebraCommonKernelGeosGeoElement:withGeogebraCommonEuclidianDrawableND:", "drawLabel", "V", 0x404, NULL, NULL },
    { "drawFunctionWithGeogebraCommonKernelGeosGeoFunction:", "drawFunction", "V", 0x404, NULL, NULL },
    { "drawImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:", "drawImplicitPoly", "V", 0x404, NULL, NULL },
    { "drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:withBoolean:", "drawSingleCurveCartesian", "V", 0x404, NULL, NULL },
    { "drawTextWithGeogebraCommonKernelGeosGeoText:", "drawText", "V", 0x404, NULL, NULL },
    { "drawLocusWithGeogebraCommonKernelGeosGeoLocus:", "drawLocus", "V", 0x404, NULL, NULL },
    { "drawLineWithDouble:withDouble:withDouble:withDouble:withGeogebraCommonKernelGeosGeoElement:", "drawLine", "V", 0x404, NULL, NULL },
    { "drawArcWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:withDouble:withDouble:", "drawArc", "V", 0x404, NULL, NULL },
    { "drawTickWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:", "drawTick", "V", 0x404, NULL, NULL },
    { "drawArrowArcWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:withDouble:withDouble:withBoolean:", "drawArrowArc", "V", 0x404, NULL, NULL },
    { "setFrameWithGeogebraCommonExportPstricksExportSettings:", "setFrame", "V", 0x11, NULL, NULL },
    { "generateAllCode", NULL, "V", 0x401, NULL, NULL },
    { "ColorCodeWithGeogebraCommonAwtGColor:withJavaLangStringBuilder:", "ColorCode", "V", 0x404, NULL, NULL },
    { "drawPolyLineWithGeogebraCommonKernelGeosGeoPolyLine:", "drawPolyLine", "V", 0x404, NULL, NULL },
    { "drawHistogramOrBarChartBoxWithDoubleArray:withDoubleArray:withInt:withDouble:withGeogebraCommonKernelGeosGeoNumeric:", "drawHistogramOrBarChartBox", "V", 0x404, NULL, NULL },
    { "drawGeoInequalitiesWithGeogebraCommonKernelGeosGeoFunctionNVar:withGeogebraCommonKernelGeosGeoElement:", "drawGeoInequalities", "V", 0x4, NULL, NULL },
    { "drawNyquistWithGeogebraCommonKernelGeosGeoTransferFunction:", "drawNyquist", "V", 0x404, NULL, NULL },
    { "createGraphicsWithGeogebraCommonKernelArithmeticFunctionalNVar:withGeogebraCommonKernelArithmeticInequality:withGeogebraCommonEuclidianEuclidianView:", "createGraphics", "Lgeogebra.common.awt.GGraphics2D;", 0x404, NULL, NULL },
    { "fillSplineWithGeogebraCommonKernelGeosGeoCurveCartesianArray:", "fillSpline", "Z", 0x404, NULL, NULL },
    { "getXmin", NULL, "D", 0x1, NULL, NULL },
    { "setXminWithDouble:", "setXmin", "V", 0x1, NULL, NULL },
    { "getXmax", NULL, "D", 0x1, NULL, NULL },
    { "setXmaxWithDouble:", "setXmax", "V", 0x1, NULL, NULL },
    { "getYmin", NULL, "D", 0x1, NULL, NULL },
    { "setYminWithDouble:", "setYmin", "V", 0x1, NULL, NULL },
    { "getYmax", NULL, "D", 0x1, NULL, NULL },
    { "setYmaxWithDouble:", "setYmax", "V", 0x1, NULL, NULL },
    { "getXunit", NULL, "D", 0x1, NULL, NULL },
    { "setXunitWithDouble:", "setXunit", "V", 0x1, NULL, NULL },
    { "getYunit", NULL, "D", 0x1, NULL, NULL },
    { "setYunitWithDouble:", "setYunit", "V", 0x1, NULL, NULL },
    { "markWithDoubleArray:withDoubleArray:withInt:withGeogebraCommonKernelGeosGeoElement:", "mark", "V", 0x4, NULL, NULL },
    { "markAngleWithGeogebraCommonKernelGeosGeoAngle:withDouble:withDoubleArray:withDouble:withDouble:", "markAngle", "V", 0x4, NULL, NULL },
    { "drawAllElements", NULL, "V", 0x4, NULL, NULL },
    { "startBeamerWithJavaLangStringBuilder:", "startBeamer", "V", 0x4, NULL, NULL },
    { "endBeamerWithJavaLangStringBuilder:", "endBeamer", "V", 0x4, NULL, NULL },
    { "resizeFontWithJavaLangStringBuilder:", "resizeFont", "V", 0x4, NULL, NULL },
    { "getImplicitExprWithGeogebraCommonKernelImplicitGeoImplicitPoly:", "getImplicitExpr", "Ljava.lang.String;", 0x4, NULL, NULL },
    { "getStringTemplate", NULL, "Lgeogebra.common.kernel.StringTemplate;", 0x4, NULL, NULL },
    { "drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction:withDouble:withDouble:withInt:withNSString:", "drawNoLatexFunction", "Ljava.lang.StringBuilder;", 0x4, NULL, NULL },
    { "drawNyquistDiagramWithGeogebraCommonKernelGeosGeoTransferFunction:withNSString:withNSString:withNSString:withNSString:", "drawNyquistDiagram", "Ljava.lang.StringBuilder;", 0x4, NULL, NULL },
    { "isLatexFunctionWithNSString:", "isLatexFunction", "Z", 0x4, NULL, NULL },
    { "addTextPackage", NULL, "V", 0x4, NULL, NULL },
    { "drawCurveCartesianWithGeogebraCommonKernelGeosGeoElement:", "drawCurveCartesian", "V", 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "beamerSlideNumber_", NULL, 0x4, "I", NULL, NULL,  },
    { "PRECISION_XRANGE_FUNCTION_", NULL, 0x14, "D", NULL, NULL,  },
    { "code_", NULL, 0x4, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "codePoint_", NULL, 0x4, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "codePreamble_", NULL, 0x4, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "codeFilledObject_", NULL, 0x4, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "codeBeginDoc_", NULL, 0x4, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "app_", NULL, 0x2, "Lgeogebra.common.main.App;", NULL, NULL,  },
    { "kernel_", NULL, 0x4, "Lgeogebra.common.kernel.Kernel;", NULL, NULL,  },
    { "construction_", NULL, 0x4, "Lgeogebra.common.kernel.Construction;", NULL, NULL,  },
    { "euclidianView_", NULL, 0x4, "Lgeogebra.common.euclidian.EuclidianView;", NULL, NULL,  },
    { "frame_", NULL, 0x4, "Lgeogebra.common.export.pstricks.ExportSettings;", NULL, NULL,  },
    { "CustomColor_", NULL, 0x4, "Ljava.util.HashMap;", NULL, "Ljava/util/HashMap<Lgeogebra/common/awt/GColor;Ljava/lang/String;>;",  },
    { "xunit_", NULL, 0x4, "D", NULL, NULL,  },
    { "yunit_", NULL, 0x4, "D", NULL, NULL,  },
    { "xmin_", NULL, 0x4, "D", NULL, NULL,  },
    { "xmax_", NULL, 0x4, "D", NULL, NULL,  },
    { "ymin_", NULL, 0x4, "D", NULL, NULL,  },
    { "ymax_", NULL, 0x4, "D", NULL, NULL,  },
    { "format__", "format", 0x4, "I", NULL, NULL,  },
    { "isBeamer_", NULL, 0x4, "Z", NULL, NULL,  },
    { "barNumber_", NULL, 0x4, "I", NULL, NULL,  },
    { "tpl_", NULL, 0x2, "Lgeogebra.common.kernel.StringTemplate;", NULL, NULL,  },
  };
  static const char *inner_classes[] = {"Lgeogebra.common.export.pstricks.GeoGebraExport$Info;"};
  static const J2ObjcClassInfo _GeogebraCommonExportPstricksGeoGebraExport = { 2, "GeoGebraExport", "geogebra.common.export.pstricks", NULL, 0x401, 82, methods, 23, fields, 0, NULL, 1, inner_classes, NULL, NULL };
  return &_GeogebraCommonExportPstricksGeoGebraExport;
}

@end

void GeogebraCommonExportPstricksGeoGebraExport_initWithGeogebraCommonMainApp_(GeogebraCommonExportPstricksGeoGebraExport *self, GeogebraCommonMainApp *app) {
  NSObject_init(self);
  self->beamerSlideNumber_ = 1;
  self->PRECISION_XRANGE_FUNCTION_ = 0.00001;
  self->format__ = 0;
  self->isBeamer_ = NO;
  GeogebraCommonExportPstricksGeoGebraExport_set_app_(self, app);
  GeogebraCommonExportPstricksGeoGebraExport_set_kernel_(self, [((GeogebraCommonMainApp *) nil_chk(app)) getKernel]);
  GeogebraCommonExportPstricksGeoGebraExport_set_construction_(self, [((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getConstruction]);
  GeogebraCommonExportPstricksGeoGebraExport_set_euclidianView_(self, (GeogebraCommonEuclidianEuclidianView *) check_class_cast([app getActiveEuclidianView], [GeogebraCommonEuclidianEuclidianView class]));
  GeogebraCommonExportPstricksGeoGebraExport_set_tpl_(self, GeogebraCommonKernelStringTemplate_printFiguresWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_withInt_withBoolean_(GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_PSTRICKS(), 12, NO));
  GeogebraCommonExportPstricksGeoGebraExport_initBounds(self);
}

void GeogebraCommonExportPstricksGeoGebraExport_initBounds(GeogebraCommonExportPstricksGeoGebraExport *self) {
  self->xunit_ = 1;
  self->yunit_ = 1;
  id<GeogebraCommonAwtGRectangle> rect = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->euclidianView_)) getSelectionRectangle];
  if (rect != nil) {
    self->xmin_ = [self->euclidianView_ toRealWorldCoordXWithDouble:[rect getMinX]];
    self->xmax_ = [self->euclidianView_ toRealWorldCoordXWithDouble:[rect getMaxX]];
    self->ymin_ = [self->euclidianView_ toRealWorldCoordYWithDouble:[rect getMaxY]];
    self->ymax_ = [self->euclidianView_ toRealWorldCoordYWithDouble:[rect getMinY]];
  }
  else {
    self->xmin_ = [self->euclidianView_ getXmin];
    self->xmax_ = [self->euclidianView_ getXmax];
    self->ymin_ = [self->euclidianView_ getYmin];
    self->ymax_ = [self->euclidianView_ getYmax];
  }
}

void GeogebraCommonExportPstricksGeoGebraExport_drawCurveCartesianWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonExportPstricksGeoGebraExport *self, GeogebraCommonKernelGeosGeoElement *geo) {
  if (![self isLatexFunctionWithNSString:[((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()]]) {
    GeogebraCommonKernelGeosGeoCurveCartesian *curve = (GeogebraCommonKernelGeosGeoCurveCartesian *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoCurveCartesian class]);
    GeogebraCommonKernelArithmeticFunction *f = [curve getFunX];
    GeogebraCommonKernelArithmeticExpressionNode *exl = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk(f)) getFunctionExpression])) getLeftTree];
    GeogebraCommonKernelArithmeticExpressionNode *exr = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([f getFunctionExpression])) getRightTree];
    NSString *exls = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exl)) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()];
    NSString *exrs = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exr)) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()];
    exrs = [((NSString *) nil_chk(exrs)) replace:@"{" withSequence:@""];
    exrs = [((NSString *) nil_chk(exrs)) replace:@"}" withSequence:@""];
    exls = [((NSString *) nil_chk(exls)) replace:@"{" withSequence:@""];
    exls = [((NSString *) nil_chk(exls)) replace:@"}" withSequence:@""];
    IOSObjectArray *exlsv = [((NSString *) nil_chk(exls)) split:@","];
    IOSObjectArray *exrsv = [((NSString *) nil_chk(exrs)) split:@","];
    IOSObjectArray *paramValues = [IOSObjectArray arrayWithLength:((IOSObjectArray *) nil_chk(exlsv))->size_ + 1 type:NSString_class_()];
    IOSObjectArray_Set(paramValues, 0, @"0");
    for (jint i = 0; i < exlsv->size_; i++) {
      IOSObjectArray_Set(paramValues, i + 1, IOSObjectArray_Get(nil_chk([((NSString *) nil_chk(IOSObjectArray_Get(exlsv, i))) split:@"<"]), 1));
    }
    IOSObjectArray *curves = [IOSObjectArray arrayWithLength:exlsv->size_ type:GeogebraCommonKernelGeosGeoCurveCartesian_class_()];
    GeogebraCommonKernelCommandsAlgebraProcessor *ap = [((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getAlgebraProcessor];
    for (jint i = 0; i < exlsv->size_; i++) {
      GeogebraCommonKernelGeosGeoFunction *fxx = [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk(ap)) evaluateToFunctionWithNSString:JreStrcat("$$", @"xspline(t)=", IOSObjectArray_Get(nil_chk(exrsv), i)) withBoolean:YES];
      IOSObjectArray_SetAndConsume(curves, i, new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(self->construction_));
      [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) setFunctionXWithGeogebraCommonKernelArithmeticFunction:[((GeogebraCommonKernelGeosGeoFunction *) nil_chk(fxx)) getFunction]];
      [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) setIntervalWithDouble:JavaLangDouble_parseDoubleWithNSString_(IOSObjectArray_Get(paramValues, i)) withDouble:JavaLangDouble_parseDoubleWithNSString_(IOSObjectArray_Get(paramValues, i + 1))];
      [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) setAllVisualPropertiesWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO];
    }
    f = [curve getFunY];
    exl = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk(f)) getFunctionExpression])) getLeftTree];
    exr = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([f getFunctionExpression])) getRightTree];
    exls = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exl)) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()];
    exrs = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exr)) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()];
    exrs = [((NSString *) nil_chk(exrs)) replace:@"{" withSequence:@""];
    exrs = [((NSString *) nil_chk(exrs)) replace:@"}" withSequence:@""];
    exls = [((NSString *) nil_chk(exls)) replace:@"{" withSequence:@""];
    exls = [((NSString *) nil_chk(exls)) replace:@"}" withSequence:@""];
    exlsv = [((NSString *) nil_chk(exls)) split:@","];
    exrsv = [((NSString *) nil_chk(exrs)) split:@","];
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(exlsv))->size_; i++) {
      GeogebraCommonKernelGeosGeoFunction *fxx = [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk(ap)) evaluateToFunctionWithNSString:JreStrcat("$$", @"yspline(t)=", IOSObjectArray_Get(nil_chk(exrsv), i)) withBoolean:YES];
      [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) setFunctionYWithGeogebraCommonKernelArithmeticFunction:[((GeogebraCommonKernelGeosGeoFunction *) nil_chk(fxx)) getFunction]];
      [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) setIntervalWithDouble:JavaLangDouble_parseDoubleWithNSString_(IOSObjectArray_Get(paramValues, i)) withDouble:JavaLangDouble_parseDoubleWithNSString_(IOSObjectArray_Get(paramValues, i + 1))];
    }
    jboolean fill = [self fillSplineWithGeogebraCommonKernelGeosGeoCurveCartesianArray:curves];
    if (!fill) {
      for (jint i = 0; i < curves->size_; i++) {
        [self drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:IOSObjectArray_Get(curves, i) withBoolean:YES];
      }
    }
  }
  else {
    [self drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoCurveCartesian class]) withBoolean:YES];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonExportPstricksGeoGebraExport)

@implementation GeogebraCommonExportPstricksGeoGebraExport_Info

- (instancetype)initWithGeogebraCommonExportPstricksGeoGebraExport:(GeogebraCommonExportPstricksGeoGebraExport *)outer$
                            withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  GeogebraCommonExportPstricksGeoGebraExport_Info_initWithGeogebraCommonExportPstricksGeoGebraExport_withGeogebraCommonKernelGeosGeoElement_(self, outer$, geo);
  return self;
}

- (jfloat)getAlpha {
  return alpha_;
}

- (jint)getY {
  return y_;
}

- (jdouble)getAngle {
  return angle_;
}

- (GeogebraCommonKernelGeosGeoElement_FillTypeEnum *)getFillType {
  return fillType_;
}

- (GeogebraCommonAwtGColor *)getLinecolor {
  return linecolor_;
}

- (void)dealloc {
  RELEASE_(fillType_);
  RELEASE_(linecolor_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonExportPstricksGeoGebraExport:withGeogebraCommonKernelGeosGeoElement:", "Info", NULL, 0x1, NULL, NULL },
    { "getAlpha", NULL, "F", 0x1, NULL, NULL },
    { "getY", NULL, "I", 0x1, NULL, NULL },
    { "getAngle", NULL, "D", 0x1, NULL, NULL },
    { "getFillType", NULL, "Lgeogebra.common.kernel.geos.GeoElement$FillType;", 0x1, NULL, NULL },
    { "getLinecolor", NULL, "Lgeogebra.common.awt.GColor;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "alpha_", NULL, 0x2, "F", NULL, NULL,  },
    { "y_", NULL, 0x2, "I", NULL, NULL,  },
    { "angle_", NULL, 0x2, "D", NULL, NULL,  },
    { "fillType_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoElement$FillType;", NULL, NULL,  },
    { "linecolor_", NULL, 0x2, "Lgeogebra.common.awt.GColor;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonExportPstricksGeoGebraExport_Info = { 2, "Info", "geogebra.common.export.pstricks", "GeoGebraExport", 0x4, 6, methods, 5, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonExportPstricksGeoGebraExport_Info;
}

@end

void GeogebraCommonExportPstricksGeoGebraExport_Info_initWithGeogebraCommonExportPstricksGeoGebraExport_withGeogebraCommonKernelGeosGeoElement_(GeogebraCommonExportPstricksGeoGebraExport_Info *self, GeogebraCommonExportPstricksGeoGebraExport *outer$, GeogebraCommonKernelGeosGeoElement *geo) {
  NSObject_init(self);
  self->alpha_ = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getAlphaValue];
  self->y_ = [geo getHatchingDistance];
  self->angle_ = [geo getHatchingAngle];
  GeogebraCommonExportPstricksGeoGebraExport_Info_set_fillType_(self, [geo getFillType]);
  GeogebraCommonExportPstricksGeoGebraExport_Info_set_linecolor_(self, [geo getObjectColor]);
  IOSFloatArray *rgb = nil;
  if ([[geo getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoBarChart class]]) {
    GeogebraCommonKernelAlgosAlgoBarChart *algo = (GeogebraCommonKernelAlgosAlgoBarChart *) check_class_cast([geo getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoBarChart class]);
    if ([((GeogebraCommonKernelAlgosAlgoBarChart *) nil_chk(algo)) getBarColorWithInt:outer$->barNumber_] != nil) {
      rgb = [IOSFloatArray arrayWithLength:4];
      [((GeogebraCommonAwtGColor *) nil_chk([algo getBarColorWithInt:outer$->barNumber_])) getRGBColorComponentsWithFloatArray:rgb];
      GeogebraCommonExportPstricksGeoGebraExport_Info_set_linecolor_(self, [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newColorWithFloat:IOSFloatArray_Get(rgb, 0) withFloat:IOSFloatArray_Get(rgb, 1) withFloat:IOSFloatArray_Get(rgb, 2) withFloat:IOSFloatArray_Get(rgb, 3)]);
    }
    if ([algo getBarHatchDistanceWithInt:outer$->barNumber_] != -1) {
      self->y_ = [algo getBarHatchDistanceWithInt:outer$->barNumber_];
    }
    if ([algo getBarHatchAngleWithInt:outer$->barNumber_] != -1) {
      self->angle_ = [algo getBarHatchAngleWithInt:outer$->barNumber_];
    }
    if ([algo getBarFillTypeWithInt:outer$->barNumber_] != nil) {
      GeogebraCommonExportPstricksGeoGebraExport_Info_set_fillType_(self, IOSObjectArray_Get(nil_chk(GeogebraCommonKernelGeosGeoElement_FillTypeEnum_values()), [((GeogebraCommonKernelGeosGeoElement_FillTypeEnum *) nil_chk([algo getBarFillTypeWithInt:outer$->barNumber_])) ordinal]));
    }
    if ([algo getBarAlphaWithInt:outer$->barNumber_] != -1 && rgb != nil) {
      self->alpha_ = IOSFloatArray_Get(rgb, 3);
    }
  }
}

GeogebraCommonExportPstricksGeoGebraExport_Info *new_GeogebraCommonExportPstricksGeoGebraExport_Info_initWithGeogebraCommonExportPstricksGeoGebraExport_withGeogebraCommonKernelGeosGeoElement_(GeogebraCommonExportPstricksGeoGebraExport *outer$, GeogebraCommonKernelGeosGeoElement *geo) {
  GeogebraCommonExportPstricksGeoGebraExport_Info *self = [GeogebraCommonExportPstricksGeoGebraExport_Info alloc];
  GeogebraCommonExportPstricksGeoGebraExport_Info_initWithGeogebraCommonExportPstricksGeoGebraExport_withGeogebraCommonKernelGeosGeoElement_(self, outer$, geo);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonExportPstricksGeoGebraExport_Info)
