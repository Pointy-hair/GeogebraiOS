//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/algos/AlgoShearOrStretch.java
//


#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/MatrixTransformable.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoShearOrStretch.h"
#include "geogebra/common/kernel/algos/AlgoTransformation.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoConicPart.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoList.h"
#include "geogebra/common/kernel/geos/GeoPoly.h"
#include "geogebra/common/kernel/geos/GeoVec3D.h"
#include "geogebra/common/kernel/geos/GeoVector.h"
#include "geogebra/common/kernel/geos/Translateable.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/util/MyMath.h"
#include "java/lang/Math.h"

@interface GeogebraCommonKernelAlgosAlgoShearOrStretch () {
 @public
  id<GeogebraCommonKernelMatrixTransformable> out_;
  GeogebraCommonKernelGeosGeoElement *inGeo_, *outGeo_;
  GeogebraCommonKernelGeosGeoVec3D *line_;
  id<GeogebraCommonKernelArithmeticNumberValue> num_;
  jboolean shear_;
  jdouble n_;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoShearOrStretch, out_, id<GeogebraCommonKernelMatrixTransformable>)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoShearOrStretch, inGeo_, GeogebraCommonKernelGeosGeoElement *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoShearOrStretch, outGeo_, GeogebraCommonKernelGeosGeoElement *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoShearOrStretch, line_, GeogebraCommonKernelGeosGeoVec3D *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoShearOrStretch, num_, id<GeogebraCommonKernelArithmeticNumberValue>)

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoShearOrStretch_compute(GeogebraCommonKernelAlgosAlgoShearOrStretch *self);

@implementation GeogebraCommonKernelAlgosAlgoShearOrStretch

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                  withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)inArg
                    withGeogebraCommonKernelGeosGeoVec3D:(GeogebraCommonKernelGeosGeoVec3D *)l
           withGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)num
                                             withBoolean:(jboolean)shear {
  GeogebraCommonKernelAlgosAlgoShearOrStretch_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoVec3D_withGeogebraCommonKernelArithmeticNumberValue_withBoolean_(self, cons, inArg, l, num, shear);
  return self;
}

- (GeogebraCommonKernelCommandsCommandsEnum *)getClassName {
  if (shear_) return GeogebraCommonKernelCommandsCommandsEnum_get_Shear();
  return GeogebraCommonKernelCommandsCommandsEnum_get_Stretch();
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_setAndConsume_input_(self, [IOSObjectArray newArrayWithLength:num_ == nil ? 2 : 3 type:GeogebraCommonKernelGeosGeoElement_class_()]);
  IOSObjectArray_Set(input_, 0, inGeo_);
  IOSObjectArray_Set(input_, 1, line_);
  if (num_ != nil) IOSObjectArray_Set(input_, 2, [num_ toGeoElement]);
  [self setOutputLengthWithInt:1];
  [self setOutputWithInt:0 withGeogebraCommonKernelGeosGeoElement:outGeo_];
  [self setDependencies];
}

- (GeogebraCommonKernelGeosGeoElement *)getResult {
  return outGeo_;
}

- (void)compute {
  GeogebraCommonKernelAlgosAlgoShearOrStretch_compute(self);
}

- (void)setTransformedObjectWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)g
                            withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)g2 {
  GeogebraCommonKernelAlgosAlgoShearOrStretch_set_inGeo_(self, g);
  GeogebraCommonKernelAlgosAlgoShearOrStretch_set_outGeo_(self, g2);
  if (!([outGeo_ isKindOfClass:[GeogebraCommonKernelGeosGeoList class]])) GeogebraCommonKernelAlgosAlgoShearOrStretch_set_out_(self, (id<GeogebraCommonKernelMatrixTransformable>) check_protocol_cast(outGeo_, @protocol(GeogebraCommonKernelMatrixTransformable)));
}

- (GeogebraCommonKernelGeosGeoElement *)getResultTemplateWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([geo isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) return [new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(cons_) autorelease];
  return [super getResultTemplateWithGeogebraCommonKernelGeosGeoElement:geo];
}

- (void)transformLimitedPathWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)a
                            withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)b {
  if (!([a isKindOfClass:[GeogebraCommonKernelGeosGeoConicPart class]])) {
    [super transformLimitedPathWithGeogebraCommonKernelGeosGeoElement:a withGeogebraCommonKernelGeosGeoElement:b];
  }
  else {
    [super transformLimitedConicWithGeogebraCommonKernelGeosGeoElement:a withGeogebraCommonKernelGeosGeoElement:b];
  }
}

- (jboolean)swapOrientationWithGeogebraCommonKernelGeosGeoConicPart:(GeogebraCommonKernelGeosGeoConicPart *)arc {
  if (shear_ || num_ == nil) return (arc == nil || [arc positiveOrientation]);
  return (arc == nil || [arc positiveOrientation]) ^ ([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(num_)) getDouble] < 0);
}

- (jdouble)getAreaScaleFactor {
  if (shear_) {
    return 1;
  }
  return n_;
}

- (void)dealloc {
  RELEASE_(out_);
  RELEASE_(inGeo_);
  RELEASE_(outGeo_);
  RELEASE_(line_);
  RELEASE_(num_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelGeosGeoElement:withGeogebraCommonKernelGeosGeoVec3D:withGeogebraCommonKernelArithmeticNumberValue:withBoolean:", "AlgoShearOrStretch", NULL, 0x1, NULL, NULL },
    { "getClassName", NULL, "Lgeogebra.common.kernel.commands.Commands;", 0x1, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x4, NULL, NULL },
    { "getResult", NULL, "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "compute", NULL, "V", 0x11, NULL, NULL },
    { "setTransformedObjectWithGeogebraCommonKernelGeosGeoElement:withGeogebraCommonKernelGeosGeoElement:", "setTransformedObject", "V", 0x4, NULL, NULL },
    { "getResultTemplateWithGeogebraCommonKernelGeosGeoElement:", "getResultTemplate", "Lgeogebra.common.kernel.geos.GeoElement;", 0x4, NULL, NULL },
    { "transformLimitedPathWithGeogebraCommonKernelGeosGeoElement:withGeogebraCommonKernelGeosGeoElement:", "transformLimitedPath", "V", 0x4, NULL, NULL },
    { "swapOrientationWithGeogebraCommonKernelGeosGeoConicPart:", "swapOrientation", "Z", 0x1, NULL, NULL },
    { "getAreaScaleFactor", NULL, "D", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "out_", NULL, 0x2, "Lgeogebra.common.kernel.MatrixTransformable;", NULL, NULL,  },
    { "inGeo_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoElement;", NULL, NULL,  },
    { "outGeo_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoElement;", NULL, NULL,  },
    { "line_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoVec3D;", NULL, NULL,  },
    { "num_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.NumberValue;", NULL, NULL,  },
    { "shear_", NULL, 0x2, "Z", NULL, NULL,  },
    { "n_", NULL, 0x2, "D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelAlgosAlgoShearOrStretch = { 2, "AlgoShearOrStretch", "geogebra.common.kernel.algos", NULL, 0x1, 10, methods, 7, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelAlgosAlgoShearOrStretch;
}

@end

void GeogebraCommonKernelAlgosAlgoShearOrStretch_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoVec3D_withGeogebraCommonKernelArithmeticNumberValue_withBoolean_(GeogebraCommonKernelAlgosAlgoShearOrStretch *self, GeogebraCommonKernelConstruction *cons, GeogebraCommonKernelGeosGeoElement *inArg, GeogebraCommonKernelGeosGeoVec3D *l, id<GeogebraCommonKernelArithmeticNumberValue> num, jboolean shear) {
  GeogebraCommonKernelAlgosAlgoTransformation_initWithGeogebraCommonKernelConstruction_(self, cons);
  self->shear_ = shear;
  GeogebraCommonKernelAlgosAlgoShearOrStretch_set_line_(self, l);
  GeogebraCommonKernelAlgosAlgoShearOrStretch_set_num_(self, num);
  GeogebraCommonKernelAlgosAlgoShearOrStretch_set_inGeo_(self, inArg);
  if ([GeogebraCommonKernelGeosGeoPoly_class_() isInstance:self->inGeo_] || [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->inGeo_)) isLimitedPath]) {
    GeogebraCommonKernelAlgosAlgoShearOrStretch_set_outGeo_(self, [((GeogebraCommonKernelGeosGeoElement *) nil_chk(inArg)) copyInternalWithGeogebraCommonKernelConstruction:cons]);
    GeogebraCommonKernelAlgosAlgoShearOrStretch_set_out_(self, (id<GeogebraCommonKernelMatrixTransformable>) check_protocol_cast(self->outGeo_, @protocol(GeogebraCommonKernelMatrixTransformable)));
  }
  else if ([self->inGeo_ isGeoList]) {
    GeogebraCommonKernelAlgosAlgoShearOrStretch_setAndConsume_outGeo_(self, new_GeogebraCommonKernelGeosGeoList_initWithGeogebraCommonKernelConstruction_(cons));
  }
  else if ([self->inGeo_ isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) {
    GeogebraCommonKernelAlgosAlgoShearOrStretch_setAndConsume_out_(self, new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(cons));
    GeogebraCommonKernelAlgosAlgoShearOrStretch_set_outGeo_(self, (GeogebraCommonKernelGeosGeoElement *) check_class_cast(self->out_, [GeogebraCommonKernelGeosGeoElement class]));
  }
  else {
    GeogebraCommonKernelAlgosAlgoShearOrStretch_set_out_(self, (id<GeogebraCommonKernelMatrixTransformable>) check_protocol_cast([self->inGeo_ copy__], @protocol(GeogebraCommonKernelMatrixTransformable)));
    GeogebraCommonKernelAlgosAlgoShearOrStretch_set_outGeo_(self, [((id<GeogebraCommonKernelMatrixTransformable>) nil_chk(self->out_)) toGeoElement]);
  }
  [self setInputOutput];
  GeogebraCommonKernelAlgosAlgoShearOrStretch_compute(self);
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->inGeo_)) isGeoFunction]) [((GeogebraCommonKernelConstruction *) nil_chk(cons)) registerEuclidianViewCEWithGeogebraCommonKernelEuclidianViewCE:self];
}

GeogebraCommonKernelAlgosAlgoShearOrStretch *new_GeogebraCommonKernelAlgosAlgoShearOrStretch_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoVec3D_withGeogebraCommonKernelArithmeticNumberValue_withBoolean_(GeogebraCommonKernelConstruction *cons, GeogebraCommonKernelGeosGeoElement *inArg, GeogebraCommonKernelGeosGeoVec3D *l, id<GeogebraCommonKernelArithmeticNumberValue> num, jboolean shear) {
  GeogebraCommonKernelAlgosAlgoShearOrStretch *self = [GeogebraCommonKernelAlgosAlgoShearOrStretch alloc];
  GeogebraCommonKernelAlgosAlgoShearOrStretch_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoVec3D_withGeogebraCommonKernelArithmeticNumberValue_withBoolean_(self, cons, inArg, l, num, shear);
  return self;
}

void GeogebraCommonKernelAlgosAlgoShearOrStretch_compute(GeogebraCommonKernelAlgosAlgoShearOrStretch *self) {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->inGeo_)) isGeoList]) {
    [self transformListWithGeogebraCommonKernelGeosGeoList:(GeogebraCommonKernelGeosGeoList *) check_class_cast(self->inGeo_, [GeogebraCommonKernelGeosGeoList class]) withGeogebraCommonKernelGeosGeoList:(GeogebraCommonKernelGeosGeoList *) check_class_cast(self->outGeo_, [GeogebraCommonKernelGeosGeoList class])];
    return;
  }
  if ([self->inGeo_ isGeoFunction]) {
    [((GeogebraCommonKernelGeosGeoFunction *) check_class_cast(self->inGeo_, [GeogebraCommonKernelGeosGeoFunction class])) toGeoCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *) check_class_cast(self->outGeo_, [GeogebraCommonKernelGeosGeoCurveCartesian class])];
  }
  else [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->outGeo_)) setWithGeogebraCommonKernelGeosGeoElement:self->inGeo_];
  if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->outGeo_)) isDefined]) {
    return;
  }
  id<GeogebraCommonKernelGeosTranslateable> tranOut = (id<GeogebraCommonKernelGeosTranslateable>) check_protocol_cast(self->out_, @protocol(GeogebraCommonKernelGeosTranslateable));
  jdouble qx = 0.0, qy = 0.0, s, c;
  self->n_ = GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_(((GeogebraCommonKernelGeosGeoVec3D *) nil_chk(self->line_))->x_, self->line_->y_);
  if ([self->line_ isKindOfClass:[GeogebraCommonKernelGeosGeoLine class]]) {
    if (JavaLangMath_absWithDouble_(self->line_->x_) > JavaLangMath_absWithDouble_(self->line_->y_)) {
      qx = self->line_->z_ / self->line_->x_;
    }
    else {
      qy = self->line_->z_ / self->line_->y_;
    }
    s = -self->line_->x_ / self->n_;
    c = self->line_->y_ / self->n_;
    self->n_ = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(self->num_)) getDouble];
  }
  else {
    id<GeogebraCommonKernelKernelNDGeoPointND> sp = [((GeogebraCommonKernelGeosGeoVector *) check_class_cast(self->line_, [GeogebraCommonKernelGeosGeoVector class])) getStartPoint];
    if (sp != nil) {
      GeogebraCommonKernelMatrixCoords *qCoords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk([((GeogebraCommonKernelGeosGeoVector *) check_class_cast(self->line_, [GeogebraCommonKernelGeosGeoVector class])) getStartPoint])) getCoordsInD2];
      qx = -[((GeogebraCommonKernelMatrixCoords *) nil_chk(qCoords)) getX];
      qy = -[qCoords getY];
    }
    c = -self->line_->y_ / self->n_;
    s = self->line_->x_ / self->n_;
  }
  [((id<GeogebraCommonKernelGeosTranslateable>) nil_chk(tranOut)) translateWithGeogebraCommonKernelMatrixCoords:[new_GeogebraCommonKernelMatrixCoords_initWithDouble_withDouble_withDouble_(qx, qy, 0) autorelease]];
  if (self->shear_) {
    [((id<GeogebraCommonKernelMatrixTransformable>) nil_chk(self->out_)) matrixTransformWithDouble:1 - c * s * self->n_ withDouble:c * c * self->n_ withDouble:-s * s * self->n_ withDouble:1 + s * c * self->n_];
  }
  else {
    [((id<GeogebraCommonKernelMatrixTransformable>) nil_chk(self->out_)) matrixTransformWithDouble:c * c + s * s * self->n_ withDouble:c * s * (1 - self->n_) withDouble:c * s * (1 - self->n_) withDouble:s * s + c * c * self->n_];
  }
  [tranOut translateWithGeogebraCommonKernelMatrixCoords:[new_GeogebraCommonKernelMatrixCoords_initWithDouble_withDouble_withDouble_(-qx, -qy, 0) autorelease]];
  if ([self->inGeo_ isLimitedPath]) {
    [self transformLimitedPathWithGeogebraCommonKernelGeosGeoElement:self->inGeo_ withGeogebraCommonKernelGeosGeoElement:self->outGeo_];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelAlgosAlgoShearOrStretch)
