//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/arithmetic/ExpressionNode.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GPoint.h"
#include "geogebra/common/export/MathmlTemplate.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/arithmetic/BooleanValue.h"
#include "geogebra/common/kernel/arithmetic/Command.h"
#include "geogebra/common/kernel/arithmetic/Equation.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeEvaluator.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionNVar.h"
#include "geogebra/common/kernel/arithmetic/FunctionVariable.h"
#include "geogebra/common/kernel/arithmetic/Functional.h"
#include "geogebra/common/kernel/arithmetic/FunctionalNVar.h"
#include "geogebra/common/kernel/arithmetic/Inspecting.h"
#include "geogebra/common/kernel/arithmetic/ListValue.h"
#include "geogebra/common/kernel/arithmetic/MyBoolean.h"
#include "geogebra/common/kernel/arithmetic/MyDouble.h"
#include "geogebra/common/kernel/arithmetic/MyList.h"
#include "geogebra/common/kernel/arithmetic/MyNumberPair.h"
#include "geogebra/common/kernel/arithmetic/MySpecialDouble.h"
#include "geogebra/common/kernel/arithmetic/MyStringBuffer.h"
#include "geogebra/common/kernel/arithmetic/MyVecNode.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/arithmetic/Polynomial.h"
#include "geogebra/common/kernel/arithmetic/ReplaceChildrenByValues.h"
#include "geogebra/common/kernel/arithmetic/Term.h"
#include "geogebra/common/kernel/arithmetic/TextValue.h"
#include "geogebra/common/kernel/arithmetic/Traversing.h"
#include "geogebra/common/kernel/arithmetic/ValidExpression.h"
#include "geogebra/common/kernel/arithmetic/Variable.h"
#include "geogebra/common/kernel/arithmetic/VectorValue.h"
#include "geogebra/common/kernel/arithmetic3D/MyVec3DNode.h"
#include "geogebra/common/kernel/arithmetic3D/Vector3DValue.h"
#include "geogebra/common/kernel/geos/CasEvaluableFunction.h"
#include "geogebra/common/kernel/geos/GeoCasCell.h"
#include "geogebra/common/kernel/geos/GeoDummyVariable.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoFunctionNVar.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/geos/GeoPolygon.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/main/MyError.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/util/Unicode.h"
#include "geogebra/common/util/debug/Log.h"
#include "java/lang/Double.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"

@interface GeogebraCommonKernelArithmeticExpressionNode () {
 @public
  GeogebraCommonMainLocalization *loc_;
  GeogebraCommonKernelKernel *kernel_;
  id<GeogebraCommonKernelArithmeticExpressionValue> left_, right_;
  GeogebraCommonPluginOperationEnum *operation_;
  jboolean forceVector_, forcePoint_, forceFunction_;
  jboolean brackets_;
}

- (void)simplifyAndEvalCommands;

- (void)doResolveVariables;

- (GeogebraCommonKernelArithmeticPolynomial *)makePolyTreeFromFunctionWithGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)func
                                                                      withGeogebraCommonKernelArithmeticEquation:(GeogebraCommonKernelArithmeticEquation *)equ;

+ (jboolean)polynomialOperationWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation2;

- (jboolean)expandForOGPWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev;

- (NSString *)getTreeClassWithNSString:(NSString *)prefix;

+ (NSString *)checkMathmlWithNSString:(NSString *)str
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl;

+ (NSString *)degFixWithNSString:(NSString *)string
withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
  withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel;

+ (void)trigWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                              withNSString:(NSString *)leftStr
                 withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                              withNSString:(NSString *)mathml
                              withNSString:(NSString *)latex
                              withNSString:(NSString *)psTricks
                              withNSString:(NSString *)key
                              withNSString:(NSString *)libreOffice
    withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
        withGeogebraCommonMainLocalization:(GeogebraCommonMainLocalization *)loc
                               withBoolean:(jboolean)needDegrees;

+ (void)trigWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                              withNSString:(NSString *)leftStr
                 withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                              withNSString:(NSString *)mathml
                              withNSString:(NSString *)latex
                              withNSString:(NSString *)psTricks
                              withNSString:(NSString *)key
                              withNSString:(NSString *)libreOffice
                              withNSString:(NSString *)giac
    withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
        withGeogebraCommonMainLocalization:(GeogebraCommonMainLocalization *)loc
                               withBoolean:(jboolean)needDegrees;

+ (void)appendReduceFunctionWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
    withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                                         withNSString:(NSString *)string;

+ (jboolean)isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev
                                                                   withDouble:(jdouble)v;

- (GeogebraCommonKernelArithmeticExpressionNode *)wrapWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)exp;

- (GeogebraCommonKernelArithmeticExpressionNode *)linearIntegralWithInt:(jint)i
                                  withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op
                     withGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv;

+ (jdouble)getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv
                                withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev2;

+ (jdouble)getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv
                                   withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev2;

- (GeogebraCommonKernelArithmeticExpressionNode *)wrapWithDouble:(jdouble)n;

- (jboolean)checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticExpressionNode, loc_, GeogebraCommonMainLocalization *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticExpressionNode, kernel_, GeogebraCommonKernelKernel *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticExpressionNode, left_, id<GeogebraCommonKernelArithmeticExpressionValue>)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticExpressionNode, right_, id<GeogebraCommonKernelArithmeticExpressionValue>)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticExpressionNode, operation_, GeogebraCommonPluginOperationEnum *)

__attribute__((unused)) static GeogebraCommonPluginOperationEnum *GeogebraCommonKernelArithmeticExpressionNode_getOperation(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNode_getLeft(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_setLeftWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> l);

__attribute__((unused)) static id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNode_getRight(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> r);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_simplifyLeafs(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_simplifyAndEvalCommands(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_simplifyConstantIntegers(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_doResolveVariables(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_includesDivisionByWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> val);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_includesNonContinuousIntegral(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static jint GeogebraCommonKernelArithmeticExpressionNode_replaceVariablesWithNSString_withGeogebraCommonKernelArithmeticFunctionVariable_(GeogebraCommonKernelArithmeticExpressionNode *self, NSString *varName, GeogebraCommonKernelArithmeticFunctionVariable *fVar);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_containsCasEvaluableFunction(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_containsGeoFunctionNVar(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static GeogebraCommonKernelArithmeticPolynomial *GeogebraCommonKernelArithmeticExpressionNode_makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelArithmeticEquation *equ);

__attribute__((unused)) static GeogebraCommonKernelArithmeticPolynomial *GeogebraCommonKernelArithmeticExpressionNode_makePolyTreeFromFunctionWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticEquation_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelArithmeticFunction *func, GeogebraCommonKernelArithmeticEquation *equ);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_polynomialOperationWithGeogebraCommonPluginOperationEnum_(GeogebraCommonPluginOperationEnum *operation2);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_isConstant(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_hasOperations(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static JavaUtilHashSet *GeogebraCommonKernelArithmeticExpressionNode_getVariables(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_isLeaf(GeogebraCommonKernelArithmeticExpressionNode *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_expandForOGPWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> ev);

__attribute__((unused)) static NSString *GeogebraCommonKernelArithmeticExpressionNode_getTreeClassWithNSString_(GeogebraCommonKernelArithmeticExpressionNode *self, NSString *prefix);

__attribute__((unused)) static NSString *GeogebraCommonKernelArithmeticExpressionNode_toStringWithGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelStringTemplate *tpl);

__attribute__((unused)) static NSString *GeogebraCommonKernelArithmeticExpressionNode_toValueStringWithGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelStringTemplate *tpl);

__attribute__((unused)) static NSString *GeogebraCommonKernelArithmeticExpressionNode_checkMathmlWithNSString_withGeogebraCommonKernelStringTemplate_(NSString *str, GeogebraCommonKernelStringTemplate *tpl);

__attribute__((unused)) static NSString *GeogebraCommonKernelArithmeticExpressionNode_degFixWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(NSString *string, id<GeogebraCommonKernelArithmeticExpressionValue> left, GeogebraCommonKernelKernel *kernel);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> left, NSString *leftStr, JavaLangStringBuilder *sb, NSString *mathml, NSString *latex, NSString *psTricks, NSString *key, NSString *libreOffice, GeogebraCommonKernelStringTemplate *tpl, GeogebraCommonMainLocalization *loc, jboolean needDegrees);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> left, NSString *leftStr, JavaLangStringBuilder *sb, NSString *mathml, NSString *latex, NSString *psTricks, NSString *key, NSString *libreOffice, NSString *giac, GeogebraCommonKernelStringTemplate *tpl, GeogebraCommonMainLocalization *loc, jboolean needDegrees);

__attribute__((unused)) static void GeogebraCommonKernelArithmeticExpressionNode_appendReduceFunctionWithJavaLangStringBuilder_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_(JavaLangStringBuilder *sb, id<GeogebraCommonKernelArithmeticExpressionValue> left, NSString *string);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(id<GeogebraCommonKernelArithmeticExpressionValue> ev, jdouble v);

__attribute__((unused)) static GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> exp);

__attribute__((unused)) static GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelArithmeticExpressionNode_linearIntegralWithInt_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionVariable_(GeogebraCommonKernelArithmeticExpressionNode *self, jint i, GeogebraCommonPluginOperationEnum *op, GeogebraCommonKernelArithmeticFunctionVariable *fv);

__attribute__((unused)) static jdouble GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticFunctionVariable *fv, id<GeogebraCommonKernelArithmeticExpressionValue> ev2);

__attribute__((unused)) static jdouble GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticFunctionVariable *fv, id<GeogebraCommonKernelArithmeticExpressionValue> ev2);

__attribute__((unused)) static GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(GeogebraCommonKernelArithmeticExpressionNode *self, jdouble n);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticExpressionNode_checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> ev);

@implementation GeogebraCommonKernelArithmeticExpressionNode

- (instancetype)init {
  GeogebraCommonKernelArithmeticExpressionNode_init(self);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
             withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation
 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)right {
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self, kernel, left, operation, right);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)leaf {
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self, kernel, leaf);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)node {
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelArithmeticExpressionNode_(self, node);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel2
                                        withDouble:(jdouble)d {
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(self, kernel2, d);
  return self;
}

- (GeogebraCommonKernelKernel *)getKernel {
  return kernel_;
}

- (GeogebraCommonPluginOperationEnum *)getOperation {
  return GeogebraCommonKernelArithmeticExpressionNode_getOperation(self);
}

- (void)setOperationWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op {
  GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, op);
}

- (void)setHoldsLaTeXtextWithBoolean:(jboolean)flag {
  holdsLaTeXtext_ = flag;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)getLeft {
  return GeogebraCommonKernelArithmeticExpressionNode_getLeft(self);
}

- (void)setLeftWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)l {
  GeogebraCommonKernelArithmeticExpressionNode_setLeftWithGeogebraCommonKernelArithmeticExpressionValue_(self, l);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)getLeftTree {
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isExpressionNode]) {
    return (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]);
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)getRight {
  return GeogebraCommonKernelArithmeticExpressionNode_getRight(self);
}

- (void)setRightWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)r {
  GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(self, r);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)getRightTree {
  if (right_ == nil) {
    return nil;
  }
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isExpressionNode]) {
    return (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right_, [GeogebraCommonKernelArithmeticExpressionNode class]);
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, right_) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)deepCopyWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel1 {
  return [self getCopyWithGeogebraCommonKernelKernel:kernel1];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)getCopyWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel1 {
  GeogebraCommonKernelArithmeticExpressionNode *newNode = nil;
  id<GeogebraCommonKernelArithmeticExpressionValue> lev = nil, rev = nil;
  if (left_ != nil) {
    lev = GeogebraCommonKernelArithmeticExpressionNode_copy__WithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(left_, kernel1);
  }
  if (right_ != nil) {
    rev = GeogebraCommonKernelArithmeticExpressionNode_copy__WithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(right_, kernel1);
  }
  if (lev != nil) {
    newNode = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel1, lev, operation_, rev) autorelease];
    newNode->leaf_ = leaf_;
  }
  else {
    return nil;
  }
  ((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(newNode))->forceVector_ = forceVector_;
  newNode->forcePoint_ = forcePoint_;
  newNode->forceFunction_ = forceFunction_;
  return newNode;
}

+ (id<GeogebraCommonKernelArithmeticExpressionValue>)copy__WithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev
                                                                              withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  return GeogebraCommonKernelArithmeticExpressionNode_copy__WithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(ev, kernel);
}

- (void)simplifyLeafs {
  GeogebraCommonKernelArithmeticExpressionNode_simplifyLeafs(self);
}

- (void)simplifyAndEvalCommands {
  GeogebraCommonKernelArithmeticExpressionNode_simplifyAndEvalCommands(self);
}

- (void)simplifyConstantIntegers {
  GeogebraCommonKernelArithmeticExpressionNode_simplifyConstantIntegers(self);
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)evaluateWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [((GeogebraCommonKernelArithmeticExpressionNodeEvaluator *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getExpressionNodeEvaluator])) evaluateWithGeogebraCommonKernelArithmeticExpressionNode:self withGeogebraCommonKernelStringTemplate:tpl];
}

- (void)resolveVariables {
  GeogebraCommonKernelArithmeticExpressionNode_doResolveVariables(self);
  GeogebraCommonKernelArithmeticExpressionNode_simplifyAndEvalCommands(self);
  GeogebraCommonKernelArithmeticExpressionNode_simplifyLeafs(self);
  switch ([operation_ ordinal]) {
    case GeogebraCommonPluginOperation_POWER:
    if (([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:left_]) && ([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(left_, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble] == JavaLangMath_E)) {
      GeogebraCommonKernelGeosGeoElement *geo = [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) lookupLabelWithNSString:@"e"];
      if ((geo != nil) && [geo needsReplacingInExpressionNode]) {
        GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_EXP());
        GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, right_);
        [((GeogebraCommonKernelConstruction *) nil_chk([kernel_ getConstruction])) removeLabelWithGeogebraCommonKernelGeosGeoElement:geo];
      }
    }
    break;
    case GeogebraCommonPluginOperation_MULTIPLY:
    case GeogebraCommonPluginOperation_DIVIDE:
    case GeogebraCommonPluginOperation_PLUS:
    case GeogebraCommonPluginOperation_MINUS:
    if (([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:left_]) && ([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(left_, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble] == JavaLangMath_E)) {
      GeogebraCommonKernelGeosGeoElement *geo = [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) lookupLabelWithNSString:@"e"];
      if ((geo != nil) && [geo needsReplacingInExpressionNode]) {
        GeogebraCommonKernelArithmeticExpressionNode_setAndConsume_left_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1.0) autorelease], GeogebraCommonPluginOperationEnum_get_EXP(), nil));
        [((GeogebraCommonKernelConstruction *) nil_chk([kernel_ getConstruction])) removeLabelWithGeogebraCommonKernelGeosGeoElement:geo];
      }
    }
    else if (([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:right_]) && ([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(right_, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble] == JavaLangMath_E)) {
      GeogebraCommonKernelGeosGeoElement *geo = [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) lookupLabelWithNSString:@"e"];
      if ((geo != nil) && [geo needsReplacingInExpressionNode]) {
        GeogebraCommonKernelArithmeticExpressionNode_setAndConsume_right_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1.0) autorelease], GeogebraCommonPluginOperationEnum_get_EXP(), nil));
        [((GeogebraCommonKernelConstruction *) nil_chk([kernel_ getConstruction])) removeLabelWithGeogebraCommonKernelGeosGeoElement:geo];
      }
    }
    break;
  }
}

- (void)doResolveVariables {
  GeogebraCommonKernelArithmeticExpressionNode_doResolveVariables(self);
}

- (jboolean)shouldEvaluateToGeoVector {
  if (forcePoint_) {
    return NO;
  }
  if (forceVector_) {
    return YES;
  }
  jboolean evalToVector = NO;
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isExpressionNode]) {
    evalToVector = ([((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])) shouldEvaluateToGeoVector]);
  }
  else if ([left_ isGeoElement]) {
    GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(left_, [GeogebraCommonKernelGeosGeoElement class]);
    evalToVector = ([geo isGeoVector] || [geo isNumberValue]);
  }
  else if ([left_ isNumberValue]) {
    evalToVector = YES;
  }
  if ((right_ != nil) && evalToVector) {
    if ([right_ isExpressionNode]) {
      evalToVector = [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right_, [GeogebraCommonKernelArithmeticExpressionNode class])) shouldEvaluateToGeoVector];
    }
    else if ([right_ isGeoElement]) {
      GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(right_, [GeogebraCommonKernelGeosGeoElement class]);
      evalToVector = ([geo isGeoVector] || [geo isNumberValue]);
    }
    else if ([right_ isNumberValue]) {
      evalToVector = YES;
    }
  }
  return evalToVector;
}

- (jboolean)includesDivisionByWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)val {
  return GeogebraCommonKernelArithmeticExpressionNode_includesDivisionByWithGeogebraCommonKernelArithmeticExpressionValue_(self, val);
}

- (jboolean)includesNonContinuousIntegral {
  return GeogebraCommonKernelArithmeticExpressionNode_includesNonContinuousIntegral(self);
}

- (jint)replaceVariablesWithNSString:(NSString *)varName
withGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fVar {
  return GeogebraCommonKernelArithmeticExpressionNode_replaceVariablesWithNSString_withGeogebraCommonKernelArithmeticFunctionVariable_(self, varName, fVar);
}

- (jint)replaceXYZnodesWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)xVar
                       withGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)yVar
                       withGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)zVar
                                                    withJavaUtilArrayList:(JavaUtilArrayList *)undecided {
  if ((xVar == nil) && ((yVar == nil) & (zVar == nil))) {
    return 0;
  }
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isExpressionNode]) {
    [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])) replaceXYZnodesWithGeogebraCommonKernelArithmeticFunctionVariable:xVar withGeogebraCommonKernelArithmeticFunctionVariable:yVar withGeogebraCommonKernelArithmeticFunctionVariable:zVar withJavaUtilArrayList:undecided];
  }
  if ((right_ != nil) && [right_ isExpressionNode]) {
    [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right_, [GeogebraCommonKernelArithmeticExpressionNode class])) replaceXYZnodesWithGeogebraCommonKernelArithmeticFunctionVariable:xVar withGeogebraCommonKernelArithmeticFunctionVariable:yVar withGeogebraCommonKernelArithmeticFunctionVariable:zVar withJavaUtilArrayList:undecided];
  }
  switch ([operation_ ordinal]) {
    case GeogebraCommonPluginOperation_XCOORD:
    if (xVar != nil) {
      [((JavaUtilArrayList *) nil_chk(undecided)) addWithId:self];
      GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_MULTIPLY_OR_FUNCTION());
      GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, left_);
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, xVar);
    }
    break;
    case GeogebraCommonPluginOperation_YCOORD:
    if (yVar != nil) {
      [((JavaUtilArrayList *) nil_chk(undecided)) addWithId:self];
      GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_MULTIPLY_OR_FUNCTION());
      GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, left_);
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, yVar);
    }
    break;
    case GeogebraCommonPluginOperation_ZCOORD:
    if (zVar != nil) {
      [((JavaUtilArrayList *) nil_chk(undecided)) addWithId:self];
      GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_MULTIPLY_OR_FUNCTION());
      GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, left_);
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, zVar);
    }
    break;
    case GeogebraCommonPluginOperation_POWER:
    if ([left_ isExpressionNode] && ((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))->operation_ == GeogebraCommonPluginOperationEnum_get_MULTIPLY_OR_FUNCTION() && ![((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])) hasBrackets]) {
      GeogebraCommonKernelArithmeticExpressionNode_setAndConsume_right_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, GeogebraCommonKernelArithmeticExpressionNode_getRight(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))), GeogebraCommonPluginOperationEnum_get_POWER(), right_));
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, GeogebraCommonKernelArithmeticExpressionNode_getLeft(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))));
      GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_MULTIPLY());
    }
    break;
    case GeogebraCommonPluginOperation_FACTORIAL:
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isExpressionNode] && ((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))->operation_ == GeogebraCommonPluginOperationEnum_get_MULTIPLY_OR_FUNCTION() && ![((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])) hasBrackets]) {
      GeogebraCommonKernelArithmeticExpressionNode_setAndConsume_right_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, GeogebraCommonKernelArithmeticExpressionNode_getRight(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))), GeogebraCommonPluginOperationEnum_get_FACTORIAL(), nil));
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, GeogebraCommonKernelArithmeticExpressionNode_getLeft(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))));
      GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_MULTIPLY());
    }
    case GeogebraCommonPluginOperation_SQRT_SHORT:
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isExpressionNode] && ((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))->operation_ == GeogebraCommonPluginOperationEnum_get_MULTIPLY_OR_FUNCTION() && ![((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])) hasBrackets]) {
      GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, GeogebraCommonKernelArithmeticExpressionNode_getRight(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))));
      GeogebraCommonKernelArithmeticExpressionNode_setAndConsume_left_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, GeogebraCommonKernelArithmeticExpressionNode_getLeft(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class]))), GeogebraCommonPluginOperationEnum_get_SQRT(), nil));
      GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_MULTIPLY());
    }
  }
  return [((JavaUtilArrayList *) nil_chk(undecided)) size];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)traverseWithGeogebraCommonKernelArithmeticTraversing:(id<GeogebraCommonKernelArithmeticTraversing>)t {
  id<GeogebraCommonKernelArithmeticExpressionValue> ev = [((id<GeogebraCommonKernelArithmeticTraversing>) nil_chk(t)) processWithGeogebraCommonKernelArithmeticExpressionValue:self];
  if (ev != self) return ev;
  GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) traverseWithGeogebraCommonKernelArithmeticTraversing:t]);
  if (right_ != nil) GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, [right_ traverseWithGeogebraCommonKernelArithmeticTraversing:t]);
  return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) unwrap])) wrap];
}

- (jboolean)inspectWithGeogebraCommonKernelArithmeticInspecting:(id<GeogebraCommonKernelArithmeticInspecting>)t {
  return [((id<GeogebraCommonKernelArithmeticInspecting>) nil_chk(t)) checkWithGeogebraCommonKernelArithmeticExpressionValue:self] || [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) inspectWithGeogebraCommonKernelArithmeticInspecting:t] || (right_ != nil && [right_ inspectWithGeogebraCommonKernelArithmeticInspecting:t]);
}

- (void)replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isGeoElement]) {
    GeogebraCommonKernelGeosGeoElement *treeGeo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(left_, [GeogebraCommonKernelGeosGeoElement class]);
    if ((left_ == geo) || [treeGeo isChildOfWithGeogebraCommonKernelGeosGeoElement:geo]) {
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, [treeGeo copyInternalWithGeogebraCommonKernelConstruction:[treeGeo getConstruction]]);
    }
  }
  else if ([GeogebraCommonKernelArithmeticReplaceChildrenByValues_class_() isInstance:left_]) {
    [((id<GeogebraCommonKernelArithmeticReplaceChildrenByValues>) check_protocol_cast(left_, @protocol(GeogebraCommonKernelArithmeticReplaceChildrenByValues))) replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:geo];
  }
  if (right_ != nil) {
    if ([right_ isGeoElement]) {
      GeogebraCommonKernelGeosGeoElement *treeGeo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(right_, [GeogebraCommonKernelGeosGeoElement class]);
      if ((right_ == geo) || [treeGeo isChildOfWithGeogebraCommonKernelGeosGeoElement:geo]) {
        GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, [treeGeo copyInternalWithGeogebraCommonKernelConstruction:[treeGeo getConstruction]]);
      }
    }
    else if ([GeogebraCommonKernelArithmeticReplaceChildrenByValues_class_() isInstance:right_]) {
      [((id<GeogebraCommonKernelArithmeticReplaceChildrenByValues>) check_protocol_cast(right_, @protocol(GeogebraCommonKernelArithmeticReplaceChildrenByValues))) replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:geo];
    }
  }
}

- (jboolean)containsWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev {
  if (leaf_) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:ev];
  }
  return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:ev] || [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:ev];
}

- (jboolean)containsCasEvaluableFunction {
  return GeogebraCommonKernelArithmeticExpressionNode_containsCasEvaluableFunction(self);
}

- (jboolean)containsGeoFunctionNVar {
  return GeogebraCommonKernelArithmeticExpressionNode_containsGeoFunctionNVar(self);
}

- (GeogebraCommonKernelArithmeticPolynomial *)makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation:(GeogebraCommonKernelArithmeticEquation *)equ {
  return GeogebraCommonKernelArithmeticExpressionNode_makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation_(self, equ);
}

- (GeogebraCommonKernelArithmeticPolynomial *)makePolyTreeFromFunctionWithGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)func
                                                                      withGeogebraCommonKernelArithmeticEquation:(GeogebraCommonKernelArithmeticEquation *)equ {
  return GeogebraCommonKernelArithmeticExpressionNode_makePolyTreeFromFunctionWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticEquation_(self, func, equ);
}

+ (jboolean)polynomialOperationWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation2 {
  return GeogebraCommonKernelArithmeticExpressionNode_polynomialOperationWithGeogebraCommonPluginOperationEnum_(operation2);
}

- (jboolean)isConstant {
  return GeogebraCommonKernelArithmeticExpressionNode_isConstant(self);
}

- (jboolean)evaluatesToNonComplex2DVector {
  if (operation_ == GeogebraCommonPluginOperationEnum_get_RANDOM() || operation_ == GeogebraCommonPluginOperationEnum_get_XCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_YCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_ZCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_ABS() || operation_ == GeogebraCommonPluginOperationEnum_get_ARG()) {
    return NO;
  }
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToNonComplex2DVector];
  }
  if (GeogebraCommonPluginOperationEnum_isSimpleFunctionWithGeogebraCommonPluginOperationEnum_(operation_) || operation_ == GeogebraCommonPluginOperationEnum_get_CONJUGATE()) {
    return NO;
  }
  jboolean leftVector = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToNonComplex2DVector];
  jboolean rightVector = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) evaluatesToNonComplex2DVector];
  jboolean ret = leftVector || rightVector;
  if (leftVector && rightVector && (operation_ == GeogebraCommonPluginOperationEnum_get_MULTIPLY() || operation_ == GeogebraCommonPluginOperationEnum_get_VECTORPRODUCT())) {
    ret = NO;
  }
  return ret;
}

- (jboolean)evaluatesToVectorNotPoint {
  if (operation_ == GeogebraCommonPluginOperationEnum_get_RANDOM() || operation_ == GeogebraCommonPluginOperationEnum_get_XCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_YCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_ZCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_ABS() || operation_ == GeogebraCommonPluginOperationEnum_get_ARG()) {
    return NO;
  }
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToVectorNotPoint];
  }
  if (GeogebraCommonPluginOperationEnum_isSimpleFunctionWithGeogebraCommonPluginOperationEnum_(operation_) || operation_ == GeogebraCommonPluginOperationEnum_get_CONJUGATE()) {
    return NO;
  }
  jboolean leftVector = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToVectorNotPoint];
  jboolean rightVector = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) evaluatesToVectorNotPoint];
  jboolean ret = leftVector || rightVector;
  if (leftVector && rightVector && (operation_ == GeogebraCommonPluginOperationEnum_get_MULTIPLY() || operation_ == GeogebraCommonPluginOperationEnum_get_VECTORPRODUCT())) {
    ret = NO;
  }
  return ret;
}

- (jboolean)evaluatesTo3DVector {
  if (operation_ == GeogebraCommonPluginOperationEnum_get_RANDOM() || operation_ == GeogebraCommonPluginOperationEnum_get_XCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_YCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_ZCOORD()) {
    return NO;
  }
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesTo3DVector];
  }
  jboolean leftVector = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesTo3DVector];
  jboolean rightVector = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) evaluatesTo3DVector];
  jboolean ret = leftVector || rightVector;
  if (leftVector && rightVector && operation_ == GeogebraCommonPluginOperationEnum_get_MULTIPLY()) {
    ret = NO;
  }
  return ret;
}

- (void)setForceVector {
  forceVector_ = YES;
}

- (jboolean)isForcedVector {
  return forceVector_;
}

- (void)setForcePoint {
  forcePoint_ = YES;
}

- (jboolean)isForcedPoint {
  return forcePoint_;
}

- (void)setForceFunction {
  forceFunction_ = YES;
}

- (jboolean)isForcedFunction {
  return forceFunction_;
}

- (jboolean)hasOperations {
  return GeogebraCommonKernelArithmeticExpressionNode_hasOperations(self);
}

- (JavaUtilHashSet *)getVariables {
  return GeogebraCommonKernelArithmeticExpressionNode_getVariables(self);
}

- (IOSObjectArray *)getGeoElementVariables {
  JavaUtilHashSet *varset = GeogebraCommonKernelArithmeticExpressionNode_getVariables(self);
  if (varset == nil) {
    return nil;
  }
  id<JavaUtilIterator> i = [((JavaUtilHashSet *) nil_chk(varset)) iterator];
  IOSObjectArray *ret = [IOSObjectArray arrayWithLength:[varset size] type:GeogebraCommonKernelGeosGeoElement_class_()];
  jint j = 0;
  while ([((id<JavaUtilIterator>) nil_chk(i)) hasNext]) {
    IOSObjectArray_Set(ret, j++, [i next]);
  }
  return ret;
}

- (jboolean)isLeaf {
  return GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self);
}

- (jboolean)isSingleGeoElement {
  return leaf_ && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isGeoElement];
}

- (GeogebraCommonKernelGeosGeoElement *)getSingleGeoElement {
  return (GeogebraCommonKernelGeosGeoElement *) check_class_cast(left_, [GeogebraCommonKernelGeosGeoElement class]);
}

- (jboolean)isSingleVariable {
  return (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self) && ([left_ isKindOfClass:[GeogebraCommonKernelArithmeticVariable class]]));
}

- (jboolean)isImaginaryUnit {
  return (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self) && ([left_ isKindOfClass:[GeogebraCommonKernelGeosGeoVec2D class]]) && [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(((GeogebraCommonKernelGeosGeoVec2D *) check_class_cast(left_, [GeogebraCommonKernelGeosGeoVec2D class])))) isImaginaryUnit]);
}

- (jboolean)containsMyStringBuffer {
  if (([left_ isKindOfClass:[GeogebraCommonKernelArithmeticMyStringBuffer class]]) || ([right_ isKindOfClass:[GeogebraCommonKernelArithmeticMyStringBuffer class]])) {
    return YES;
  }
  jboolean ret = NO;
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isExpressionNode]) {
    ret = (ret || [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])) containsMyStringBuffer]);
  }
  if ((right_ != nil) && [right_ isExpressionNode]) {
    ret = (ret || [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right_, [GeogebraCommonKernelArithmeticExpressionNode class])) containsMyStringBuffer]);
  }
  return ret;
}

- (NSString *)getCASstringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                     withBoolean:(jboolean)symbolic {
  NSString *ret = nil;
  @try {
    if (leaf_) {
      if (symbolic && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isGeoElement]) {
        ret = [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left_, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl];
      }
      else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isExpressionNode]) {
        ret = [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])) getCASstringWithGeogebraCommonKernelStringTemplate:tpl withBoolean:symbolic];
      }
      else {
        ret = symbolic ? [left_ toStringWithGeogebraCommonKernelStringTemplate:tpl] : [left_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
      }
    }
    else {
      NSString *leftStr = nil, *rightStr = nil;
      if (symbolic && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isGeoElement]) {
        leftStr = [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left_, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl];
      }
      else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isExpressionNode]) {
        leftStr = [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])) getCASstringWithGeogebraCommonKernelStringTemplate:tpl withBoolean:symbolic];
      }
      else {
        leftStr = symbolic ? [left_ toStringWithGeogebraCommonKernelStringTemplate:tpl] : [left_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
      }
      if (right_ != nil) {
        if (symbolic && [right_ isGeoElement]) {
          rightStr = [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(right_, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl];
        }
        else if ([right_ isExpressionNode]) {
          rightStr = [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right_, [GeogebraCommonKernelArithmeticExpressionNode class])) getCASstringWithGeogebraCommonKernelStringTemplate:tpl withBoolean:symbolic];
        }
        else {
          rightStr = symbolic ? [right_ toStringWithGeogebraCommonKernelStringTemplate:tpl] : [right_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
        }
      }
      ret = GeogebraCommonKernelArithmeticExpressionNode_operationToStringWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withNSString_withNSString_withBoolean_withGeogebraCommonKernelStringTemplate_withGeogebraCommonKernelKernel_(left_, right_, operation_, leftStr, rightStr, !symbolic, tpl, kernel_);
    }
  }
  @finally {
  }
  return ret;
}

- (NSString *)getTreeClass {
  return GeogebraCommonKernelArithmeticExpressionNode_getTreeClassWithNSString_(self, @"");
}

- (jboolean)expandForOGPWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev {
  return GeogebraCommonKernelArithmeticExpressionNode_expandForOGPWithGeogebraCommonKernelArithmeticExpressionValue_(self, ev);
}

- (NSString *)getTreeClassWithNSString:(NSString *)prefix {
  return GeogebraCommonKernelArithmeticExpressionNode_getTreeClassWithNSString_(self, prefix);
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return GeogebraCommonKernelArithmeticExpressionNode_toStringWithGeogebraCommonKernelStringTemplate_(self, tpl);
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return GeogebraCommonKernelArithmeticExpressionNode_toValueStringWithGeogebraCommonKernelStringTemplate_(self, tpl);
}

- (NSString *)toOutputValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    if (left_ != nil) {
      return [left_ toOutputValueStringWithGeogebraCommonKernelStringTemplate:tpl];
    }
  }
  NSString *leftStr = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) toOutputValueStringWithGeogebraCommonKernelStringTemplate:tpl];
  NSString *rightStr = nil;
  if (right_ != nil) {
    rightStr = [right_ toOutputValueStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  return GeogebraCommonKernelArithmeticExpressionNode_operationToStringWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withNSString_withNSString_withBoolean_withGeogebraCommonKernelStringTemplate_withGeogebraCommonKernelKernel_(left_, right_, operation_, leftStr, rightStr, YES, tpl, kernel_);
}

- (NSString *)toLaTeXStringWithBoolean:(jboolean)symbolic
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  NSString *ret;
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    if (left_ != nil) {
      ret = [left_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl];
      return GeogebraCommonKernelArithmeticExpressionNode_checkMathmlWithNSString_withGeogebraCommonKernelStringTemplate_(ret, tpl);
    }
  }
  NSString *leftStr = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl];
  NSString *rightStr = nil;
  if (right_ != nil) {
    rightStr = [right_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl];
    if (((operation_ == GeogebraCommonPluginOperationEnum_get_FUNCTION_NVAR()) || (operation_ == GeogebraCommonPluginOperationEnum_get_ELEMENT_OF())) && ([right_ isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]])) {
      rightStr = [rightStr substring:7 endIndex:((jint) [((NSString *) nil_chk(rightStr)) length]) - 9];
      rightStr = [((NSString *) nil_chk(rightStr)) concat:@"}"];
    }
  }
  ret = GeogebraCommonKernelArithmeticExpressionNode_operationToStringWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withNSString_withNSString_withBoolean_withGeogebraCommonKernelStringTemplate_withGeogebraCommonKernelKernel_(left_, right_, operation_, leftStr, rightStr, !symbolic, tpl, kernel_);
  return GeogebraCommonKernelArithmeticExpressionNode_checkMathmlWithNSString_withGeogebraCommonKernelStringTemplate_(ret, tpl);
}

+ (NSString *)checkMathmlWithNSString:(NSString *)str
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return GeogebraCommonKernelArithmeticExpressionNode_checkMathmlWithNSString_withGeogebraCommonKernelStringTemplate_(str, tpl);
}

+ (NSString *)operationToStringWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                               withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)right
                                           withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation
                                                                    withNSString:(NSString *)leftStr
                                                                    withNSString:(NSString *)rightStr
                                                                     withBoolean:(jboolean)valueForm
                                          withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                  withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  return GeogebraCommonKernelArithmeticExpressionNode_operationToStringWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withNSString_withNSString_withBoolean_withGeogebraCommonKernelStringTemplate_withGeogebraCommonKernelKernel_(left, right, operation, leftStr, rightStr, valueForm, tpl, kernel);
}

+ (NSString *)degFixWithNSString:(NSString *)string
withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
  withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  return GeogebraCommonKernelArithmeticExpressionNode_degFixWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(string, left, kernel);
}

+ (void)trigWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                              withNSString:(NSString *)leftStr
                 withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                              withNSString:(NSString *)mathml
                              withNSString:(NSString *)latex
                              withNSString:(NSString *)psTricks
                              withNSString:(NSString *)key
                              withNSString:(NSString *)libreOffice
    withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
        withGeogebraCommonMainLocalization:(GeogebraCommonMainLocalization *)loc
                               withBoolean:(jboolean)needDegrees {
  GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, mathml, latex, psTricks, key, libreOffice, tpl, loc, needDegrees);
}

+ (void)trigWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                              withNSString:(NSString *)leftStr
                 withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                              withNSString:(NSString *)mathml
                              withNSString:(NSString *)latex
                              withNSString:(NSString *)psTricks
                              withNSString:(NSString *)key
                              withNSString:(NSString *)libreOffice
                              withNSString:(NSString *)giac
    withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
        withGeogebraCommonMainLocalization:(GeogebraCommonMainLocalization *)loc
                               withBoolean:(jboolean)needDegrees {
  GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, mathml, latex, psTricks, key, libreOffice, giac, tpl, loc, needDegrees);
}

+ (void)appendReduceFunctionWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
    withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                                         withNSString:(NSString *)string {
  GeogebraCommonKernelArithmeticExpressionNode_appendReduceFunctionWithJavaLangStringBuilder_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_(sb, left, string);
}

+ (jboolean)isMultiplyOrDivideWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)exp {
  return GeogebraCommonKernelArithmeticExpressionNode_isMultiplyOrDivideWithGeogebraCommonKernelArithmeticExpressionNode_(exp);
}

+ (jint)opIDWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev {
  return GeogebraCommonKernelArithmeticExpressionNode_opIDWithGeogebraCommonKernelArithmeticExpressionValue_(ev);
}

- (jboolean)isNumberValue {
  return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([self evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()])) isNumberValue];
}

- (jboolean)evaluatesToList {
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToList];
  }
  if (GeogebraCommonPluginOperationEnum_isSimpleFunctionWithGeogebraCommonPluginOperationEnum_(operation_) || operation_ == GeogebraCommonPluginOperationEnum_get_FUNCTION()) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToList];
  }
  if (operation_ == GeogebraCommonPluginOperationEnum_get_IS_ELEMENT_OF() || operation_ == GeogebraCommonPluginOperationEnum_get_IS_SUBSET_OF() || operation_ == GeogebraCommonPluginOperationEnum_get_IS_SUBSET_OF_STRICT() || operation_ == GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN() || operation_ == GeogebraCommonPluginOperationEnum_get_NOT_EQUAL() || operation_ == GeogebraCommonPluginOperationEnum_get_FREEHAND() || operation_ == GeogebraCommonPluginOperationEnum_get_ELEMENT_OF() || operation_ == GeogebraCommonPluginOperationEnum_get_FUNCTION_NVAR()) {
    return NO;
  }
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToList] || (right_ != nil && [right_ evaluatesToList])) {
    return YES;
  }
  return NO;
}

- (jboolean)evaluatesToText {
  if (leaf_) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToText];
  }
  return ([((GeogebraCommonPluginOperationEnum *) nil_chk(operation_)) isEqual:GeogebraCommonPluginOperationEnum_get_PLUS()] || [operation_ isEqual:GeogebraCommonPluginOperationEnum_get_MULTIPLY()]) && ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToText] || [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) evaluatesToText]);
}

- (jboolean)isExpressionNode {
  return YES;
}

+ (jboolean)isEqualWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev1
                   withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev2 {
  return GeogebraCommonKernelArithmeticExpressionNode_isEqualWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(ev1, ev2);
}

+ (jboolean)isEqualStringWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev
                                                                withDouble:(jdouble)val
                                                               withBoolean:(jboolean)symbolic {
  return GeogebraCommonKernelArithmeticExpressionNode_isEqualStringWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_withBoolean_(ev, val, symbolic);
}

- (jboolean)isTopLevelCommand {
  return GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self) && ([left_ isKindOfClass:[GeogebraCommonKernelArithmeticCommand class]]);
}

- (GeogebraCommonKernelArithmeticCommand *)getTopLevelCommand {
  if ([self isTopLevelCommand]) {
    return (GeogebraCommonKernelArithmeticCommand *) check_class_cast(left_, [GeogebraCommonKernelArithmeticCommand class]);
  }
  return nil;
}

- (JavaLangDouble *)getCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv {
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    if ([((NSString *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_toStringWithGeogebraCommonKernelStringTemplate_(self, GeogebraCommonKernelStringTemplate_get_defaultTemplate_()))) isEqual:[((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk(fv)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
      return JavaLangDouble_valueOfWithDouble_(1.0);
    }
    return JavaLangDouble_valueOfWithDouble_(0.0);
  }
  JavaLangDouble *lc = [self getLeftTree] == nil ? nil : [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self getLeftTree])) getCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable:fv];
  JavaLangDouble *rc = [self getRightTree] == nil ? nil : [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self getRightTree])) getCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable:fv];
  if ((lc == nil) || (rc == nil)) {
    return nil;
  }
  switch ([self->operation_ ordinal]) {
    case GeogebraCommonPluginOperation_PLUS:
    return JavaLangDouble_valueOfWithDouble_([lc doubleValue] + [rc doubleValue]);
    case GeogebraCommonPluginOperation_MINUS:
    return JavaLangDouble_valueOfWithDouble_([lc doubleValue] - [rc doubleValue]);
    case GeogebraCommonPluginOperation_MULTIPLY:
    if (![((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self getRightTree])) containsFunctionVariable]) {
      return JavaLangDouble_valueOfWithDouble_([lc doubleValue] * [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self getRightTree])) evaluateDouble]);
    }
    else if (![((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self getLeftTree])) containsFunctionVariable]) {
      return JavaLangDouble_valueOfWithDouble_([rc doubleValue] * [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self getLeftTree])) evaluateDouble]);
    }
    break;
    case GeogebraCommonPluginOperation_DIVIDE:
    if (![((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self getRightTree])) containsFunctionVariable]) {
      return JavaLangDouble_valueOfWithDouble_([lc doubleValue] / [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self getRightTree])) evaluateDouble]);
    }
    break;
  }
  if (([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:fv] || [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:fv])) {
    return nil;
  }
  return JavaLangDouble_valueOfWithDouble_(0.0);
}

+ (jboolean)chainedBooleanOpWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op {
  return GeogebraCommonKernelArithmeticExpressionNode_chainedBooleanOpWithGeogebraCommonPluginOperationEnum_(op);
}

+ (jboolean)isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev
                                                                   withDouble:(jdouble)v {
  return GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(ev, v);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)plusWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  if (GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(v2, 0)) return self;
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self) && GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(left_, 0)) return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(v2)) wrap];
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_PLUS(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)lessThanWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_LESS(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)lessThanWithDouble:(jdouble)d {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_LESS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)lessThanEqualWithDouble:(jdouble)d {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_LESS_EQUAL(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)erf {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_ERF(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)abs {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_ABS(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)sec {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_SEC(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)tan {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_TAN(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)sech {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_SECH(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)tanh {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_TANH(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)cosech {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_CSCH(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)coth {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_COTH(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)cosec {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_CSC(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)cot {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_COT(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)factorial {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_FACTORIAL(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)ln {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_LOG(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)gamma {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_GAMMA(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)gammaIncompleteReverseArgsWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, v2, GeogebraCommonPluginOperationEnum_get_GAMMA_INCOMPLETE(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)gammaIncompleteWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_GAMMA_INCOMPLETE(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)betaWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_BETA(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)exp {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_EXP(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)polygammaWithDouble:(jdouble)n {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, n), GeogebraCommonPluginOperationEnum_get_POLYGAMMA(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)sin {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_SIN(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)sinh {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_SINH(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)cosh {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_COSH(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)cos {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_COS(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)reciprocate {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_POWER(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, -1) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)sqrt {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_SQRT(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)cbrt {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_CBRT(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)sgn {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_SGN(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)atan {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_ARCTAN(), nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)reverseSign {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, -1.0) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)reverseSign2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 0.0) autorelease], GeogebraCommonPluginOperationEnum_get_MINUS(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)betaRegularizedWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v1
                                                                 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyNumberPair_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, v1) autorelease], GeogebraCommonPluginOperationEnum_get_BETA_INCOMPLETE_REGULARIZED(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)square {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_POWER(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 2.0) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)subtractWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  if (GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(v2, 0)) return self;
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self) && GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(left_, 0)) return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(v2)) wrap])) reverseSign];
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_MINUS(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)plusWithDouble:(jdouble)d {
  if (d == 0) {
    return self;
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)plusRWithDouble:(jdouble)d {
  if (d == 0) {
    return self;
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease], GeogebraCommonPluginOperationEnum_get_PLUS(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)multiplyWithDouble:(jdouble)d {
  if (d == 0 || GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(self, 0)) {
    return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 0) autorelease];
  }
  else if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(1, d)) {
    return self;
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)multiplyRWithDouble:(jdouble)d {
  if (d == 0) {
    return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 0) autorelease];
  }
  else if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(1, d)) {
    return self;
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)powerWithDouble:(jdouble)d {
  if (GeogebraCommonKernelKernel_isZeroWithDouble_(d)) {
    return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1) autorelease];
  }
  else if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(1, d) || GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(self, 1) || GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(self, 0)) {
    return self;
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_POWER(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)subtractWithDouble:(jdouble)d {
  if (d == 0) {
    return self;
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_MINUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)subtractRWithDouble:(jdouble)d {
  if (d == 0) {
    return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, -1) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), self) autorelease];
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease], GeogebraCommonPluginOperationEnum_get_MINUS(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)multiplyWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  if (GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(v2, 0) || GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(self, 1)) return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(v2)) wrap];
  if (GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(v2, 1) || GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(self, 0)) return self;
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, v2, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)multiplyRWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  if (GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(v2, 0)) return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(v2)) wrap];
  if (GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(v2, 1)) return self;
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)powerWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  if (GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(v2, 0)) return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1) autorelease];
  if (GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(v2, 1)) return self;
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_POWER(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)powerRWithDouble:(jdouble)d {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease], GeogebraCommonPluginOperationEnum_get_POWER(), self) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)divideWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_DIVIDE(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)divideWithDouble:(jdouble)d {
  if (d == 1) {
    return self;
  }
  if (d == -1) {
    return [self multiplyRWithDouble:-1];
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_DIVIDE(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, d) autorelease]) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)and__WithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_AND(), v2) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)negation {
  GeogebraCommonPluginOperationEnum *opNegated = [((GeogebraCommonPluginOperationEnum *) nil_chk(self->operation_)) negate];
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonPluginOperationEnum_get_NOT())) isEqual:opNegated]) {
    return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_NOT(), nil) autorelease];
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, opNegated, right_) autorelease];
}

- (jboolean)replacePowersRootsWithBoolean:(jboolean)toRoot
                                  withInt:(jint)maxRoot {
  jboolean didReplacement = NO;
  if (toRoot && GeogebraCommonKernelArithmeticExpressionNode_getOperation(self) == GeogebraCommonPluginOperationEnum_get_POWER() && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getRight(self))) isExpressionNode]) {
    jboolean hit = NO;
    GeogebraCommonKernelArithmeticExpressionNode *rightLeaf = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(GeogebraCommonKernelArithmeticExpressionNode_getRight(self), [GeogebraCommonKernelArithmeticExpressionNode class]);
    if ((GeogebraCommonKernelArithmeticExpressionNode_getOperation(nil_chk(rightLeaf)) == GeogebraCommonPluginOperationEnum_get_DIVIDE()) && GeogebraCommonKernelArithmeticExpressionNode_isConstant(rightLeaf)) {
      if ([((NSString *) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getRight(rightLeaf))) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()])) isEqual:@"2"]) {
        [self setOperationWithGeogebraCommonPluginOperationEnum:GeogebraCommonPluginOperationEnum_get_SQRT()];
        hit = YES;
      }
      else if ([((NSString *) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getRight(rightLeaf))) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()])) isEqual:@"3"]) {
        [self setOperationWithGeogebraCommonPluginOperationEnum:GeogebraCommonPluginOperationEnum_get_CBRT()];
        hit = YES;
      }
      else if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getRight(rightLeaf))) unwrap])) isExpressionNode] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:GeogebraCommonKernelArithmeticExpressionNode_getRight(rightLeaf)] && GeogebraCommonKernelKernel_isIntegerWithDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(GeogebraCommonKernelArithmeticExpressionNode_getRight(rightLeaf), @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble]) && [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(GeogebraCommonKernelArithmeticExpressionNode_getRight(rightLeaf), @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble] <= maxRoot) {
        [self setOperationWithGeogebraCommonPluginOperationEnum:GeogebraCommonPluginOperationEnum_get_NROOT()];
        GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(self, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(GeogebraCommonKernelArithmeticExpressionNode_getRight(rightLeaf), @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble]) autorelease]);
        hit = YES;
      }
      if (hit) {
        didReplacement = YES;
        if ([((NSString *) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getLeft(rightLeaf))) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()])) isEqual:@"1"]) {
          if (operation_ != GeogebraCommonPluginOperationEnum_get_NROOT()) GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(self, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, JavaLangDouble_NaN) autorelease]);
        }
        else {
          jdouble c = 1;
          if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getLeft(rightLeaf))) isConstant]) c = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getLeft(rightLeaf))) evaluateDouble];
          if (c < 0) {
            GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(self, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getLeft(self))) wrap])) powerWithDouble:-c], GeogebraCommonKernelArithmeticExpressionNode_getOperation(self), GeogebraCommonKernelArithmeticExpressionNode_getRight(self)) autorelease]);
            [self setOperationWithGeogebraCommonPluginOperationEnum:GeogebraCommonPluginOperationEnum_get_DIVIDE()];
            GeogebraCommonKernelArithmeticExpressionNode_setLeftWithGeogebraCommonKernelArithmeticExpressionValue_(self, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1.0) autorelease]);
          }
          else GeogebraCommonKernelArithmeticExpressionNode_setLeftWithGeogebraCommonKernelArithmeticExpressionValue_(self, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, GeogebraCommonKernelArithmeticExpressionNode_getLeft(self), GeogebraCommonPluginOperationEnum_get_POWER(), GeogebraCommonKernelArithmeticExpressionNode_getLeft(rightLeaf)) autorelease]);
        }
      }
    }
  }
  else if (!toRoot) {
    jboolean hit = NO;
    GeogebraCommonKernelArithmeticExpressionNode *power = nil;
    if (GeogebraCommonKernelArithmeticExpressionNode_getOperation(self) == GeogebraCommonPluginOperationEnum_get_SQRT()) {
      power = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1) autorelease], GeogebraCommonPluginOperationEnum_get_DIVIDE(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 2) autorelease]) autorelease];
      hit = YES;
    }
    else if (GeogebraCommonKernelArithmeticExpressionNode_getOperation(self) == GeogebraCommonPluginOperationEnum_get_CBRT()) {
      power = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1) autorelease], GeogebraCommonPluginOperationEnum_get_DIVIDE(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 3) autorelease]) autorelease];
      hit = YES;
    }
    else if (GeogebraCommonKernelArithmeticExpressionNode_getOperation(self) == GeogebraCommonPluginOperationEnum_get_NROOT()) {
      power = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1) autorelease], GeogebraCommonPluginOperationEnum_get_DIVIDE(), right_) autorelease];
      hit = YES;
    }
    if (hit) {
      didReplacement = YES;
      [self setOperationWithGeogebraCommonPluginOperationEnum:GeogebraCommonPluginOperationEnum_get_POWER()];
      GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(self, power);
    }
  }
  return didReplacement;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)replaceWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)oldObj
                                                            withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)newObj {
  return [self traverseWithGeogebraCommonKernelArithmeticTraversing:GeogebraCommonKernelArithmeticTraversing_Replacer_getReplacerWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(oldObj, newObj)];
}

- (GeogebraCommonKernelGeosGeoFunction *)buildFunctionWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv {
  GeogebraCommonKernelArithmeticFunction *tempFun = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(self, fv) autorelease];
  [tempFun initFunction];
  return [new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getConstruction], tempFun) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)unwrap {
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) return GeogebraCommonKernelArithmeticExpressionNode_getLeft(self);
  return self;
}

- (GeogebraCommonKernelArithmeticExpressionNode *)wrap {
  return self;
}

- (jboolean)hasCoords {
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) return left_ != nil && [left_ hasCoords];
  return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getLeft(self))) hasCoords] || [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getRight(self))) hasCoords];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv {
  {
    GeogebraCommonKernelArithmeticMyNumberPair *np;
    GeogebraCommonKernelArithmeticMyList *rtDiff;
    GeogebraCommonKernelArithmeticMyList *rt;
    switch ([operation_ ordinal]) {
      case GeogebraCommonPluginOperation_LESS:
      case GeogebraCommonPluginOperation_LESS_EQUAL:
      case GeogebraCommonPluginOperation_GREATER:
      case GeogebraCommonPluginOperation_GREATER_EQUAL:
      case GeogebraCommonPluginOperation_NOT:
      case GeogebraCommonPluginOperation_XCOORD:
      case GeogebraCommonPluginOperation_YCOORD:
      case GeogebraCommonPluginOperation_ZCOORD:
      return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 0.0) autorelease];
      case GeogebraCommonPluginOperation_POWER:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isNumberValue] && ![right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        if (GeogebraCommonKernelKernel_isZeroWithDouble_([right_ evaluateDouble])) {
          return GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 0.0) autorelease]);
        }
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) powerWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, right_))) subtractWithDouble:1]])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:right_];
      }
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) powerWithGeogebraCommonKernelArithmeticExpressionValue:right_])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [right_ derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) ln]])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, right_))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) divideWithGeogebraCommonKernelArithmeticExpressionValue:left_]]];
      case GeogebraCommonPluginOperation_NO_OPERATION:
      return GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]);
      case GeogebraCommonPluginOperation_DIVIDE:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isNumberValue] && ![right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv])) divideWithGeogebraCommonKernelArithmeticExpressionValue:right_];
      }
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:right_])) subtractWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [right_ derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_]])) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, right_))) square]];
      case GeogebraCommonPluginOperation_MULTIPLY:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isNumberValue] && ![right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:right_];
      }
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isNumberValue] && ![left_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, right_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_];
      }
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[right_ derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, right_))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[left_ derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]]];
      case GeogebraCommonPluginOperation_PLUS:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_MINUS:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) subtractWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_SIN:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_COS(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_COS:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_SIN(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) multiplyWithDouble:-1];
      case GeogebraCommonPluginOperation_TAN:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_SEC(), nil) autorelease]) square])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_SEC:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_SEC(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_TAN(), nil) autorelease]])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_CSC:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_CSC(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_COT(), nil) autorelease]])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) multiplyWithDouble:-1];
      case GeogebraCommonPluginOperation_COT:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_CSC(), nil) autorelease]) square])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) multiplyWithDouble:-1];
      case GeogebraCommonPluginOperation_SINH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_COSH(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_COSH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_SINH(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_TANH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_SECH(), nil) autorelease]) square])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_SECH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_SECH(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_TANH(), nil) autorelease]])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) multiplyWithDouble:-1];
      case GeogebraCommonPluginOperation_CSCH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_CSCH(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_COTH(), nil) autorelease]])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) multiplyWithDouble:-1];
      case GeogebraCommonPluginOperation_COTH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_CSCH(), nil) autorelease]) square])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk((left_))) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]])) multiplyWithDouble:-1];
      case GeogebraCommonPluginOperation_ARCSIN:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) square])) subtractRWithDouble:1])) sqrt]];
      case GeogebraCommonPluginOperation_ARCCOS:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) square])) subtractRWithDouble:1])) sqrt]])) multiplyWithDouble:-1];
      case GeogebraCommonPluginOperation_ARCTAN:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) square])) plusWithDouble:1]];
      case GeogebraCommonPluginOperation_ASINH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) square])) plusWithDouble:1])) sqrt]];
      case GeogebraCommonPluginOperation_ACOSH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) plusWithDouble:1])) sqrt])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) subtractWithDouble:1])) sqrt]]];
      case GeogebraCommonPluginOperation_ATANH:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) square])) subtractRWithDouble:1]];
      case GeogebraCommonPluginOperation_ABS:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) abs]];
      case GeogebraCommonPluginOperation_SGN:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 0) autorelease]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:fv];
      case GeogebraCommonPluginOperation_EXP:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) exp]];
      case GeogebraCommonPluginOperation_SI:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sin])) divideWithGeogebraCommonKernelArithmeticExpressionValue:left_]];
      case GeogebraCommonPluginOperation_CI:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cos])) divideWithGeogebraCommonKernelArithmeticExpressionValue:left_]];
      case GeogebraCommonPluginOperation_EI:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) exp])) divideWithGeogebraCommonKernelArithmeticExpressionValue:left_]];
      case GeogebraCommonPluginOperation_ERF:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, 2)])) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) square])) exp])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, JavaLangMath_PI))) sqrt]]];
      case GeogebraCommonPluginOperation_PSI:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) polygammaWithDouble:1]];
      case GeogebraCommonPluginOperation_POLYGAMMA:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isNumberValue] && ![left_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        jdouble n = [((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(left_, @protocol(GeogebraCommonKernelArithmeticNumberValue))) getDouble];
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, right_))) polygammaWithDouble:n + 1]];
      }
      break;
      case GeogebraCommonPluginOperation_IF_ELSE:
      np = (GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(left_, [GeogebraCommonKernelArithmeticMyNumberPair class]);
      np = [new_GeogebraCommonKernelArithmeticMyNumberPair_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, ((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(np))->x_, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(np->y_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]) autorelease];
      return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, np, GeogebraCommonPluginOperationEnum_get_IF_ELSE(), [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]) autorelease];
      case GeogebraCommonPluginOperation_IF:
      return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_IF(), [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]) autorelease];
      case GeogebraCommonPluginOperation_IF_LIST:
      rtDiff = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel_) autorelease];
      rt = (GeogebraCommonKernelArithmeticMyList *) check_class_cast(right_, [GeogebraCommonKernelArithmeticMyList class]);
      for (jint i = 0; i < [((GeogebraCommonKernelArithmeticMyList *) nil_chk(rt)) size]; i++) {
        [rtDiff addListElementWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([rt getListElementWithInt:i])) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      }
      return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_IF_LIST(), rtDiff) autorelease];
      case GeogebraCommonPluginOperation_LOG:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:left_];
      case GeogebraCommonPluginOperation_LOG10:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:left_])) divideWithDouble:JavaLangMath_logWithDouble_(10)];
      case GeogebraCommonPluginOperation_LOG2:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:left_])) divideWithDouble:JavaLangMath_logWithDouble_(2)];
      case GeogebraCommonPluginOperation_LOGB:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isNumberValue] && ![left_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:right_])) divideWithDouble:JavaLangMath_logWithDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(left_, @protocol(GeogebraCommonKernelArithmeticNumberValue))) getDouble])];
      }
      break;
      case GeogebraCommonPluginOperation_NROOT:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isNumberValue] && ![right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) nrootWithGeogebraCommonKernelArithmeticExpressionValue:right_]])) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:right_]];
      }
      break;
      case GeogebraCommonPluginOperation_SQRT:
      case GeogebraCommonPluginOperation_SQRT_SHORT:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) powerWithDouble:-0.5]])) divideWithDouble:2];
      case GeogebraCommonPluginOperation_CBRT:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) square])) cbrt]])) divideWithDouble:3];
      case GeogebraCommonPluginOperation_FUNCTION:
      if ([left_ isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) {
        GeogebraCommonKernelArithmeticFunction *fun = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(((GeogebraCommonKernelGeosGeoFunction *) check_class_cast(left_, [GeogebraCommonKernelGeosGeoFunction class])))) getFunction];
        GeogebraCommonKernelArithmeticFunctionVariable *fv2 = IOSObjectArray_Get(nil_chk(((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun))->fVars_), 0);
        id<GeogebraCommonKernelArithmeticExpressionValue> deriv = [fun derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv2];
        GeogebraCommonKernelArithmeticFunction *fun2 = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(deriv, [GeogebraCommonKernelArithmeticExpressionNode class]), fv2) autorelease];
        GeogebraCommonKernelGeosGeoFunction *geoFun = [new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getConstruction], fun2) autorelease];
        GeogebraCommonKernelArithmeticExpressionNode *ret = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, geoFun, GeogebraCommonPluginOperationEnum_get_FUNCTION(), fv2) autorelease];
        return ret;
      }
      break;
    }
  }
  GeogebraCommonMainApp_errorWithNSString_(JreStrcat("$$", @"unhandled operation in derivative() (no CAS version): ", [((GeogebraCommonPluginOperationEnum *) nil_chk(operation_)) description]));
  return GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, JavaLangDouble_NaN);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)wrapWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)exp {
  return GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, exp);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)integralWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv {
  {
    jdouble coeff;
    GeogebraCommonKernelArithmeticMyNumberPair *np;
    switch ([operation_ ordinal]) {
      case GeogebraCommonPluginOperation_XCOORD:
      case GeogebraCommonPluginOperation_YCOORD:
      case GeogebraCommonPluginOperation_ZCOORD:
      return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), fv) autorelease];
      case GeogebraCommonPluginOperation_POWER:
      if (left_ == fv && ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        jdouble index = [right_ evaluateDouble];
        if (!JavaLangDouble_isNaNWithDouble_(index) && !JavaLangDouble_isInfiniteWithDouble_(index)) {
          if (GeogebraCommonKernelKernel_isZeroWithDouble_(index + 1)) {
            return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_LOG(), nil) autorelease];
          }
          return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) powerWithDouble:index + 1])) divideWithDouble:index + 1];
        }
      }
      else if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        if (right_ == fv) {
          jdouble base = [left_ evaluateDouble];
          if (!JavaLangDouble_isNaNWithDouble_(base) && !JavaLangDouble_isInfiniteWithDouble_(base)) {
            if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(base, 1)) {
              return GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, fv);
            }
            if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(base, 0)) {
              return [self divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) ln]];
            }
          }
        }
      }
      else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isNumberValue] && ![right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        jdouble index = [right_ evaluateDouble];
        if (!JavaLangDouble_isNaNWithDouble_(index) && !JavaLangDouble_isInfiniteWithDouble_(index)) {
          jdouble coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
          if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
            if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(index, -1)) {
              return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) abs])) ln])) divideWithDouble:coeff];
            }
            return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) powerWithDouble:index + 1])) divideWithDouble:coeff * ((index + 1))];
          }
          coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
          if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
            if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(index, -1)) {
              return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) abs])) ln])) multiplyWithDouble:coeff];
            }
            return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) powerWithDouble:index + 1])) multiplyWithDouble:coeff / ((index + 1))];
          }
        }
      }
      break;
      case GeogebraCommonPluginOperation_NO_OPERATION:
      return GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]);
      case GeogebraCommonPluginOperation_DIVIDE:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isNumberValue] && ![right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) divideWithGeogebraCommonKernelArithmeticExpressionValue:right_];
      }
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isNumberValue] && ![left_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv] && right_ == fv) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv, GeogebraCommonPluginOperationEnum_get_LOG(), nil) autorelease]) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_];
      }
      break;
      case GeogebraCommonPluginOperation_MULTIPLY:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isNumberValue] && ![right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyRWithGeogebraCommonKernelArithmeticExpressionValue:right_];
      }
      else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isNumberValue] && ![left_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [right_ integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) multiplyRWithGeogebraCommonKernelArithmeticExpressionValue:left_];
      }
      break;
      case GeogebraCommonPluginOperation_PLUS:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_MINUS:
      return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]))) subtractWithGeogebraCommonKernelArithmeticExpressionValue:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]];
      case GeogebraCommonPluginOperation_SIN:
      return GeogebraCommonKernelArithmeticExpressionNode_linearIntegralWithInt_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionVariable_(self, -1, GeogebraCommonPluginOperationEnum_get_COS(), fv);
      case GeogebraCommonPluginOperation_COS:
      return GeogebraCommonKernelArithmeticExpressionNode_linearIntegralWithInt_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionVariable_(self, 1, GeogebraCommonPluginOperationEnum_get_SIN(), fv);
      case GeogebraCommonPluginOperation_TAN:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sec])) abs])) ln])) divideWithDouble:coeff];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sec])) abs])) ln])) multiplyWithDouble:coeff];
      }
      break;
      case GeogebraCommonPluginOperation_SEC:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sec])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) tan]])) abs])) ln])) divideWithDouble:coeff];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sec])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) tan]])) abs])) ln])) multiplyWithDouble:coeff];
      }
      break;
      case GeogebraCommonPluginOperation_CSC:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cosec])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cot]])) abs])) ln])) divideWithDouble:-coeff];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cosec])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cot]])) abs])) ln])) multiplyWithDouble:-coeff];
      }
      break;
      case GeogebraCommonPluginOperation_COT:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sin])) abs])) ln])) divideWithDouble:coeff];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sin])) abs])) ln])) multiplyWithDouble:coeff];
      }
      break;
      case GeogebraCommonPluginOperation_SINH:
      return GeogebraCommonKernelArithmeticExpressionNode_linearIntegralWithInt_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionVariable_(self, 1, GeogebraCommonPluginOperationEnum_get_COSH(), fv);
      case GeogebraCommonPluginOperation_COSH:
      return GeogebraCommonKernelArithmeticExpressionNode_linearIntegralWithInt_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionVariable_(self, 1, GeogebraCommonPluginOperationEnum_get_SINH(), fv);
      case GeogebraCommonPluginOperation_TANH:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cosh])) abs])) ln])) divideWithDouble:coeff];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cosh])) abs])) ln])) multiplyWithDouble:coeff];
      }
      break;
      case GeogebraCommonPluginOperation_SECH:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) exp])) atan])) divideWithDouble:coeff / 2];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) exp])) atan])) multiplyWithDouble:2 * coeff];
      }
      break;
      case GeogebraCommonPluginOperation_CSCH:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cosech])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) coth]])) abs])) ln])) divideWithDouble:-coeff];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cosech])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) coth]])) abs])) ln])) multiplyWithDouble:-coeff];
      }
      break;
      case GeogebraCommonPluginOperation_COTH:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sinh])) abs])) ln])) divideWithDouble:coeff];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sinh])) abs])) ln])) multiplyWithDouble:coeff];
      }
      break;
      case GeogebraCommonPluginOperation_EXP:
      return GeogebraCommonKernelArithmeticExpressionNode_linearIntegralWithInt_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionVariable_(self, 1, GeogebraCommonPluginOperationEnum_get_EXP(), fv);
      case GeogebraCommonPluginOperation_ARCSIN:
      case GeogebraCommonPluginOperation_ARCCOS:
      case GeogebraCommonPluginOperation_ARCTAN:
      case GeogebraCommonPluginOperation_ASINH:
      case GeogebraCommonPluginOperation_ACOSH:
      case GeogebraCommonPluginOperation_ATANH:
      case GeogebraCommonPluginOperation_ABS:
      case GeogebraCommonPluginOperation_SGN:
      case GeogebraCommonPluginOperation_SI:
      case GeogebraCommonPluginOperation_CI:
      case GeogebraCommonPluginOperation_EI:
      case GeogebraCommonPluginOperation_ERF:
      case GeogebraCommonPluginOperation_PSI:
      case GeogebraCommonPluginOperation_POLYGAMMA:
      case GeogebraCommonPluginOperation_LOGB:
      break;
      case GeogebraCommonPluginOperation_IF_ELSE:
      np = (GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(left_, [GeogebraCommonKernelArithmeticMyNumberPair class]);
      np = [new_GeogebraCommonKernelArithmeticMyNumberPair_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, ((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(np))->x_, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(np->y_)) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:fv]) autorelease];
      return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, np, GeogebraCommonPluginOperationEnum_get_IF_ELSE(), [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]) autorelease];
      case GeogebraCommonPluginOperation_IF:
      return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left_, GeogebraCommonPluginOperationEnum_get_IF(), [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) integralWithGeogebraCommonKernelArithmeticFunctionVariable:fv]) autorelease];
      case GeogebraCommonPluginOperation_LOG:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) ln])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) subtractWithGeogebraCommonKernelArithmeticExpressionValue:left_])) divideWithDouble:coeff];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) ln])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) subtractWithGeogebraCommonKernelArithmeticExpressionValue:left_])) multiplyWithDouble:coeff];
      }
      break;
      case GeogebraCommonPluginOperation_LOG10:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) ln])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) subtractWithGeogebraCommonKernelArithmeticExpressionValue:left_])) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, 10))) ln])) multiplyWithDouble:coeff]];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) ln])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) subtractWithGeogebraCommonKernelArithmeticExpressionValue:left_])) multiplyWithDouble:coeff])) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, 10))) ln]];
      }
      break;
      case GeogebraCommonPluginOperation_LOG2:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) ln])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) subtractWithGeogebraCommonKernelArithmeticExpressionValue:left_])) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, 2))) ln])) multiplyWithDouble:coeff]];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) ln])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) subtractWithGeogebraCommonKernelArithmeticExpressionValue:left_])) multiplyWithDouble:coeff])) divideWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, 2))) ln]];
      }
      break;
      case GeogebraCommonPluginOperation_NROOT:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isNumberValue] && ![right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
        coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
        if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
          return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) nrootWithGeogebraCommonKernelArithmeticExpressionValue:right_])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:right_])) divideWithDouble:([right_ evaluateDouble] + 1) * coeff];
        }
        coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
        if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
          return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) nrootWithGeogebraCommonKernelArithmeticExpressionValue:right_])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:right_])) divideWithDouble:([right_ evaluateDouble] + 1) / coeff];
        }
      }
      break;
      case GeogebraCommonPluginOperation_SQRT:
      case GeogebraCommonPluginOperation_SQRT_SHORT:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sqrt])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) divideWithDouble:coeff * 3.0 / 2.0];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) sqrt])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) multiplyWithDouble:coeff * 2.0 / 3.0];
      }
      break;
      case GeogebraCommonPluginOperation_CBRT:
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cbrt])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) divideWithDouble:coeff * 4.0 / 3.0];
      }
      coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, left_);
      if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
        return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_))) cbrt])) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:left_])) multiplyWithDouble:coeff * 3.0 / 4.0];
      }
      break;
    }
  }
  GeogebraCommonMainApp_errorWithNSString_(JreStrcat("$$", @"unhandled operation in integral() (no CAS version): ", [((GeogebraCommonPluginOperationEnum *) nil_chk(operation_)) description]));
  return GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, JavaLangDouble_NaN);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)nrootWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)n {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, GeogebraCommonPluginOperationEnum_get_NROOT(), n) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)linearIntegralWithInt:(jint)i
                                  withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op
                     withGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv {
  return GeogebraCommonKernelArithmeticExpressionNode_linearIntegralWithInt_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionVariable_(self, i, op, fv);
}

+ (jdouble)getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv
                                withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev2 {
  return GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, ev2);
}

+ (jdouble)getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable:(GeogebraCommonKernelArithmeticFunctionVariable *)fv
                                   withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev2 {
  return GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, ev2);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)wrapWithDouble:(jdouble)n {
  return GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, n);
}

- (jboolean)isConditional {
  return operation_ == GeogebraCommonPluginOperationEnum_get_IF() || operation_ == GeogebraCommonPluginOperationEnum_get_IF_ELSE() || operation_ == GeogebraCommonPluginOperationEnum_get_IF_LIST();
}

- (jboolean)isConditionalDeep {
  return [self isConditional] || ([left_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]] && [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left_, [GeogebraCommonKernelArithmeticExpressionNode class])))) isConditionalDeep]) || ([right_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]] && [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right_, [GeogebraCommonKernelArithmeticExpressionNode class])))) isConditionalDeep]);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)ifElseWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ifBranch
                                                        withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)elseBranch {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyNumberPair_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, ifBranch) autorelease], GeogebraCommonPluginOperationEnum_get_IF_ELSE(), elseBranch) autorelease];
}

- (jdouble)evaluateDouble {
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluateDouble];
  }
  {
    jdouble lt;
    switch ([operation_ ordinal]) {
      case GeogebraCommonPluginOperation_PLUS:
      return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluateDouble] + [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) evaluateDouble];
      case GeogebraCommonPluginOperation_MINUS:
      return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluateDouble] - [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) evaluateDouble];
      case GeogebraCommonPluginOperation_DIVIDE:
      return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluateDouble] / [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) evaluateDouble];
      case GeogebraCommonPluginOperation_POWER:
      if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) isNumberValue]) {
        return [super evaluateDouble];
      }
      lt = [left_ evaluateDouble];
      if (lt < 0 && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) isExpressionNode] && GeogebraCommonKernelArithmeticExpressionNode_getOperation(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right_, [GeogebraCommonKernelArithmeticExpressionNode class]))) == GeogebraCommonPluginOperationEnum_get_DIVIDE()) {
        return GeogebraCommonKernelArithmeticExpressionNodeEvaluator_negPowerWithDouble_withGeogebraCommonKernelArithmeticExpressionValue_(lt, right_);
      }
      return JavaLangMath_powWithDouble_withDouble_([left_ evaluateDouble], [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) evaluateDouble]);
      case GeogebraCommonPluginOperation_SIN:
      return JavaLangMath_sinWithDouble_([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluateDouble]);
      case GeogebraCommonPluginOperation_COS:
      return JavaLangMath_cosWithDouble_([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluateDouble]);
      case GeogebraCommonPluginOperation_SQRT:
      return JavaLangMath_sqrtWithDouble_([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluateDouble]);
    }
  }
  return [super evaluateDouble];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)replaceCasCommands {
  return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([self traverseWithGeogebraCommonKernelArithmeticTraversing:GeogebraCommonKernelArithmeticTraversing_CASCommandReplacer_get_replacer_()])) wrap];
}

- (jboolean)hasBrackets {
  return brackets_;
}

- (void)setBracketsWithBoolean:(jboolean)brackets {
  self->brackets_ = brackets;
}

- (GeogebraCommonKernelArithmeticExpressionNode *)applyWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation2 {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, operation2, nil) autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)applyWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation2
                                           withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)arg {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self, operation2, arg) autorelease];
}

- (jboolean)containsFreeFunctionVariable {
  return GeogebraCommonKernelArithmeticExpressionNode_checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue_(self, left_) || (right_ != nil && GeogebraCommonKernelArithmeticExpressionNode_checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue_(self, right_)) || (operation_ == GeogebraCommonPluginOperationEnum_get_FUNCTION_NVAR() && [right_ isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]] && [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(((GeogebraCommonKernelArithmeticValidExpression *) check_class_cast(right_, [GeogebraCommonKernelArithmeticValidExpression class])))) containsFunctionVariable]);
}

- (jboolean)checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev {
  return GeogebraCommonKernelArithmeticExpressionNode_checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue_(self, ev);
}

- (jboolean)evaluatesToNumberWithBoolean:(jboolean)def {
  if (operation_ == GeogebraCommonPluginOperationEnum_get_RANDOM() || operation_ == GeogebraCommonPluginOperationEnum_get_XCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_YCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_ZCOORD() || operation_ == GeogebraCommonPluginOperationEnum_get_ABS() || operation_ == GeogebraCommonPluginOperationEnum_get_ARG()) {
    return YES;
  }
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self) || GeogebraCommonPluginOperationEnum_isSimpleFunctionWithGeogebraCommonPluginOperationEnum_(self->operation_)) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToNumberWithBoolean:def];
  }
  if (right_ != nil && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToNumberWithBoolean:def] && [right_ evaluatesToNumberWithBoolean:def]) {
    return YES;
  }
  if (right_ != nil && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToNumberWithBoolean:def] && ![right_ evaluatesToNumberWithBoolean:def]) {
    return NO;
  }
  if (right_ != nil && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToNumberWithBoolean:def] && ![right_ evaluatesToNumberWithBoolean:def]) {
    return self->operation_ == GeogebraCommonPluginOperationEnum_get_POWER();
  }
  if (right_ != nil && ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) evaluatesToNumberWithBoolean:def] && ![right_ evaluatesToNumberWithBoolean:def]) {
    if (operation_ == GeogebraCommonPluginOperationEnum_get_PLUS() || operation_ == GeogebraCommonPluginOperationEnum_get_MINUS()) {
      return NO;
    }
  }
  return def;
}

- (JavaUtilHashSet *)getUnconditionalVars {
  if (![self isConditionalDeep]) {
    return nil;
  }
  if (leaf_) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) getVariables];
  }
  if ([self isConditional]) {
    return [new_JavaUtilHashSet_init() autorelease];
  }
  JavaUtilHashSet *leftVars = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left_)) getVariables];
  JavaUtilHashSet *rightVars = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right_)) getVariables];
  if (leftVars == nil) {
    return rightVars;
  }
  else if (rightVars == nil) {
    return leftVars;
  }
  else {
    [leftVars addAllWithJavaUtilCollection:rightVars];
    return leftVars;
  }
}

- (void)dealloc {
  RELEASE_(loc_);
  RELEASE_(kernel_);
  RELEASE_(left_);
  RELEASE_(right_);
  RELEASE_(operation_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "ExpressionNode", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelKernel:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonPluginOperationEnum:withGeogebraCommonKernelArithmeticExpressionValue:", "ExpressionNode", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelKernel:withGeogebraCommonKernelArithmeticExpressionValue:", "ExpressionNode", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelArithmeticExpressionNode:", "ExpressionNode", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelKernel:withDouble:", "ExpressionNode", NULL, 0x1, NULL, NULL },
    { "getKernel", NULL, "Lgeogebra.common.kernel.Kernel;", 0x1, NULL, NULL },
    { "getOperation", NULL, "Lgeogebra.common.plugin.Operation;", 0x11, NULL, NULL },
    { "setOperationWithGeogebraCommonPluginOperationEnum:", "setOperation", "V", 0x1, NULL, NULL },
    { "setHoldsLaTeXtextWithBoolean:", "setHoldsLaTeXtext", "V", 0x1, NULL, NULL },
    { "getLeft", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x11, NULL, NULL },
    { "setLeftWithGeogebraCommonKernelArithmeticExpressionValue:", "setLeft", "V", 0x11, NULL, NULL },
    { "getLeftTree", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "getRight", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x11, NULL, NULL },
    { "setRightWithGeogebraCommonKernelArithmeticExpressionValue:", "setRight", "V", 0x11, NULL, NULL },
    { "getRightTree", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "deepCopyWithGeogebraCommonKernelKernel:", "deepCopy", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "getCopyWithGeogebraCommonKernelKernel:", "getCopy", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "copy__WithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelKernel:", "copy", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x9, NULL, NULL },
    { "simplifyLeafs", NULL, "V", 0x11, NULL, NULL },
    { "simplifyAndEvalCommands", NULL, "V", 0x12, NULL, NULL },
    { "simplifyConstantIntegers", NULL, "V", 0x11, NULL, NULL },
    { "evaluateWithGeogebraCommonKernelStringTemplate:", "evaluate", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "resolveVariables", NULL, "V", 0x11, NULL, NULL },
    { "doResolveVariables", NULL, "V", 0x2, NULL, NULL },
    { "shouldEvaluateToGeoVector", NULL, "Z", 0x1, NULL, NULL },
    { "includesDivisionByWithGeogebraCommonKernelArithmeticExpressionValue:", "includesDivisionBy", "Z", 0x11, NULL, NULL },
    { "includesNonContinuousIntegral", NULL, "Z", 0x11, NULL, NULL },
    { "replaceVariablesWithNSString:withGeogebraCommonKernelArithmeticFunctionVariable:", "replaceVariables", "I", 0x11, NULL, NULL },
    { "replaceXYZnodesWithGeogebraCommonKernelArithmeticFunctionVariable:withGeogebraCommonKernelArithmeticFunctionVariable:withGeogebraCommonKernelArithmeticFunctionVariable:withJavaUtilArrayList:", "replaceXYZnodes", "I", 0x4, NULL, NULL },
    { "traverseWithGeogebraCommonKernelArithmeticTraversing:", "traverse", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "inspectWithGeogebraCommonKernelArithmeticInspecting:", "inspect", "Z", 0x1, NULL, NULL },
    { "replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:", "replaceChildrenByValues", "V", 0x1, NULL, NULL },
    { "containsWithGeogebraCommonKernelArithmeticExpressionValue:", "contains", "Z", 0x11, NULL, NULL },
    { "containsCasEvaluableFunction", NULL, "Z", 0x11, NULL, NULL },
    { "containsGeoFunctionNVar", NULL, "Z", 0x11, NULL, NULL },
    { "makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation:", "makePolynomialTree", "Lgeogebra.common.kernel.arithmetic.Polynomial;", 0x14, NULL, NULL },
    { "makePolyTreeFromFunctionWithGeogebraCommonKernelArithmeticFunction:withGeogebraCommonKernelArithmeticEquation:", "makePolyTreeFromFunction", "Lgeogebra.common.kernel.arithmetic.Polynomial;", 0x2, NULL, NULL },
    { "polynomialOperationWithGeogebraCommonPluginOperationEnum:", "polynomialOperation", "Z", 0xa, NULL, NULL },
    { "isConstant", NULL, "Z", 0x11, NULL, NULL },
    { "evaluatesToNonComplex2DVector", NULL, "Z", 0x11, NULL, NULL },
    { "evaluatesToVectorNotPoint", NULL, "Z", 0x11, NULL, NULL },
    { "evaluatesTo3DVector", NULL, "Z", 0x11, NULL, NULL },
    { "setForceVector", NULL, "V", 0x1, NULL, NULL },
    { "isForcedVector", NULL, "Z", 0x11, NULL, NULL },
    { "setForcePoint", NULL, "V", 0x1, NULL, NULL },
    { "isForcedPoint", NULL, "Z", 0x11, NULL, NULL },
    { "setForceFunction", NULL, "V", 0x1, NULL, NULL },
    { "isForcedFunction", NULL, "Z", 0x11, NULL, NULL },
    { "hasOperations", NULL, "Z", 0x11, NULL, NULL },
    { "getVariables", NULL, "Ljava.util.HashSet;", 0x11, NULL, NULL },
    { "getGeoElementVariables", NULL, "[Lgeogebra.common.kernel.geos.GeoElement;", 0x11, NULL, NULL },
    { "isLeaf", NULL, "Z", 0x11, NULL, NULL },
    { "isSingleGeoElement", NULL, "Z", 0x11, NULL, NULL },
    { "getSingleGeoElement", NULL, "Lgeogebra.common.kernel.geos.GeoElement;", 0x11, NULL, NULL },
    { "isSingleVariable", NULL, "Z", 0x1, NULL, NULL },
    { "isImaginaryUnit", NULL, "Z", 0x1, NULL, NULL },
    { "containsMyStringBuffer", NULL, "Z", 0x1, NULL, NULL },
    { "getCASstringWithGeogebraCommonKernelStringTemplate:withBoolean:", "getCASstring", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getTreeClass", NULL, "Ljava.lang.String;", 0x11, NULL, NULL },
    { "expandForOGPWithGeogebraCommonKernelArithmeticExpressionValue:", "expandForOGP", "Z", 0x12, NULL, NULL },
    { "getTreeClassWithNSString:", "getTreeClass", "Ljava.lang.String;", 0x12, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "toOutputValueStringWithGeogebraCommonKernelStringTemplate:", "toOutputValueString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "toLaTeXStringWithBoolean:withGeogebraCommonKernelStringTemplate:", "toLaTeXString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "checkMathmlWithNSString:withGeogebraCommonKernelStringTemplate:", "checkMathml", "Ljava.lang.String;", 0xa, NULL, NULL },
    { "operationToStringWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonPluginOperationEnum:withNSString:withNSString:withBoolean:withGeogebraCommonKernelStringTemplate:withGeogebraCommonKernelKernel:", "operationToString", "Ljava.lang.String;", 0x19, NULL, NULL },
    { "degFixWithNSString:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelKernel:", "degFix", "Ljava.lang.String;", 0xa, NULL, NULL },
    { "trigWithGeogebraCommonKernelKernel:withGeogebraCommonKernelArithmeticExpressionValue:withNSString:withJavaLangStringBuilder:withNSString:withNSString:withNSString:withNSString:withNSString:withGeogebraCommonKernelStringTemplate:withGeogebraCommonMainLocalization:withBoolean:", "trig", "V", 0xa, NULL, NULL },
    { "trigWithGeogebraCommonKernelKernel:withGeogebraCommonKernelArithmeticExpressionValue:withNSString:withJavaLangStringBuilder:withNSString:withNSString:withNSString:withNSString:withNSString:withNSString:withGeogebraCommonKernelStringTemplate:withGeogebraCommonMainLocalization:withBoolean:", "trig", "V", 0xa, NULL, NULL },
    { "appendReduceFunctionWithJavaLangStringBuilder:withGeogebraCommonKernelArithmeticExpressionValue:withNSString:", "appendReduceFunction", "V", 0xa, NULL, NULL },
    { "isMultiplyOrDivideWithGeogebraCommonKernelArithmeticExpressionNode:", "isMultiplyOrDivide", "Z", 0x9, NULL, NULL },
    { "opIDWithGeogebraCommonKernelArithmeticExpressionValue:", "opID", "I", 0x9, NULL, NULL },
    { "isNumberValue", NULL, "Z", 0x1, NULL, NULL },
    { "evaluatesToList", NULL, "Z", 0x1, NULL, NULL },
    { "evaluatesToText", NULL, "Z", 0x1, NULL, NULL },
    { "isExpressionNode", NULL, "Z", 0x11, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "isEqual", "Z", 0x9, NULL, NULL },
    { "isEqualStringWithGeogebraCommonKernelArithmeticExpressionValue:withDouble:withBoolean:", "isEqualString", "Z", 0x19, NULL, NULL },
    { "isTopLevelCommand", NULL, "Z", 0x1, NULL, NULL },
    { "getTopLevelCommand", NULL, "Lgeogebra.common.kernel.arithmetic.Command;", 0x1, NULL, NULL },
    { "getCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable:", "getCoefficient", "Ljava.lang.Double;", 0x1, NULL, NULL },
    { "chainedBooleanOpWithGeogebraCommonPluginOperationEnum:", "chainedBooleanOp", "Z", 0x9, NULL, NULL },
    { "isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue:withDouble:", "isConstantDouble", "Z", 0xa, NULL, NULL },
    { "plusWithGeogebraCommonKernelArithmeticExpressionValue:", "plus", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "lessThanWithGeogebraCommonKernelArithmeticExpressionValue:", "lessThan", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "lessThanWithDouble:", "lessThan", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "lessThanEqualWithDouble:", "lessThanEqual", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "erf", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "abs", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "sec", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "tan", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "sech", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "tanh", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "cosech", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "coth", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "cosec", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "cot", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "factorial", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "ln", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "gamma", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "gammaIncompleteReverseArgsWithGeogebraCommonKernelArithmeticExpressionValue:", "gammaIncompleteReverseArgs", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "gammaIncompleteWithGeogebraCommonKernelArithmeticExpressionValue:", "gammaIncomplete", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "betaWithGeogebraCommonKernelArithmeticExpressionValue:", "beta", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "exp", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "polygammaWithDouble:", "polygamma", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "sin", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "sinh", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "cosh", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "cos", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "reciprocate", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "sqrt", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "cbrt", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "sgn", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "atan", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "reverseSign", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "reverseSign2", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "betaRegularizedWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "betaRegularized", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "square", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "subtractWithGeogebraCommonKernelArithmeticExpressionValue:", "subtract", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "plusWithDouble:", "plus", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "plusRWithDouble:", "plusR", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "multiplyWithDouble:", "multiply", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "multiplyRWithDouble:", "multiplyR", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "powerWithDouble:", "power", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "subtractWithDouble:", "subtract", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "subtractRWithDouble:", "subtractR", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "multiplyWithGeogebraCommonKernelArithmeticExpressionValue:", "multiply", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "multiplyRWithGeogebraCommonKernelArithmeticExpressionValue:", "multiplyR", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "powerWithGeogebraCommonKernelArithmeticExpressionValue:", "power", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "powerRWithDouble:", "powerR", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "divideWithGeogebraCommonKernelArithmeticExpressionValue:", "divide", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "divideWithDouble:", "divide", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "and__WithGeogebraCommonKernelArithmeticExpressionValue:", "and", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "negation", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "replacePowersRootsWithBoolean:withInt:", "replacePowersRoots", "Z", 0x1, NULL, NULL },
    { "replaceWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "replace", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "buildFunctionWithGeogebraCommonKernelArithmeticFunctionVariable:", "buildFunction", "Lgeogebra.common.kernel.geos.GeoFunction;", 0x1, NULL, NULL },
    { "unwrap", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "wrap", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "hasCoords", NULL, "Z", 0x1, NULL, NULL },
    { "derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:", "derivative", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "wrapWithGeogebraCommonKernelArithmeticExpressionValue:", "wrap", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x2, NULL, NULL },
    { "integralWithGeogebraCommonKernelArithmeticFunctionVariable:", "integral", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "nrootWithGeogebraCommonKernelArithmeticExpressionValue:", "nroot", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "linearIntegralWithInt:withGeogebraCommonPluginOperationEnum:withGeogebraCommonKernelArithmeticFunctionVariable:", "linearIntegral", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x2, NULL, NULL },
    { "getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable:withGeogebraCommonKernelArithmeticExpressionValue:", "getLinearCoefficient", "D", 0xa, NULL, NULL },
    { "getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable:withGeogebraCommonKernelArithmeticExpressionValue:", "getLinearCoefficientDiv", "D", 0xa, NULL, NULL },
    { "wrapWithDouble:", "wrap", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x2, NULL, NULL },
    { "isConditional", NULL, "Z", 0x1, NULL, NULL },
    { "isConditionalDeep", NULL, "Z", 0x1, NULL, NULL },
    { "ifElseWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "ifElse", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "evaluateDouble", NULL, "D", 0x1, NULL, NULL },
    { "replaceCasCommands", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "hasBrackets", NULL, "Z", 0x1, NULL, NULL },
    { "setBracketsWithBoolean:", "setBrackets", "V", 0x1, NULL, NULL },
    { "applyWithGeogebraCommonPluginOperationEnum:", "apply", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "applyWithGeogebraCommonPluginOperationEnum:withGeogebraCommonKernelArithmeticExpressionValue:", "apply", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "containsFreeFunctionVariable", NULL, "Z", 0x1, NULL, NULL },
    { "checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue:", "checkForFreeVars", "Z", 0x2, NULL, NULL },
    { "evaluatesToNumberWithBoolean:", "evaluatesToNumber", "Z", 0x1, NULL, NULL },
    { "getUnconditionalVars", NULL, "Ljava.util.HashSet;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "loc_", NULL, 0x2, "Lgeogebra.common.main.Localization;", NULL, NULL,  },
    { "kernel_", NULL, 0x2, "Lgeogebra.common.kernel.Kernel;", NULL, NULL,  },
    { "left_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", NULL, NULL,  },
    { "right_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", NULL, NULL,  },
    { "operation_", NULL, 0x2, "Lgeogebra.common.plugin.Operation;", NULL, NULL,  },
    { "forceVector_", NULL, 0x2, "Z", NULL, NULL,  },
    { "forcePoint_", NULL, 0x2, "Z", NULL, NULL,  },
    { "forceFunction_", NULL, 0x2, "Z", NULL, NULL,  },
    { "holdsLaTeXtext_", NULL, 0x1, "Z", NULL, NULL,  },
    { "leaf_", NULL, 0x1, "Z", NULL, NULL,  },
    { "brackets_", NULL, 0x2, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelArithmeticExpressionNode = { 2, "ExpressionNode", "geogebra.common.kernel.arithmetic", NULL, 0x1, 162, methods, 11, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelArithmeticExpressionNode;
}

@end

void GeogebraCommonKernelArithmeticExpressionNode_init(GeogebraCommonKernelArithmeticExpressionNode *self) {
  GeogebraCommonKernelArithmeticValidExpression_init(self);
  GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_NO_OPERATION());
  self->forceVector_ = NO;
  self->forcePoint_ = NO;
  self->forceFunction_ = NO;
  self->holdsLaTeXtext_ = NO;
  self->leaf_ = NO;
}

GeogebraCommonKernelArithmeticExpressionNode *new_GeogebraCommonKernelArithmeticExpressionNode_init() {
  GeogebraCommonKernelArithmeticExpressionNode *self = [GeogebraCommonKernelArithmeticExpressionNode alloc];
  GeogebraCommonKernelArithmeticExpressionNode_init(self);
  return self;
}

void GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> left, GeogebraCommonPluginOperationEnum *operation, id<GeogebraCommonKernelArithmeticExpressionValue> right) {
  GeogebraCommonKernelArithmeticValidExpression_init(self);
  GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_NO_OPERATION());
  self->forceVector_ = NO;
  self->forcePoint_ = NO;
  self->forceFunction_ = NO;
  self->holdsLaTeXtext_ = NO;
  self->leaf_ = NO;
  GeogebraCommonKernelArithmeticExpressionNode_set_kernel_(self, kernel);
  GeogebraCommonKernelArithmeticExpressionNode_set_loc_(self, [((GeogebraCommonKernelKernel *) nil_chk(kernel)) getLocalization]);
  GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, operation);
  GeogebraCommonKernelArithmeticExpressionNode_setLeftWithGeogebraCommonKernelArithmeticExpressionValue_(self, left);
  if (right != nil) {
    GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(self, right);
  }
  else {
    GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(self, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel, JavaLangDouble_NaN) autorelease]);
  }
}

GeogebraCommonKernelArithmeticExpressionNode *new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> left, GeogebraCommonPluginOperationEnum *operation, id<GeogebraCommonKernelArithmeticExpressionValue> right) {
  GeogebraCommonKernelArithmeticExpressionNode *self = [GeogebraCommonKernelArithmeticExpressionNode alloc];
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self, kernel, left, operation, right);
  return self;
}

void GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> leaf) {
  GeogebraCommonKernelArithmeticValidExpression_init(self);
  GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_NO_OPERATION());
  self->forceVector_ = NO;
  self->forcePoint_ = NO;
  self->forceFunction_ = NO;
  self->holdsLaTeXtext_ = NO;
  self->leaf_ = NO;
  GeogebraCommonKernelArithmeticExpressionNode_set_kernel_(self, kernel);
  GeogebraCommonKernelArithmeticExpressionNode_set_loc_(self, [((GeogebraCommonKernelKernel *) nil_chk(kernel)) getLocalization]);
  GeogebraCommonKernelArithmeticExpressionNode_setLeftWithGeogebraCommonKernelArithmeticExpressionValue_(self, leaf);
  self->leaf_ = YES;
}

GeogebraCommonKernelArithmeticExpressionNode *new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> leaf) {
  GeogebraCommonKernelArithmeticExpressionNode *self = [GeogebraCommonKernelArithmeticExpressionNode alloc];
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self, kernel, leaf);
  return self;
}

void GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelArithmeticExpressionNode_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelArithmeticExpressionNode *node) {
  GeogebraCommonKernelArithmeticValidExpression_init(self);
  GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, GeogebraCommonPluginOperationEnum_get_NO_OPERATION());
  self->forceVector_ = NO;
  self->forcePoint_ = NO;
  self->forceFunction_ = NO;
  self->holdsLaTeXtext_ = NO;
  self->leaf_ = NO;
  GeogebraCommonKernelArithmeticExpressionNode_set_kernel_(self, ((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(node))->kernel_);
  GeogebraCommonKernelArithmeticExpressionNode_set_loc_(self, node->loc_);
  self->leaf_ = node->leaf_;
  GeogebraCommonKernelArithmeticExpressionNode_set_operation_(self, node->operation_);
  GeogebraCommonKernelArithmeticExpressionNode_setLeftWithGeogebraCommonKernelArithmeticExpressionValue_(self, node->left_);
  GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(self, node->right_);
}

GeogebraCommonKernelArithmeticExpressionNode *new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelArithmeticExpressionNode_(GeogebraCommonKernelArithmeticExpressionNode *node) {
  GeogebraCommonKernelArithmeticExpressionNode *self = [GeogebraCommonKernelArithmeticExpressionNode alloc];
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelArithmeticExpressionNode_(self, node);
  return self;
}

void GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelKernel *kernel2, jdouble d) {
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self, kernel2, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel2, d) autorelease]);
}

GeogebraCommonKernelArithmeticExpressionNode *new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(GeogebraCommonKernelKernel *kernel2, jdouble d) {
  GeogebraCommonKernelArithmeticExpressionNode *self = [GeogebraCommonKernelArithmeticExpressionNode alloc];
  GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(self, kernel2, d);
  return self;
}

GeogebraCommonPluginOperationEnum *GeogebraCommonKernelArithmeticExpressionNode_getOperation(GeogebraCommonKernelArithmeticExpressionNode *self) {
  return self->operation_;
}

id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNode_getLeft(GeogebraCommonKernelArithmeticExpressionNode *self) {
  return self->left_;
}

void GeogebraCommonKernelArithmeticExpressionNode_setLeftWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> l) {
  GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, l);
  [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) setInTreeWithBoolean:YES];
}

id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNode_getRight(GeogebraCommonKernelArithmeticExpressionNode *self) {
  return self->right_;
}

void GeogebraCommonKernelArithmeticExpressionNode_setRightWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> r) {
  GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, r);
  if (self->right_ != nil) {
    [self->right_ setInTreeWithBoolean:YES];
  }
  self->leaf_ = (self->operation_ == GeogebraCommonPluginOperationEnum_get_NO_OPERATION());
}

id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNode_copy__WithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(id<GeogebraCommonKernelArithmeticExpressionValue> ev, GeogebraCommonKernelKernel *kernel) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if (ev == nil) {
    return nil;
  }
  id<GeogebraCommonKernelArithmeticExpressionValue> ret = nil;
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) isExpressionNode]) {
    GeogebraCommonKernelArithmeticExpressionNode *en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]);
    ret = [en getCopyWithGeogebraCommonKernelKernel:kernel];
  }
  else if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]]) {
    GeogebraCommonKernelArithmeticMyList *en = (GeogebraCommonKernelArithmeticMyList *) check_class_cast(ev, [GeogebraCommonKernelArithmeticMyList class]);
    ret = [en getCopyWithGeogebraCommonKernelKernel:kernel];
  }
  else if (([ev inspectWithGeogebraCommonKernelArithmeticInspecting:GeogebraCommonKernelArithmeticInspecting_CommandFinderEnum_get_INSTANCE()]) || [ev isConstant] || [ev isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]] || [ev isKindOfClass:[GeogebraCommonKernelArithmeticEquation class]] || [ev isKindOfClass:[GeogebraCommonKernelArithmeticMyVecNode class]] || [ev isKindOfClass:[GeogebraCommonKernelArithmetic3DMyVec3DNode class]]) {
    ret = [ev deepCopyWithGeogebraCommonKernelKernel:kernel];
  }
  else {
    ret = ev;
  }
  return ret;
}

void GeogebraCommonKernelArithmeticExpressionNode_simplifyLeafs(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode]) {
    GeogebraCommonKernelArithmeticExpressionNode *node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class]);
    if (node->leaf_) {
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, node->left_);
      GeogebraCommonKernelArithmeticExpressionNode_simplifyLeafs(self);
    }
  }
  if (self->right_ != nil) {
    if ([self->right_ isExpressionNode]) {
      GeogebraCommonKernelArithmeticExpressionNode *node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class]);
      if (node->leaf_) {
        GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, node->left_);
        GeogebraCommonKernelArithmeticExpressionNode_simplifyLeafs(self);
      }
    }
  }
}

void GeogebraCommonKernelArithmeticExpressionNode_simplifyAndEvalCommands(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if ([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) isResolveUnkownVarsAsDummyGeos]) {
    return;
  }
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode]) {
    GeogebraCommonKernelArithmeticExpressionNode_simplifyAndEvalCommands(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])));
  }
  else if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticCommand class]]) {
    GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, [((GeogebraCommonKernelArithmeticCommand *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticCommand class])) evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
  }
  if (self->right_ != nil) {
    if ([self->right_ isExpressionNode]) {
      GeogebraCommonKernelArithmeticExpressionNode_simplifyAndEvalCommands(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class])));
    }
    else if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticCommand class]]) {
      GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, [((GeogebraCommonKernelArithmeticCommand *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticCommand class])) evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
    }
  }
}

void GeogebraCommonKernelArithmeticExpressionNode_simplifyConstantIntegers(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode]) {
    GeogebraCommonKernelArithmeticExpressionNode *node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class]);
    if ([self->left_ isConstant]) {
      id<GeogebraCommonKernelArithmeticExpressionValue> eval = [node evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
      if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:eval]) {
        if (GeogebraCommonKernelKernel_isIntegerWithDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(eval, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble])) {
          GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, eval);
        }
      }
      else {
        GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, eval);
      }
    }
    else {
      GeogebraCommonKernelArithmeticExpressionNode_simplifyConstantIntegers(node);
    }
  }
  if ((self->right_ != nil) && [self->right_ isExpressionNode]) {
    GeogebraCommonKernelArithmeticExpressionNode *node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class]);
    if ([self->right_ isConstant]) {
      id<GeogebraCommonKernelArithmeticExpressionValue> eval = [node evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
      if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:eval]) {
        if (GeogebraCommonKernelKernel_isIntegerWithDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(eval, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble])) {
          GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, eval);
        }
      }
      else {
        GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, eval);
      }
    }
    else {
      GeogebraCommonKernelArithmeticExpressionNode_simplifyConstantIntegers(node);
    }
  }
}

void GeogebraCommonKernelArithmeticExpressionNode_doResolveVariables(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isVariable]) {
    GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, [((GeogebraCommonKernelArithmeticVariable *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticVariable class])) resolveAsExpressionValue]);
  }
  else {
    [self->left_ resolveVariables];
  }
  if (self->right_ != nil) {
    if ([self->right_ isVariable]) {
      GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, [((GeogebraCommonKernelArithmeticVariable *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticVariable class])) resolveAsExpressionValue]);
    }
    else {
      [self->right_ resolveVariables];
    }
  }
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_includesDivisionByWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> val) {
  if (self->operation_ == GeogebraCommonPluginOperationEnum_get_DIVIDE()) {
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->right_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:val]) {
      return YES;
    }
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode] && GeogebraCommonKernelArithmeticExpressionNode_includesDivisionByWithGeogebraCommonKernelArithmeticExpressionValue_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])), val)) {
      return YES;
    }
  }
  else {
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode] && GeogebraCommonKernelArithmeticExpressionNode_includesDivisionByWithGeogebraCommonKernelArithmeticExpressionValue_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])), val)) {
      return YES;
    }
    if ((self->right_ != nil) && [self->right_ isExpressionNode] && GeogebraCommonKernelArithmeticExpressionNode_includesDivisionByWithGeogebraCommonKernelArithmeticExpressionValue_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class])), val)) {
      return YES;
    }
  }
  return NO;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_includesNonContinuousIntegral(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if (GeogebraCommonPluginOperationEnum_integralIsNonContinuousWithGeogebraCommonPluginOperationEnum_(self->operation_)) {
    return YES;
  }
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode] && GeogebraCommonKernelArithmeticExpressionNode_includesNonContinuousIntegral(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])))) {
    return YES;
  }
  if ((self->right_ != nil) && [self->right_ isExpressionNode] && GeogebraCommonKernelArithmeticExpressionNode_includesNonContinuousIntegral(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class])))) {
    return YES;
  }
  return NO;
}

jint GeogebraCommonKernelArithmeticExpressionNode_replaceVariablesWithNSString_withGeogebraCommonKernelArithmeticFunctionVariable_(GeogebraCommonKernelArithmeticExpressionNode *self, NSString *varName, GeogebraCommonKernelArithmeticFunctionVariable *fVar) {
  jint replacements = 0;
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode]) {
    replacements += GeogebraCommonKernelArithmeticExpressionNode_replaceVariablesWithNSString_withGeogebraCommonKernelArithmeticFunctionVariable_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])), varName, fVar);
  }
  else if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]]) {
    replacements += [((GeogebraCommonKernelArithmeticMyList *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticMyList class])) replaceVariablesWithNSString:varName withGeogebraCommonKernelArithmeticFunctionVariable:fVar];
  }
  else if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticVariable class]]) {
    if ([((NSString *) nil_chk(varName)) isEqual:[((GeogebraCommonKernelArithmeticVariable *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticVariable class])) getNameWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, fVar);
      replacements++;
    }
  }
  else if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticCommand class]]) {
    replacements += [((GeogebraCommonKernelArithmeticCommand *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticCommand class])) replaceVariablesWithNSString:varName withGeogebraCommonKernelArithmeticFunctionVariable:fVar];
  }
  if ([self->left_ isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]]) {
    if ([((NSString *) nil_chk(varName)) isEqual:[((GeogebraCommonKernelGeosGeoDummyVariable *) nil_chk(((GeogebraCommonKernelGeosGeoDummyVariable *) check_class_cast(self->left_, [GeogebraCommonKernelGeosGeoDummyVariable class])))) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, fVar);
      replacements++;
    }
  }
  else if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
    if ([((NSString *) nil_chk(varName)) isEqual:[((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk(((GeogebraCommonKernelArithmeticFunctionVariable *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticFunctionVariable class])))) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
      GeogebraCommonKernelArithmeticExpressionNode_set_left_(self, fVar);
      replacements++;
    }
  }
  if (self->right_ != nil) {
    if ([self->right_ isExpressionNode]) {
      replacements += GeogebraCommonKernelArithmeticExpressionNode_replaceVariablesWithNSString_withGeogebraCommonKernelArithmeticFunctionVariable_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class])), varName, fVar);
    }
    else if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]]) {
      replacements += [((GeogebraCommonKernelArithmeticMyList *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticMyList class])) replaceVariablesWithNSString:varName withGeogebraCommonKernelArithmeticFunctionVariable:fVar];
    }
    else if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticVariable class]]) {
      if ([((NSString *) nil_chk(varName)) isEqual:[((GeogebraCommonKernelArithmeticVariable *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticVariable class])) getNameWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
        GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, fVar);
        replacements++;
      }
    }
    else if ([self->right_ isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]]) {
      if ([((NSString *) nil_chk(varName)) isEqual:[((GeogebraCommonKernelGeosGeoDummyVariable *) check_class_cast(self->right_, [GeogebraCommonKernelGeosGeoDummyVariable class])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
        GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, fVar);
        replacements++;
      }
    }
    else if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
      if ([((NSString *) nil_chk(varName)) isEqual:[((GeogebraCommonKernelArithmeticFunctionVariable *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticFunctionVariable class])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
        GeogebraCommonKernelArithmeticExpressionNode_set_right_(self, fVar);
        replacements++;
      }
    }
  }
  return replacements;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_containsCasEvaluableFunction(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if (([GeogebraCommonKernelGeosCasEvaluableFunction_class_() isInstance:self->left_]) || ([GeogebraCommonKernelGeosCasEvaluableFunction_class_() isInstance:self->right_])) {
    return YES;
  }
  if (([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) && GeogebraCommonKernelArithmeticExpressionNode_containsCasEvaluableFunction(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class]))))) {
    return YES;
  }
  if (([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) && GeogebraCommonKernelArithmeticExpressionNode_containsCasEvaluableFunction(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class]))))) {
    return YES;
  }
  return NO;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_containsGeoFunctionNVar(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if (([self->left_ isKindOfClass:[GeogebraCommonKernelGeosGeoFunctionNVar class]]) || ([self->right_ isKindOfClass:[GeogebraCommonKernelGeosGeoFunctionNVar class]])) {
    return YES;
  }
  if (([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) && GeogebraCommonKernelArithmeticExpressionNode_containsGeoFunctionNVar(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class]))))) {
    return YES;
  }
  if (([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) && GeogebraCommonKernelArithmeticExpressionNode_containsGeoFunctionNVar(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class]))))) {
    return YES;
  }
  return NO;
}

GeogebraCommonKernelArithmeticPolynomial *GeogebraCommonKernelArithmeticExpressionNode_makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelArithmeticEquation *equ) {
  GeogebraCommonKernelArithmeticPolynomial *lt;
  GeogebraCommonKernelArithmeticPolynomial *rt = nil;
  if (self->operation_ == GeogebraCommonPluginOperationEnum_get_FUNCTION_NVAR()) {
    if (([GeogebraCommonKernelArithmeticFunctionalNVar_class_() isInstance:self->left_]) && ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]])) {
      GeogebraCommonKernelArithmeticMyList *list = ((GeogebraCommonKernelArithmeticMyList *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticMyList class]));
      GeogebraCommonKernelArithmeticFunctionNVar *func = [((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(((id<GeogebraCommonKernelArithmeticFunctionalNVar>) check_protocol_cast(self->left_, @protocol(GeogebraCommonKernelArithmeticFunctionalNVar))))) getFunction];
      GeogebraCommonKernelArithmeticExpressionNode *expr = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(func)) getExpression])) getCopyWithGeogebraCommonKernelKernel:self->kernel_];
      if (((IOSObjectArray *) nil_chk([func getFunctionVariables]))->size_ == [((GeogebraCommonKernelArithmeticMyList *) nil_chk(list)) size]) {
        for (jint i = 0; i < [list size]; i++) {
          id<GeogebraCommonKernelArithmeticExpressionValue> ev = [list getListElementWithInt:i];
          if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
            GeogebraCommonKernelArithmeticExpressionNode *en = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class])))) getCopyWithGeogebraCommonKernelKernel:self->kernel_];
            if (![((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ)) isFunctionDependent]) {
              [equ setFunctionDependentWithBoolean:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en)) containsFunctionVariable]];
            }
            ev = en;
          }
          else if ([[list getListElementWithInt:i] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
            [((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ)) setFunctionDependentWithBoolean:YES];
          }
          expr = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(expr)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:IOSObjectArray_Get(nil_chk([func getFunctionVariables]), i) withGeogebraCommonKernelArithmeticExpressionValue:ev])) wrap];
        }
      }
      else {
        @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(self->loc_, [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalArgumentNumber" } count:1 type:NSString_class_()]) autorelease];
      }
      if ([((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ)) isFunctionDependent]) {
        return GeogebraCommonKernelArithmeticExpressionNode_makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation_(nil_chk(expr), equ);
      }
    }
  }
  else if (self->operation_ == GeogebraCommonPluginOperationEnum_get_FUNCTION()) {
    if ([self->left_ isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) {
      GeogebraCommonKernelArithmeticFunction *func = [((id<GeogebraCommonKernelArithmeticFunctional>) nil_chk(((id<GeogebraCommonKernelArithmeticFunctional>) check_protocol_cast(self->left_, @protocol(GeogebraCommonKernelArithmeticFunctional))))) getFunction];
      return GeogebraCommonKernelArithmeticExpressionNode_makePolyTreeFromFunctionWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticEquation_(self, func, equ);
    }
    else if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]] && GeogebraCommonKernelArithmeticExpressionNode_getOperation(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])))) == GeogebraCommonPluginOperationEnum_get_DERIVATIVE()) {
      GeogebraCommonKernelArithmeticFunction *base = [((id<GeogebraCommonKernelArithmeticFunctional>) nil_chk(((id<GeogebraCommonKernelArithmeticFunctional>) check_protocol_cast(GeogebraCommonKernelArithmeticExpressionNode_getLeft(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])))), @protocol(GeogebraCommonKernelArithmeticFunctional))))) getFunction];
      jint deg = J2ObjCFpToInt(JavaLangMath_ceilWithDouble_([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getRight(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])))))) evaluateDouble]));
      for (jint i = 0; i < deg; i++) {
        base = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk([((id<GeogebraCommonKernelArithmeticFunctional>) nil_chk(((id<GeogebraCommonKernelArithmeticFunctional>) check_protocol_cast(GeogebraCommonKernelArithmeticExpressionNode_getLeft(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])))), @protocol(GeogebraCommonKernelArithmeticFunctional))))) getFunction])) derivativeWithGeogebraCommonKernelArithmeticFunctionVariable:[((GeogebraCommonKernelArithmeticFunction *) nil_chk(base)) getFunctionVariable]])) wrap], [base getFunctionVariable]) autorelease];
      }
      return GeogebraCommonKernelArithmeticExpressionNode_makePolyTreeFromFunctionWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticEquation_(self, base, equ);
    }
  }
  if (!GeogebraCommonKernelArithmeticExpressionNode_polynomialOperationWithGeogebraCommonPluginOperationEnum_(self->operation_)) {
    if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticValidExpression class]] && [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(((GeogebraCommonKernelArithmeticValidExpression *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticValidExpression class])))) containsFunctionVariable]) {
      [((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ)) setIsPolynomialWithBoolean:NO];
    }
    if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticValidExpression class]] && [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(((GeogebraCommonKernelArithmeticValidExpression *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticValidExpression class])))) containsFunctionVariable]) {
      [((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ)) setIsPolynomialWithBoolean:NO];
    }
    return [new_GeogebraCommonKernelArithmeticPolynomial_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticTerm_(self->kernel_, [new_GeogebraCommonKernelArithmeticTerm_initWithGeogebraCommonKernelArithmeticExpressionValue_withNSString_([new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, self->left_, self->operation_, self->right_) autorelease], @"") autorelease]) autorelease];
  }
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode]) {
    lt = GeogebraCommonKernelArithmeticExpressionNode_makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])), equ);
  }
  else if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
    lt = [new_GeogebraCommonKernelArithmeticPolynomial_initWithGeogebraCommonKernelKernel_withNSString_(self->kernel_, [((GeogebraCommonKernelArithmeticFunctionVariable *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticFunctionVariable class])) getSetVarString]) autorelease];
  }
  else {
    lt = [new_GeogebraCommonKernelArithmeticPolynomial_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticTerm_(self->kernel_, [new_GeogebraCommonKernelArithmeticTerm_initWithGeogebraCommonKernelArithmeticExpressionValue_withNSString_(self->left_, @"") autorelease]) autorelease];
  }
  if (self->right_ != nil) {
    if ([self->right_ isExpressionNode]) {
      rt = GeogebraCommonKernelArithmeticExpressionNode_makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class])), equ);
    }
    else if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
      rt = [new_GeogebraCommonKernelArithmeticPolynomial_initWithGeogebraCommonKernelKernel_withNSString_(self->kernel_, [((GeogebraCommonKernelArithmeticFunctionVariable *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticFunctionVariable class])) getSetVarString]) autorelease];
    }
    else {
      if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]]) {
        GeogebraCommonKernelArithmeticMyList *list = (GeogebraCommonKernelArithmeticMyList *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticMyList class]);
        for (jint i = 0; i < [list size]; i++) {
          id<GeogebraCommonKernelArithmeticExpressionValue> ev = [list getListElementWithInt:i];
          if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
            GeogebraCommonKernelArithmeticExpressionNode_makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation_(nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]))), equ);
          }
        }
      }
      return [((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(lt)) applyWithGeogebraCommonPluginOperationEnum:self->operation_ withGeogebraCommonKernelArithmeticExpressionValue:self->right_ withGeogebraCommonKernelArithmeticEquation:equ];
    }
  }
  return [((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(lt)) applyWithGeogebraCommonPluginOperationEnum:self->operation_ withGeogebraCommonKernelArithmeticPolynomial:rt withGeogebraCommonKernelArithmeticEquation:equ];
}

GeogebraCommonKernelArithmeticPolynomial *GeogebraCommonKernelArithmeticExpressionNode_makePolyTreeFromFunctionWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticEquation_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelArithmeticFunction *func, GeogebraCommonKernelArithmeticEquation *equ) {
  if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
    if (![((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ)) isFunctionDependent]) {
      [equ setFunctionDependentWithBoolean:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class])))) containsFunctionVariable]];
    }
  }
  else if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
    [((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ)) setFunctionDependentWithBoolean:YES];
  }
  if ([((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ)) isFunctionDependent]) {
    GeogebraCommonKernelArithmeticExpressionNode *expr = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk(func)) getExpression])) getCopyWithGeogebraCommonKernelKernel:self->kernel_];
    expr = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(expr)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:[func getFunctionVariable] withGeogebraCommonKernelArithmeticExpressionValue:self->right_])) wrap];
    return GeogebraCommonKernelArithmeticExpressionNode_makePolynomialTreeWithGeogebraCommonKernelArithmeticEquation_(nil_chk(expr), equ);
  }
  return [new_GeogebraCommonKernelArithmeticPolynomial_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticTerm_(self->kernel_, [new_GeogebraCommonKernelArithmeticTerm_initWithGeogebraCommonKernelArithmeticExpressionValue_withNSString_([new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, self->left_, self->operation_, self->right_) autorelease], @"") autorelease]) autorelease];
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_polynomialOperationWithGeogebraCommonPluginOperationEnum_(GeogebraCommonPluginOperationEnum *operation2) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  switch ([operation2 ordinal]) {
    case GeogebraCommonPluginOperation_NO_OPERATION:
    case GeogebraCommonPluginOperation_PLUS:
    case GeogebraCommonPluginOperation_MINUS:
    case GeogebraCommonPluginOperation_MULTIPLY:
    case GeogebraCommonPluginOperation_MULTIPLY_OR_FUNCTION:
    case GeogebraCommonPluginOperation_DIVIDE:
    case GeogebraCommonPluginOperation_POWER:
    case GeogebraCommonPluginOperation_FUNCTION:
    case GeogebraCommonPluginOperation_FUNCTION_NVAR:
    return YES;
  }
  return NO;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_isConstant(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isConstant];
  }
  return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isConstant] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->right_)) isConstant];
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_hasOperations(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if (self->leaf_) {
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isExpressionNode]) {
      GeogebraCommonKernelArithmeticExpressionNode_hasOperations(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])));
    }
    else {
      return NO;
    }
  }
  return (self->right_ != nil);
}

JavaUtilHashSet *GeogebraCommonKernelArithmeticExpressionNode_getVariables(GeogebraCommonKernelArithmeticExpressionNode *self) {
  if (self->leaf_) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) getVariables];
  }
  JavaUtilHashSet *leftVars = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) getVariables];
  JavaUtilHashSet *rightVars = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->right_)) getVariables];
  if (leftVars == nil) {
    return rightVars;
  }
  else if (rightVars == nil) {
    return leftVars;
  }
  else {
    [leftVars addAllWithJavaUtilCollection:rightVars];
    return leftVars;
  }
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_isLeaf(GeogebraCommonKernelArithmeticExpressionNode *self) {
  return self->leaf_;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_expandForOGPWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> ev) {
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk(self->operation_)) isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()] && [ev isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) return NO;
  return (([self->operation_ isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()] || [self->operation_ isEqual:GeogebraCommonPluginOperationEnum_get_DIVIDE()] || [self->operation_ isEqual:GeogebraCommonPluginOperationEnum_get_MULTIPLY()] || [self->operation_ isEqual:GeogebraCommonPluginOperationEnum_get_MINUS()] || [self->operation_ isEqual:GeogebraCommonPluginOperationEnum_get_PLUS()] || [self->operation_ isEqual:GeogebraCommonPluginOperationEnum_get_POWER()]) && ([ev isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]] || [ev isKindOfClass:[GeogebraCommonKernelGeosGeoPolygon class]] || [ev isKindOfClass:[GeogebraCommonKernelGeosGeoNumeric class]]));
}

NSString *GeogebraCommonKernelArithmeticExpressionNode_getTreeClassWithNSString_(GeogebraCommonKernelArithmeticExpressionNode *self, NSString *prefix) {
  NSString *ret = @"";
  ret = JreStrcat("$$", ret, @"-\n");
  if (self->left_ != nil) {
    ret = JreStrcat("$$", ret, JreStrcat("$$", prefix, @"  \\l:"));
    if ([self->left_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
      ret = JreStrcat("$$", ret, GeogebraCommonKernelArithmeticExpressionNode_getTreeClassWithNSString_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->left_, [GeogebraCommonKernelArithmeticExpressionNode class])), JreStrcat("$$", prefix, @"   ")));
    }
    else {
      ret = JreStrcat("$@", ret, [self->left_ getClass]);
    }
    ret = JreStrcat("$C", ret, 0x000a);
  }
  if (self->right_ != nil) {
    ret = JreStrcat("$$", ret, JreStrcat("$$", prefix, @"  \\r:"));
    if ([self->right_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
      ret = JreStrcat("$$", ret, GeogebraCommonKernelArithmeticExpressionNode_getTreeClassWithNSString_(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->right_, [GeogebraCommonKernelArithmeticExpressionNode class])), JreStrcat("$$", prefix, @"   ")));
    }
    else {
      ret = JreStrcat("$@", ret, [self->right_ getClass]);
    }
    ret = JreStrcat("$C", ret, 0x000a);
  }
  return ret;
}

NSString *GeogebraCommonKernelArithmeticExpressionNode_toStringWithGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelStringTemplate *tpl) {
  if (self->leaf_) {
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isGeoElement]) {
      return [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(self->left_, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl];
    }
    return [self->left_ toStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  NSString *leftStr = nil, *rightStr = nil;
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) isGeoElement]) {
    if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getStringType])) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_OGP()] && GeogebraCommonKernelArithmeticExpressionNode_expandForOGPWithGeogebraCommonKernelArithmeticExpressionValue_(self, self->left_)) {
      leftStr = [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(self->left_, [GeogebraCommonKernelGeosGeoElement class])) getCommandDescriptionWithGeogebraCommonKernelStringTemplate:tpl];
    }
    else leftStr = [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(self->left_, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl];
  }
  else {
    leftStr = [self->left_ toStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  if (self->right_ != nil) {
    if ([self->right_ isGeoElement]) {
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getStringType])) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_OGP()] && GeogebraCommonKernelArithmeticExpressionNode_expandForOGPWithGeogebraCommonKernelArithmeticExpressionValue_(self, self->right_)) {
        rightStr = [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(self->right_, [GeogebraCommonKernelGeosGeoElement class])) getCommandDescriptionWithGeogebraCommonKernelStringTemplate:tpl];
      }
      else rightStr = [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(self->right_, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl];
    }
    else {
      rightStr = [self->right_ toStringWithGeogebraCommonKernelStringTemplate:tpl];
    }
  }
  return GeogebraCommonKernelArithmeticExpressionNode_operationToStringWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withNSString_withNSString_withBoolean_withGeogebraCommonKernelStringTemplate_withGeogebraCommonKernelKernel_(self->left_, self->right_, self->operation_, leftStr, rightStr, NO, tpl, self->kernel_);
}

NSString *GeogebraCommonKernelArithmeticExpressionNode_toValueStringWithGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelArithmeticExpressionNode *self, GeogebraCommonKernelStringTemplate *tpl) {
  if (GeogebraCommonKernelArithmeticExpressionNode_isLeaf(self)) {
    if (self->left_ != nil) {
      return [self->left_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
    }
  }
  NSString *leftStr = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(self->left_)) toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
  NSString *rightStr = nil;
  if (self->right_ != nil) {
    rightStr = [self->right_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  return GeogebraCommonKernelArithmeticExpressionNode_operationToStringWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withNSString_withNSString_withBoolean_withGeogebraCommonKernelStringTemplate_withGeogebraCommonKernelKernel_(self->left_, self->right_, self->operation_, leftStr, rightStr, YES, tpl, self->kernel_);
}

NSString *GeogebraCommonKernelArithmeticExpressionNode_checkMathmlWithNSString_withGeogebraCommonKernelStringTemplate_(NSString *str, GeogebraCommonKernelStringTemplate *tpl) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()] && [((NSString *) nil_chk(str)) charAtWithInt:0] != '<') {
    return JreStrcat("$$$", @"<ci>", str, @"</ci>");
  }
  return str;
}

NSString *GeogebraCommonKernelArithmeticExpressionNode_operationToStringWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withNSString_withNSString_withBoolean_withGeogebraCommonKernelStringTemplate_withGeogebraCommonKernelKernel_(id<GeogebraCommonKernelArithmeticExpressionValue> left, id<GeogebraCommonKernelArithmeticExpressionValue> right, GeogebraCommonPluginOperationEnum *operation, NSString *leftStr, NSString *rightStr, jboolean valueForm, GeogebraCommonKernelStringTemplate *tpl, GeogebraCommonKernelKernel *kernel) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  id<GeogebraCommonKernelArithmeticExpressionValue> leftEval;
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *stringType = [((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getStringType];
  GeogebraCommonMainLocalization *loc = [((GeogebraCommonKernelKernel *) nil_chk(kernel)) getLocalization];
  {
    GeogebraCommonKernelArithmeticMyList *cond;
    GeogebraCommonKernelArithmeticMyList *fn;
    switch ([operation ordinal]) {
      case GeogebraCommonPluginOperation_NO_OPERATION:
      return leftStr;
      case GeogebraCommonPluginOperation_NOT:
      return [tpl notStringWithGeogebraCommonKernelArithmeticExpressionValue:left withNSString:leftStr];
      case GeogebraCommonPluginOperation_OR:
      return [tpl orStringWithGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withNSString:leftStr withNSString:rightStr];
      case GeogebraCommonPluginOperation_AND_INTERVAL:
      return [tpl andIntervalStringWithGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withNSString:leftStr withNSString:rightStr withBoolean:valueForm];
      case GeogebraCommonPluginOperation_AND:
      return [tpl andStringWithGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withNSString:leftStr withNSString:rightStr];
      case GeogebraCommonPluginOperation_IMPLICATION:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<implies/>", leftStr, rightStr);
      }
      else {
        [tpl appendWithJavaLangStringBuilder:sb withNSString:leftStr withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonPluginOperationEnum:operation];
        [sb appendWithChar:' '];
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          if ([tpl isInsertLineBreaks]) {
            [sb appendWithNSString:@"\\-"];
          }
          [sb appendWithNSString:@"\\to"];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@"toward"];
          break;
          default:
          [sb appendWithNSString:GeogebraCommonKernelArithmeticExpressionNodeConstants_get_strIMPLIES_()];
        }
        [sb appendWithChar:' '];
        [tpl appendWithJavaLangStringBuilder:sb withNSString:rightStr withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation];
      }
      break;
      case GeogebraCommonPluginOperation_EQUAL_BOOLEAN:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<eq/>", leftStr, rightStr);
      }
      else if ([stringType isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_OGP()]) {
        [sb appendWithNSString:JreStrcat("$$C$C", @"AreEqual[", leftStr, ',', rightStr, ']')];
      }
      else {
        if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk([tpl getStringType])) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
          [sb appendWithNSString:@"when(ggb\\_is\\_zero(simplify("];
          [tpl appendWithJavaLangStringBuilder:sb withNSString:leftStr withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonPluginOperationEnum:operation];
          [sb appendWithNSString:@"-("];
          [tpl appendWithJavaLangStringBuilder:sb withNSString:rightStr withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation];
          [sb appendWithNSString:@"))),true,false)"];
        }
        else {
          [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl equalSign]];
        }
      }
      break;
      case GeogebraCommonPluginOperation_NOT_EQUAL:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<neq/>", leftStr, rightStr);
      }
      else {
        [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl notEqualSign]];
      }
      break;
      case GeogebraCommonPluginOperation_IS_ELEMENT_OF:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<in/>", leftStr, rightStr);
      }
      else if ([stringType isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
        [sb appendWithNSString:@"when(count\\_eq("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@")==0,false,true)"];
      }
      else {
        [tpl appendWithJavaLangStringBuilder:sb withNSString:leftStr withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonPluginOperationEnum:operation];
        [sb appendWithChar:' '];
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          if ([tpl isInsertLineBreaks]) {
            [sb appendWithNSString:@"\\-"];
          }
          [sb appendWithNSString:@"\\in"];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@" in "];
          break;
          default:
          [sb appendWithNSString:GeogebraCommonKernelArithmeticExpressionNodeConstants_get_strIS_ELEMENT_OF_()];
        }
        [sb appendWithChar:' '];
        [tpl appendWithJavaLangStringBuilder:sb withNSString:rightStr withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation];
      }
      break;
      case GeogebraCommonPluginOperation_IS_SUBSET_OF:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<subset/>", leftStr, rightStr);
      }
      else if ([stringType isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
        [sb appendWithNSString:@"when(("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@") union ("];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@")==("];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@") union {},true,false"];
      }
      else {
        [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl subsetSign]];
      }
      break;
      case GeogebraCommonPluginOperation_IS_SUBSET_OF_STRICT:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<prsubset/>", leftStr, rightStr);
      }
      else if ([stringType isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
        [sb appendWithNSString:@"when(("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@") union ("];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@")==("];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@") union {} && dim("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"union {})<dim("];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"union {}),true,false"];
      }
      else {
        [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl strictSubsetSign]];
      }
      break;
      case GeogebraCommonPluginOperation_SET_DIFFERENCE:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<setdiff/>", leftStr, rightStr);
      }
      else if ([stringType isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
        [sb appendWithChar:'('];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@" minus "];
        [sb appendWithNSString:rightStr];
        [sb appendWithChar:')'];
      }
      else {
        [tpl appendWithJavaLangStringBuilder:sb withNSString:leftStr withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonPluginOperationEnum:operation];
        [sb appendWithChar:' '];
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          if ([tpl isInsertLineBreaks]) {
            [sb appendWithNSString:@"\\-"];
          }
          [sb appendWithNSString:@"\\setminus"];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@" setminus "];
          break;
          default:
          [sb appendWithNSString:GeogebraCommonKernelArithmeticExpressionNodeConstants_get_strSET_DIFFERENCE_()];
        }
        [sb appendWithChar:' '];
        if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right)) isExpressionNode] && GeogebraCommonKernelArithmeticExpressionNode_getOperation(nil_chk([right wrap])) == GeogebraCommonPluginOperationEnum_get_SET_DIFFERENCE()) {
          [sb appendWithNSString:[tpl leftBracket]];
          [sb appendWithNSString:rightStr];
          [sb appendWithNSString:[tpl rightBracket]];
        }
        else {
          [tpl appendWithJavaLangStringBuilder:sb withNSString:rightStr withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation];
        }
      }
      break;
      case GeogebraCommonPluginOperation_LESS:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<lt/>", leftStr, rightStr);
      }
      else {
        [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl lessSign]];
      }
      break;
      case GeogebraCommonPluginOperation_GREATER:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<gt/>", leftStr, rightStr);
      }
      else {
        [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl greaterSign]];
      }
      break;
      case GeogebraCommonPluginOperation_LESS_EQUAL:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<leq/>", leftStr, rightStr);
      }
      else {
        [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl leqSign]];
      }
      break;
      case GeogebraCommonPluginOperation_GREATER_EQUAL:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<qeq/>", leftStr, rightStr);
      }
      else {
        [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl geqSign]];
      }
      break;
      case GeogebraCommonPluginOperation_PARALLEL:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_OGP()]) {
        [sb appendWithNSString:JreStrcat("$$C$C", @"AreParallel[", leftStr, ',', rightStr, ']')];
        break;
      }
      [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl parallelSign]];
      break;
      case GeogebraCommonPluginOperation_PERPENDICULAR:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_OGP()]) {
        [sb appendWithNSString:JreStrcat("$$C$C", @"ArePerpendicular[", leftStr, ',', rightStr, ']')];
        break;
      }
      [tpl infixBinaryWithJavaLangStringBuilder:sb withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation withNSString:leftStr withNSString:rightStr withGeogebraCommonKernelStringTemplate:tpl withNSString:[tpl perpSign]];
      break;
      case GeogebraCommonPluginOperation_VECTORPRODUCT:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<vectorproduct/>", leftStr, rightStr);
      }
      else if ([stringType isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
        [sb appendWithNSString:@"[[[ggbcrossarg0:="];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"], [ggbcrossarg1:="];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"]],when(is3dpoint(ggbcrossarg0)||is3dpoint(ggbcrossarg1),point(cross(ggbcrossarg0,ggbcrossarg1)),cross(ggbcrossarg0,ggbcrossarg1))][1]"];
      }
      else {
        [tpl appendWithJavaLangStringBuilder:sb withNSString:leftStr withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonPluginOperationEnum:operation];
        [sb appendWithChar:' '];
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          if ([tpl isInsertLineBreaks]) {
            [sb appendWithNSString:@"\\-"];
          }
          [sb appendWithNSString:@"\\times"];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@" cdot "];
          break;
          default:
          [sb appendWithNSString:GeogebraCommonKernelArithmeticExpressionNodeConstants_get_strVECTORPRODUCT_()];
        }
        [sb appendWithChar:' '];
        [tpl appendWithJavaLangStringBuilder:sb withNSString:rightStr withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonPluginOperationEnum:operation];
      }
      break;
      case GeogebraCommonPluginOperation_PLUS:
      return [tpl plusStringWithGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withNSString:leftStr withNSString:rightStr withBoolean:valueForm];
      case GeogebraCommonPluginOperation_MINUS:
      return [tpl minusStringWithGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withNSString:leftStr withNSString:rightStr withBoolean:valueForm withGeogebraCommonMainLocalization:loc];
      case GeogebraCommonPluginOperation_MULTIPLY:
      return [tpl multiplyStringWithGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withNSString:leftStr withNSString:rightStr withBoolean:valueForm withGeogebraCommonMainLocalization:loc];
      case GeogebraCommonPluginOperation_DIVIDE:
      return [tpl divideStringWithGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withNSString:leftStr withNSString:rightStr withBoolean:valueForm];
      case GeogebraCommonPluginOperation_POWER:
      return [tpl powerStringWithGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withNSString:leftStr withNSString:rightStr withBoolean:valueForm];
      case GeogebraCommonPluginOperation_FACTORIAL:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<factorial/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"fact {"];
        if (([((NSString *) nil_chk(leftStr)) charAtWithInt:0] != '-') && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isLeaf]) {
          [sb appendWithNSString:leftStr];
        }
        else {
          [sb appendWithChar:'('];
          [sb appendWithNSString:leftStr];
          [sb appendWithChar:')'];
        }
        [sb appendWithNSString:@" }"];
        break;
        default:
        if ((([((NSString *) nil_chk(leftStr)) charAtWithInt:0] != '-') && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isLeaf]) || (GeogebraCommonKernelArithmeticExpressionNode_opIDWithGeogebraCommonKernelArithmeticExpressionValue_(left) > [((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonPluginOperationEnum_get_POWER())) ordinal])) {
          [sb appendWithNSString:leftStr];
        }
        else {
          [sb appendWithNSString:[tpl leftBracket]];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl rightBracket]];
        }
        [sb appendWithChar:'!'];
        break;
      }
      break;
      case GeogebraCommonPluginOperation_COS:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<cos/>", @"\\cos", @"COS(", @"cos", @"cos", tpl, loc, YES);
      break;
      case GeogebraCommonPluginOperation_SIN:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<sin/>", @"\\sin", @"SIN(", @"sin", @"sin", tpl, loc, YES);
      break;
      case GeogebraCommonPluginOperation_TAN:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<tan/>", @"\\tan", @"TAN(", @"tan", @"tan", tpl, loc, YES);
      break;
      case GeogebraCommonPluginOperation_CSC:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<csc/>", @"\\csc", @"CSC(", @"csc", @"csc", tpl, loc, YES);
      break;
      case GeogebraCommonPluginOperation_SEC:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<sec/>", @"\\sec", @"SEC(", @"sec", @"sec", tpl, loc, YES);
      break;
      case GeogebraCommonPluginOperation_COT:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<cot/>", @"\\cot", @"COT(", @"cot", @"cot", tpl, loc, YES);
      break;
      case GeogebraCommonPluginOperation_CSCH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<csch/>", @"\\csch", @"CSCH(", @"csch", @"func csch", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_SECH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<sech/>", @"\\sech", @"SECH(", @"sech", @"func sech", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_COTH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<coth/>", @"\\coth", @"COTH(", @"coth", @"coth", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_ARCCOS:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<arccos/>", @"\\arccos", @"ACOS(", @"acos", @"arccos", GeogebraCommonKernelArithmeticExpressionNode_degFixWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(@"acos", left, kernel), tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_ARCSIN:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<arcsin/>", @"\\arcsin", @"ASIN(", @"asin", @"arcsin", GeogebraCommonKernelArithmeticExpressionNode_degFixWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(@"asin", left, kernel), tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_ARCTAN:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<arctan/>", @"\\arctan", @"ATAN(", @"atan", @"arctan", GeogebraCommonKernelArithmeticExpressionNode_degFixWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(@"atan", left, kernel), tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_ARCTAN2:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<atan/>", leftStr, rightStr);
      }
      else {
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          [sb appendWithNSString:@"atan2 \\left( "];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@"func atan2 left( "];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PSTRICKS:
          [sb appendWithNSString:@"ATAN2("];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
          [sb appendWithNSString:GeogebraCommonKernelArithmeticExpressionNode_degFixWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(@"atan2", left, kernel)];
          [sb appendWithNSString:@"("];
          break;
          default:
          [sb appendWithNSString:@"atan2("];
        }
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:[tpl rightBracket]];
      }
      break;
      case GeogebraCommonPluginOperation_COSH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<cosh/>", @"\\cosh", @"COSH(", @"cosh", @"cosh", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_SINH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<sinh/>", @"\\sinh", @"SINH(", @"sinh", @"sinh", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_TANH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<tanh/>", @"\\tanh", @"TANH(", @"tanh", @"tanh", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_ACOSH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<arccosh/>", @"\\acosh", @"ACOSH(", @"acosh", @"arcosh", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_ASINH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<arcsinh/>", @"\\asinh", @"ASINH(", @"asinh", @"arsinh", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_ATANH:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<arctanh/>", @"\\atanh", @"ATANH(", @"atanh", @"artanh", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_REAL:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<real/>", @"\\real", @"", @"real", @"real", @"re", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_IMAGINARY:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<imaginary/>", @"\\imaginary", @"", @"imaginary", @"imaginary", @"im", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_FRACTIONAL_PART:
      GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, @"<todo/>", @"\\fractionalPart", @"", @"fractionalPart", @"fractionalPart", @"fractionalPart", tpl, loc, NO);
      break;
      case GeogebraCommonPluginOperation_ZETA:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\zeta\\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func zeta left ("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"Zeta("];
        break;
        default:
        [sb appendWithNSString:@"zeta("];
      }
      [sb appendWithNSString:leftStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_CI:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\Ci \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func Ci left ("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        GeogebraCommonKernelArithmeticExpressionNode_appendReduceFunctionWithJavaLangStringBuilder_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_(sb, left, @"Ci");
        break;
        default:
        [sb appendWithNSString:@"cosIntegral("];
      }
      [sb appendWithNSString:leftStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_SI:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\Si \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func Si left ("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        GeogebraCommonKernelArithmeticExpressionNode_appendReduceFunctionWithJavaLangStringBuilder_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_(sb, left, @"Si");
        break;
        default:
        [sb appendWithNSString:@"sinIntegral("];
      }
      [sb appendWithNSString:leftStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_EI:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\Ei \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func Ei left ("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        GeogebraCommonKernelArithmeticExpressionNode_appendReduceFunctionWithJavaLangStringBuilder_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_(sb, left, @"Ei");
        break;
        default:
        [sb appendWithNSString:@"expIntegral("];
      }
      [sb appendWithNSString:leftStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_ARBCONST:
      [sb appendWithNSString:@"arbconst("];
      [sb appendWithNSString:leftStr];
      [sb appendWithNSString:@")"];
      break;
      case GeogebraCommonPluginOperation_ARBINT:
      [sb appendWithNSString:@"arbint("];
      [sb appendWithNSString:leftStr];
      [sb appendWithNSString:@")"];
      break;
      case GeogebraCommonPluginOperation_ARBCOMPLEX:
      [sb appendWithNSString:@"arbcomplex("];
      [sb appendWithNSString:leftStr];
      [sb appendWithNSString:@")"];
      break;
      case GeogebraCommonPluginOperation_EXP:
      {
        jboolean addParentheses;
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
          GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<exp/>", leftStr, nil);
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@"func "];
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          addParentheses = ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isExpressionNode] && [((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getOperation(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left, [GeogebraCommonKernelArithmeticExpressionNode class]))))) isEqual:GeogebraCommonPluginOperationEnum_get_POWER()]);
          [sb appendWithNSString:@"\\mathit{e}^{"];
          if (addParentheses) {
            [sb appendWithNSString:[tpl leftBracket]];
          }
          [sb appendWithNSString:leftStr];
          if (addParentheses) {
            [sb appendWithNSString:[tpl rightBracket]];
          }
          [sb appendWithChar:'}'];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GEOGEBRA_XML:
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
          [sb appendWithNSString:@"exp("];
          [sb appendWithNSString:leftStr];
          [sb appendWithChar:')'];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PSTRICKS:
          [sb appendWithNSString:@"EXP("];
          [sb appendWithNSString:leftStr];
          [sb appendWithChar:')'];
          break;
          default:
          [sb appendWithNSString:GeogebraCommonUtilUnicode_get_EULER_STRING_()];
          if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isLeaf]) {
            [sb appendWithNSString:@"^"];
            [sb appendWithNSString:leftStr];
          }
          else {
            [sb appendWithNSString:@"^("];
            [sb appendWithNSString:leftStr];
            [sb appendWithChar:')'];
          }
          break;
        }
      }
      break;
      case GeogebraCommonPluginOperation_LOG:
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<ln/>", leftStr, nil);
      }
      else {
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          [sb appendWithNSString:@"\\ln \\left( "];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@"ln left ( "];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GEOGEBRA_XML:
          [sb appendWithNSString:@"log("];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PSTRICKS:
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PGF:
          default:
          [sb appendWithNSString:@"ln("];
          break;
        }
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:[tpl rightBracket]];
      }
      break;
      case GeogebraCommonPluginOperation_LOGB:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(sb, @"<log/>", @"<logbase>", leftStr, @"</logbase>", @"", rightStr, @"");
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\log_{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        [sb appendWithNSString:[tpl leftBracket]];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:[tpl rightBracket]];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"log_{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        [sb appendWithNSString:[tpl leftBracket]];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:[tpl rightBracket]];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PSTRICKS:
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PGF:
        [sb appendWithNSString:@"ln("];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@")/ln("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
        default:
        [sb appendWithNSString:@"log("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@", "];
        [sb appendWithNSString:rightStr];
        [sb appendWithChar:')'];
        break;
      }
      break;
      case GeogebraCommonPluginOperation_POLYGAMMA:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\psi_{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        [sb appendWithNSString:[tpl leftBracket]];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:[tpl rightBracket]];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        GeogebraCommonKernelArithmeticExpressionNode_appendReduceFunctionWithJavaLangStringBuilder_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_(sb, left, @"Psi");
        [sb appendWithNSString:rightStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
        default:
        [sb appendWithNSString:@"polygamma("];
        [sb appendWithNSString:leftStr];
        if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()]) [sb appendWithNSString:@"\",\""];
        else [sb appendWithNSString:@", "];
        [sb appendWithNSString:rightStr];
        [sb appendWithChar:')'];
        break;
      }
      break;
      case GeogebraCommonPluginOperation_ERF:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\erf"];
        [sb appendWithNSString:[tpl leftBracket]];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:[tpl rightBracket]];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func "];
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        default:
        [sb appendWithNSString:@"erf("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
      }
      break;
      case GeogebraCommonPluginOperation_PSI:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\psi"];
        [sb appendWithNSString:[tpl leftBracket]];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:[tpl rightBracket]];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        GeogebraCommonKernelArithmeticExpressionNode_appendReduceFunctionWithJavaLangStringBuilder_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_(sb, left, @"Psi");
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func "];
        default:
        [sb appendWithNSString:@"psi("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
      }
      break;
      case GeogebraCommonPluginOperation_LOG10:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<log/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\log_{10} \\left("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"\\right)"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"log_10 ("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@")"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PSTRICKS:
        [sb appendWithNSString:@"log("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PGF:
        [sb appendWithNSString:@"log10("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
        default:
        [sb appendWithNSString:@"lg("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
      }
      break;
      case GeogebraCommonPluginOperation_LOG2:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\log_{2} \\left("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"\\right)"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"log_2 ("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@")"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"log("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@")/log(2)"];
        break;
        default:
        [sb appendWithNSString:@"ld("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
      }
      break;
      case GeogebraCommonPluginOperation_NROOT:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<root/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\sqrt["];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"]{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"nroot{"];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"},{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GEOGEBRA:
        [sb appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getFunctionWithNSString:@"nroot"]];
        [sb appendWithNSString:@"("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:rightStr];
        [sb appendWithChar:')'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        if ([((NSString *) nil_chk(leftStr)) isEqual:GeogebraCommonUtilUnicode_get_EULER_STRING_()]) {
          [sb appendWithNSString:@"exp(1/("];
          [sb appendWithNSString:rightStr];
          [sb appendWithNSString:@"))"];
        }
        else {
          [sb appendWithNSString:@"surd("];
          [sb appendWithNSString:leftStr];
          [sb appendWithChar:','];
          [sb appendWithNSString:rightStr];
          [sb appendWithNSString:@")"];
        }
        break;
        default:
        [sb appendWithNSString:@"("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@")^(1/("];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"))"];
        break;
      }
      break;
      case GeogebraCommonPluginOperation_SQRT_SHORT:
      case GeogebraCommonPluginOperation_SQRT:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<root/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\sqrt{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"sqrt{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        break;
        default:
        [sb appendWithNSString:@"sqrt("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
      }
      break;
      case GeogebraCommonPluginOperation_CBRT:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_(sb, @"<root/>", @"<degree>", @"3", @"</degree>", @"", leftStr, @"");
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\sqrt[3]{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"nroot{3}{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"surd("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@",3)"];
        break;
        default:
        [sb appendWithNSString:@"cbrt("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
      }
      break;
      case GeogebraCommonPluginOperation_ABS:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<abs/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\left|"];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"\\right|"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"abs{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'}'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"normal(ggbabs("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"))"];
        break;
        default:
        [sb appendWithNSString:@"abs("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
      }
      break;
      case GeogebraCommonPluginOperation_SGN:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\sgn("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"sign("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func "];
        default:
        [sb appendWithNSString:@"sgn("];
      }
      [sb appendWithNSString:leftStr];
      [sb appendWithChar:')'];
      break;
      case GeogebraCommonPluginOperation_CONJUGATE:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<conjugate/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\overline{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"}"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"overline{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"}"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"conj("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
        default:
        [sb appendWithNSString:@"conjugate("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
      }
      break;
      case GeogebraCommonPluginOperation_ARG:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<arg/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\arg \\left( "];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"\\right)"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"arg("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func "];
        default:
        [sb appendWithNSString:@"arg("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
      }
      break;
      case GeogebraCommonPluginOperation_FLOOR:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<floor/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        if (![((GeogebraCommonMainApp *) nil_chk([kernel getApplication])) isHTML5Applet]) {
          [sb appendWithNSString:@"\\left"];
        }
        [sb appendWithNSString:@"\\lfloor "];
        [sb appendWithNSString:leftStr];
        if (![((GeogebraCommonMainApp *) nil_chk([kernel getApplication])) isHTML5Applet]) {
          [sb appendWithNSString:@"\\right"];
        }
        [sb appendWithNSString:@"\\rfloor "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@" left lfloor "];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@" right rfloor"];
        break;
        default:
        [sb appendWithNSString:@"floor("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
      }
      break;
      case GeogebraCommonPluginOperation_CEIL:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_MATHML:
        GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, @"<ceiling/>", leftStr, nil);
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        if (![((GeogebraCommonMainApp *) nil_chk([kernel getApplication])) isHTML5Applet]) {
          [sb appendWithNSString:@"\\left"];
        }
        [sb appendWithNSString:@"\\lceil "];
        [sb appendWithNSString:leftStr];
        if (![((GeogebraCommonMainApp *) nil_chk([kernel getApplication])) isHTML5Applet]) {
          [sb appendWithNSString:@"\\right"];
        }
        [sb appendWithNSString:@"\\rceil "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"left lceil "];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@" right rceil"];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PSTRICKS:
        [sb appendWithNSString:@"ceiling("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
        break;
        default:
        [sb appendWithNSString:@"ceil("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:')'];
      }
      break;
      case GeogebraCommonPluginOperation_ROUND:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\round \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func round left ("];
        default:
        [sb appendWithNSString:@"round("];
      }
      [sb appendWithNSString:leftStr];
      if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:right] && (!JavaLangDouble_isNaNWithDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(right, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble]) || [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right)) isGeoElement])) {
        [sb appendWithNSString:@", "];
        [sb appendWithNSString:rightStr];
      }
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_GAMMA:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\Gamma \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"%GAMMA left ("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"Gamma("];
        break;
        default:
        [sb appendWithNSString:@"gamma("];
      }
      [sb appendWithNSString:leftStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_GAMMA_INCOMPLETE:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\gamma \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"%GAMMA left ("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"igamma("];
        break;
        default:
        [sb appendWithNSString:@"gamma("];
      }
      [sb appendWithNSString:leftStr];
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()]) [sb appendWithNSString:@"\",\""];
      else [sb appendWithNSString:@", "];
      [sb appendWithNSString:rightStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_GAMMA_INCOMPLETE_REGULARIZED:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"P \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func gammaRegularized left ("];
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"igamma("];
        break;
        default:
        [sb appendWithNSString:@"gammaRegularized("];
      }
      [sb appendWithNSString:leftStr];
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()]) [sb appendWithNSString:@"\",\""];
      else [sb appendWithNSString:@", "];
      [sb appendWithNSString:rightStr];
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()) {
        [sb appendWithNSString:@",1"];
      }
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_BETA:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\Beta \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"%BETA left("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"Beta("];
        break;
        default:
        [sb appendWithNSString:@"beta("];
      }
      [sb appendWithNSString:leftStr];
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()]) [sb appendWithNSString:@"\",\""];
      else [sb appendWithNSString:@", "];
      [sb appendWithNSString:rightStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_BETA_INCOMPLETE:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"\\Beta \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"%BETA left("];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"Beta("];
        break;
        default:
        [sb appendWithNSString:@"beta("];
      }
      [sb appendWithNSString:leftStr];
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()]) [sb appendWithNSString:@"\",\""];
      else [sb appendWithNSString:@", "];
      [sb appendWithNSString:rightStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_BETA_INCOMPLETE_REGULARIZED:
      switch ([stringType ordinal]) {
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
        [sb appendWithNSString:@"I \\left( "];
        break;
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
        [sb appendWithNSString:@"func betaRegularized left ("];
        case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
        [sb appendWithNSString:@"Beta("];
        break;
        default:
        [sb appendWithNSString:@"betaRegularized("];
      }
      [sb appendWithNSString:leftStr];
      if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()]) [sb appendWithNSString:@"\",\""];
      else [sb appendWithNSString:@", "];
      [sb appendWithNSString:rightStr];
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()) {
        [sb appendWithNSString:@",1"];
      }
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_RANDOM:
      if (valueForm) {
        [sb appendWithNSString:leftStr];
      }
      else {
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
          [sb appendWithNSString:@"rand(0,1)"];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@"func "];
          default:
          [sb appendWithNSString:@"random()"];
        }
      }
      break;
      case GeogebraCommonPluginOperation_XCOORD:
      if (valueForm && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:(leftEval = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) evaluateWithGeogebraCommonKernelStringTemplate:tpl])]) {
        [sb appendWithNSString:[kernel formatWithDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(leftEval, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector])) getX] withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else if (valueForm && [GeogebraCommonKernelArithmetic3DVector3DValue_class_() isInstance:(leftEval = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) evaluateWithGeogebraCommonKernelStringTemplate:tpl])]) {
        [sb appendWithNSString:[kernel formatWithDouble:IOSDoubleArray_Get(nil_chk([((id<GeogebraCommonKernelArithmetic3DVector3DValue>) nil_chk(((id<GeogebraCommonKernelArithmetic3DVector3DValue>) check_protocol_cast(leftEval, @protocol(GeogebraCommonKernelArithmetic3DVector3DValue))))) getPointAsDouble]), 0) withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else if (valueForm && ([(leftEval = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) evaluateWithGeogebraCommonKernelStringTemplate:tpl]) isKindOfClass:[GeogebraCommonKernelGeosGeoLine class]])) {
        [sb appendWithNSString:[kernel formatWithDouble:[((GeogebraCommonKernelGeosGeoLine *) nil_chk(((GeogebraCommonKernelGeosGeoLine *) check_class_cast(leftEval, [GeogebraCommonKernelGeosGeoLine class])))) getX] withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          [sb appendWithNSString:@" x \\left( "];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl rightBracket]];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@"func x left ("];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl rightBracket]];
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
          [sb appendWithNSString:@"xcoord("];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:@")"];
          break;
          default:
          [sb appendWithNSString:@"x("];
          [sb appendWithNSString:leftStr];
          [sb appendWithChar:')'];
        }
      }
      break;
      case GeogebraCommonPluginOperation_YCOORD:
      leftEval = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) evaluateWithGeogebraCommonKernelStringTemplate:tpl];
      if (valueForm && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:leftEval]) {
        [sb appendWithNSString:[kernel formatWithDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(leftEval, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector])) getY] withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else if (valueForm && [GeogebraCommonKernelArithmetic3DVector3DValue_class_() isInstance:(leftEval = [left evaluateWithGeogebraCommonKernelStringTemplate:tpl])]) {
        [sb appendWithNSString:[kernel formatWithDouble:IOSDoubleArray_Get(nil_chk([((id<GeogebraCommonKernelArithmetic3DVector3DValue>) nil_chk(((id<GeogebraCommonKernelArithmetic3DVector3DValue>) check_protocol_cast(leftEval, @protocol(GeogebraCommonKernelArithmetic3DVector3DValue))))) getPointAsDouble]), 1) withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else if (valueForm && ([(leftEval = [left evaluateWithGeogebraCommonKernelStringTemplate:tpl]) isKindOfClass:[GeogebraCommonKernelGeosGeoLine class]])) {
        [sb appendWithNSString:[kernel formatWithDouble:[((GeogebraCommonKernelGeosGeoLine *) nil_chk(((GeogebraCommonKernelGeosGeoLine *) check_class_cast(leftEval, [GeogebraCommonKernelGeosGeoLine class])))) getY] withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          [sb appendWithNSString:@" y \\left( "];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:@"\\right)"];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@"func y left ("];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl rightBracket]];
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
          [sb appendWithNSString:@"ycoord("];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:@")"];
          break;
          default:
          [sb appendWithNSString:@"y("];
          [sb appendWithNSString:leftStr];
          [sb appendWithChar:')'];
        }
      }
      break;
      case GeogebraCommonPluginOperation_ZCOORD:
      if (valueForm && [GeogebraCommonKernelArithmetic3DVector3DValue_class_() isInstance:(leftEval = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) evaluateWithGeogebraCommonKernelStringTemplate:tpl])]) {
        [sb appendWithNSString:[kernel formatWithDouble:IOSDoubleArray_Get(nil_chk([((id<GeogebraCommonKernelArithmetic3DVector3DValue>) nil_chk(((id<GeogebraCommonKernelArithmetic3DVector3DValue>) check_protocol_cast(leftEval, @protocol(GeogebraCommonKernelArithmetic3DVector3DValue))))) getPointAsDouble]), 2) withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else if (valueForm && ([(leftEval = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) evaluateWithGeogebraCommonKernelStringTemplate:tpl]) isKindOfClass:[GeogebraCommonKernelGeosGeoLine class]])) {
        [sb appendWithNSString:[kernel formatWithDouble:[((GeogebraCommonKernelGeosGeoLine *) nil_chk(((GeogebraCommonKernelGeosGeoLine *) check_class_cast(leftEval, [GeogebraCommonKernelGeosGeoLine class])))) getZ] withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        switch ([stringType ordinal]) {
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
          [sb appendWithNSString:@" z \\left( "];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:@"\\right)"];
          break;
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
          [sb appendWithNSString:@"func z left ("];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl rightBracket]];
          case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
          [sb appendWithNSString:@"zcoord("];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:@")"];
          break;
          default:
          [sb appendWithNSString:@"z("];
          [sb appendWithNSString:leftStr];
          [sb appendWithChar:')'];
        }
      }
      break;
      case GeogebraCommonPluginOperation_MULTIPLY_OR_FUNCTION:
      GeogebraCommonUtilDebugLog_debugWithNSString_(@"Operation not resolved");
      case GeogebraCommonPluginOperation_FUNCTION:
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC() && [GeogebraCommonKernelArithmeticListValue_class_() isInstance:right]) {
        id<GeogebraCommonKernelArithmeticListValue> list = (id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(right, @protocol(GeogebraCommonKernelArithmeticListValue));
        [sb appendWithNSString:@"seq("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:'('];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"[j]),j,0,"];
        [sb appendWithInt:[((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(list)) size] - 1];
        [sb appendWithChar:')'];
        break;
      }
      if ([left isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) {
        GeogebraCommonKernelGeosGeoFunction *geo = (GeogebraCommonKernelGeosGeoFunction *) check_class_cast(left, [GeogebraCommonKernelGeosGeoFunction class]);
        if ([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(geo)) isLabelSet]) {
          if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()]) [sb appendWithNSString:@"func "];
          [sb appendWithNSString:[geo getLabelWithGeogebraCommonKernelStringTemplate:tpl]];
          [sb appendWithNSString:[tpl leftBracket]];
          [sb appendWithNSString:rightStr];
          [sb appendWithNSString:[tpl rightBracket]];
        }
        else {
          GeogebraCommonKernelArithmeticFunctionVariable *var = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([geo getFunction])) getFunctionVariable];
          NSString *oldVarStr = [((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk(var)) toStringWithGeogebraCommonKernelStringTemplate:tpl];
          [var setVarStringWithNSString:rightStr];
          if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()]) [sb appendWithNSString:@"func "];
          NSString *rhString = [((NSString *) nil_chk(oldVarStr)) isEqual:rightStr] ? leftStr : [geo getLabelWithGeogebraCommonKernelStringTemplate:tpl];
          [sb appendWithNSString:rhString];
          [var setVarStringWithNSString:oldVarStr];
        }
      }
      else if (valueForm && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isExpressionNode]) {
        GeogebraCommonKernelArithmeticExpressionNode *en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left, [GeogebraCommonKernelArithmeticExpressionNode class]);
        switch ([en->operation_ ordinal]) {
          case GeogebraCommonPluginOperation_$VAR_ROW:
          case GeogebraCommonPluginOperation_$VAR_COL:
          case GeogebraCommonPluginOperation_$VAR_ROW_COL:
          [sb appendWithNSString:[tpl leftBracket]];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl rightBracket]];
          break;
          default:
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl leftBracket]];
          [sb appendWithNSString:rightStr];
          [sb appendWithNSString:[tpl rightBracket]];
          break;
        }
      }
      else {
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:[tpl leftBracket]];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:[tpl rightBracket]];
      }
      break;
      case GeogebraCommonPluginOperation_ELEMENT_OF:
      [sb appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getCommandWithNSString:@"Element"]];
      [sb appendWithChar:'['];
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isGeoElement]) {
        [sb appendWithNSString:[((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [sb appendWithNSString:leftStr];
      }
      [sb appendWithNSString:@", "];
      [sb appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyList *) nil_chk(((GeogebraCommonKernelArithmeticMyList *) check_class_cast(right, [GeogebraCommonKernelArithmeticMyList class])))) getListElementWithInt:0])) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
      [sb appendWithChar:']'];
      break;
      case GeogebraCommonPluginOperation_FUNCTION_NVAR:
      if (valueForm) {
        if (([GeogebraCommonKernelArithmeticFunctionalNVar_class_() isInstance:left]) && ([right isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]])) {
          GeogebraCommonKernelArithmeticFunctionNVar *func = [((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(((id<GeogebraCommonKernelArithmeticFunctionalNVar>) check_protocol_cast(left, @protocol(GeogebraCommonKernelArithmeticFunctionalNVar))))) getFunction];
          GeogebraCommonKernelArithmeticExpressionNode *en = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(func)) getExpression])) getCopyWithGeogebraCommonKernelKernel:kernel];
          for (jint i = 0; (i < [func getVarNumber]) && (i < [((GeogebraCommonKernelArithmeticMyList *) nil_chk(((GeogebraCommonKernelArithmeticMyList *) check_class_cast(right, [GeogebraCommonKernelArithmeticMyList class])))) size]); i++) {
            [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:IOSObjectArray_Get(nil_chk([func getFunctionVariables]), i) withGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticMyList *) nil_chk(((GeogebraCommonKernelArithmeticMyList *) check_class_cast(right, [GeogebraCommonKernelArithmeticMyList class])))) getListElementWithInt:i]];
          }
          if (![((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk(stringType)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()]) {
            [sb appendWithNSString:[tpl leftBracket]];
          }
          [sb appendWithNSString:GeogebraCommonKernelArithmeticExpressionNode_toValueStringWithGeogebraCommonKernelStringTemplate_(nil_chk(en), tpl)];
          if (![stringType isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()]) {
            [sb appendWithNSString:[tpl rightBracket]];
          }
        }
        else if ([left isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]]) {
          [sb appendWithNSString:[tpl leftBracket]];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl leftBracket]];
          [sb appendWithNSString:[rightStr substring:1 endIndex:((jint) [((NSString *) nil_chk(rightStr)) length]) - 1]];
          [sb appendWithNSString:[tpl rightBracket]];
          [sb appendWithNSString:[tpl rightBracket]];
        }
        else {
          [sb appendWithNSString:[tpl leftBracket]];
          [sb appendWithNSString:leftStr];
          [sb appendWithNSString:[tpl rightBracket]];
        }
      }
      else {
        if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isGeoElement]) {
          [sb appendWithNSString:[((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl]];
        }
        else {
          [sb appendWithNSString:leftStr];
        }
        if (![left isGeoElement] || [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class])) isLabelSet] || [left isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]] || [left isKindOfClass:[GeogebraCommonKernelGeosGeoCasCell class]]) {
          [sb appendWithNSString:[tpl leftBracket]];
          if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk([tpl getStringType])) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()]) {
            [sb appendWithNSString:[rightStr substring:2 endIndex:((jint) [((NSString *) nil_chk(rightStr)) length]) - 2]];
          }
          else {
            [sb appendWithNSString:[rightStr substring:1 endIndex:((jint) [((NSString *) nil_chk(rightStr)) length]) - 1]];
          }
          [sb appendWithNSString:[tpl rightBracket]];
        }
      }
      break;
      case GeogebraCommonPluginOperation_VEC_FUNCTION:
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isGeoElement] && [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class])) isGeoCurveCartesian]) {
        [sb appendWithNSString:[((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [sb appendWithNSString:leftStr];
      }
      [sb appendWithNSString:[tpl leftBracket]];
      [sb appendWithNSString:rightStr];
      [sb appendWithNSString:[tpl rightBracket]];
      break;
      case GeogebraCommonPluginOperation_DIFF:
      if ([tpl hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
        [sb appendWithNSString:@"diff("];
      }
      else {
        [sb appendWithNSString:@"ggbdiff("];
      }
      [sb appendWithNSString:leftStr];
      [sb appendWithChar:','];
      [sb appendWithNSString:rightStr];
      [sb appendWithNSString:@")"];
      case GeogebraCommonPluginOperation_DERIVATIVE:
      if ([tpl hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
        [sb appendWithNSString:@"diff("];
        [sb appendWithNSString:leftStr];
        break;
      }
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isGeoElement] && [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class])) isLabelSet]) {
        [sb appendWithNSString:[((GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [sb appendWithNSString:leftStr];
      }
      if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right)) unwrap]]) {
        jint order = (jint) JavaLangMath_roundWithDouble_([right evaluateDouble]);
        for (; order > 0; order--) {
          [sb appendWithChar:'\''];
        }
      }
      else {
        [sb appendWithId:right];
      }
      break;
      case GeogebraCommonPluginOperation_$VAR_ROW:
      if (valueForm || [tpl hasCASType]) {
        [sb appendWithNSString:leftStr];
      }
      else {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class]);
        if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getSpreadsheetCoords] != nil) {
          [sb appendWithNSString:[geo getSpreadsheetLabelWithDollarsWithBoolean:NO withBoolean:YES]];
        }
        else {
          [sb appendWithNSString:leftStr];
        }
      }
      break;
      case GeogebraCommonPluginOperation_$VAR_COL:
      if (valueForm || [tpl hasCASType]) {
        [sb appendWithNSString:leftStr];
      }
      else {
        if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isGeoElement]) {
          [sb appendWithChar:'$'];
          [sb appendWithNSString:leftStr];
          break;
        }
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class]);
        if ([geo getSpreadsheetCoords] != nil) {
          [sb appendWithNSString:[geo getSpreadsheetLabelWithDollarsWithBoolean:YES withBoolean:NO]];
        }
        else {
          [sb appendWithNSString:leftStr];
        }
      }
      break;
      case GeogebraCommonPluginOperation_$VAR_ROW_COL:
      if (valueForm || [tpl hasCASType]) {
        [sb appendWithNSString:leftStr];
      }
      else {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(left, [GeogebraCommonKernelGeosGeoElement class]);
        if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getSpreadsheetCoords] != nil) {
          [sb appendWithNSString:[geo getSpreadsheetLabelWithDollarsWithBoolean:YES withBoolean:YES]];
        }
        else {
          [sb appendWithNSString:leftStr];
        }
      }
      break;
      case GeogebraCommonPluginOperation_FREEHAND:
      [sb appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getPlainWithNSString:@"Function.freehand"]];
      [sb appendWithChar:'('];
      [sb appendWithNSString:leftStr];
      [sb appendWithChar:')'];
      break;
      case GeogebraCommonPluginOperation_INTEGRAL:
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()) {
        [sb appendWithNSString:@"\\int "];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"d"];
        [sb appendWithNSString:rightStr];
      }
      else if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()) {
        [sb appendWithNSString:@"int "];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@" d"];
        [sb appendWithNSString:rightStr];
      }
      else {
        if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()) {
          [sb appendWithNSString:@"int("];
        }
        else {
          [sb appendWithNSString:@"gGbInTeGrAl("];
        }
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@")"];
      }
      break;
      case GeogebraCommonPluginOperation_SUM:
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()) {
        [sb appendWithNSString:@"\\sum_{"];
        [sb appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(left, [GeogebraCommonKernelArithmeticMyNumberPair class]))))->y_)) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
        [sb appendWithNSString:@"="];
        [sb appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(right, [GeogebraCommonKernelArithmeticMyNumberPair class]))))->x_)) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
        [sb appendWithNSString:@"}^{"];
        [sb appendWithNSString:[((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(right, [GeogebraCommonKernelArithmeticMyNumberPair class]))))->y_ toStringWithGeogebraCommonKernelStringTemplate:tpl]];
        [sb appendWithNSString:@"}"];
        [sb appendWithNSString:[((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(left, [GeogebraCommonKernelArithmeticMyNumberPair class]))))->x_ toStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()) {
        [sb appendWithNSString:@"sum from{"];
        [sb appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(left, [GeogebraCommonKernelArithmeticMyNumberPair class]))))->y_)) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
        [sb appendWithNSString:@"="];
        [sb appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(right, [GeogebraCommonKernelArithmeticMyNumberPair class]))))->x_)) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
        [sb appendWithNSString:@"} to{"];
        [sb appendWithNSString:[((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(right, [GeogebraCommonKernelArithmeticMyNumberPair class]))))->y_ toStringWithGeogebraCommonKernelStringTemplate:tpl]];
        [sb appendWithNSString:@"}"];
        [sb appendWithNSString:[((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast(left, [GeogebraCommonKernelArithmeticMyNumberPair class]))))->x_ toStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()) {
          [sb appendWithNSString:@"sum("];
        }
        else {
          [sb appendWithNSString:@"gGbSuM("];
        }
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@")"];
      }
      break;
      case GeogebraCommonPluginOperation_SUBSTITUTION:
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()) {
        [sb appendWithNSString:@"\\left."];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"\\right\\mid_{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"}"];
      }
      else if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LIBRE_OFFICE()) {
        [sb appendWithNSString:@"left none"];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"right rline_{"];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@"}"];
      }
      else {
        if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()) {
          [sb appendWithNSString:@"subst("];
        }
        else {
          [sb appendWithNSString:@"gGbSuBsTiTuTiOn("];
        }
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@")"];
      }
      break;
      case GeogebraCommonPluginOperation_IF:
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()) {
        [sb appendWithNSString:@"when("];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@",undef)"];
      }
      else {
        if ([tpl isPrintLocalizedCommandNames]) {
          [sb appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getCommandWithNSString:@"If"]];
        }
        else {
          [sb appendWithNSString:@"If"];
        }
        [sb appendWithChar:'['];
        [sb appendWithNSString:leftStr];
        [sb appendWithChar:','];
        [sb appendWithNSString:rightStr];
        [sb appendWithChar:']'];
      }
      break;
      case GeogebraCommonPluginOperation_IF_ELSE:
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()) {
        [sb appendWithNSString:@"when("];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@","];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@")"];
      }
      else {
        if ([tpl isPrintLocalizedCommandNames]) {
          [sb appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getCommandWithNSString:@"If"]];
        }
        else {
          [sb appendWithNSString:@"If"];
        }
        [sb appendWithNSString:@"["];
        [sb appendWithNSString:leftStr];
        [sb appendWithNSString:@","];
        [sb appendWithNSString:rightStr];
        [sb appendWithNSString:@"]"];
      }
      break;
      case GeogebraCommonPluginOperation_IF_LIST:
      if (stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()) {
        [sb appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getCommandWithNSString:@"piecewise("]];
      }
      else if ([tpl isPrintLocalizedCommandNames]) {
        [sb appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getCommandWithNSString:@"If"]];
        [sb appendWithNSString:@"["];
      }
      else {
        [sb appendWithNSString:@"If"];
        [sb appendWithNSString:@"["];
      }
      cond = (GeogebraCommonKernelArithmeticMyList *) check_class_cast(left, [GeogebraCommonKernelArithmeticMyList class]);
      fn = (GeogebraCommonKernelArithmeticMyList *) check_class_cast(right, [GeogebraCommonKernelArithmeticMyList class]);
      for (jint i = 0; i < [((GeogebraCommonKernelArithmeticMyList *) nil_chk(cond)) size]; i++) {
        if (i > 0) {
          [sb appendWithNSString:@", "];
        }
        [sb appendWithNSString:valueForm ? [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([cond getListElementWithInt:i])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl] : [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([cond getListElementWithInt:i])) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
        [sb appendWithNSString:@", "];
        [sb appendWithNSString:valueForm ? [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyList *) nil_chk(fn)) getListElementWithInt:i])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl] : [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyList *) nil_chk(fn)) getListElementWithInt:i])) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      if ([((GeogebraCommonKernelArithmeticMyList *) nil_chk(fn)) size] > [cond size]) {
        [sb appendWithNSString:@", "];
        [sb appendWithNSString:valueForm ? [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([fn getListElementWithInt:[fn size] - 1])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl] : [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([fn getListElementWithInt:[fn size] - 1])) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      [sb appendWithNSString:stringType == GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC() ? @")" : @"]"];
      break;
      default:
      [sb appendWithNSString:JreStrcat("$@", @"unhandled operation ", operation)];
    }
  }
  return [sb description];
}

NSString *GeogebraCommonKernelArithmeticExpressionNode_degFixWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(NSString *string, id<GeogebraCommonKernelArithmeticExpressionValue> left, GeogebraCommonKernelKernel *kernel) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if ([((GeogebraCommonKernelKernel *) nil_chk(kernel)) getInverseTrigReturnsAngle]) {
    return JreStrcat("$$", @"deg", string);
  }
  return string;
}

void GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> left, NSString *leftStr, JavaLangStringBuilder *sb, NSString *mathml, NSString *latex, NSString *psTricks, NSString *key, NSString *libreOffice, GeogebraCommonKernelStringTemplate *tpl, GeogebraCommonMainLocalization *loc, jboolean needDegrees) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(kernel, left, leftStr, sb, mathml, latex, psTricks, key, libreOffice, key, tpl, loc, needDegrees);
}

void GeogebraCommonKernelArithmeticExpressionNode_trigWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_withJavaLangStringBuilder_withNSString_withNSString_withNSString_withNSString_withNSString_withNSString_withGeogebraCommonKernelStringTemplate_withGeogebraCommonMainLocalization_withBoolean_(GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> left, NSString *leftStr, JavaLangStringBuilder *sb, NSString *mathml, NSString *latex, NSString *psTricks, NSString *key, NSString *libreOffice, NSString *giac, GeogebraCommonKernelStringTemplate *tpl, GeogebraCommonMainLocalization *loc, jboolean needDegrees) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
    GeogebraCommonExportMathmlTemplate_mathmlWithJavaLangStringBuilder_withNSString_withNSString_withNSString_(sb, mathml, leftStr, nil);
  }
  else {
    switch ([[tpl getStringType] ordinal]) {
      case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
      if ([((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel)) getApplication])) isHTML5Applet]) {
        NSString *translatedKey = [((GeogebraCommonMainLocalization *) nil_chk(loc)) getFunctionWithNSString:key];
        if ([@"exp lg ln log sin cos tan cot sec csc sinh cosh tanh coth sech csch arcsin arccos arctan asin acos atan asinh acosh atanh arcsinh arccosh arctanh" indexOfString:translatedKey] > -1) {
          [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@" \\"];
          [sb appendWithNSString:translatedKey];
        }
        else if ([@"cossech arcsh arcch arcth argsh argch argth arcos arcosh arsinh artanh arch arsh arth ch sh th cth sen tg asen atg arcsen arctg senh tgh asenh atgh arcsenh arctgh cotg cotgh" indexOfString:translatedKey] > -1) {
          [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@" \\"];
          [sb appendWithNSString:translatedKey];
        }
        else {
          [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@" "];
          [sb appendWithNSString:translatedKey];
          [sb appendWithNSString:@" "];
        }
      }
      else if ([tpl isPrintLocalizedCommandNames]) {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\operatorname{"];
        [sb appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getFunctionWithNSString:key]];
        [sb appendWithNSString:@"}"];
      }
      else {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:latex];
      }
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@" \\left( "];
      break;
      case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LIBRE_OFFICE:
      if (![((NSString *) nil_chk(libreOffice)) isEqual:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getFunctionWithNSString:key]]) {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"func "];
      }
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:[loc getFunctionWithNSString:key]];
      [sb appendWithNSString:@" left( "];
      break;
      case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:giac];
      [sb appendWithChar:'('];
      break;
      case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_PSTRICKS:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:psTricks];
      break;
      default:
      if ([tpl isPrintLocalizedCommandNames]) {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk(loc)) getFunctionWithNSString:key]];
      }
      else {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:key];
      }
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"("];
    }
    if (needDegrees && [tpl hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_PGF()]) {
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:JreStrcat("C$$", '(', leftStr, @") 180/pi")];
    }
    else {
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:leftStr];
    }
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:[tpl rightBracket]];
  }
}

void GeogebraCommonKernelArithmeticExpressionNode_appendReduceFunctionWithJavaLangStringBuilder_withGeogebraCommonKernelArithmeticExpressionValue_withNSString_(JavaLangStringBuilder *sb, id<GeogebraCommonKernelArithmeticExpressionValue> left, NSString *string) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:left]) {
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"applyfunction("];
    [sb appendWithNSString:string];
    [sb appendWithNSString:@","];
  }
  else {
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:string];
    [sb appendWithChar:'('];
  }
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_isMultiplyOrDivideWithGeogebraCommonKernelArithmeticExpressionNode_(GeogebraCommonKernelArithmeticExpressionNode *exp) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  return [((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getOperation(nil_chk(exp)))) isEqual:GeogebraCommonPluginOperationEnum_get_MULTIPLY()] || [((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getOperation(exp))) isEqual:GeogebraCommonPluginOperationEnum_get_DIVIDE()];
}

jint GeogebraCommonKernelArithmeticExpressionNode_opIDWithGeogebraCommonKernelArithmeticExpressionValue_(id<GeogebraCommonKernelArithmeticExpressionValue> ev) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) isExpressionNode]) {
    GeogebraCommonPluginOperationEnum *op = ((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]))->operation_;
    if ([((GeogebraCommonPluginOperationEnum *) nil_chk(op)) isEqual:GeogebraCommonPluginOperationEnum_get_GREATER()] || [op isEqual:GeogebraCommonPluginOperationEnum_get_LESS()] || [op isEqual:GeogebraCommonPluginOperationEnum_get_LESS_EQUAL()] || [op isEqual:GeogebraCommonPluginOperationEnum_get_GREATER_EQUAL()]) {
      return [((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonPluginOperationEnum_get_NOT_EQUAL())) ordinal] - 1;
    }
    return [op ordinal];
  }
  return -1;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_isEqualWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(id<GeogebraCommonKernelArithmeticExpressionValue> ev1, id<GeogebraCommonKernelArithmeticExpressionValue> ev2) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:ev1] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:ev2]) {
    return GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(ev1, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble], [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(ev2, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble], GeogebraCommonKernelKernel_STANDARD_PRECISION);
  }
  else if ([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:ev1] && [GeogebraCommonKernelArithmeticTextValue_class_() isInstance:ev2]) {
    return [((NSString *) nil_chk([((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(ev1, @protocol(GeogebraCommonKernelArithmeticTextValue))))) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()])) isEqual:[((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(ev2, @protocol(GeogebraCommonKernelArithmeticTextValue))))) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:ev1] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:ev2]) {
    return [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(ev1, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector])) isEqualWithGeogebraCommonKernelGeosGeoVec2D:[((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(ev2, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector]];
  }
  else if ([GeogebraCommonKernelArithmeticBooleanValue_class_() isInstance:ev1] && [GeogebraCommonKernelArithmeticBooleanValue_class_() isInstance:ev2]) {
    return [((GeogebraCommonKernelArithmeticMyBoolean *) nil_chk([((id<GeogebraCommonKernelArithmeticBooleanValue>) nil_chk(((id<GeogebraCommonKernelArithmeticBooleanValue>) check_protocol_cast(ev1, @protocol(GeogebraCommonKernelArithmeticBooleanValue))))) getMyBoolean])) getBoolean] == [((GeogebraCommonKernelArithmeticMyBoolean *) nil_chk([((id<GeogebraCommonKernelArithmeticBooleanValue>) nil_chk(((id<GeogebraCommonKernelArithmeticBooleanValue>) check_protocol_cast(ev2, @protocol(GeogebraCommonKernelArithmeticBooleanValue))))) getMyBoolean])) getBoolean];
  }
  else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev1)) isGeoElement] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev2)) isGeoElement]) {
    return [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(ev1, [GeogebraCommonKernelGeosGeoElement class])) isEqualWithGeogebraCommonKernelGeosGeoElement:((GeogebraCommonKernelGeosGeoElement *) check_class_cast(ev2, [GeogebraCommonKernelGeosGeoElement class]))];
  }
  else if ([GeogebraCommonKernelArithmeticFunctional_class_() isInstance:ev1] && [GeogebraCommonKernelArithmeticFunctional_class_() isInstance:ev2]) {
    return [((GeogebraCommonKernelGeosGeoFunction *) nil_chk([((id<GeogebraCommonKernelArithmeticFunctional>) check_protocol_cast(ev1, @protocol(GeogebraCommonKernelArithmeticFunctional))) getGeoFunction])) isEqualWithGeogebraCommonKernelGeosGeoElement:[((id<GeogebraCommonKernelArithmeticFunctional>) nil_chk(((id<GeogebraCommonKernelArithmeticFunctional>) check_protocol_cast(ev2, @protocol(GeogebraCommonKernelArithmeticFunctional))))) getGeoFunction]];
  }
  return NO;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_isEqualStringWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_withBoolean_(id<GeogebraCommonKernelArithmeticExpressionValue> ev, jdouble val, jboolean symbolic) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) isLeaf] && ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:ev])) {
    if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] || [ev isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]]) {
      return NO;
    }
    else if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticMySpecialDouble class]]) {
      return NO;
    }
    if (symbolic) {
      if ([ev isGeoElement]) {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(ev, [GeogebraCommonKernelGeosGeoElement class]);
        if ([geo isLabelSet] || [geo isLocalVariable] || ![geo isIndependent]) {
          return NO;
        }
      }
    }
    id<GeogebraCommonKernelArithmeticNumberValue> nv = (id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(ev, @protocol(GeogebraCommonKernelArithmeticNumberValue));
    return [nv getDouble] == val;
  }
  return NO;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_chainedBooleanOpWithGeogebraCommonPluginOperationEnum_(GeogebraCommonPluginOperationEnum *op) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  switch ([op ordinal]) {
    case GeogebraCommonPluginOperation_EQUAL_BOOLEAN:
    case GeogebraCommonPluginOperation_NOT_EQUAL:
    case GeogebraCommonPluginOperation_IS_SUBSET_OF:
    case GeogebraCommonPluginOperation_IS_SUBSET_OF_STRICT:
    case GeogebraCommonPluginOperation_LESS:
    case GeogebraCommonPluginOperation_LESS_EQUAL:
    case GeogebraCommonPluginOperation_GREATER:
    case GeogebraCommonPluginOperation_GREATER_EQUAL:
    case GeogebraCommonPluginOperation_PERPENDICULAR:
    case GeogebraCommonPluginOperation_PARALLEL:
    return YES;
  }
  return NO;
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_isConstantDoubleWithGeogebraCommonKernelArithmeticExpressionValue_withDouble_(id<GeogebraCommonKernelArithmeticExpressionValue> ev, jdouble v) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  id<GeogebraCommonKernelArithmeticExpressionValue> base = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) unwrap];
  return [base isKindOfClass:[GeogebraCommonKernelArithmeticMyDouble class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(base)) isConstant] && v == [((GeogebraCommonKernelArithmeticMyDouble *) check_class_cast(base, [GeogebraCommonKernelArithmeticMyDouble class])) getDouble];
}

GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelArithmeticExpressionNode_wrapWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> exp) {
  return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(exp)) wrap];
}

GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelArithmeticExpressionNode_linearIntegralWithInt_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionVariable_(GeogebraCommonKernelArithmeticExpressionNode *self, jint i, GeogebraCommonPluginOperationEnum *op, GeogebraCommonKernelArithmeticFunctionVariable *fv) {
  if (self->left_ == fv) {
    return [((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, self->left_, op, nil) autorelease]) multiplyRWithDouble:i];
  }
  jdouble coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, self->left_);
  if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
    return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, self->left_, op, nil) autorelease]) multiplyRWithDouble:i])) divideWithDouble:coeff];
  }
  coeff = GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(fv, self->left_);
  if (!JavaLangDouble_isNaNWithDouble_(coeff)) {
    return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, self->left_, op, nil) autorelease]) multiplyWithDouble:coeff])) multiplyRWithDouble:i];
  }
  GeogebraCommonMainApp_debugWithNSString_(@"not linear integral");
  return GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(self, JavaLangDouble_NaN);
}

jdouble GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticFunctionVariable *fv, id<GeogebraCommonKernelArithmeticExpressionValue> ev2) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  if (ev2 == fv) {
    return 1;
  }
  id<GeogebraCommonKernelArithmeticExpressionValue> ev = ev2;
  jdouble factor = 1;
  GeogebraCommonPluginOperationEnum *op;
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) isExpressionNode] && [(op = GeogebraCommonKernelArithmeticExpressionNode_getOperation(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class])))) isPlusorMinus]) {
    GeogebraCommonKernelArithmeticExpressionNode *en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]);
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(en->left_)) isNumberValue] && ![en->left_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
      ev = en->right_;
      factor = [((GeogebraCommonPluginOperationEnum *) nil_chk(op)) isEqual:GeogebraCommonPluginOperationEnum_get_PLUS()] ? 1 : -1;
    }
    else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(en->right_)) isNumberValue] && ![en->right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
      ev = en->left_;
      factor = 1;
    }
  }
  if (ev == fv) {
    return factor;
  }
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) isExpressionNode] && [((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getOperation(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]))))) isEqual:GeogebraCommonPluginOperationEnum_get_MULTIPLY()]) {
    GeogebraCommonKernelArithmeticExpressionNode *en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]);
    if (en->left_ == fv && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(en->right_)) isNumberValue] && ![en->right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
      return [((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(en->right_, @protocol(GeogebraCommonKernelArithmeticNumberValue))) getDouble] * factor;
    }
    else if (en->right_ == fv && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(en->left_)) isNumberValue] && ![en->left_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
      return [((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(en->left_, @protocol(GeogebraCommonKernelArithmeticNumberValue))) getDouble] * factor;
    }
  }
  return JavaLangDouble_NaN;
}

jdouble GeogebraCommonKernelArithmeticExpressionNode_getLinearCoefficientDivWithGeogebraCommonKernelArithmeticFunctionVariable_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticFunctionVariable *fv, id<GeogebraCommonKernelArithmeticExpressionValue> ev2) {
  GeogebraCommonKernelArithmeticExpressionNode_initialize();
  id<GeogebraCommonKernelArithmeticExpressionValue> ev = ev2;
  jdouble factor = 1;
  GeogebraCommonPluginOperationEnum *op;
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) isExpressionNode] && [(op = GeogebraCommonKernelArithmeticExpressionNode_getOperation(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class])))) isPlusorMinus]) {
    GeogebraCommonKernelArithmeticExpressionNode *en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]);
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(en->left_)) isNumberValue] && ![en->left_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
      ev = en->right_;
      factor = [((GeogebraCommonPluginOperationEnum *) nil_chk(op)) isEqual:GeogebraCommonPluginOperationEnum_get_PLUS()] ? 1 : -1;
    }
    else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(en->right_)) isNumberValue] && ![en->right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
      ev = en->left_;
      factor = 1;
    }
  }
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) isExpressionNode] && [((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonKernelArithmeticExpressionNode_getOperation(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]))))) isEqual:GeogebraCommonPluginOperationEnum_get_DIVIDE()]) {
    GeogebraCommonKernelArithmeticExpressionNode *en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class]);
    if (en->left_ == fv && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(en->right_)) isNumberValue] && ![en->right_ containsWithGeogebraCommonKernelArithmeticExpressionValue:fv]) {
      return [((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(en->right_, @protocol(GeogebraCommonKernelArithmeticNumberValue))) getDouble] * factor;
    }
  }
  return JavaLangDouble_NaN;
}

GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelArithmeticExpressionNode_wrapWithDouble_(GeogebraCommonKernelArithmeticExpressionNode *self, jdouble n) {
  return [((GeogebraCommonKernelArithmeticMyDouble *) [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, n) autorelease]) wrap];
}

jboolean GeogebraCommonKernelArithmeticExpressionNode_checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticExpressionNode *self, id<GeogebraCommonKernelArithmeticExpressionValue> ev) {
  if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
    return YES;
  }
  if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
    return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticExpressionNode class])))) containsFreeFunctionVariable];
  }
  if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticMyVecNode class]]) {
    return GeogebraCommonKernelArithmeticExpressionNode_checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((GeogebraCommonKernelArithmeticMyVecNode *) nil_chk(((GeogebraCommonKernelArithmeticMyVecNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticMyVecNode class])))) getX]) || GeogebraCommonKernelArithmeticExpressionNode_checkForFreeVarsWithGeogebraCommonKernelArithmeticExpressionValue_(self, [((GeogebraCommonKernelArithmeticMyVecNode *) nil_chk(((GeogebraCommonKernelArithmeticMyVecNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticMyVecNode class])))) getY]);
  }
  return NO;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelArithmeticExpressionNode)
