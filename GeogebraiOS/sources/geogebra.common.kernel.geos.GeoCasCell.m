//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/geos/GeoCasCell.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GColor.h"
#include "geogebra/common/awt/GFont.h"
#include "geogebra/common/kernel/AlgoCasCellInterface.h"
#include "geogebra/common/kernel/CASException.h"
#include "geogebra/common/kernel/CASParserInterface.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/GeoGebraCasInterface.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/VarString.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgorithmSet.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/algos/DrawInformationAlgo.h"
#include "geogebra/common/kernel/arithmetic/AssignmentType.h"
#include "geogebra/common/kernel/arithmetic/Command.h"
#include "geogebra/common/kernel/arithmetic/Equation.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionNVar.h"
#include "geogebra/common/kernel/arithmetic/FunctionVariable.h"
#include "geogebra/common/kernel/arithmetic/FunctionalNVar.h"
#include "geogebra/common/kernel/arithmetic/Inspecting.h"
#include "geogebra/common/kernel/arithmetic/MyArbitraryConstant.h"
#include "geogebra/common/kernel/arithmetic/MyList.h"
#include "geogebra/common/kernel/arithmetic/MyVecNode.h"
#include "geogebra/common/kernel/arithmetic/Traversing.h"
#include "geogebra/common/kernel/arithmetic/ValidExpression.h"
#include "geogebra/common/kernel/arithmetic3D/MyVec3DNode.h"
#include "geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "geogebra/common/kernel/geos/GeoBoolean.h"
#include "geogebra/common/kernel/geos/GeoCasCell.h"
#include "geogebra/common/kernel/geos/GeoDummyVariable.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoList.h"
#include "geogebra/common/kernel/geos/GeoLocus.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/geos/GeoText.h"
#include "geogebra/common/kernel/geos/LabelManager.h"
#include "geogebra/common/kernel/geos/Test.h"
#include "geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "geogebra/common/kernel/parser/Parser.h"
#include "geogebra/common/kernel/parser/cashandlers/ParserFunctions.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/plugin/script/GgbScript.h"
#include "geogebra/common/util/StringUtil.h"
#include "geogebra/common/util/Unicode.h"
#include "geogebra/common/util/debug/Log.h"
#include "java/io/PrintStream.h"
#include "java/lang/Character.h"
#include "java/lang/Exception.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/lang/Throwable.h"
#include "java/util/ArrayList.h"
#include "java/util/Comparator.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/Set.h"
#include "java/util/TreeSet.h"

@interface GeogebraCommonKernelGeosGeoCasCell () {
 @public
  GeogebraCommonKernelArithmeticValidExpression *inputVE_, *evalVE_, *outputVE_;
  NSString *input_, *prefix_, *postfix_, *error_, *latex_;
  NSString *localizedInput_;
  NSString *currentLanguage_;
  jboolean suppressOutput__;
  JavaUtilTreeSet *invars_, *functionvars_;
  JavaUtilTreeSet *inGeos_;
  jboolean isCircularDefinition__;
  GeogebraCommonKernelGeosGeoElement *twinGeo_;
  GeogebraCommonKernelGeosGeoElement *lastOutputEvaluationGeo_;
  jboolean firstComputeOutput_;
  jboolean ignoreTwinGeoUpdate_;
  JavaUtilHashSet *commands_;
  NSString *assignmentVar_;
  jboolean includesRowReferences__;
  jboolean includesNumericCommand__;
  jboolean useGeoGebraFallback_;
  NSString *evalCmd_, *evalComment_;
  jint row_;
  jboolean useAsText_;
  GeogebraCommonKernelGeosGeoText *commentText_;
  jboolean nativeOutput_;
  jboolean ignoreSetAssignment_;
  GeogebraCommonKernelArithmeticMyArbitraryConstant *arbconst_;
  GeogebraCommonKernelArithmeticValidExpression *expandedEvalVE_;
  jboolean pointList_;
  NSString *tooltip_;
  jint SCREEN_WIDTH_;
}

- (jboolean)suppressOutput;

- (void)updateLocalizedInputWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                      withNSString:(NSString *)input1;

- (GeogebraCommonKernelArithmeticValidExpression *)parseGeoGebraCASInputAndResolveDummyVarsWithNSString:(NSString *)inValue;

- (void)updateInputVariablesWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve;

+ (NSString *)getFunctionVariableWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve
                                                    withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel;

- (void)internalizeInput;

- (NSString *)localizeInputWithNSString:(NSString *)input1
 withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl;

- (void)setAssignmentVarWithNSString:(NSString *)var;

- (void)changeAssignmentVarWithNSString:(NSString *)oldLabel
                           withNSString:(NSString *)newLabel;

- (JavaUtilTreeSet *)getInVars;

- (JavaUtilTreeSet *)getFunctionVars;

- (void)clearInVars;

- (JavaUtilTreeSet *)updateInputGeoElementsWithJavaUtilTreeSet:(JavaUtilTreeSet *)inputVars;

- (GeogebraCommonKernelArithmeticValidExpression *)resolveInputReferencesWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve
                                                                                                       withJavaUtilTreeSet:(JavaUtilTreeSet *)inputGeos;

+ (void)resolveFunctionVariableReferencesWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)outputVE;

- (void)resolveGeoElementReferencesWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)outVE;

- (void)createTwinGeoWithBoolean:(jboolean)allowFunction;

- (void)setEquationMode;

- (void)simpleUpdateTwinGeoWithBoolean:(jboolean)allowFunction;

- (GeogebraCommonKernelGeosGeoElement *)silentEvalInGeoGebraWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve
                                                                                                  withBoolean:(jboolean)allowFunction;

- (void)computeOutputWithBoolean:(jboolean)doTwinGeoUpdate
                     withBoolean:(jboolean)allowFunction;

- (GeogebraCommonKernelArithmeticValidExpression *)wrapPointListWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)arg;

- (GeogebraCommonKernelArithmeticValidExpression *)wrapEvaluateWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)arg
                                                                                                     withBoolean:(jboolean)forceWrapping;

- (GeogebraCommonKernelArithmeticValidExpression *)processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve;

- (NSString *)lhsWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)arg
                                                      withNSString:(NSString *)fallback;

- (void)finalizeComputationWithBoolean:(jboolean)success
                          withNSString:(NSString *)result
  withGeogebraCommonKernelCASException:(GeogebraCommonKernelCASException *)ce
                           withBoolean:(jboolean)doTwinGeoUpdate
                           withBoolean:(jboolean)allowFunction;

- (void)setTwinGeoWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)newTwinGeo;

+ (jboolean)dependsOnDummyWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo;

- (void)setInputVEWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)inputVE;

- (jboolean)inequalityInEvalVE;

- (void)clearStrings;

- (NSString *)getPlotVar;

- (NSString *)getOutputPrefix;

- (void)updateDependentCellInput;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, inputVE_, GeogebraCommonKernelArithmeticValidExpression *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, evalVE_, GeogebraCommonKernelArithmeticValidExpression *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, outputVE_, GeogebraCommonKernelArithmeticValidExpression *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, input_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, prefix_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, postfix_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, error_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, latex_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, localizedInput_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, currentLanguage_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, invars_, JavaUtilTreeSet *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, functionvars_, JavaUtilTreeSet *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, inGeos_, JavaUtilTreeSet *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, twinGeo_, GeogebraCommonKernelGeosGeoElement *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, lastOutputEvaluationGeo_, GeogebraCommonKernelGeosGeoElement *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, commands_, JavaUtilHashSet *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, assignmentVar_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, evalCmd_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, evalComment_, NSString *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, commentText_, GeogebraCommonKernelGeosGeoText *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, arbconst_, GeogebraCommonKernelArithmeticMyArbitraryConstant *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, expandedEvalVE_, GeogebraCommonKernelArithmeticValidExpression *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoCasCell, tooltip_, NSString *)

static NSString *GeogebraCommonKernelGeosGeoCasCell_PLOT_VAR_ = @"GgbmpvarPlot";
J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelGeosGeoCasCell, PLOT_VAR_, NSString *)

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoCasCell_suppressOutput(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_updateLocalizedInputWithGeogebraCommonKernelStringTemplate_withNSString_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelStringTemplate *tpl, NSString *input1);

__attribute__((unused)) static GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_parseGeoGebraCASInputAndResolveDummyVarsWithNSString_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *inValue);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_updateInputVariablesWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *ve);

__attribute__((unused)) static NSString *GeogebraCommonKernelGeosGeoCasCell_getFunctionVariableWithGeogebraCommonKernelArithmeticValidExpression_withGeogebraCommonKernelKernel_(GeogebraCommonKernelArithmeticValidExpression *ve, GeogebraCommonKernelKernel *kernel);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_internalizeInput(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static NSString *GeogebraCommonKernelGeosGeoCasCell_localizeInputWithNSString_withGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *input1, GeogebraCommonKernelStringTemplate *tpl);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_setAssignmentVarWithNSString_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *var);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_changeAssignmentVarWithNSString_withNSString_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *oldLabel, NSString *newLabel);

__attribute__((unused)) static JavaUtilTreeSet *GeogebraCommonKernelGeosGeoCasCell_getInVars(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static JavaUtilTreeSet *GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_clearInVars(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static JavaUtilTreeSet *GeogebraCommonKernelGeosGeoCasCell_updateInputGeoElementsWithJavaUtilTreeSet_(GeogebraCommonKernelGeosGeoCasCell *self, JavaUtilTreeSet *inputVars);

__attribute__((unused)) static GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_resolveInputReferencesWithGeogebraCommonKernelArithmeticValidExpression_withJavaUtilTreeSet_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *ve, JavaUtilTreeSet *inputGeos);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_resolveFunctionVariableReferencesWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelArithmeticValidExpression *outputVE);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_resolveGeoElementReferencesWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *outVE);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoCasCell_includesOnlyDefinedVariablesWithBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean ignoreUndefinedXY);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoCasCell_includesNumericCommand(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *cmd);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_createTwinGeoWithBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean allowFunction);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_setEquationMode(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_simpleUpdateTwinGeoWithBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean allowFunction);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoElement *GeogebraCommonKernelGeosGeoCasCell_silentEvalInGeoGebraWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *ve, jboolean allowFunction);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_computeOutputWithBoolean_withBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean doTwinGeoUpdate, jboolean allowFunction);

__attribute__((unused)) static GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_wrapPointListWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *arg);

__attribute__((unused)) static GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_wrapEvaluateWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *arg, jboolean forceWrapping);

__attribute__((unused)) static GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *ve);

__attribute__((unused)) static NSString *GeogebraCommonKernelGeosGeoCasCell_lhsWithGeogebraCommonKernelArithmeticExpressionValue_withNSString_(GeogebraCommonKernelGeosGeoCasCell *self, id<GeogebraCommonKernelArithmeticExpressionValue> arg, NSString *fallback);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_finalizeComputationWithBoolean_withNSString_withGeogebraCommonKernelCASException_withBoolean_withBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean success, NSString *result, GeogebraCommonKernelCASException *ce, jboolean doTwinGeoUpdate, jboolean allowFunction);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_setTwinGeoWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelGeosGeoElement *newTwinGeo);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoElement *geo);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_setInputVEWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *inputVE);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoCasCell_inequalityInEvalVE(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_clearStrings(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static NSString *GeogebraCommonKernelGeosGeoCasCell_getPlotVar(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static NSString *GeogebraCommonKernelGeosGeoCasCell_getOutputPrefix(GeogebraCommonKernelGeosGeoCasCell *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_updateDependentCellInput(GeogebraCommonKernelGeosGeoCasCell *self);

@interface GeogebraCommonKernelGeosGeoCasCell_$1 : NSObject < GeogebraCommonKernelArithmeticInspecting >

- (jboolean)checkWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v;

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelGeosGeoCasCell_$1)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_$1_init(GeogebraCommonKernelGeosGeoCasCell_$1 *self);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoCasCell_$1 *new_GeogebraCommonKernelGeosGeoCasCell_$1_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelGeosGeoCasCell_$1)

@interface GeogebraCommonKernelGeosGeoCasCell_$2 : NSObject < JavaUtilComparator >

- (jint)compareWithId:(NSString *)o1
               withId:(NSString *)o2;

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelGeosGeoCasCell_$2)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCasCell_$2_init(GeogebraCommonKernelGeosGeoCasCell_$2 *self);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoCasCell_$2 *new_GeogebraCommonKernelGeosGeoCasCell_$2_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelGeosGeoCasCell_$2)

@implementation GeogebraCommonKernelGeosGeoCasCell

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c {
  GeogebraCommonKernelGeosGeoCasCell_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
}

- (NSString *)getInputWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) isPrintLocalizedCommandNames]) {
    if (currentLanguage_ == nil || ![currentLanguage_ isEqual:[((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getLanguage]]) {
      GeogebraCommonKernelGeosGeoCasCell_updateLocalizedInputWithGeogebraCommonKernelStringTemplate_withNSString_(self, tpl, input_);
    }
    return localizedInput_;
  }
  return input_;
}

- (NSString *)getOutputWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (error_ != nil) {
    if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) isPrintLocalizedCommandNames]) {
      return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getErrorWithNSString:error_];
    }
    return error_;
  }
  if (outputVE_ == nil) {
    return @"";
  }
  return [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(outputVE_)) toAssignmentStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (NSString *)getOutputRHSWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (error_ != nil) {
    if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) isPrintLocalizedCommandNames]) {
      return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getErrorWithNSString:error_];
    }
    return error_;
  }
  if (outputVE_ == nil) {
    return @"";
  }
  return [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(outputVE_)) toStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (NSString *)getPrefix {
  return prefix_;
}

- (NSString *)getEvalText {
  if (evalVE_ == nil) {
    return @"";
  }
  return [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(evalVE_)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_xmlTemplate_()];
}

- (GeogebraCommonKernelArithmeticValidExpression *)getEvalVE {
  return evalVE_;
}

- (GeogebraCommonKernelArithmeticValidExpression *)getInputVE {
  return inputVE_;
}

- (NSString *)getPostfix {
  return postfix_;
}

- (NSString *)getLaTeXOutput {
  if ([self isError]) return nil;
  else if (latex_ == nil) {
    if (outputVE_ != nil) {
      JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_initWithNSString_(@"\\mathbf{") autorelease];
      if (nativeOutput_ || !([outputVE_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]])) {
        [sb appendWithNSString:[outputVE_ toAssignmentLaTeXStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelGeosGeoCasCell_includesNumericCommand(self) ? GeogebraCommonKernelStringTemplate_get_numericLatex_() : GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
      }
      else {
        GeogebraCommonKernelGeosGeoElement *geo = ((GeogebraCommonKernelGeosGeoElement *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(outputVE_, [GeogebraCommonKernelArithmeticExpressionNode class])) getLeft], [GeogebraCommonKernelGeosGeoElement class]));
        if (GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(self)) {
          [sb appendWithNSString:[self getAssignmentLHSWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
          if ([geo isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) {
            [sb appendWithChar:'('];
            [sb appendWithNSString:[((GeogebraCommonKernelGeosGeoFunction *) nil_chk(((GeogebraCommonKernelGeosGeoFunction *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoFunction class])))) getVarStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
            [sb appendWithChar:')'];
          }
          switch ([[outputVE_ getAssignmentType] ordinal]) {
            case GeogebraCommonKernelArithmeticAssignmentType_DEFAULT:
            [sb appendWithNSString:[((NSString *) nil_chk([outputVE_ getAssignmentOperator])) trim]];
            break;
            case GeogebraCommonKernelArithmeticAssignmentType_DELAYED:
            [sb appendWithNSString:[((NSString *) nil_chk([outputVE_ getDelayedAssignmentOperator])) trim]];
            break;
          }
        }
        if (!([geo isKindOfClass:[GeogebraCommonKernelGeosGeoLocus class]])) {
          [sb appendWithNSString:[((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
        }
        else {
          [sb appendWithNSString:[((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo))->algoParent_)) getCommandDescriptionWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
        }
      }
      [sb appendWithNSString:@"}"];
      GeogebraCommonKernelGeosGeoCasCell_set_latex_(self, [sb description]);
    }
  }
  return latex_;
}

- (jboolean)isUseAsText {
  return useAsText_;
}

- (void)setUseAsTextWithBoolean:(jboolean)val {
  useAsText_ = val;
  if (!val) {
    GeogebraCommonKernelGeosGeoCasCell_set_input_(self, [((GeogebraCommonKernelGeosGeoText *) nil_chk(self->commentText_)) getTextString]);
  }
  else {
    [((GeogebraCommonKernelGeosGeoText *) nil_chk(self->commentText_)) setTextStringWithNSString:input_];
  }
  suppressOutput__ = useAsText_;
  [self update];
}

- (void)setFontWithGeogebraCommonAwtGFont:(GeogebraCommonAwtGFont *)ft {
  [self setFontSizeMultiplierWithDouble:(jdouble) [((GeogebraCommonAwtGFont *) nil_chk(ft)) getSize] / (jdouble) [((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getApplication])) getFontSize]];
  [self setFontStyleWithInt:[ft getStyle]];
}

- (void)setFontStyleWithInt:(jint)style {
  [((GeogebraCommonKernelGeosGeoText *) nil_chk(commentText_)) setFontStyleWithInt:style];
}

- (GeogebraCommonAwtGColor *)getFontColor {
  return [self getObjectColor];
}

- (void)setFontColorWithGeogebraCommonAwtGColor:(GeogebraCommonAwtGColor *)c {
  [self setObjColorWithGeogebraCommonAwtGColor:c];
}

- (jint)getFontStyle {
  return [((GeogebraCommonKernelGeosGeoText *) nil_chk(commentText_)) getFontStyle];
}

- (void)setFontSizeMultiplierWithDouble:(jdouble)d {
  [((GeogebraCommonKernelGeosGeoText *) nil_chk(commentText_)) setFontSizeMultiplierWithDouble:d];
}

- (jdouble)getFontSizeMultiplier {
  return [((GeogebraCommonKernelGeosGeoText *) nil_chk(commentText_)) getFontSizeMultiplier];
}

- (void)setGeoTextWithGeogebraCommonKernelGeosGeoText:(GeogebraCommonKernelGeosGeoText *)gt {
  if (gt != nil) {
    GeogebraCommonKernelGeosGeoCasCell_set_commentText_(self, gt);
  }
}

- (GeogebraCommonKernelGeosGeoText *)getGeoText {
  return commentText_;
}

- (jboolean)isEmpty {
  return [self isInputEmpty] && [self isOutputEmpty];
}

- (jboolean)isInputEmpty {
  return [self getInputVE] == nil;
}

- (jboolean)isOutputEmpty {
  return outputVE_ == nil && error_ == nil;
}

- (jboolean)showOutput {
  return ![self isOutputEmpty] && !GeogebraCommonKernelGeosGeoCasCell_suppressOutput(self);
}

- (jboolean)suppressOutput {
  return GeogebraCommonKernelGeosGeoCasCell_suppressOutput(self);
}

- (jboolean)hasTwinGeo {
  return twinGeo_ != nil;
}

- (void)setInputFromTwinGeoWithBoolean:(jboolean)force {
  if (ignoreTwinGeoUpdate_ && !force) {
    return;
  }
  if (twinGeo_ != nil && [twinGeo_ isIndependent] && [twinGeo_ isLabelSet]) {
    NSString *assignmentStr = [twinGeo_ toCasAssignmentWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
    if (suppressOutput__) assignmentStr = JreStrcat("$C", assignmentStr, ';');
    NSString *evalCmd1 = evalCmd_;
    if ([self setInputWithNSString:assignmentStr]) {
      if ([((NSString *) nil_chk(evalCmd1)) isEqual:@"Numeric"]) {
        [self setProcessingInformationWithNSString:@"" withNSString:JreStrcat("$$C", @"Numeric[", [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(evalVE_)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()], ']') withNSString:@""];
      }
      GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(self, evalCmd1);
      GeogebraCommonKernelGeosGeoCasCell_computeOutputWithBoolean_withBoolean_(self, NO, NO);
      [self update];
    }
  }
}

- (jboolean)setInputWithNSString:(NSString *)inValue {
  return [self setInputWithNSString:inValue withBoolean:NO];
}

- (jboolean)setInputWithNSString:(NSString *)inValue
                     withBoolean:(jboolean)internalInput {
  if (useAsText_) {
    suppressOutput__ = YES;
    GeogebraCommonKernelGeosGeoCasCell_setInputVEWithGeogebraCommonKernelArithmeticValidExpression_(self, nil);
    [((GeogebraCommonKernelGeosGeoText *) nil_chk(self->commentText_)) setTextStringWithNSString:inValue != nil ? inValue : @""];
  }
  else {
    suppressOutput__ = [((NSString *) nil_chk(inValue)) hasSuffix:@";"];
    GeogebraCommonKernelGeosGeoCasCell_setInputVEWithGeogebraCommonKernelArithmeticValidExpression_(self, GeogebraCommonKernelGeosGeoCasCell_parseGeoGebraCASInputAndResolveDummyVarsWithNSString_(self, inValue));
  }
  GeogebraCommonKernelGeosGeoCasCell_set_input_(self, inValue != nil ? inValue : @"");
  GeogebraCommonKernelGeosGeoCasCell_set_prefix_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_set_evalVE_(self, [self getInputVE]);
  GeogebraCommonKernelGeosGeoCasCell_set_postfix_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_set_evalComment_(self, @"");
  [self setErrorWithNSString:nil];
  GeogebraCommonKernelGeosGeoCasCell_updateInputVariablesWithGeogebraCommonKernelArithmeticValidExpression_(self, [self getInputVE]);
  if (!internalInput) {
    GeogebraCommonKernelGeosGeoCasCell_internalizeInput(self);
  }
  GeogebraCommonKernelGeosGeoCasCell_updateLocalizedInputWithGeogebraCommonKernelStringTemplate_withNSString_(self, GeogebraCommonKernelStringTemplate_get_defaultTemplate_(), input_);
  firstComputeOutput_ = YES;
  if (![self isEmpty]) {
    [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) addToGeoSetWithCasCellsWithGeogebraCommonKernelGeosGeoCasCell:self];
  }
  return YES;
}

- (void)updateLocalizedInputWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                      withNSString:(NSString *)input1 {
  GeogebraCommonKernelGeosGeoCasCell_updateLocalizedInputWithGeogebraCommonKernelStringTemplate_withNSString_(self, tpl, input1);
}

- (void)setRowNumberWithInt:(jint)row {
  self->row_ = row;
}

- (jint)getRowNumber {
  return row_;
}

- (void)updateInputStringWithRowReferences {
  [self updateInputStringWithRowReferencesWithBoolean:NO];
}

- (void)updateInputStringWithRowReferencesWithBoolean:(jboolean)force {
  if (!includesRowReferences__ && !force) return;
  GeogebraCommonKernelGeosGeoCasCell_set_input_(self, [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) toAssignmentStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()]);
  GeogebraCommonKernelGeosGeoCasCell_updateLocalizedInputWithGeogebraCommonKernelStringTemplate_withNSString_(self, GeogebraCommonKernelStringTemplate_get_defaultTemplate_(), [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) toAssignmentStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
  if (suppressOutput__) {
    GeogebraCommonKernelGeosGeoCasCell_set_input_(self, JreStrcat("$C", input_, ';'));
    GeogebraCommonKernelGeosGeoCasCell_set_localizedInput_(self, JreStrcat("$C", localizedInput_, ';'));
  }
}

- (void)setProcessingInformationWithNSString:(NSString *)prefix
                                withNSString:(NSString *)evaluate
                                withNSString:(NSString *)postfix {
  NSString *eval = evaluate;
  NSString *postfix1 = postfix;
  NSString *prefix1 = prefix;
  GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_set_evalComment_(self, @"");
  if (prefix1 == nil) {
    prefix1 = @"";
  }
  if (postfix1 == nil) {
    postfix1 = @"";
  }
  if (GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(self)) {
    eval = JreStrcat("$$$", prefix1, eval, postfix1);
    prefix1 = @"";
    postfix1 = @"";
  }
  GeogebraCommonKernelGeosGeoCasCell_set_evalVE_(self, GeogebraCommonKernelGeosGeoCasCell_parseGeoGebraCASInputAndResolveDummyVarsWithNSString_(self, eval));
  if (inputVE_ != nil && [inputVE_ getLabel] != nil) {
    [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(evalVE_)) setLabelWithNSString:[inputVE_ getLabel]];
    [evalVE_ setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:[inputVE_ getAssignmentType]];
  }
  if (evalVE_ != nil) {
    GeogebraCommonKernelGeosGeoCasCell_set_evalVE_(self, GeogebraCommonKernelGeosGeoCasCell_resolveInputReferencesWithGeogebraCommonKernelArithmeticValidExpression_withJavaUtilTreeSet_(self, evalVE_, inGeos_));
    if ([((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(evalVE_)) isTopLevelCommand]) {
      GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(self, [((GeogebraCommonKernelArithmeticCommand *) nil_chk([evalVE_ getTopLevelCommand])) getName]);
    }
    GeogebraCommonKernelGeosGeoCasCell_set_prefix_(self, prefix1);
    GeogebraCommonKernelGeosGeoCasCell_set_postfix_(self, postfix1);
  }
  else {
    GeogebraCommonKernelGeosGeoCasCell_set_evalVE_(self, [self getInputVE]);
    GeogebraCommonKernelGeosGeoCasCell_set_prefix_(self, @"");
    GeogebraCommonKernelGeosGeoCasCell_set_postfix_(self, @"");
  }
}

- (jboolean)isStructurallyEqualToLocalizedInputWithNSString:(NSString *)newInput {
  if (localizedInput_ != nil && [localizedInput_ isEqual:newInput]) return YES;
  if (![((id<GeogebraCommonKernelGeoGebraCasInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getGeoGebraCAS])) isStructurallyEqualWithGeogebraCommonKernelArithmeticValidExpression:[self getInputVE] withNSString:newInput withGeogebraCommonKernelKernel:[self getKernel]]) {
    [self setErrorWithNSString:@"CAS.SelectionStructureError"];
    return NO;
  }
  return YES;
}

- (GeogebraCommonKernelArithmeticValidExpression *)parseGeoGebraCASInputAndResolveDummyVarsWithNSString:(NSString *)inValue {
  return GeogebraCommonKernelGeosGeoCasCell_parseGeoGebraCASInputAndResolveDummyVarsWithNSString_(self, inValue);
}

- (void)updateInputVariablesWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve {
  GeogebraCommonKernelGeosGeoCasCell_updateInputVariablesWithGeogebraCommonKernelArithmeticValidExpression_(self, ve);
}

+ (NSString *)getFunctionVariableWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve
                                                    withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  return GeogebraCommonKernelGeosGeoCasCell_getFunctionVariableWithGeogebraCommonKernelArithmeticValidExpression_withGeogebraCommonKernelKernel_(ve, kernel);
}

- (void)internalizeInput {
  GeogebraCommonKernelGeosGeoCasCell_internalizeInput(self);
}

- (NSString *)localizeInputWithNSString:(NSString *)input1
 withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return GeogebraCommonKernelGeosGeoCasCell_localizeInputWithNSString_withGeogebraCommonKernelStringTemplate_(self, input1, tpl);
}

- (void)setAssignmentVarWithNSString:(NSString *)var {
  GeogebraCommonKernelGeosGeoCasCell_setAssignmentVarWithNSString_(self, var);
}

- (void)changeAssignmentVarWithNSString:(NSString *)oldLabel
                           withNSString:(NSString *)newLabel {
  GeogebraCommonKernelGeosGeoCasCell_changeAssignmentVarWithNSString_withNSString_(self, oldLabel, newLabel);
}

- (JavaUtilTreeSet *)getInVars {
  return GeogebraCommonKernelGeosGeoCasCell_getInVars(self);
}

- (JavaUtilTreeSet *)getFunctionVars {
  return GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(self);
}

- (void)clearInVars {
  GeogebraCommonKernelGeosGeoCasCell_clearInVars(self);
}

- (NSString *)getInVarWithInt:(jint)n {
  if (invars_ == nil) return nil;
  id<JavaUtilIterator> it = [((JavaUtilTreeSet *) nil_chk(invars_)) iterator];
  jint pos = 0;
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    NSString *var = [it next];
    if (pos == n) return var;
    pos++;
  }
  return nil;
}

- (JavaUtilTreeSet *)getGeoElementVariables {
  if (inGeos_ == nil) {
    GeogebraCommonKernelGeosGeoCasCell_set_inGeos_(self, GeogebraCommonKernelGeosGeoCasCell_updateInputGeoElementsWithJavaUtilTreeSet_(self, invars_));
  }
  return inGeos_;
}

- (JavaUtilTreeSet *)updateInputGeoElementsWithJavaUtilTreeSet:(JavaUtilTreeSet *)inputVars {
  return GeogebraCommonKernelGeosGeoCasCell_updateInputGeoElementsWithJavaUtilTreeSet_(self, inputVars);
}

- (GeogebraCommonKernelArithmeticValidExpression *)resolveInputReferencesWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve
                                                                                                       withJavaUtilTreeSet:(JavaUtilTreeSet *)inputGeos {
  return GeogebraCommonKernelGeosGeoCasCell_resolveInputReferencesWithGeogebraCommonKernelArithmeticValidExpression_withJavaUtilTreeSet_(self, ve, inputGeos);
}

+ (void)resolveFunctionVariableReferencesWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)outputVE {
  GeogebraCommonKernelGeosGeoCasCell_resolveFunctionVariableReferencesWithGeogebraCommonKernelArithmeticValidExpression_(outputVE);
}

- (void)resolveGeoElementReferencesWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)outVE {
  GeogebraCommonKernelGeosGeoCasCell_resolveGeoElementReferencesWithGeogebraCommonKernelArithmeticValidExpression_(self, outVE);
}

- (jboolean)includesOnlyDefinedVariables {
  return GeogebraCommonKernelGeosGeoCasCell_includesOnlyDefinedVariablesWithBoolean_(self, NO);
}

- (jboolean)includesOnlyDefinedVariablesWithBoolean:(jboolean)ignoreUndefinedXY {
  return GeogebraCommonKernelGeosGeoCasCell_includesOnlyDefinedVariablesWithBoolean_(self, ignoreUndefinedXY);
}

- (jboolean)isInputVariableWithNSString:(NSString *)var {
  return invars_ != nil && [invars_ containsWithId:var];
}

- (jboolean)isFunctionVariableWithNSString:(NSString *)var {
  return functionvars_ != nil && [functionvars_ containsWithId:var];
}

- (NSString *)getFunctionVariable {
  if (functionvars_ != nil && ![functionvars_ isEmpty]) {
    return [functionvars_ first];
  }
  return nil;
}

- (jboolean)includesRowReferences {
  return includesRowReferences__;
}

- (jboolean)includesNumericCommand {
  return GeogebraCommonKernelGeosGeoCasCell_includesNumericCommand(self);
}

- (NSString *)getAssignmentVariable {
  return assignmentVar_;
}

- (jboolean)isAssignmentVariableDefined {
  return GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(self);
}

- (void)setEvalCommandWithNSString:(NSString *)cmd {
  GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(self, cmd);
}

- (void)setKeepInputUsedWithBoolean:(jboolean)keepInputUsed {
  if ([self getInputVE] != nil) [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) setKeepInputUsedWithBoolean:keepInputUsed];
  if (evalVE_ != nil) [evalVE_ setKeepInputUsedWithBoolean:keepInputUsed];
}

- (void)setEvalCommentWithNSString:(NSString *)comment {
  if (comment != nil) {
    GeogebraCommonKernelGeosGeoCasCell_set_evalComment_(self, comment);
  }
}

- (void)setOutputWithNSString:(NSString *)output
                  withBoolean:(jboolean)prependLabel {
  GeogebraCommonKernelGeosGeoCasCell_set_error_(self, nil);
  GeogebraCommonKernelGeosGeoCasCell_clearStrings(self);
  jboolean isFunctionDeclaration = GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(self) && functionvars_ != nil && ![functionvars_ isEmpty];
  if (nativeOutput_) {
    NSString *res = output;
    if (isFunctionDeclaration && prependLabel) {
      GeogebraCommonKernelGeosGeoCasCell_set_outputVE_(self, (GeogebraCommonKernelArithmeticValidExpression *) check_class_cast([((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_parseGeoGebraCASInputAndResolveDummyVarsWithNSString_(self, res))) traverseWithGeogebraCommonKernelArithmeticTraversing:GeogebraCommonKernelArithmeticTraversing_FunctionCreator_getCreator()], [GeogebraCommonKernelArithmeticValidExpression class]));
      JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
      [sb appendWithNSString:[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getLabelForAssignment]];
      switch ([[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getAssignmentType] ordinal]) {
        case GeogebraCommonKernelArithmeticAssignmentType_DEFAULT:
        [sb appendWithNSString:[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getAssignmentOperator]];
        break;
        case GeogebraCommonKernelArithmeticAssignmentType_DELAYED:
        [sb appendWithNSString:[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getDelayedAssignmentOperator]];
        break;
      }
      [sb appendWithNSString:GeogebraCommonKernelGeosGeoCasCell_includesNumericCommand(self) ? [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(outputVE_)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericDefault_()] : [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(outputVE_)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
      res = [sb description];
    }
    GeogebraCommonKernelArithmeticValidExpression *parsed = GeogebraCommonKernelGeosGeoCasCell_parseGeoGebraCASInputAndResolveDummyVarsWithNSString_(self, res);
    GeogebraCommonKernelGeosGeoCasCell_set_outputVE_(self, parsed == nil ? nil : (GeogebraCommonKernelArithmeticValidExpression *) check_class_cast([parsed traverseWithGeogebraCommonKernelArithmeticTraversing:GeogebraCommonKernelArithmeticTraversing_GgbVectRemover_getInstance()], [GeogebraCommonKernelArithmeticValidExpression class]));
    if (outputVE_ != nil) {
      GeogebraCommonKernelArithmeticTraversing_CommandReplacer *cr = GeogebraCommonKernelArithmeticTraversing_CommandReplacer_getReplacerWithGeogebraCommonMainApp_([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getApplication]);
      [outputVE_ traverseWithGeogebraCommonKernelArithmeticTraversing:cr];
      if (inputVE_ != nil) {
        if ([inputVE_ isTopLevelCommand] && [@"Vector" isEqual:[((GeogebraCommonKernelArithmeticCommand *) nil_chk([inputVE_ getTopLevelCommand])) getName]]) {
          GeogebraCommonKernelArithmeticExpressionNode *wrapped = [outputVE_ wrap];
          [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(wrapped)) setForceVector];
          GeogebraCommonKernelGeosGeoCasCell_set_outputVE_(self, wrapped);
        }
      }
    }
    else {
      [self setErrorWithNSString:@"CAS.GeneralErrorMessage"];
    }
  }
  if (isFunctionDeclaration) {
    GeogebraCommonKernelGeosGeoCasCell_resolveFunctionVariableReferencesWithGeogebraCommonKernelArithmeticValidExpression_(outputVE_);
    GeogebraCommonKernelGeosGeoCasCell_resolveGeoElementReferencesWithGeogebraCommonKernelArithmeticValidExpression_(self, outputVE_);
  }
  else if (GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(self)) {
    [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(outputVE_)) setLabelWithNSString:assignmentVar_];
    if (JavaLangCharacter_isLowerCaseWithChar_([((NSString *) nil_chk(assignmentVar_)) charAtWithInt:0])) {
      id<GeogebraCommonKernelArithmeticExpressionValue> ve = [outputVE_ unwrap];
      if ([ve isKindOfClass:[GeogebraCommonKernelArithmeticMyVecNode class]]) {
        GeogebraCommonKernelArithmeticMyVecNode *node = (GeogebraCommonKernelArithmeticMyVecNode *) check_class_cast(ve, [GeogebraCommonKernelArithmeticMyVecNode class]);
        [((GeogebraCommonKernelArithmeticMyVecNode *) nil_chk(node)) setCASVector];
      }
      else if ([ve isKindOfClass:[GeogebraCommonKernelArithmetic3DMyVec3DNode class]]) {
        GeogebraCommonKernelArithmetic3DMyVec3DNode *node3d = (GeogebraCommonKernelArithmetic3DMyVec3DNode *) check_class_cast(ve, [GeogebraCommonKernelArithmetic3DMyVec3DNode class]);
        [((GeogebraCommonKernelArithmetic3DMyVec3DNode *) nil_chk(node3d)) setCASVector];
      }
    }
  }
}

- (void)updateTwinGeoWithBoolean:(jboolean)allowFunction {
  ignoreTwinGeoUpdate_ = YES;
  if (firstComputeOutput_ && twinGeo_ == nil) {
    GeogebraCommonKernelGeosGeoCasCell_createTwinGeoWithBoolean_(self, allowFunction);
  }
  else {
    GeogebraCommonKernelGeosGeoCasCell_simpleUpdateTwinGeoWithBoolean_(self, allowFunction);
  }
  ignoreTwinGeoUpdate_ = NO;
}

- (void)createTwinGeoWithBoolean:(jboolean)allowFunction {
  GeogebraCommonKernelGeosGeoCasCell_createTwinGeoWithBoolean_(self, allowFunction);
}

- (void)setEquationMode {
  GeogebraCommonKernelGeosGeoCasCell_setEquationMode(self);
}

- (jboolean)setLabelOfTwinGeo {
  if (twinGeo_ == nil || [twinGeo_ isLabelSet] || !GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(self)) return NO;
  [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) removeCasCellLabelWithNSString:assignmentVar_];
  [((GeogebraCommonKernelGeosGeoElement *) nil_chk(twinGeo_)) setLabelWithNSString:assignmentVar_];
  [cons_ putCasCellLabelWithGeogebraCommonKernelGeosGeoCasCell:self withNSString:assignmentVar_];
  return YES;
}

- (void)simpleUpdateTwinGeoWithBoolean:(jboolean)allowFunction {
  GeogebraCommonKernelGeosGeoCasCell_simpleUpdateTwinGeoWithBoolean_(self, allowFunction);
}

- (void)updateCascade {
  [self update];
  GeogebraCommonUtilDebugLog_debugWithNSString_(JreStrcat("$$", @"updating", [self getLabelWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]));
  if (twinGeo_ != nil && !GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(twinGeo_)) {
    ignoreTwinGeoUpdate_ = YES;
    [twinGeo_ update];
    ignoreTwinGeoUpdate_ = NO;
    [self updateAlgoUpdateSetWithWithGeogebraCommonKernelGeosGeoElement:twinGeo_];
  }
  else if (algoUpdateSet_ != nil) {
    [algoUpdateSet_ updateAll];
  }
}

- (void)update {
  GeogebraCommonKernelGeosGeoCasCell_clearStrings(self);
  [super update];
}

- (GeogebraCommonKernelGeosGeoElement *)silentEvalInGeoGebraWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve
                                                                                                  withBoolean:(jboolean)allowFunction {
  return GeogebraCommonKernelGeosGeoCasCell_silentEvalInGeoGebraWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(self, ve, allowFunction);
}

- (void)computeOutput {
  if (!useAsText_) {
    if ([self getEvalVE] == nil) return;
    GeogebraCommonKernelGeosGeoCasCell_computeOutputWithBoolean_withBoolean_(self, [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getEvalVE])) getAssignmentType] != GeogebraCommonKernelArithmeticAssignmentTypeEnum_get_DELAYED(), NO);
  }
}

- (void)computeOutputWithBoolean:(jboolean)doTwinGeoUpdate
                     withBoolean:(jboolean)allowFunction {
  GeogebraCommonKernelGeosGeoCasCell_computeOutputWithBoolean_withBoolean_(self, doTwinGeoUpdate, allowFunction);
}

- (GeogebraCommonKernelArithmeticValidExpression *)wrapPointListWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)arg {
  return GeogebraCommonKernelGeosGeoCasCell_wrapPointListWithGeogebraCommonKernelArithmeticValidExpression_(self, arg);
}

- (GeogebraCommonKernelArithmeticValidExpression *)wrapEvaluateWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)arg
                                                                                                     withBoolean:(jboolean)forceWrapping {
  return GeogebraCommonKernelGeosGeoCasCell_wrapEvaluateWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(self, arg, forceWrapping);
}

- (GeogebraCommonKernelArithmeticValidExpression *)processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)ve {
  return GeogebraCommonKernelGeosGeoCasCell_processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression_(self, ve);
}

- (NSString *)lhsWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)arg
                                                      withNSString:(NSString *)fallback {
  return GeogebraCommonKernelGeosGeoCasCell_lhsWithGeogebraCommonKernelArithmeticExpressionValue_withNSString_(self, arg, fallback);
}

- (void)finalizeComputationWithBoolean:(jboolean)success
                          withNSString:(NSString *)result
  withGeogebraCommonKernelCASException:(GeogebraCommonKernelCASException *)ce
                           withBoolean:(jboolean)doTwinGeoUpdate
                           withBoolean:(jboolean)allowFunction {
  GeogebraCommonKernelGeosGeoCasCell_finalizeComputationWithBoolean_withNSString_withGeogebraCommonKernelCASException_withBoolean_withBoolean_(self, success, result, ce, doTwinGeoUpdate, allowFunction);
}

- (void)setErrorWithNSString:(NSString *)error {
  GeogebraCommonKernelGeosGeoCasCell_set_error_(self, error);
  GeogebraCommonKernelGeosGeoCasCell_clearStrings(self);
  GeogebraCommonKernelGeosGeoCasCell_set_outputVE_(self, nil);
}

- (jboolean)isError {
  return error_ != nil;
}

- (jboolean)isCircularDefinition {
  return isCircularDefinition__;
}

- (void)getElementOpenTagXMLWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"<cascell"];
  if (assignmentVar_ != nil) {
    [sb appendWithNSString:@" caslabel=\""];
    GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, assignmentVar_);
    [sb appendWithNSString:@"\" "];
  }
  [sb appendWithNSString:@">\n"];
}

- (void)getElementCloseTagXMLWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"</cascell>\n"];
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\t<cellPair>\n"];
  if (useAsText_) {
    [sb appendWithNSString:@"\t\t"];
    [sb appendWithNSString:@"<useAsText>\n"];
    [sb appendWithNSString:@"\t\t\t"];
    [sb appendWithNSString:@"<FontStyle"];
    [sb appendWithNSString:@" value=\""];
    [sb appendWithInt:[self getFontStyle]];
    [sb appendWithNSString:@"\" "];
    [sb appendWithNSString:@"/>\n"];
    [sb appendWithNSString:@"\t\t\t"];
    [sb appendWithNSString:@"<FontSizeM"];
    [sb appendWithNSString:@" value=\""];
    [sb appendWithDouble:[self getFontSizeMultiplier]];
    [sb appendWithNSString:@"\" "];
    [sb appendWithNSString:@"/>\n"];
    [sb appendWithNSString:@"\t\t\t"];
    [sb appendWithNSString:@"<FontColor"];
    [sb appendWithNSString:@" r=\""];
    [sb appendWithInt:[((GeogebraCommonAwtGColor *) nil_chk([self getFontColor])) getRed]];
    [sb appendWithNSString:@"\" "];
    [sb appendWithNSString:@" b=\""];
    [sb appendWithInt:[((GeogebraCommonAwtGColor *) nil_chk([self getFontColor])) getBlue]];
    [sb appendWithNSString:@"\" "];
    [sb appendWithNSString:@" g=\""];
    [sb appendWithInt:[((GeogebraCommonAwtGColor *) nil_chk([self getFontColor])) getGreen]];
    [sb appendWithNSString:@"\" "];
    [sb appendWithNSString:@"/>\n"];
    [sb appendWithNSString:@"\t\t"];
    [sb appendWithNSString:@"</useAsText>\n"];
  }
  if (![self isInputEmpty] || useAsText_ || (input_ != nil && ((jint) [input_ length]) > 0)) {
    [sb appendWithNSString:@"\t\t"];
    [sb appendWithNSString:@"<inputCell>\n"];
    [sb appendWithNSString:@"\t\t\t"];
    [sb appendWithNSString:@"<expression"];
    [sb appendWithNSString:@" value=\""];
    if (useAsText_) {
      GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, [((GeogebraCommonKernelGeosGeoText *) nil_chk(commentText_)) getTextString]);
      [sb appendWithNSString:@"\" "];
    }
    else {
      GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, input_);
      [sb appendWithNSString:@"\" "];
      if (evalVE_ != [self getInputVE]) {
        if (![@"" isEqual:prefix_]) {
          [sb appendWithNSString:@" prefix=\""];
          GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, prefix_);
          [sb appendWithNSString:@"\" "];
        }
        [sb appendWithNSString:@" eval=\""];
        GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, [self getEvalText]);
        [sb appendWithNSString:@"\" "];
        if (![@"" isEqual:postfix_]) {
          [sb appendWithNSString:@" postfix=\""];
          GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, postfix_);
          [sb appendWithNSString:@"\" "];
        }
        [sb appendWithNSString:@"evalCmd=\""];
        GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, evalCmd_);
        [sb appendWithNSString:@"\""];
      }
      if (pointList_) {
        [sb appendWithNSString:@" pointList=\"true\""];
      }
    }
    [sb appendWithNSString:@"/>\n"];
    [sb appendWithNSString:@"\t\t"];
    [sb appendWithNSString:@"</inputCell>\n"];
  }
  if (![self isOutputEmpty]) {
    [sb appendWithNSString:@"\t\t"];
    [sb appendWithNSString:@"<outputCell>\n"];
    [sb appendWithNSString:@"\t\t\t"];
    [sb appendWithNSString:@"<expression"];
    [sb appendWithNSString:@" value=\""];
    GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, [self getOutputWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_xmlTemplate_()]);
    [sb appendWithNSString:@"\""];
    if ([self isError]) {
      [sb appendWithNSString:@" error=\"true\""];
    }
    if ([self isNative]) {
      [sb appendWithNSString:@" native=\"true\""];
    }
    if (![@"" isEqual:evalCmd_]) {
      [sb appendWithNSString:@" evalCommand=\""];
      GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, evalCmd_);
      [sb appendWithNSString:@"\" "];
    }
    if (![@"" isEqual:evalComment_]) {
      [sb appendWithNSString:@" evalComment=\""];
      GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, evalComment_);
      [sb appendWithNSString:@"\" "];
    }
    [sb appendWithNSString:@"/>\n"];
    [sb appendWithNSString:@"\t\t"];
    [sb appendWithNSString:@"</outputCell>\n"];
  }
  [sb appendWithNSString:@"\t</cellPair>\n"];
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_CAS_CELL();
}

- (GeogebraCommonKernelGeosGeoElement *)copy__ {
  GeogebraCommonKernelGeosGeoCasCell *casCell = [new_GeogebraCommonKernelGeosGeoCasCell_initWithGeogebraCommonKernelConstruction_(cons_) autorelease];
  [casCell setWithGeogebraCommonKernelGeosGeoElement:self];
  return casCell;
}

- (jboolean)isDefined {
  return ![self isError];
}

- (void)setUndefined {
  [self setErrorWithNSString:@"CAS.GeneralErrorMessage"];
  if (twinGeo_ != nil) {
    [twinGeo_ setUndefined];
  }
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return outputVE_ != nil ? [outputVE_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl] : [self toStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (jboolean)showInAlgebraView {
  return NO;
}

- (jboolean)showInEuclidianView {
  return NO;
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)Geo {
  return NO;
}

- (NSString *)getLabelWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (assignmentVar_ != nil) {
    return [((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) printVariableNameWithNSString:assignmentVar_];
  }
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  switch ([[((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getStringType] ordinal]) {
    case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
    [sb appendWithNSString:@" ("];
    [sb appendWithNSString:outputVE_ == nil ? @"?" : [outputVE_ toStringWithGeogebraCommonKernelStringTemplate:tpl]];
    [sb appendWithNSString:@") "];
    break;
    default:
    if (row_ >= 0) {
      if ([tpl hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()]) {
        [sb appendWithNSString:@"\\$"];
      }
      else {
        [sb appendWithNSString:GeogebraCommonKernelArithmeticExpressionNodeConstants_get_CAS_ROW_REFERENCE_PREFIX_()];
      }
      [sb appendWithInt:row_ + 1];
    }
    break;
  }
  return [sb description];
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [self getLabelWithGeogebraCommonKernelStringTemplate:tpl];
}

- (jboolean)isGeoCasCell {
  return YES;
}

- (void)doRemove {
  if (assignmentVar_ != nil) {
    [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) removeCasCellLabelWithNSString:assignmentVar_];
    GeogebraCommonKernelGeosGeoCasCell_set_assignmentVar_(self, nil);
  }
  [super doRemove];
  [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) removeFromGeoSetWithCasCellsWithGeogebraCommonKernelGeosGeoCasCell:self];
  GeogebraCommonKernelGeosGeoCasCell_setTwinGeoWithGeogebraCommonKernelGeosGeoElement_(self, nil);
  if ([self isInConstructionList]) [cons_ updateCasCells];
}

- (void)setTwinGeoWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)newTwinGeo {
  GeogebraCommonKernelGeosGeoCasCell_setTwinGeoWithGeogebraCommonKernelGeosGeoElement_(self, newTwinGeo);
}

+ (jboolean)dependsOnDummyWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  return GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(geo);
}

- (GeogebraCommonKernelGeosGeoElement *)getTwinGeo {
  return twinGeo_;
}

- (jboolean)addToUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:(GeogebraCommonKernelAlgosAlgoElement *)algorithm {
  jboolean added = [super addToUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:algorithm];
  if (twinGeo_ != nil && [twinGeo_ isIndependent]) {
    [twinGeo_ addToUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:algorithm];
  }
  return added;
}

- (jboolean)removeFromUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:(GeogebraCommonKernelAlgosAlgoElement *)algorithm {
  jboolean removed = [super removeFromUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:algorithm];
  if (twinGeo_ != nil && [twinGeo_ isIndependent]) {
    [twinGeo_ removeFromUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:algorithm];
  }
  return removed;
}

- (GeogebraCommonKernelArithmeticValidExpression *)getOutputValidExpression {
  return outputVE_;
}

- (jboolean)isLaTeXDrawableGeo {
  return YES;
}

- (NSString *)getVarStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if ([[self getInputVE] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]]) {
    return [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast([self getInputVE], [GeogebraCommonKernelArithmeticFunctionNVar class])))) getVarStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  return @"";
}

- (GeogebraCommonKernelArithmeticMyList *)getFunctionVariableList {
  if ([[self getInputVE] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]]) {
    GeogebraCommonKernelArithmeticMyList *ml = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel_) autorelease];
    {
      IOSObjectArray *a__ = [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast([self getInputVE], [GeogebraCommonKernelArithmeticFunctionNVar class])))) getFunctionVariables];
      GeogebraCommonKernelArithmeticFunctionVariable * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
      GeogebraCommonKernelArithmeticFunctionVariable * const *e__ = b__ + a__->size_;
      while (b__ < e__) {
        GeogebraCommonKernelArithmeticFunctionVariable *fv = *b__++;
        [ml addListElementWithGeogebraCommonKernelArithmeticExpressionValue:fv];
      }
    }
    return ml;
  }
  return nil;
}

- (IOSObjectArray *)getFunctionVariables {
  if ([[self getInputVE] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]]) {
    return [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast([self getInputVE], [GeogebraCommonKernelArithmeticFunctionNVar class])))) getFunctionVariables];
  }
  return [IOSObjectArray arrayWithLength:0 type:GeogebraCommonKernelArithmeticFunctionVariable_class_()];
}

- (void)setInputVEWithGeogebraCommonKernelArithmeticValidExpression:(GeogebraCommonKernelArithmeticValidExpression *)inputVE {
  GeogebraCommonKernelGeosGeoCasCell_setInputVEWithGeogebraCommonKernelArithmeticValidExpression_(self, inputVE);
}

- (GeogebraCommonAwtGColor *)getAlgebraColor {
  if (twinGeo_ == nil) return GeogebraCommonAwtGColor_get_BLACK_();
  return [((GeogebraCommonKernelGeosGeoElement *) nil_chk(twinGeo_)) getAlgebraColor];
}

- (void)setNativeWithBoolean:(jboolean)b {
  nativeOutput_ = b;
}

- (jboolean)isNative {
  return nativeOutput_;
}

- (void)toggleTwinGeoEuclidianVisible {
  jboolean visible;
  if ([self hasTwinGeo]) {
    visible = (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(twinGeo_)) isEuclidianVisible] && [twinGeo_ isEuclidianShowable]);
  }
  else {
    if (outputVE_ == nil || ![self plot]) {
      return;
    }
    visible = ([self hasTwinGeo] && [((GeogebraCommonKernelGeosGeoElement *) nil_chk(twinGeo_)) isEuclidianShowable]);
  }
  if ([self hasTwinGeo]) {
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(twinGeo_)) setEuclidianVisibleWithBoolean:visible];
    [twinGeo_ updateVisualStyle];
  }
  [((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getApplication])) storeUndoInfo];
  [kernel_ notifyRepaint];
}

- (jboolean)plot {
  if ([self getEvalVE] == nil || [((NSString *) nil_chk(input_)) isEqual:@""]) {
    return NO;
  }
  else if ([self hasTwinGeo]) {
    return YES;
  }
  NSString *oldEvalComment = evalComment_;
  GeogebraCommonKernelArithmeticValidExpression *oldEvalVE = evalVE_;
  GeogebraCommonKernelArithmeticValidExpression *oldInputVE = [self getInputVE];
  NSString *oldAssignmentVar = assignmentVar_;
  GeogebraCommonKernelArithmeticAssignmentTypeEnum *oldOVEAssignmentType = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(outputVE_)) getAssignmentType];
  GeogebraCommonKernelArithmeticAssignmentTypeEnum *oldIVEAssignmentType = [self getInputVE] == nil ? [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(evalVE_)) getAssignmentType] : [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getAssignmentType];
  GeogebraCommonKernelGeosGeoCasCell_set_assignmentVar_(self, GeogebraCommonKernelGeosGeoCasCell_getPlotVar(self));
  [self adjustPointListWithBoolean:NO];
  self->firstComputeOutput_ = YES;
  GeogebraCommonKernelGeosGeoCasCell_computeOutputWithBoolean_withBoolean_(self, YES, YES);
  if (twinGeo_ != nil && !GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(twinGeo_)) [twinGeo_ setLabelWithNSString:nil];
  if (twinGeo_ != nil && [twinGeo_ getLabelSimple] != nil && [twinGeo_ isEuclidianShowable]) {
    NSString *twinGeoLabelSimple = [twinGeo_ getLabelSimple];
    GeogebraCommonKernelGeosGeoCasCell_changeAssignmentVarWithNSString_withNSString_(self, assignmentVar_, twinGeoLabelSimple);
    GeogebraCommonKernelArithmeticValidExpression *ex = (GeogebraCommonKernelArithmeticValidExpression *) check_class_cast([((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getEvalVE])) deepCopyWithGeogebraCommonKernelKernel:kernel_], [GeogebraCommonKernelArithmeticValidExpression class]);
    GeogebraCommonKernelArithmeticTraversing_CommandRemover *remover;
    if ([((NSString *) nil_chk(input_)) hasPrefix:@"Numeric["]) {
      remover = GeogebraCommonKernelArithmeticTraversing_CommandRemover_getRemoverWithNSStringArray_([IOSObjectArray arrayWithObjects:(id[]){ @"KeepInput", @"Evaluate" } count:2 type:NSString_class_()]);
    }
    else {
      remover = GeogebraCommonKernelArithmeticTraversing_CommandRemover_getRemoverWithNSStringArray_([IOSObjectArray arrayWithObjects:(id[]){ @"KeepInput", @"Evaluate", @"Numeric" } count:3 type:NSString_class_()]);
    }
    [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(ex)) traverseWithGeogebraCommonKernelArithmeticTraversing:remover];
    [ex setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:GeogebraCommonKernelArithmeticAssignmentTypeEnum_get_DEFAULT()];
    [ex setLabelWithNSString:[twinGeo_ getAssignmentLHSWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
    if ([twinGeo_ isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) {
      [ex traverseWithGeogebraCommonKernelArithmeticTraversing:GeogebraCommonKernelArithmeticTraversing_FunctionCreator_getCreator()];
    }
    [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getEvalVE])) setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:GeogebraCommonKernelArithmeticAssignmentTypeEnum_get_DEFAULT()];
    [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getEvalVE])) setLabelWithNSString:[twinGeo_ getAssignmentLHSWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
    jboolean wasKeepInputUsed = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(inputVE_)) isKeepInputUsed];
    jboolean wasNumericUsed = [((NSString *) nil_chk(evalCmd_)) isEqual:@"Numeric"];
    [self setInputWithNSString:[ex toAssignmentStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericDefault_()]];
    if (wasKeepInputUsed) {
      [inputVE_ setKeepInputUsedWithBoolean:YES];
      GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(self, @"KeepInput");
    }
    else if (wasNumericUsed) {
      [self setProcessingInformationWithNSString:@"" withNSString:JreStrcat("$$C", @"Numeric[", [inputVE_ toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()], ']') withNSString:@""];
      GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(self, @"Numeric");
    }
    GeogebraCommonKernelGeosGeoCasCell_computeOutputWithBoolean_withBoolean_(self, NO, NO);
    [self update];
    GeogebraCommonKernelGeosGeoCasCell_clearStrings(self);
    [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) addToConstructionListWithGeogebraCommonKernelAlgosConstructionElement:twinGeo_ withBoolean:YES];
  }
  else {
    GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$", @"Fail", oldEvalComment));
    if (twinGeo_ != nil && [twinGeo_ getLabelSimple] != nil) [twinGeo_ doRemove];
    GeogebraCommonKernelGeosGeoCasCell_set_assignmentVar_(self, oldAssignmentVar);
    [outputVE_ setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:oldOVEAssignmentType];
    [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getEvalVE])) setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:oldIVEAssignmentType];
    self->firstComputeOutput_ = YES;
    GeogebraCommonKernelGeosGeoCasCell_set_evalComment_(self, oldEvalComment);
    GeogebraCommonKernelGeosGeoCasCell_set_evalVE_(self, oldEvalVE);
    GeogebraCommonKernelGeosGeoCasCell_setInputVEWithGeogebraCommonKernelArithmeticValidExpression_(self, oldInputVE);
    GeogebraCommonKernelGeosGeoCasCell_computeOutputWithBoolean_withBoolean_(self, YES, NO);
    return NO;
  }
  return YES;
}

- (jboolean)inequalityInEvalVE {
  return GeogebraCommonKernelGeosGeoCasCell_inequalityInEvalVE(self);
}

- (void)clearStrings {
  GeogebraCommonKernelGeosGeoCasCell_clearStrings(self);
}

- (NSString *)getPlotVar {
  return GeogebraCommonKernelGeosGeoCasCell_getPlotVar(self);
}

- (void)setPointListWithBoolean:(jboolean)pointList2 {
  pointList_ = pointList2;
}

- (jboolean)hasCoords {
  return outputVE_ != nil && [outputVE_ hasCoords];
}

- (NSString *)getTooltipTextWithBoolean:(jboolean)colored
                            withBoolean:(jboolean)alwaysOn {
  if ([self isError]) return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getErrorWithNSString:error_];
  if (tooltip_ == nil && outputVE_ != nil) {
    GeogebraCommonKernelGeosGeoCasCell_set_tooltip_(self, [self getOutputWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
    GeogebraCommonKernelGeosGeoCasCell_set_tooltip_(self, [((NSString *) nil_chk(tooltip_)) replace:@"gGbSuM(" withSequence:@"\u03a3("]);
    GeogebraCommonKernelGeosGeoCasCell_set_tooltip_(self, [((NSString *) nil_chk(tooltip_)) replace:@"gGbInTeGrAl(" withSequence:@"\u222b("]);
    if (((jint) [((NSString *) nil_chk(tooltip_)) length]) > SCREEN_WIDTH_ && [tooltip_ indexOf:'{'] > -1) {
      jint listStart = [tooltip_ indexOf:'{'];
      JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_initWithInt_(((jint) [tooltip_ length]) + 20) autorelease];
      [sb appendWithNSString:[tooltip_ substring:0 endIndex:listStart + 1]];
      jint currLine = 0;
      for (jint i = listStart + 1; i < ((jint) [tooltip_ length]); i++) {
        if ([tooltip_ charAtWithInt:i] == ',') {
          jint nextComma = [tooltip_ indexOf:',' fromIndex:i + 1];
          if (nextComma == -1) nextComma = ((jint) [tooltip_ length]) - 1;
          if (currLine + (nextComma - i) > SCREEN_WIDTH_) {
            [sb appendWithNSString:@",\n"];
            currLine = 0;
            i++;
          }
        }
        currLine++;
        [sb appendWithChar:[tooltip_ charAtWithInt:i]];
      }
      GeogebraCommonKernelGeosGeoCasCell_set_tooltip_(self, [sb description]);
    }
    GeogebraCommonKernelGeosGeoCasCell_set_tooltip_(self, GeogebraCommonKernelGeosGeoElement_indicesToHTMLWithNSString_withBoolean_(tooltip_, YES));
  }
  return tooltip_;
}

- (NSString *)getCommandAndComment {
  if (![self showOutput]) return @"";
  JavaLangStringBuilder *evalCmdLocal = [new_JavaLangStringBuilder_init() autorelease];
  if (pointList_) {
    [evalCmdLocal appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getCommandWithNSString:@"PointList"]];
  }
  else if ([@"" isEqual:evalCmd_]) {
    return GeogebraCommonKernelGeosGeoCasCell_getOutputPrefix(self);
  }
  else if ([@"Numeric" isEqual:evalCmd_]) {
    return GeogebraCommonUtilUnicode_get_CAS_OUTPUT_NUMERIC_();
  }
  else if ([@"KeepInput" isEqual:evalCmd_]) {
    return GeogebraCommonUtilUnicode_get_CAS_OUTPUT_KEEPINPUT_();
  }
  else {
    [evalCmdLocal appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getCommandWithNSString:evalCmd_]];
  }
  if ([((NSString *) nil_chk(input_)) hasPrefix:[evalCmdLocal description]] || (localizedInput_ != nil && [localizedInput_ hasPrefix:[evalCmdLocal description]])) {
    return GeogebraCommonKernelGeosGeoCasCell_getOutputPrefix(self);
  }
  if (((jint) [((NSString *) nil_chk(evalComment_)) length]) > 0) {
    if ([evalCmdLocal length] != 0) {
      [evalCmdLocal appendWithNSString:@", "];
    }
    [evalCmdLocal appendWithNSString:evalComment_];
  }
  [evalCmdLocal appendWithNSString:@":"];
  return [evalCmdLocal description];
}

- (NSString *)getOutputPrefix {
  return GeogebraCommonKernelGeosGeoCasCell_getOutputPrefix(self);
}

- (jboolean)hasVariablesOrCommands {
  if ([self getGeoElementVariables] != nil) return YES;
  return inputVE_ != nil && [inputVE_ inspectWithGeogebraCommonKernelArithmeticInspecting:GeogebraCommonKernelArithmeticInspecting_CommandFinderEnum_get_INSTANCE()];
}

- (void)adjustPointListWithBoolean:(jboolean)onlySolutions {
  if ([((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(evalVE_)) isTopLevelCommand] && ([((NSString *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getPlotVar(self))) isEqual:assignmentVar_])) {
    NSString *cmd = [((GeogebraCommonKernelArithmeticCommand *) nil_chk([evalVE_ getTopLevelCommand])) getName];
    if (!GeogebraCommonKernelGeosGeoCasCell_inequalityInEvalVE(self) && (([((NSString *) nil_chk(cmd)) isEqual:@"Solutions"] || [cmd isEqual:@"CSolutions"] || [cmd isEqual:@"NSolutions"]) || (!onlySolutions && ([cmd isEqual:@"Solve"] || [cmd isEqual:@"CSolve"] || [cmd isEqual:@"NSolve"] || [cmd isEqual:@"Root"] || [cmd isEqual:@"ComplexRoot"])))) {
      if (!pointList_) {
        GeogebraCommonKernelGeosGeoCasCell_set_inputVE_(self, evalVE_);
      }
      pointList_ = YES;
    }
  }
}

- (void)updateDependentCellInput {
  GeogebraCommonKernelGeosGeoCasCell_updateDependentCellInput(self);
}

- (jint)getPrintDecimals {
  return 0;
}

- (jint)getPrintFigures {
  return 0;
}

- (void)setPrintDecimalsWithInt:(jint)printDecimals
                    withBoolean:(jboolean)update {
}

- (void)setPrintFiguresWithInt:(jint)printFigures
                   withBoolean:(jboolean)update {
}

- (jboolean)isSerifFont {
  return NO;
}

- (void)setSerifFontWithBoolean:(jboolean)serifFont {
}

- (jboolean)useSignificantFigures {
  return NO;
}

- (jboolean)justFontSize {
  return NO;
}

- (jboolean)isLaTeXTextCommand {
  return NO;
}

- (GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)getLastHitType {
  return GeogebraCommonKernelGeosGeoElement_HitTypeEnum_get_ON_FILLING();
}

- (void)dealloc {
  RELEASE_(inputVE_);
  RELEASE_(evalVE_);
  RELEASE_(outputVE_);
  RELEASE_(input_);
  RELEASE_(prefix_);
  RELEASE_(postfix_);
  RELEASE_(error_);
  RELEASE_(latex_);
  RELEASE_(localizedInput_);
  RELEASE_(currentLanguage_);
  RELEASE_(invars_);
  RELEASE_(functionvars_);
  RELEASE_(inGeos_);
  RELEASE_(twinGeo_);
  RELEASE_(lastOutputEvaluationGeo_);
  RELEASE_(commands_);
  RELEASE_(assignmentVar_);
  RELEASE_(evalCmd_);
  RELEASE_(evalComment_);
  RELEASE_(commentText_);
  RELEASE_(arbconst_);
  RELEASE_(expandedEvalVE_);
  RELEASE_(tooltip_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:", "GeoCasCell", NULL, 0x1, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "getInputWithGeogebraCommonKernelStringTemplate:", "getInput", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getOutputWithGeogebraCommonKernelStringTemplate:", "getOutput", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getOutputRHSWithGeogebraCommonKernelStringTemplate:", "getOutputRHS", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getPrefix", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getEvalText", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getEvalVE", NULL, "Lgeogebra.common.kernel.arithmetic.ValidExpression;", 0x1, NULL, NULL },
    { "getInputVE", NULL, "Lgeogebra.common.kernel.arithmetic.ValidExpression;", 0x1, NULL, NULL },
    { "getPostfix", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getLaTeXOutput", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "isUseAsText", NULL, "Z", 0x1, NULL, NULL },
    { "setUseAsTextWithBoolean:", "setUseAsText", "V", 0x1, NULL, NULL },
    { "setFontWithGeogebraCommonAwtGFont:", "setFont", "V", 0x1, NULL, NULL },
    { "setFontStyleWithInt:", "setFontStyle", "V", 0x1, NULL, NULL },
    { "getFontColor", NULL, "Lgeogebra.common.awt.GColor;", 0x1, NULL, NULL },
    { "setFontColorWithGeogebraCommonAwtGColor:", "setFontColor", "V", 0x1, NULL, NULL },
    { "getFontStyle", NULL, "I", 0x1, NULL, NULL },
    { "setFontSizeMultiplierWithDouble:", "setFontSizeMultiplier", "V", 0x1, NULL, NULL },
    { "getFontSizeMultiplier", NULL, "D", 0x1, NULL, NULL },
    { "setGeoTextWithGeogebraCommonKernelGeosGeoText:", "setGeoText", "V", 0x1, NULL, NULL },
    { "getGeoText", NULL, "Lgeogebra.common.kernel.geos.GeoText;", 0x1, NULL, NULL },
    { "isEmpty", NULL, "Z", 0x1, NULL, NULL },
    { "isInputEmpty", NULL, "Z", 0x1, NULL, NULL },
    { "isOutputEmpty", NULL, "Z", 0x1, NULL, NULL },
    { "showOutput", NULL, "Z", 0x1, NULL, NULL },
    { "suppressOutput", NULL, "Z", 0x2, NULL, NULL },
    { "hasTwinGeo", NULL, "Z", 0x1, NULL, NULL },
    { "setInputFromTwinGeoWithBoolean:", "setInputFromTwinGeo", "V", 0x1, NULL, NULL },
    { "setInputWithNSString:", "setInput", "Z", 0x1, NULL, NULL },
    { "setInputWithNSString:withBoolean:", "setInput", "Z", 0x1, NULL, NULL },
    { "updateLocalizedInputWithGeogebraCommonKernelStringTemplate:withNSString:", "updateLocalizedInput", "V", 0x2, NULL, NULL },
    { "setRowNumberWithInt:", "setRowNumber", "V", 0x11, NULL, NULL },
    { "getRowNumber", NULL, "I", 0x11, NULL, NULL },
    { "updateInputStringWithRowReferences", NULL, "V", 0x1, NULL, NULL },
    { "updateInputStringWithRowReferencesWithBoolean:", "updateInputStringWithRowReferences", "V", 0x1, NULL, NULL },
    { "setProcessingInformationWithNSString:withNSString:withNSString:", "setProcessingInformation", "V", 0x1, NULL, NULL },
    { "isStructurallyEqualToLocalizedInputWithNSString:", "isStructurallyEqualToLocalizedInput", "Z", 0x1, NULL, NULL },
    { "parseGeoGebraCASInputAndResolveDummyVarsWithNSString:", "parseGeoGebraCASInputAndResolveDummyVars", "Lgeogebra.common.kernel.arithmetic.ValidExpression;", 0x2, NULL, NULL },
    { "updateInputVariablesWithGeogebraCommonKernelArithmeticValidExpression:", "updateInputVariables", "V", 0x2, NULL, NULL },
    { "getFunctionVariableWithGeogebraCommonKernelArithmeticValidExpression:withGeogebraCommonKernelKernel:", "getFunctionVariable", "Ljava.lang.String;", 0xa, NULL, NULL },
    { "internalizeInput", NULL, "V", 0x2, NULL, NULL },
    { "localizeInputWithNSString:withGeogebraCommonKernelStringTemplate:", "localizeInput", "Ljava.lang.String;", 0x2, NULL, NULL },
    { "setAssignmentVarWithNSString:", "setAssignmentVar", "V", 0x2, NULL, NULL },
    { "changeAssignmentVarWithNSString:withNSString:", "changeAssignmentVar", "V", 0x2, NULL, NULL },
    { "getInVars", NULL, "Ljava.util.TreeSet;", 0x2, NULL, NULL },
    { "getFunctionVars", NULL, "Ljava.util.TreeSet;", 0x2, NULL, NULL },
    { "clearInVars", NULL, "V", 0x2, NULL, NULL },
    { "getInVarWithInt:", "getInVar", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getGeoElementVariables", NULL, "Ljava.util.TreeSet;", 0x1, NULL, NULL },
    { "updateInputGeoElementsWithJavaUtilTreeSet:", "updateInputGeoElements", "Ljava.util.TreeSet;", 0x2, NULL, NULL },
    { "resolveInputReferencesWithGeogebraCommonKernelArithmeticValidExpression:withJavaUtilTreeSet:", "resolveInputReferences", "Lgeogebra.common.kernel.arithmetic.ValidExpression;", 0x2, NULL, NULL },
    { "resolveFunctionVariableReferencesWithGeogebraCommonKernelArithmeticValidExpression:", "resolveFunctionVariableReferences", "V", 0xa, NULL, NULL },
    { "resolveGeoElementReferencesWithGeogebraCommonKernelArithmeticValidExpression:", "resolveGeoElementReferences", "V", 0x2, NULL, NULL },
    { "includesOnlyDefinedVariables", NULL, "Z", 0x11, NULL, NULL },
    { "includesOnlyDefinedVariablesWithBoolean:", "includesOnlyDefinedVariables", "Z", 0x11, NULL, NULL },
    { "isInputVariableWithNSString:", "isInputVariable", "Z", 0x11, NULL, NULL },
    { "isFunctionVariableWithNSString:", "isFunctionVariable", "Z", 0x11, NULL, NULL },
    { "getFunctionVariable", NULL, "Ljava.lang.String;", 0x11, NULL, NULL },
    { "includesRowReferences", NULL, "Z", 0x11, NULL, NULL },
    { "includesNumericCommand", NULL, "Z", 0x11, NULL, NULL },
    { "getAssignmentVariable", NULL, "Ljava.lang.String;", 0x11, NULL, NULL },
    { "isAssignmentVariableDefined", NULL, "Z", 0x11, NULL, NULL },
    { "setEvalCommandWithNSString:", "setEvalCommand", "V", 0x11, NULL, NULL },
    { "setKeepInputUsedWithBoolean:", "setKeepInputUsed", "V", 0x1, NULL, NULL },
    { "setEvalCommentWithNSString:", "setEvalComment", "V", 0x11, NULL, NULL },
    { "setOutputWithNSString:withBoolean:", "setOutput", "V", 0x1, NULL, NULL },
    { "updateTwinGeoWithBoolean:", "updateTwinGeo", "V", 0x1, NULL, NULL },
    { "createTwinGeoWithBoolean:", "createTwinGeo", "V", 0x2, NULL, NULL },
    { "setEquationMode", NULL, "V", 0x2, NULL, NULL },
    { "setLabelOfTwinGeo", NULL, "Z", 0x1, NULL, NULL },
    { "simpleUpdateTwinGeoWithBoolean:", "simpleUpdateTwinGeo", "V", 0x2, NULL, NULL },
    { "updateCascade", NULL, "V", 0x1, NULL, NULL },
    { "update", NULL, "V", 0x1, NULL, NULL },
    { "silentEvalInGeoGebraWithGeogebraCommonKernelArithmeticValidExpression:withBoolean:", "silentEvalInGeoGebra", "Lgeogebra.common.kernel.geos.GeoElement;", 0x2, NULL, NULL },
    { "computeOutput", NULL, "V", 0x11, NULL, NULL },
    { "computeOutputWithBoolean:withBoolean:", "computeOutput", "V", 0x2, NULL, NULL },
    { "wrapPointListWithGeogebraCommonKernelArithmeticValidExpression:", "wrapPointList", "Lgeogebra.common.kernel.arithmetic.ValidExpression;", 0x2, NULL, NULL },
    { "wrapEvaluateWithGeogebraCommonKernelArithmeticValidExpression:withBoolean:", "wrapEvaluate", "Lgeogebra.common.kernel.arithmetic.ValidExpression;", 0x2, NULL, NULL },
    { "processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression:", "processSolveCommand", "Lgeogebra.common.kernel.arithmetic.ValidExpression;", 0x2, NULL, NULL },
    { "lhsWithGeogebraCommonKernelArithmeticExpressionValue:withNSString:", "lhs", "Ljava.lang.String;", 0x2, NULL, NULL },
    { "finalizeComputationWithBoolean:withNSString:withGeogebraCommonKernelCASException:withBoolean:withBoolean:", "finalizeComputation", "V", 0x2, NULL, NULL },
    { "setErrorWithNSString:", "setError", "V", 0x1, NULL, NULL },
    { "isError", NULL, "Z", 0x1, NULL, NULL },
    { "isCircularDefinition", NULL, "Z", 0x1, NULL, NULL },
    { "getElementOpenTagXMLWithJavaLangStringBuilder:", "getElementOpenTagXML", "V", 0x4, NULL, NULL },
    { "getElementCloseTagXMLWithJavaLangStringBuilder:", "getElementCloseTagXML", "V", 0x4, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "copy__", "copy", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "isDefined", NULL, "Z", 0x1, NULL, NULL },
    { "setUndefined", NULL, "V", 0x1, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "showInAlgebraView", NULL, "Z", 0x1, NULL, NULL },
    { "showInEuclidianView", NULL, "Z", 0x4, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x1, NULL, NULL },
    { "getLabelWithGeogebraCommonKernelStringTemplate:", "getLabel", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "isGeoCasCell", NULL, "Z", 0x1, NULL, NULL },
    { "doRemove", NULL, "V", 0x1, NULL, NULL },
    { "setTwinGeoWithGeogebraCommonKernelGeosGeoElement:", "setTwinGeo", "V", 0x2, NULL, NULL },
    { "dependsOnDummyWithGeogebraCommonKernelGeosGeoElement:", "dependsOnDummy", "Z", 0xa, NULL, NULL },
    { "getTwinGeo", NULL, "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "addToUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:", "addToUpdateSets", "Z", 0x1, NULL, NULL },
    { "removeFromUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:", "removeFromUpdateSets", "Z", 0x1, NULL, NULL },
    { "getOutputValidExpression", NULL, "Lgeogebra.common.kernel.arithmetic.ValidExpression;", 0x1, NULL, NULL },
    { "isLaTeXDrawableGeo", NULL, "Z", 0x1, NULL, NULL },
    { "getVarStringWithGeogebraCommonKernelStringTemplate:", "getVarString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getFunctionVariableList", NULL, "Lgeogebra.common.kernel.arithmetic.MyList;", 0x1, NULL, NULL },
    { "getFunctionVariables", NULL, "[Lgeogebra.common.kernel.arithmetic.FunctionVariable;", 0x1, NULL, NULL },
    { "setInputVEWithGeogebraCommonKernelArithmeticValidExpression:", "setInputVE", "V", 0x2, NULL, NULL },
    { "getAlgebraColor", NULL, "Lgeogebra.common.awt.GColor;", 0x1, NULL, NULL },
    { "setNativeWithBoolean:", "setNative", "V", 0x1, NULL, NULL },
    { "isNative", NULL, "Z", 0x1, NULL, NULL },
    { "toggleTwinGeoEuclidianVisible", NULL, "V", 0x1, NULL, NULL },
    { "plot", NULL, "Z", 0x1, NULL, NULL },
    { "inequalityInEvalVE", NULL, "Z", 0x2, NULL, NULL },
    { "clearStrings", NULL, "V", 0x2, NULL, NULL },
    { "getPlotVar", NULL, "Ljava.lang.String;", 0x2, NULL, NULL },
    { "setPointListWithBoolean:", "setPointList", "V", 0x1, NULL, NULL },
    { "hasCoords", NULL, "Z", 0x1, NULL, NULL },
    { "getTooltipTextWithBoolean:withBoolean:", "getTooltipText", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getCommandAndComment", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getOutputPrefix", NULL, "Ljava.lang.String;", 0x2, NULL, NULL },
    { "hasVariablesOrCommands", NULL, "Z", 0x1, NULL, NULL },
    { "adjustPointListWithBoolean:", "adjustPointList", "V", 0x1, NULL, NULL },
    { "updateDependentCellInput", NULL, "V", 0x2, NULL, NULL },
    { "getPrintDecimals", NULL, "I", 0x1, NULL, NULL },
    { "getPrintFigures", NULL, "I", 0x1, NULL, NULL },
    { "setPrintDecimalsWithInt:withBoolean:", "setPrintDecimals", "V", 0x1, NULL, NULL },
    { "setPrintFiguresWithInt:withBoolean:", "setPrintFigures", "V", 0x1, NULL, NULL },
    { "isSerifFont", NULL, "Z", 0x1, NULL, NULL },
    { "setSerifFontWithBoolean:", "setSerifFont", "V", 0x1, NULL, NULL },
    { "useSignificantFigures", NULL, "Z", 0x1, NULL, NULL },
    { "justFontSize", NULL, "Z", 0x1, NULL, NULL },
    { "isLaTeXTextCommand", NULL, "Z", 0x1, NULL, NULL },
    { "getLastHitType", NULL, "Lgeogebra.common.kernel.geos.GeoElement$HitType;", 0x11, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "ROW_REFERENCE_STATIC_", NULL, 0x19, "C", NULL, NULL, .constantValue.asUnichar = GeogebraCommonKernelGeosGeoCasCell_ROW_REFERENCE_STATIC },
    { "ROW_REFERENCE_DYNAMIC_", NULL, 0x19, "C", NULL, NULL, .constantValue.asUnichar = GeogebraCommonKernelGeosGeoCasCell_ROW_REFERENCE_DYNAMIC },
    { "PLOT_VAR_", NULL, 0x1a, "Ljava.lang.String;", &GeogebraCommonKernelGeosGeoCasCell_PLOT_VAR_, NULL,  },
    { "inputVE_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ValidExpression;", NULL, NULL,  },
    { "evalVE_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ValidExpression;", NULL, NULL,  },
    { "outputVE_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ValidExpression;", NULL, NULL,  },
    { "input_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "prefix_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "postfix_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "error_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "latex_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "localizedInput_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "currentLanguage_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "suppressOutput__", "suppressOutput", 0x2, "Z", NULL, NULL,  },
    { "invars_", NULL, 0x2, "Ljava.util.TreeSet;", NULL, "Ljava/util/TreeSet<Ljava/lang/String;>;",  },
    { "functionvars_", NULL, 0x2, "Ljava.util.TreeSet;", NULL, "Ljava/util/TreeSet<Ljava/lang/String;>;",  },
    { "inGeos_", NULL, 0x2, "Ljava.util.TreeSet;", NULL, "Ljava/util/TreeSet<Lgeogebra/common/kernel/geos/GeoElement;>;",  },
    { "isCircularDefinition__", "isCircularDefinition", 0x2, "Z", NULL, NULL,  },
    { "twinGeo_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoElement;", NULL, NULL,  },
    { "lastOutputEvaluationGeo_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoElement;", NULL, NULL,  },
    { "firstComputeOutput_", NULL, 0x2, "Z", NULL, NULL,  },
    { "ignoreTwinGeoUpdate_", NULL, 0x2, "Z", NULL, NULL,  },
    { "commands_", NULL, 0x2, "Ljava.util.HashSet;", NULL, "Ljava/util/HashSet<Lgeogebra/common/kernel/arithmetic/Command;>;",  },
    { "assignmentVar_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "includesRowReferences__", "includesRowReferences", 0x2, "Z", NULL, NULL,  },
    { "includesNumericCommand__", "includesNumericCommand", 0x2, "Z", NULL, NULL,  },
    { "useGeoGebraFallback_", NULL, 0x2, "Z", NULL, NULL,  },
    { "evalCmd_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "evalComment_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "row_", NULL, 0x2, "I", NULL, NULL,  },
    { "useAsText_", NULL, 0x2, "Z", NULL, NULL,  },
    { "commentText_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoText;", NULL, NULL,  },
    { "nativeOutput_", NULL, 0x2, "Z", NULL, NULL,  },
    { "ignoreSetAssignment_", NULL, 0x2, "Z", NULL, NULL,  },
    { "arbconst_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.MyArbitraryConstant;", NULL, NULL,  },
    { "expandedEvalVE_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ValidExpression;", NULL, NULL,  },
    { "pointList_", NULL, 0x2, "Z", NULL, NULL,  },
    { "tooltip_", NULL, 0x2, "Ljava.lang.String;", NULL, NULL,  },
    { "SCREEN_WIDTH_", NULL, 0x2, "I", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoCasCell = { 2, "GeoCasCell", "geogebra.common.kernel.geos", NULL, 0x1, 137, methods, 39, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoCasCell;
}

@end

void GeogebraCommonKernelGeosGeoCasCell_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoElement_initWithGeogebraCommonKernelConstruction_(self, c);
  self->suppressOutput__ = NO;
  self->row_ = -1;
  self->ignoreSetAssignment_ = NO;
  GeogebraCommonKernelGeosGeoCasCell_setAndConsume_arbconst_(self, new_GeogebraCommonKernelArithmeticMyArbitraryConstant_initWithGeogebraCommonKernelAlgosConstructionElement_(self));
  self->SCREEN_WIDTH_ = 80;
  GeogebraCommonKernelGeosGeoCasCell_set_input_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_set_localizedInput_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_setInputVEWithGeogebraCommonKernelArithmeticValidExpression_(self, nil);
  GeogebraCommonKernelGeosGeoCasCell_set_outputVE_(self, nil);
  GeogebraCommonKernelGeosGeoCasCell_set_prefix_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_set_evalVE_(self, nil);
  GeogebraCommonKernelGeosGeoCasCell_set_postfix_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_set_evalCmd_(self, @"");
  GeogebraCommonKernelGeosGeoCasCell_set_evalComment_(self, @"");
  self->useAsText_ = NO;
  GeogebraCommonKernelGeosGeoCasCell_setAndConsume_commentText_(self, new_GeogebraCommonKernelGeosGeoText_initWithGeogebraCommonKernelConstruction_withNSString_(c, @""));
  GeogebraCommonKernelGeosGeoCasCell_set_twinGeo_(self, nil);
}

GeogebraCommonKernelGeosGeoCasCell *new_GeogebraCommonKernelGeosGeoCasCell_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoCasCell *self = [GeogebraCommonKernelGeosGeoCasCell alloc];
  GeogebraCommonKernelGeosGeoCasCell_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

jboolean GeogebraCommonKernelGeosGeoCasCell_suppressOutput(GeogebraCommonKernelGeosGeoCasCell *self) {
  return self->suppressOutput__ && ![self isError];
}

void GeogebraCommonKernelGeosGeoCasCell_updateLocalizedInputWithGeogebraCommonKernelStringTemplate_withNSString_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelStringTemplate *tpl, NSString *input1) {
  GeogebraCommonKernelGeosGeoCasCell_set_currentLanguage_(self, [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getLanguage]);
  GeogebraCommonKernelGeosGeoCasCell_set_localizedInput_(self, GeogebraCommonKernelGeosGeoCasCell_localizeInputWithNSString_withGeogebraCommonKernelStringTemplate_(self, input1, tpl));
}

GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_parseGeoGebraCASInputAndResolveDummyVarsWithNSString_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *inValue) {
  @try {
    return [((id<GeogebraCommonKernelCASParserInterface>) nil_chk([((id<GeogebraCommonKernelGeoGebraCasInterface>) nil_chk(([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getGeoGebraCAS]))) getCASparser])) parseGeoGebraCASInputAndResolveDummyVarsWithNSString:inValue withGeogebraCommonKernelKernel:[self getKernel]];
  }
  @catch (GeogebraCommonKernelCASException *c) {
    [self setErrorWithNSString:[((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getErrorWithNSString:[((GeogebraCommonKernelCASException *) nil_chk(c)) getKey]]];
    return nil;
  }
  @catch (JavaLangThrowable *e) {
    return nil;
  }
}

void GeogebraCommonKernelGeosGeoCasCell_updateInputVariablesWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *ve) {
  GeogebraCommonKernelGeosGeoCasCell_clearInVars(self);
  if (ve == nil || self->useAsText_) return;
  GeogebraCommonKernelGeosGeoCasCell_setAndConsume_commands_(self, new_JavaUtilHashSet_init());
  [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(ve)) traverseWithGeogebraCommonKernelArithmeticTraversing:GeogebraCommonKernelArithmeticTraversing_CommandCollector_getCollectorWithJavaUtilSet_(self->commands_)];
  if ([self->commands_ isEmpty]) {
    GeogebraCommonKernelGeosGeoCasCell_set_commands_(self, nil);
  }
  else {
    for (GeogebraCommonKernelArithmeticCommand * __strong cmd in self->commands_) {
      NSString *cmdName = [((GeogebraCommonKernelArithmeticCommand *) nil_chk(cmd)) getName];
      self->includesNumericCommand__ = (self->includesNumericCommand__ || ([@"Numeric" isEqual:cmdName] && [cmd getArgumentNumber] > 1));
      if (![((id<GeogebraCommonKernelGeoGebraCasInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getGeoGebraCAS])) isCommandAvailableWithGeogebraCommonKernelArithmeticCommand:cmd]) {
        if ([self->kernel_ lookupCasCellLabelWithNSString:cmdName] != nil || [self->kernel_ lookupLabelWithNSString:cmdName] != nil) {
          [((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getInVars(self))) addWithId:cmdName];
        }
        else if ([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([self->kernel_ getAlgebraProcessor])) isCommandAvailableWithNSString:cmdName]) {
          self->useGeoGebraFallback_ = YES;
        }
        else {
          [((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getInVars(self))) addWithId:cmdName];
        }
      }
    }
  }
  self->useGeoGebraFallback_ = (self->useGeoGebraFallback_ || [ve inspectWithGeogebraCommonKernelArithmeticInspecting:GeogebraCommonKernelArithmeticInspecting_get_textFinder_()]);
  jboolean isFunction = [ve isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]];
  if ([ve isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]]) {
    {
      IOSObjectArray *a__ = [((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(ve, [GeogebraCommonKernelArithmeticFunctionNVar class])) getFunctionVariables];
      GeogebraCommonKernelArithmeticFunctionVariable * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
      GeogebraCommonKernelArithmeticFunctionVariable * const *e__ = b__ + a__->size_;
      while (b__ < e__) {
        GeogebraCommonKernelArithmeticFunctionVariable *fv = *b__++;
        [((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(self))) addWithId:[((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk(fv)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
      }
    }
  }
  JavaUtilHashSet *geoVars = [ve getVariables];
  if (geoVars != nil) {
    for (GeogebraCommonKernelGeosGeoElement * __strong geo in geoVars) {
      NSString *var = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getLabelWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
      if (isFunction && [((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(ve, [GeogebraCommonKernelArithmeticFunctionNVar class])) isFunctionVariableWithNSString:var]) {
        [((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(self))) addWithId:var];
      }
      else {
        [((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getInVars(self))) addWithId:var];
        [((JavaUtilTreeSet *) nil_chk([((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) getCASdummies])) addAllWithJavaUtilCollection:self->invars_];
      }
    }
  }
  switch ([[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getAssignmentType] ordinal]) {
    case GeogebraCommonKernelArithmeticAssignmentType_NONE:
    GeogebraCommonKernelGeosGeoCasCell_setAssignmentVarWithNSString_(self, nil);
    break;
    case GeogebraCommonKernelArithmeticAssignmentType_DEFAULT:
    GeogebraCommonKernelGeosGeoCasCell_setAssignmentVarWithNSString_(self, [ve getLabel]);
    break;
    case GeogebraCommonKernelArithmeticAssignmentType_DELAYED:
    GeogebraCommonKernelGeosGeoCasCell_setAssignmentVarWithNSString_(self, [ve getLabel]);
    break;
  }
  if ([ve getLabel] != nil && [((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(self))) isEmpty]) {
    NSString *var = GeogebraCommonKernelGeosGeoCasCell_getFunctionVariableWithGeogebraCommonKernelArithmeticValidExpression_withGeogebraCommonKernelKernel_(ve, [self getKernel]);
    if (var != nil) [((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(self))) addWithId:var];
  }
  GeogebraCommonKernelGeosGeoCasCell_set_inGeos_(self, GeogebraCommonKernelGeosGeoCasCell_updateInputGeoElementsWithJavaUtilTreeSet_(self, self->invars_));
  GeogebraCommonKernelGeosGeoCasCell_setInputVEWithGeogebraCommonKernelArithmeticValidExpression_(self, GeogebraCommonKernelGeosGeoCasCell_resolveInputReferencesWithGeogebraCommonKernelArithmeticValidExpression_withJavaUtilTreeSet_(self, [self getInputVE], self->inGeos_));
  self->isCircularDefinition__ = NO;
  if (self->inGeos_ != nil) {
    for (GeogebraCommonKernelGeosGeoElement * __strong inGeo in self->inGeos_) {
      if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(inGeo)) isChildOfWithGeogebraCommonKernelGeosGeoElement:self] || [self isEqual:inGeo]) {
        self->isCircularDefinition__ = YES;
        [self setErrorWithNSString:@"CircularDefinition"];
      }
    }
  }
}

NSString *GeogebraCommonKernelGeosGeoCasCell_getFunctionVariableWithGeogebraCommonKernelArithmeticValidExpression_withGeogebraCommonKernelKernel_(GeogebraCommonKernelArithmeticValidExpression *ve, GeogebraCommonKernelKernel *kernel) {
  GeogebraCommonKernelGeosGeoCasCell_initialize();
  if (![((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(ve)) isTopLevelCommand]) return nil;
  GeogebraCommonKernelArithmeticCommand *cmd = [ve getTopLevelCommand];
  if ([@"Derivative" isEqual:[((GeogebraCommonKernelArithmeticCommand *) nil_chk(cmd)) getName]]) {
    if ([cmd getArgumentNumber] > 1) {
      if (![((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cmd getArgumentWithInt:1])) isLeaf] || !([[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cmd getArgumentWithInt:1])) getLeft] isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]])) return nil;
      return [((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cmd getArgumentWithInt:1])) getLeft], [GeogebraCommonKernelGeosGeoElement class])))) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
    }
    id<JavaUtilIterator> it = [((JavaUtilHashSet *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cmd getArgumentWithInt:0])) getVariables])) iterator];
    while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
      GeogebraCommonKernelGeosGeoElement *em = [it next];
      if ([((GeogebraCommonKernelKernel *) nil_chk(kernel)) lookupLabelWithNSString:[((GeogebraCommonKernelGeosGeoElement *) nil_chk(em)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]] == nil) if ([GeogebraCommonKernelVarString_class_() isInstance:em]) {
        return [((id<GeogebraCommonKernelVarString>) check_protocol_cast(em, @protocol(GeogebraCommonKernelVarString))) getVarStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
      }
    }
  }
  return nil;
}

void GeogebraCommonKernelGeosGeoCasCell_internalizeInput(GeogebraCommonKernelGeosGeoCasCell *self) {
  GeogebraCommonKernelGeosGeoCasCell_set_input_(self, GeogebraCommonPluginScriptGgbScript_localizedScript2ScriptWithGeogebraCommonMainApp_withNSString_([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getApplication], self->input_));
}

NSString *GeogebraCommonKernelGeosGeoCasCell_localizeInputWithNSString_withGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *input1, GeogebraCommonKernelStringTemplate *tpl) {
  if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) isPrintLocalizedCommandNames]) {
    return GeogebraCommonPluginScriptGgbScript_script2LocalizedScriptWithGeogebraCommonMainApp_withNSString_([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getApplication], input1);
  }
  return input1;
}

void GeogebraCommonKernelGeosGeoCasCell_setAssignmentVarWithNSString_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *var) {
  if (self->ignoreSetAssignment_) {
    return;
  }
  if (self->assignmentVar_ != nil && [self->assignmentVar_ isEqual:var]) {
    return;
  }
  if (self->assignmentVar_ != nil) {
    [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) removeCasCellLabelWithNSString:self->assignmentVar_];
  }
  if (var == nil) {
    GeogebraCommonKernelGeosGeoCasCell_set_assignmentVar_(self, var);
  }
  else if ([((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) isFreeLabelWithNSString:var]) {
    if (!GeogebraCommonKernelGeosLabelManager_validVarWithNSString_(var)) {
      [self setErrorWithNSString:@"CAS.VariableIsDynamicReference"];
    }
    GeogebraCommonKernelGeosGeoCasCell_set_assignmentVar_(self, var);
  }
  else {
    GeogebraCommonKernelGeosGeoCasCell_changeAssignmentVarWithNSString_withNSString_(self, var, [self getDefaultLabel]);
  }
  if (self->assignmentVar_ != nil) {
    if (self->twinGeo_ != nil) {
      self->ignoreSetAssignment_ = YES;
      [self->twinGeo_ renameWithNSString:self->assignmentVar_];
    }
    GeogebraCommonKernelGeosGeoCasCell_updateDependentCellInput(self);
    [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) putCasCellLabelWithGeogebraCommonKernelGeosGeoCasCell:self withNSString:self->assignmentVar_];
  }
  else {
    GeogebraCommonKernelGeosGeoCasCell_setTwinGeoWithGeogebraCommonKernelGeosGeoElement_(self, nil);
  }
  self->ignoreSetAssignment_ = NO;
}

void GeogebraCommonKernelGeosGeoCasCell_changeAssignmentVarWithNSString_withNSString_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *oldLabel, NSString *newLabel) {
  if ([((NSString *) nil_chk(newLabel)) isEqual:oldLabel]) return;
  [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) setLabelWithNSString:newLabel];
  if (oldLabel != nil) {
    GeogebraCommonKernelGeosGeoCasCell_set_input_(self, [((NSString *) nil_chk(self->input_)) replaceFirst:oldLabel withReplacement:newLabel]);
    GeogebraCommonKernelGeosGeoCasCell_set_localizedInput_(self, [((NSString *) nil_chk(self->localizedInput_)) replaceFirst:oldLabel withReplacement:newLabel]);
  }
  GeogebraCommonKernelGeosGeoCasCell_set_assignmentVar_(self, newLabel);
}

JavaUtilTreeSet *GeogebraCommonKernelGeosGeoCasCell_getInVars(GeogebraCommonKernelGeosGeoCasCell *self) {
  if (self->invars_ == nil) GeogebraCommonKernelGeosGeoCasCell_setAndConsume_invars_(self, new_JavaUtilTreeSet_init());
  return self->invars_;
}

JavaUtilTreeSet *GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(GeogebraCommonKernelGeosGeoCasCell *self) {
  if (self->functionvars_ == nil) GeogebraCommonKernelGeosGeoCasCell_setAndConsume_functionvars_(self, new_JavaUtilTreeSet_init());
  return self->functionvars_;
}

void GeogebraCommonKernelGeosGeoCasCell_clearInVars(GeogebraCommonKernelGeosGeoCasCell *self) {
  GeogebraCommonKernelGeosGeoCasCell_set_invars_(self, nil);
  GeogebraCommonKernelGeosGeoCasCell_set_functionvars_(self, nil);
  self->includesRowReferences__ = NO;
  self->includesNumericCommand__ = NO;
  self->useGeoGebraFallback_ = NO;
}

JavaUtilTreeSet *GeogebraCommonKernelGeosGeoCasCell_updateInputGeoElementsWithJavaUtilTreeSet_(GeogebraCommonKernelGeosGeoCasCell *self, JavaUtilTreeSet *inputVars) {
  if (inputVars == nil || [inputVars isEmpty]) return nil;
  JavaUtilTreeSet *geoVars = [new_JavaUtilTreeSet_init() autorelease];
  for (NSString * __strong varLabel in nil_chk(inputVars)) {
    GeogebraCommonKernelGeosGeoElement *geo = [((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) lookupCasCellLabelWithNSString:varLabel];
    if (geo == nil) {
      if ([((NSString *) nil_chk(varLabel)) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_get_CAS_ROW_REFERENCE_PREFIX_()]) {
        geo = self->row_ > 0 ? [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) getCasCellWithInt:self->row_ - 1] : [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) getLastCasCell];
      }
      else {
        @try {
          geo = [self->kernel_ lookupCasRowReferenceWithNSString:varLabel];
        }
        @catch (GeogebraCommonKernelCASException *ex) {
          [self setErrorWithNSString:[((GeogebraCommonKernelCASException *) nil_chk(ex)) getKey]];
          return nil;
        }
      }
      if (geo != nil) {
        self->includesRowReferences__ = YES;
      }
    }
    if (geo == nil) {
      geo = [self->kernel_ lookupLabelWithNSString:varLabel];
      if (geo != nil && [geo getCorrespondingCasCell] != nil) {
        geo = [geo getCorrespondingCasCell];
      }
    }
    if (geo != nil) {
      [geoVars addWithId:geo];
    }
  }
  if ([geoVars size] == 0) {
    return nil;
  }
  return geoVars;
}

GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_resolveInputReferencesWithGeogebraCommonKernelArithmeticValidExpression_withJavaUtilTreeSet_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *ve, JavaUtilTreeSet *inputGeos) {
  if (ve == nil) {
    return ve;
  }
  GeogebraCommonKernelArithmeticAssignmentTypeEnum *assign = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(ve)) getAssignmentType];
  GeogebraCommonKernelArithmeticValidExpression *ret;
  GeogebraCommonKernelArithmeticExpressionNode *node;
  if ([ve isTopLevelCommand] && [((id<JavaUtilIterator>) nil_chk([((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(self))) iterator])) hasNext]) {
    GeogebraCommonUtilDebugLog_warnWithNSString_(@"wrong function syntax");
    IOSObjectArray *labels = [ve getLabels];
    if ([ve isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
      node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ve, [GeogebraCommonKernelArithmeticExpressionNode class]);
    }
    else {
      node = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, ve) autorelease];
    }
    ret = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(node, [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(self->kernel_, [((id<JavaUtilIterator>) nil_chk([((JavaUtilTreeSet *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_getFunctionVars(self))) iterator])) next]) autorelease]) autorelease];
    [ret setLabelsWithNSStringArray:labels];
  }
  else if ([ve isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]]) {
    node = [((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(ve, [GeogebraCommonKernelArithmeticFunctionNVar class])) getExpression];
    ret = ve;
  }
  else if ([ve isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
    node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(ve, [GeogebraCommonKernelArithmeticExpressionNode class]);
    ret = ve;
  }
  else {
    node = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, ve) autorelease];
    [node setLabelWithNSString:[ve getLabel]];
    ret = node;
  }
  if (inputGeos != nil) {
    for (GeogebraCommonKernelGeosGeoElement * __strong inGeo in inputGeos) {
      GeogebraCommonKernelArithmeticTraversing_GeoDummyReplacer *ge = GeogebraCommonKernelArithmeticTraversing_GeoDummyReplacer_getReplacerWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_([((GeogebraCommonKernelGeosGeoElement *) nil_chk(inGeo)) getLabelWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()], inGeo, NO);
      [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(node)) traverseWithGeogebraCommonKernelArithmeticTraversing:ge];
      if (![((GeogebraCommonKernelArithmeticTraversing_GeoDummyReplacer *) nil_chk(ge)) didReplacement]) {
        ge = GeogebraCommonKernelArithmeticTraversing_GeoDummyReplacer_getReplacerWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_(GeogebraCommonKernelArithmeticExpressionNodeConstants_get_CAS_ROW_REFERENCE_PREFIX_(), inGeo, NO);
        [node traverseWithGeogebraCommonKernelArithmeticTraversing:ge];
      }
    }
  }
  if (self->useGeoGebraFallback_) {
    if (!GeogebraCommonKernelGeosGeoCasCell_includesOnlyDefinedVariablesWithBoolean_(self, YES)) {
      self->useGeoGebraFallback_ = NO;
    }
  }
  [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(ret)) setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:assign];
  return ret;
}

void GeogebraCommonKernelGeosGeoCasCell_resolveFunctionVariableReferencesWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelArithmeticValidExpression *outputVE) {
  GeogebraCommonKernelGeosGeoCasCell_initialize();
  if (!([outputVE isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]])) return;
  GeogebraCommonKernelArithmeticFunctionNVar *fun = (GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(outputVE, [GeogebraCommonKernelArithmeticFunctionNVar class]);
  {
    IOSObjectArray *a__ = [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(fun)) getFunctionVariables];
    GeogebraCommonKernelArithmeticFunctionVariable * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    GeogebraCommonKernelArithmeticFunctionVariable * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      GeogebraCommonKernelArithmeticFunctionVariable *fVar = *b__++;
      [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([fun getExpression])) replaceVariablesWithNSString:[((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk(fVar)) getSetVarString] withGeogebraCommonKernelArithmeticFunctionVariable:fVar];
    }
  }
}

void GeogebraCommonKernelGeosGeoCasCell_resolveGeoElementReferencesWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *outVE) {
  if (self->invars_ == nil || !([outVE isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]])) return;
  GeogebraCommonKernelArithmeticFunctionNVar *fun = (GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(outVE, [GeogebraCommonKernelArithmeticFunctionNVar class]);
  for (NSString * __strong varLabel in nil_chk(self->invars_)) {
    GeogebraCommonKernelGeosGeoElement *geo = [((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) lookupLabelWithNSString:varLabel];
    if (geo != nil) {
      GeogebraCommonKernelArithmeticTraversing_GeoDummyReplacer *ge = GeogebraCommonKernelArithmeticTraversing_GeoDummyReplacer_getReplacerWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_(varLabel, geo, NO);
      [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(fun)) getExpression])) traverseWithGeogebraCommonKernelArithmeticTraversing:ge];
    }
  }
}

jboolean GeogebraCommonKernelGeosGeoCasCell_includesOnlyDefinedVariablesWithBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean ignoreUndefinedXY) {
  if (self->invars_ == nil) return YES;
  for (NSString * __strong varLabel in nil_chk(self->invars_)) {
    if (!(ignoreUndefinedXY && ([((NSString *) nil_chk(varLabel)) isEqual:@"x"] || [varLabel isEqual:@"y"]))) if ([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) lookupLabelWithNSString:varLabel] == nil) return NO;
  }
  return YES;
}

jboolean GeogebraCommonKernelGeosGeoCasCell_includesNumericCommand(GeogebraCommonKernelGeosGeoCasCell *self) {
  return self->includesNumericCommand__;
}

jboolean GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(GeogebraCommonKernelGeosGeoCasCell *self) {
  return self->assignmentVar_ != nil;
}

void GeogebraCommonKernelGeosGeoCasCell_setEvalCommandWithNSString_(GeogebraCommonKernelGeosGeoCasCell *self, NSString *cmd) {
  if ([@"Evaluate" isEqual:cmd]) {
    GeogebraCommonKernelGeosGeoCasCell_set_evalCmd_(self, @"");
    [self setKeepInputUsedWithBoolean:NO];
    return;
  }
  if ([@"Substitute" isEqual:cmd]) {
    GeogebraCommonKernelGeosGeoCasCell_updateInputVariablesWithGeogebraCommonKernelArithmeticValidExpression_(self, self->evalVE_);
  }
  GeogebraCommonKernelGeosGeoCasCell_set_evalCmd_(self, cmd);
  [self setKeepInputUsedWithBoolean:self->evalCmd_ != nil && [self->evalCmd_ isEqual:@"KeepInput"]];
}

void GeogebraCommonKernelGeosGeoCasCell_createTwinGeoWithBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean allowFunction) {
  if ([self isError]) return;
  if (!GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(self)) return;
  if ([self isNative] && ([[self getInputVE] isKindOfClass:[GeogebraCommonKernelArithmeticFunction class]]) && ([self->outputVE_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]])) {
    IOSObjectArray *labels = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->outputVE_)) getLabels];
    GeogebraCommonKernelGeosGeoCasCell_setAndConsume_outputVE_(self, new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->outputVE_, [GeogebraCommonKernelArithmeticExpressionNode class]), [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([self getInputVE], [GeogebraCommonKernelArithmeticFunction class])))) getFunctionVariable]));
    [self->outputVE_ setLabelsWithNSStringArray:labels];
    [self->outputVE_ setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getAssignmentType]];
  }
  else if ([self isNative] && ([[self getInputVE] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]]) && ([self->outputVE_ isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]])) {
    IOSObjectArray *labels = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->outputVE_)) getLabels];
    GeogebraCommonKernelGeosGeoCasCell_setAndConsume_outputVE_(self, new_GeogebraCommonKernelArithmeticFunctionNVar_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariableArray_((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->outputVE_, [GeogebraCommonKernelArithmeticExpressionNode class]), [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast([self getInputVE], [GeogebraCommonKernelArithmeticFunctionNVar class])))) getFunctionVariables]));
    [self->outputVE_ setLabelsWithNSStringArray:labels];
    [self->outputVE_ setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getAssignmentType]];
  }
  if ([((GeogebraCommonKernelParserCashandlersParserFunctions *) nil_chk([((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getApplication])) getParserFunctions])) isReservedWithNSString:self->assignmentVar_]) return;
  GeogebraCommonKernelArithmeticTraversing_ArbconstReplacer *repl = GeogebraCommonKernelArithmeticTraversing_ArbconstReplacer_getReplacerWithGeogebraCommonKernelArithmeticMyArbitraryConstant_(self->arbconst_);
  [((GeogebraCommonKernelArithmeticMyArbitraryConstant *) nil_chk(self->arbconst_)) reset];
  [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->outputVE_)) traverseWithGeogebraCommonKernelArithmeticTraversing:repl];
  GeogebraCommonKernelGeosGeoCasCell_setEquationMode(self);
  GeogebraCommonKernelGeosGeoElement *newTwinGeo = GeogebraCommonKernelGeosGeoCasCell_silentEvalInGeoGebraWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(self, self->outputVE_, allowFunction);
  if ([[self->outputVE_ unwrap] isKindOfClass:[GeogebraCommonKernelGeosGeoElement class]] && [GeogebraCommonKernelAlgosDrawInformationAlgo_class_() isInstance:[((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast([self->outputVE_ unwrap], [GeogebraCommonKernelGeosGeoElement class])))) getDrawAlgorithm]]) {
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(newTwinGeo)) setDrawAlgorithmWithGeogebraCommonKernelAlgosDrawInformationAlgo:(id<GeogebraCommonKernelAlgosDrawInformationAlgo>) check_protocol_cast([((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast([self->outputVE_ unwrap], [GeogebraCommonKernelGeosGeoElement class])))) getDrawAlgorithm], @protocol(GeogebraCommonKernelAlgosDrawInformationAlgo))];
  }
  if (newTwinGeo != nil && !GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(newTwinGeo)) {
    GeogebraCommonKernelGeosGeoCasCell_setTwinGeoWithGeogebraCommonKernelGeosGeoElement_(self, newTwinGeo);
    if ([self->twinGeo_ isKindOfClass:[GeogebraCommonKernelImplicitGeoImplicitPoly class]]) {
      [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(((GeogebraCommonKernelImplicitGeoImplicitPoly *) check_class_cast(self->twinGeo_, [GeogebraCommonKernelImplicitGeoImplicitPoly class])))) setInputForm];
    }
    if ([newTwinGeo isKindOfClass:[GeogebraCommonKernelGeosGeoNumeric class]]) {
      [newTwinGeo setLabelVisibleWithBoolean:YES];
    }
  }
}

void GeogebraCommonKernelGeosGeoCasCell_setEquationMode(GeogebraCommonKernelGeosGeoCasCell *self) {
  if (self->inputVE_ != nil && [[self->inputVE_ unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticEquation class]] && [self->inputVE_ inspectWithGeogebraCommonKernelArithmeticInspecting:[new_GeogebraCommonKernelGeosGeoCasCell_$1_init() autorelease]]) {
    if ([[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->outputVE_)) unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticEquation class]]) {
      [((GeogebraCommonKernelArithmeticEquation *) nil_chk(((GeogebraCommonKernelArithmeticEquation *) check_class_cast([self->outputVE_ unwrap], [GeogebraCommonKernelArithmeticEquation class])))) setForcePlane];
    }
  }
}

void GeogebraCommonKernelGeosGeoCasCell_simpleUpdateTwinGeoWithBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean allowFunction) {
  if (self->twinGeo_ == nil) {
    return;
  }
  else if ([self isError]) {
    [self->twinGeo_ setUndefined];
    return;
  }
  GeogebraCommonKernelArithmeticTraversing_ArbconstReplacer *repl = GeogebraCommonKernelArithmeticTraversing_ArbconstReplacer_getReplacerWithGeogebraCommonKernelArithmeticMyArbitraryConstant_(self->arbconst_);
  [((GeogebraCommonKernelArithmeticMyArbitraryConstant *) nil_chk(self->arbconst_)) reset];
  [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->outputVE_)) traverseWithGeogebraCommonKernelArithmeticTraversing:repl];
  GeogebraCommonKernelGeosGeoCasCell_setEquationMode(self);
  GeogebraCommonKernelGeosGeoCasCell_set_lastOutputEvaluationGeo_(self, GeogebraCommonKernelGeosGeoCasCell_silentEvalInGeoGebraWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(self, self->outputVE_, allowFunction));
  if (self->lastOutputEvaluationGeo_ != nil && !GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(self->lastOutputEvaluationGeo_)) {
    @try {
      if (GeogebraCommonKernelGeosTestEnum_canSetWithGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(self->twinGeo_, self->lastOutputEvaluationGeo_)) {
        [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->twinGeo_)) setWithGeogebraCommonKernelGeosGeoElement:self->lastOutputEvaluationGeo_];
      }
      else if (![self->lastOutputEvaluationGeo_ isDefined]) {
        [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->twinGeo_)) setUndefined];
      }
      else {
        GeogebraCommonKernelGeosGeoCasCell_set_twinGeo_(self, self->lastOutputEvaluationGeo_);
        [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) replaceWithGeogebraCommonKernelGeosGeoElement:self->twinGeo_ withGeogebraCommonKernelGeosGeoElement:self->lastOutputEvaluationGeo_];
      }
      if ([[self->outputVE_ unwrap] isKindOfClass:[GeogebraCommonKernelGeosGeoElement class]] && [GeogebraCommonKernelAlgosDrawInformationAlgo_class_() isInstance:[((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast([self->outputVE_ unwrap], [GeogebraCommonKernelGeosGeoElement class])))) getDrawAlgorithm]]) {
        [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->twinGeo_)) setDrawAlgorithmWithGeogebraCommonKernelAlgosDrawInformationAlgo:(id<GeogebraCommonKernelAlgosDrawInformationAlgo>) check_protocol_cast([((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast([self->outputVE_ unwrap], [GeogebraCommonKernelGeosGeoElement class])))) getDrawAlgorithm], @protocol(GeogebraCommonKernelAlgosDrawInformationAlgo))];
      }
    }
    @catch (JavaLangException *e) {
      [((JavaLangException *) nil_chk(e)) printStackTrace];
    }
  }
  else {
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->twinGeo_)) setUndefined];
    [self->twinGeo_ setAlgebraVisibleWithBoolean:NO];
    [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) removeFromConstructionListWithGeogebraCommonKernelAlgosConstructionElement:self->twinGeo_];
    return;
  }
  [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->twinGeo_)) update];
}

GeogebraCommonKernelGeosGeoElement *GeogebraCommonKernelGeosGeoCasCell_silentEvalInGeoGebraWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *ve, jboolean allowFunction) {
  if (!self->nativeOutput_ && [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->outputVE_)) isExpressionNode] && [[((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->outputVE_, [GeogebraCommonKernelArithmeticExpressionNode class])) getLeft] isKindOfClass:[GeogebraCommonKernelGeosGeoElement class]]) {
    GeogebraCommonKernelGeosGeoElement *ret = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(self->outputVE_, [GeogebraCommonKernelArithmeticExpressionNode class])) getLeft], [GeogebraCommonKernelGeosGeoElement class]);
    return ret;
  }
  jboolean wasFunction = [self->outputVE_ isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]];
  GeogebraCommonKernelArithmeticFunctionVariable *fvX = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(self->kernel_, @"x") autorelease];
  id<GeogebraCommonKernelArithmeticTraversing> variableReplacer = GeogebraCommonKernelArithmeticTraversing_VariableReplacer_getReplacerWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(@"x", fvX, self->kernel_);
  [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(ve)) traverseWithGeogebraCommonKernelArithmeticTraversing:variableReplacer];
  GeogebraCommonKernelArithmeticFunctionVariable *fvY = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(self->kernel_, @"y") autorelease];
  variableReplacer = GeogebraCommonKernelArithmeticTraversing_VariableReplacer_getReplacerWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(@"y", fvY, self->kernel_);
  [ve traverseWithGeogebraCommonKernelArithmeticTraversing:variableReplacer];
  if ([((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getApplication])) is3D]) {
    GeogebraCommonKernelArithmeticFunctionVariable *fvZ = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(self->kernel_, @"z") autorelease];
    variableReplacer = GeogebraCommonKernelArithmeticTraversing_VariableReplacer_getReplacerWithNSString_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelKernel_(@"z", fvZ, self->kernel_);
    [ve traverseWithGeogebraCommonKernelArithmeticTraversing:variableReplacer];
  }
  jboolean oldValue = [self->kernel_ isSilentMode];
  [self->kernel_ setSilentModeWithBoolean:YES];
  @try {
    GeogebraCommonKernelArithmeticExpressionNode *copy_ = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([ve deepCopyWithGeogebraCommonKernelKernel:self->kernel_])) wrap];
    [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(copy_)) setLabelWithNSString:[ve getLabel]];
    IOSObjectArray *ggbEval = [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([self->kernel_ getAlgebraProcessor])) doProcessValidExpressionWithGeogebraCommonKernelArithmeticValidExpression:copy_];
    if (ggbEval != nil) {
      if (!allowFunction && ([GeogebraCommonKernelArithmeticFunctionalNVar_class_() isInstance:IOSObjectArray_Get(ggbEval, 0)]) && !wasFunction) return nil;
      return IOSObjectArray_Get(ggbEval, 0);
    }
    return nil;
  }
  @catch (JavaLangThrowable *e) {
    [((JavaIoPrintStream *) nil_chk(JavaLangSystem_get_err_())) printlnWithNSString:JreStrcat("$@$$", @"GeoCasCell.silentEvalInGeoGebra: ", ve, @"\n\terror: ", [((JavaLangThrowable *) nil_chk(e)) getMessage])];
    return nil;
  }
  @finally {
    [self->kernel_ setSilentModeWithBoolean:oldValue];
  }
}

void GeogebraCommonKernelGeosGeoCasCell_computeOutputWithBoolean_withBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean doTwinGeoUpdate, jboolean allowFunction) {
  if (self->isCircularDefinition__) {
    [self setErrorWithNSString:@"CircularDefinition"];
    if (doTwinGeoUpdate) {
      [self updateTwinGeoWithBoolean:allowFunction];
    }
    return;
  }
  NSString *result = nil;
  jboolean success = NO;
  GeogebraCommonKernelCASException *ce = nil;
  self->nativeOutput_ = YES;
  if (self->inputVE_ != nil && [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getAssignmentType] == GeogebraCommonKernelArithmeticAssignmentTypeEnum_get_DELAYED()) {
    result = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self->inputVE_ wrap])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericNoLocal_()];
    success = (result != nil);
  }
  else if (!self->useGeoGebraFallback_) {
    @try {
      if (self->evalVE_ == nil) {
        @throw [new_GeogebraCommonKernelCASException_initWithNSString_(@"Invalid input (evalVE is null)") autorelease];
      }
      GeogebraCommonKernelArithmeticCommand *cmd = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->evalVE_)) getTopLevelCommand];
      jboolean isSubstitute = (cmd == nil) ? NO : [@"Substitute" isEqual:[cmd getName]];
      GeogebraCommonKernelGeosGeoCasCell_set_evalVE_(self, GeogebraCommonKernelGeosGeoCasCell_wrapEvaluateWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(self, self->evalVE_, isSubstitute && ![((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->inputVE_)) isKeepInputUsed]));
      if (GeogebraCommonKernelGeosGeoCasCell_isAssignmentVariableDefined(self)) {
        [self adjustPointListWithBoolean:YES];
      }
      GeogebraCommonKernelGeosGeoCasCell_set_expandedEvalVE_(self, self->pointList_ ? GeogebraCommonKernelGeosGeoCasCell_wrapPointListWithGeogebraCommonKernelArithmeticValidExpression_(self, self->evalVE_) : self->evalVE_);
      if (!([self->expandedEvalVE_ isTopLevelCommand]) || ![((NSString *) nil_chk([((GeogebraCommonKernelArithmeticCommand *) nil_chk([self->expandedEvalVE_ getTopLevelCommand])) getName])) isEqual:@"Delete"]) {
        GeogebraCommonKernelArithmeticTraversing_FunctionExpander *fex = GeogebraCommonKernelArithmeticTraversing_FunctionExpander_getCollector();
        GeogebraCommonKernelGeosGeoCasCell_set_expandedEvalVE_(self, (GeogebraCommonKernelArithmeticValidExpression *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self->expandedEvalVE_ wrap])) getCopyWithGeogebraCommonKernelKernel:self->kernel_])) traverseWithGeogebraCommonKernelArithmeticTraversing:fex], [GeogebraCommonKernelArithmeticValidExpression class]));
        GeogebraCommonKernelGeosGeoCasCell_set_expandedEvalVE_(self, GeogebraCommonKernelGeosGeoCasCell_processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression_(self, self->expandedEvalVE_));
      }
      result = [((id<GeogebraCommonKernelGeoGebraCasInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getGeoGebraCAS])) evaluateGeoGebraCASWithGeogebraCommonKernelArithmeticValidExpression:self->expandedEvalVE_ withGeogebraCommonKernelArithmeticMyArbitraryConstant:self->arbconst_ withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericNoLocal_() withGeogebraCommonKernelKernel:self->kernel_];
      if (!isSubstitute && self->inputVE_ != nil && [self->inputVE_ isKeepInputUsed]) {
        result = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([self->inputVE_ wrap])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericNoLocal_()];
      }
      success = (result != nil);
    }
    @catch (GeogebraCommonKernelCASException *e) {
      GeogebraCommonMainApp_errorWithNSString_(JreStrcat("$@$$", @"GeoCasCell.computeOutput(), CAS eval: ", self->evalVE_, @"\n\terror: ", [((GeogebraCommonKernelCASException *) nil_chk(e)) getMessage]));
      success = NO;
      ce = e;
    }
    @catch (JavaLangException *e) {
      GeogebraCommonMainApp_errorWithNSString_(JreStrcat("$@$@", @"GeoCasCell.computeOutput(), CAS eval: ", self->evalVE_, @"\n\t ", e));
      success = NO;
      ce = [new_GeogebraCommonKernelCASException_initWithJavaLangThrowable_(e) autorelease];
    }
  }
  else {
    jboolean oldValue = [((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) isSilentMode];
    [self->kernel_ setSilentModeWithBoolean:YES];
    @try {
      IOSObjectArray *geos = [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([self->kernel_ getAlgebraProcessor])) processAlgebraCommandNoExceptionHandlingWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->evalVE_)) deepCopyWithGeogebraCommonKernelKernel:self->kernel_])) traverseWithGeogebraCommonKernelArithmeticTraversing:GeogebraCommonKernelArithmeticTraversing_CommandRemover_getRemoverWithNSStringArray_([IOSObjectArray arrayWithObjects:(id[]){ @"Numeric" } count:1 type:NSString_class_()])])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_maxPrecision_()] withBoolean:NO withBoolean:NO withBoolean:NO withBoolean:NO];
      if (geos != nil) {
        if (geos->size_ == 0 && [self->evalVE_ isTopLevelCommand] && [@"Delete" isEqual:[((GeogebraCommonKernelArithmeticCommand *) nil_chk([self->evalVE_ getTopLevelCommand])) getName]]) {
          geos = [IOSObjectArray arrayWithObjects:(id[]){ [new_GeogebraCommonKernelGeosGeoBoolean_initWithGeogebraCommonKernelConstruction_withBoolean_(self->cons_, YES) autorelease] } count:1 type:GeogebraCommonKernelGeosGeoElement_class_()];
        }
        success = YES;
        result = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 0))) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericNoLocal_()];
        GeogebraCommonKernelAlgosAlgoElement *parentAlgo = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 0))) getParentAlgorithm];
        if (parentAlgo != nil) {
          [parentAlgo remove];
          [parentAlgo setPrintedInXMLWithBoolean:NO];
        }
        GeogebraCommonKernelGeosGeoCasCell_setAndConsume_outputVE_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, IOSObjectArray_Get(geos, 0)));
        [self->outputVE_ setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([self getInputVE])) getAssignmentType]];
        self->nativeOutput_ = NO;
      }
    }
    @catch (JavaLangThrowable *th2) {
      [((JavaIoPrintStream *) nil_chk(JavaLangSystem_get_err_())) printlnWithNSString:JreStrcat("$@$$", @"GeoCasCell.computeOutput(), GeoGebra eval: ", self->evalVE_, @"\n error: ", [((JavaLangThrowable *) nil_chk(th2)) getMessage])];
      success = NO;
    }
    @finally {
      [self->kernel_ setSilentModeWithBoolean:oldValue];
    }
  }
  GeogebraCommonKernelGeosGeoCasCell_finalizeComputationWithBoolean_withNSString_withGeogebraCommonKernelCASException_withBoolean_withBoolean_(self, success, result, ce, doTwinGeoUpdate, allowFunction);
}

GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_wrapPointListWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *arg) {
  GeogebraCommonKernelArithmeticCommand *c = [new_GeogebraCommonKernelArithmeticCommand_initWithGeogebraCommonKernelKernel_withNSString_withBoolean_(self->kernel_, @"PointList", NO) autorelease];
  [c addArgumentWithGeogebraCommonKernelArithmeticExpressionNode:[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(arg)) wrap]];
  GeogebraCommonKernelArithmeticExpressionNode *expr = [c wrap];
  [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(expr)) setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:[arg getAssignmentType]];
  [expr setLabelWithNSString:[arg getLabel]];
  return expr;
}

GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_wrapEvaluateWithGeogebraCommonKernelArithmeticValidExpression_withBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *arg, jboolean forceWrapping) {
  if ([[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(arg)) unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticCommand class]] && !forceWrapping) {
    return arg;
  }
  if ([[arg unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
    GeogebraCommonKernelArithmeticExpressionNode *en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast([arg unwrap], [GeogebraCommonKernelArithmeticExpressionNode class]);
    if (([((GeogebraCommonPluginOperationEnum *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en)) getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_FUNCTION()] || [((GeogebraCommonPluginOperationEnum *) nil_chk([en getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_FUNCTION_NVAR()]) && [[en getLeft] isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
      GeogebraCommonKernelArithmeticExpressionNode *en2 = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast([en getLeft], [GeogebraCommonKernelArithmeticExpressionNode class]);
      if ([((GeogebraCommonPluginOperationEnum *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en2)) getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_DERIVATIVE()] && [[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([en getRight])) unwrap] isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]]) {
        return arg;
      }
    }
  }
  id<GeogebraCommonKernelArithmeticExpressionValue> argUnwrapped = [arg unwrap];
  GeogebraCommonKernelArithmeticExpressionNode *en;
  if ([arg isExpressionNode]) {
    en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(arg, [GeogebraCommonKernelArithmeticExpressionNode class]);
  }
  else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(argUnwrapped)) isExpressionNode]) {
    en = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(argUnwrapped, [GeogebraCommonKernelArithmeticExpressionNode class]);
  }
  else {
    en = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [arg unwrap], GeogebraCommonPluginOperationEnum_get_NO_OPERATION(), nil) autorelease];
  }
  GeogebraCommonKernelArithmeticCommand *c = [new_GeogebraCommonKernelArithmeticCommand_initWithGeogebraCommonKernelKernel_withNSString_withBoolean_(self->kernel_, @"Evaluate", NO) autorelease];
  [c addArgumentWithGeogebraCommonKernelArithmeticExpressionNode:en];
  GeogebraCommonKernelArithmeticExpressionNode *expr = [c wrap];
  [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(expr)) setAssignmentTypeWithGeogebraCommonKernelArithmeticAssignmentTypeEnum:[arg getAssignmentType]];
  [expr setLabelWithNSString:[arg getLabel]];
  return expr;
}

GeogebraCommonKernelArithmeticValidExpression *GeogebraCommonKernelGeosGeoCasCell_processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *ve) {
  if ((!([[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(ve)) unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticCommand class]]))) {
    return ve;
  }
  if ([((NSString *) nil_chk([((GeogebraCommonKernelArithmeticCommand *) nil_chk(((GeogebraCommonKernelArithmeticCommand *) check_class_cast([ve unwrap], [GeogebraCommonKernelArithmeticCommand class])))) getName])) isEqual:@"Numeric"]) {
    [((GeogebraCommonKernelArithmeticCommand *) nil_chk(((GeogebraCommonKernelArithmeticCommand *) check_class_cast([ve unwrap], [GeogebraCommonKernelArithmeticCommand class])))) setArgumentWithInt:0 withGeogebraCommonKernelArithmeticExpressionNode:[((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression_(self, [((GeogebraCommonKernelArithmeticCommand *) nil_chk(((GeogebraCommonKernelArithmeticCommand *) check_class_cast([ve unwrap], [GeogebraCommonKernelArithmeticCommand class])))) getArgumentWithInt:0]))) wrap]];
    return ve;
  }
  if (![((NSString *) nil_chk([((GeogebraCommonKernelArithmeticCommand *) nil_chk(((GeogebraCommonKernelArithmeticCommand *) check_class_cast([ve unwrap], [GeogebraCommonKernelArithmeticCommand class])))) getName])) isEqual:@"Solve"]) {
    return ve;
  }
  GeogebraCommonKernelArithmeticCommand *cmd = (GeogebraCommonKernelArithmeticCommand *) check_class_cast([ve unwrap], [GeogebraCommonKernelArithmeticCommand class]);
  GeogebraCommonKernelArithmeticMyList *arg = [[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticCommand *) nil_chk(cmd)) getArgumentWithInt:0])) unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]] ? (GeogebraCommonKernelArithmeticMyList *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cmd getArgumentWithInt:0])) unwrap], [GeogebraCommonKernelArithmeticMyList class]) : nil;
  if (arg != nil && [arg size] == 2) {
    NSString *lhs1 = GeogebraCommonKernelGeosGeoCasCell_lhsWithGeogebraCommonKernelArithmeticExpressionValue_withNSString_(self, [arg getListElementWithInt:0], @"@0");
    NSString *lhs2 = GeogebraCommonKernelGeosGeoCasCell_lhsWithGeogebraCommonKernelArithmeticExpressionValue_withNSString_(self, [arg getListElementWithInt:1], @"@1");
    if ([((NSString *) nil_chk(lhs1)) isEqual:lhs2]) {
      NSString *test = nil;
      @try {
        test = [((GeogebraCommonKernelParserParser *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getParser])) parseLabelWithNSString:lhs1];
      }
      @catch (JavaLangThrowable *t) {
      }
      if (test != nil && ![((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticEquation *) nil_chk(((GeogebraCommonKernelArithmeticEquation *) check_class_cast([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([arg getListElementWithInt:0])) unwrap], [GeogebraCommonKernelArithmeticEquation class])))) getRHS])) evaluatesToNumberWithBoolean:YES]) {
        GeogebraCommonKernelArithmeticEquation *merge = [new_GeogebraCommonKernelArithmeticEquation_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [((GeogebraCommonKernelArithmeticEquation *) nil_chk(((GeogebraCommonKernelArithmeticEquation *) check_class_cast([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([arg getListElementWithInt:0])) unwrap], [GeogebraCommonKernelArithmeticEquation class])))) getRHS], [((GeogebraCommonKernelArithmeticEquation *) nil_chk(((GeogebraCommonKernelArithmeticEquation *) check_class_cast([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([arg getListElementWithInt:1])) unwrap], [GeogebraCommonKernelArithmeticEquation class])))) getRHS]) autorelease];
        [cmd setArgumentWithInt:0 withGeogebraCommonKernelArithmeticExpressionNode:[merge wrap]];
      }
    }
  }
  if ([cmd getArgumentNumber] >= 2) {
    if ([[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cmd getArgumentWithInt:1])) unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]]) {
      GeogebraCommonKernelArithmeticMyList *argList = (GeogebraCommonKernelArithmeticMyList *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cmd getArgumentWithInt:1])) unwrap], [GeogebraCommonKernelArithmeticMyList class]);
      if ([((GeogebraCommonKernelArithmeticMyList *) nil_chk(argList)) size] == 1) {
        [cmd setArgumentWithInt:1 withGeogebraCommonKernelArithmeticExpressionNode:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([argList getItemWithInt:0])) wrap]];
      }
    }
    return [cmd wrap];
  }
  if ([cmd getArgumentNumber] == 0) {
    return [cmd wrap];
  }
  GeogebraCommonKernelArithmeticExpressionNode *en = [cmd getArgumentWithInt:0];
  id<JavaUtilSet> set = [new_JavaUtilTreeSet_initWithJavaUtilComparator_([new_GeogebraCommonKernelGeosGeoCasCell_$2_init() autorelease]) autorelease];
  [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cmd getArgumentWithInt:0])) traverseWithGeogebraCommonKernelArithmeticTraversing:GeogebraCommonKernelArithmeticTraversing_DummyVariableCollector_getCollectorWithJavaUtilSet_(set)];
  jint n = [[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en)) unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]] ? [((GeogebraCommonKernelArithmeticMyList *) nil_chk(((GeogebraCommonKernelArithmeticMyList *) check_class_cast([en unwrap], [GeogebraCommonKernelArithmeticMyList class])))) getLength] : 1;
  GeogebraCommonKernelArithmeticMyList *variables = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_withInt_(self->kernel_, n) autorelease];
  jint i = 0;
  id<JavaUtilIterator> ite = [set iterator];
  if (n == 1) {
    if ([((id<JavaUtilIterator>) nil_chk(ite)) hasNext]) {
      [cmd addArgumentWithGeogebraCommonKernelArithmeticExpressionNode:[((GeogebraCommonKernelGeosGeoDummyVariable *) [new_GeogebraCommonKernelGeosGeoDummyVariable_initWithGeogebraCommonKernelConstruction_withNSString_(self->cons_, [ite next]) autorelease]) wrap]];
    }
  }
  else {
    while (i < n && [((id<JavaUtilIterator>) nil_chk(ite)) hasNext]) {
      [variables addListElementWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelGeosGeoDummyVariable_initWithGeogebraCommonKernelConstruction_withNSString_(self->cons_, [((id<JavaUtilIterator>) nil_chk(ite)) next]) autorelease]];
      i++;
    }
    if ([variables size] > 0) {
      [cmd addArgumentWithGeogebraCommonKernelArithmeticExpressionNode:[variables wrap]];
    }
  }
  return [cmd wrap];
}

NSString *GeogebraCommonKernelGeosGeoCasCell_lhsWithGeogebraCommonKernelArithmeticExpressionValue_withNSString_(GeogebraCommonKernelGeosGeoCasCell *self, id<GeogebraCommonKernelArithmeticExpressionValue> arg, NSString *fallback) {
  return [[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(arg)) unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticEquation class]] ? [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticEquation *) nil_chk(((GeogebraCommonKernelArithmeticEquation *) check_class_cast([arg unwrap], [GeogebraCommonKernelArithmeticEquation class])))) getLHS])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()] : fallback;
}

void GeogebraCommonKernelGeosGeoCasCell_finalizeComputationWithBoolean_withNSString_withGeogebraCommonKernelCASException_withBoolean_withBoolean_(GeogebraCommonKernelGeosGeoCasCell *self, jboolean success, NSString *result, GeogebraCommonKernelCASException *ce, jboolean doTwinGeoUpdate, jboolean allowFunction) {
  if (success) {
    if (((jint) [((NSString *) nil_chk(self->prefix_)) length]) == 0 && ((jint) [((NSString *) nil_chk(self->postfix_)) length]) == 0) {
      [self setOutputWithNSString:result withBoolean:YES];
    }
    else {
      JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
      [sb appendWithNSString:self->prefix_];
      [sb appendWithNSString:@" ("];
      [sb appendWithNSString:result];
      [sb appendWithNSString:@") "];
      [sb appendWithNSString:self->postfix_];
      [self setOutputWithNSString:[sb description] withBoolean:YES];
    }
  }
  else {
    if (ce == nil) {
      [self setErrorWithNSString:@"CAS.GeneralErrorMessage"];
    }
    else {
      [self setErrorWithNSString:[ce getKey]];
    }
  }
  if (doTwinGeoUpdate) {
    [self updateTwinGeoWithBoolean:allowFunction];
  }
  if (self->outputVE_ != nil && (!doTwinGeoUpdate || self->twinGeo_ == nil) && ![((GeogebraCommonKernelArithmeticAssignmentTypeEnum *) nil_chk([self->outputVE_ getAssignmentType])) isEqual:GeogebraCommonKernelArithmeticAssignmentTypeEnum_get_DELAYED()]) {
    GeogebraCommonKernelArithmeticTraversing_ArbconstReplacer *repl = GeogebraCommonKernelArithmeticTraversing_ArbconstReplacer_getReplacerWithGeogebraCommonKernelArithmeticMyArbitraryConstant_(self->arbconst_);
    [((GeogebraCommonKernelArithmeticMyArbitraryConstant *) nil_chk(self->arbconst_)) reset];
    [self->outputVE_ traverseWithGeogebraCommonKernelArithmeticTraversing:repl];
  }
  self->firstComputeOutput_ = NO;
  GeogebraCommonKernelGeosGeoCasCell_clearStrings(self);
}

void GeogebraCommonKernelGeosGeoCasCell_setTwinGeoWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelGeosGeoElement *newTwinGeo) {
  if (newTwinGeo == nil && self->twinGeo_ != nil) {
    GeogebraCommonKernelGeosGeoElement *oldTwinGeo = self->twinGeo_;
    GeogebraCommonKernelGeosGeoCasCell_set_twinGeo_(self, nil);
    [oldTwinGeo setCorrespondingCasCellWithGeogebraCommonKernelGeosGeoCasCell:nil];
    [oldTwinGeo doRemove];
  }
  GeogebraCommonKernelGeosGeoCasCell_set_twinGeo_(self, newTwinGeo);
  if (self->twinGeo_ == nil) {
    return;
  }
  [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->twinGeo_)) setCorrespondingCasCellWithGeogebraCommonKernelGeosGeoCasCell:self];
  [self->twinGeo_ setParentAlgorithmWithGeogebraCommonKernelAlgosAlgoElement:[self getParentAlgorithm]];
  if (GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(self->twinGeo_)) {
    [self->twinGeo_ setUndefined];
    [self->twinGeo_ setAlgebraVisibleWithBoolean:NO];
  }
  else {
    [self->twinGeo_ setAlgebraVisibleWithBoolean:YES];
  }
}

jboolean GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoElement *geo) {
  GeogebraCommonKernelGeosGeoCasCell_initialize();
  if ([geo isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]]) {
    GeogebraCommonKernelGeosGeoElement *subst = [((GeogebraCommonKernelGeosGeoDummyVariable *) nil_chk(((GeogebraCommonKernelGeosGeoDummyVariable *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoDummyVariable class])))) getElementWithSameName];
    if (subst != nil && !subst->sendValueToCas_) {
      return NO;
    }
    GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$@", @"DUMMY", geo));
    return YES;
  }
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoList]) {
    for (jint i = 0; i < [((GeogebraCommonKernelGeosGeoList *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoList class])) size]; i++) if (GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_([((GeogebraCommonKernelGeosGeoList *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoList class])) getWithInt:i])) {
      return YES;
    }
  }
  GeogebraCommonKernelAlgosAlgoElement *algo = [geo getParentAlgorithm];
  if (algo == nil || [geo getParentAlgorithm] == nil) {
    return NO;
  }
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk([((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(algo)) getInput]))->size_; i++) if (GeogebraCommonKernelGeosGeoCasCell_dependsOnDummyWithGeogebraCommonKernelGeosGeoElement_(IOSObjectArray_Get(nil_chk([algo getInput]), i))) {
    return YES;
  }
  return NO;
}

void GeogebraCommonKernelGeosGeoCasCell_setInputVEWithGeogebraCommonKernelArithmeticValidExpression_(GeogebraCommonKernelGeosGeoCasCell *self, GeogebraCommonKernelArithmeticValidExpression *inputVE) {
  GeogebraCommonKernelGeosGeoCasCell_set_inputVE_(self, inputVE);
}

jboolean GeogebraCommonKernelGeosGeoCasCell_inequalityInEvalVE(GeogebraCommonKernelGeosGeoCasCell *self) {
  if (self->expandedEvalVE_ == nil) return NO;
  return [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->expandedEvalVE_)) inspectWithGeogebraCommonKernelArithmeticInspecting:GeogebraCommonKernelArithmeticInspecting_IneqFinderEnum_get_INSTANCE()];
}

void GeogebraCommonKernelGeosGeoCasCell_clearStrings(GeogebraCommonKernelGeosGeoCasCell *self) {
  GeogebraCommonKernelGeosGeoCasCell_set_tooltip_(self, nil);
  GeogebraCommonKernelGeosGeoCasCell_set_latex_(self, nil);
}

NSString *GeogebraCommonKernelGeosGeoCasCell_getPlotVar(GeogebraCommonKernelGeosGeoCasCell *self) {
  jboolean isCasVector = NO;
  if (self->outputVE_ == nil) {
    return GeogebraCommonKernelGeosGeoCasCell_PLOT_VAR_;
  }
  id<GeogebraCommonKernelArithmeticExpressionValue> unwrapped = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(self->outputVE_)) unwrap];
  if (unwrapped == nil) {
    return GeogebraCommonKernelGeosGeoCasCell_PLOT_VAR_;
  }
  if ([unwrapped isKindOfClass:[GeogebraCommonKernelArithmeticMyVecNode class]]) {
    isCasVector = [((GeogebraCommonKernelArithmeticMyVecNode *) nil_chk(((GeogebraCommonKernelArithmeticMyVecNode *) check_class_cast(unwrapped, [GeogebraCommonKernelArithmeticMyVecNode class])))) evaluatesToVectorNotPoint];
  }
  else if ([unwrapped isKindOfClass:[GeogebraCommonKernelArithmetic3DMyVec3DNode class]]) {
    isCasVector = [((GeogebraCommonKernelArithmetic3DMyVec3DNode *) nil_chk(((GeogebraCommonKernelArithmetic3DMyVec3DNode *) check_class_cast(unwrapped, [GeogebraCommonKernelArithmetic3DMyVec3DNode class])))) evaluatesToVectorNotPoint];
  }
  if (isCasVector) {
    return [((NSString *) nil_chk(GeogebraCommonKernelGeosGeoCasCell_PLOT_VAR_)) lowercaseString];
  }
  return GeogebraCommonKernelGeosGeoCasCell_PLOT_VAR_;
}

NSString *GeogebraCommonKernelGeosGeoCasCell_getOutputPrefix(GeogebraCommonKernelGeosGeoCasCell *self) {
  if (((GeogebraCommonMainLocalization *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getLocalization]))->rightToLeftReadingOrder__) {
    return GeogebraCommonUtilUnicode_get_CAS_OUTPUT_PREFIX_RTL_();
  }
  return GeogebraCommonUtilUnicode_get_CAS_OUTPUT_PREFIX_();
}

void GeogebraCommonKernelGeosGeoCasCell_updateDependentCellInput(GeogebraCommonKernelGeosGeoCasCell *self) {
  id<JavaUtilList> algos = [self getAlgorithmList];
  if (algos != nil) {
    for (GeogebraCommonKernelAlgosAlgoElement * __strong algo in algos) {
      if ([GeogebraCommonKernelAlgoCasCellInterface_class_() isInstance:algo]) {
        id<GeogebraCommonKernelAlgoCasCellInterface> algoCell = (id<GeogebraCommonKernelAlgoCasCellInterface>) check_protocol_cast(algo, @protocol(GeogebraCommonKernelAlgoCasCellInterface));
        [((GeogebraCommonKernelGeosGeoCasCell *) nil_chk([((id<GeogebraCommonKernelAlgoCasCellInterface>) nil_chk(algoCell)) getCasCell])) updateInputStringWithRowReferencesWithBoolean:YES];
      }
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoCasCell)

@implementation GeogebraCommonKernelGeosGeoCasCell_$1

- (jboolean)checkWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v {
  return ([v isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] || [v isKindOfClass:[GeogebraCommonKernelGeosGeoDummyVariable class]]) && [@"z" isEqual:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(v)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
}

- (instancetype)init {
  GeogebraCommonKernelGeosGeoCasCell_$1_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "checkWithGeogebraCommonKernelArithmeticExpressionValue:", "check", "Z", 0x1, NULL, NULL },
    { "init", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "GeogebraCommonKernelGeosGeoCasCell", "setEquationMode" };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoCasCell_$1 = { 2, "", "geogebra.common.kernel.geos", "GeoCasCell", 0x8008, 2, methods, 0, NULL, 0, NULL, 0, NULL, &enclosing_method, NULL };
  return &_GeogebraCommonKernelGeosGeoCasCell_$1;
}

@end

void GeogebraCommonKernelGeosGeoCasCell_$1_init(GeogebraCommonKernelGeosGeoCasCell_$1 *self) {
  NSObject_init(self);
}

GeogebraCommonKernelGeosGeoCasCell_$1 *new_GeogebraCommonKernelGeosGeoCasCell_$1_init() {
  GeogebraCommonKernelGeosGeoCasCell_$1 *self = [GeogebraCommonKernelGeosGeoCasCell_$1 alloc];
  GeogebraCommonKernelGeosGeoCasCell_$1_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoCasCell_$1)

@implementation GeogebraCommonKernelGeosGeoCasCell_$2

- (jint)compareWithId:(NSString *)o1
               withId:(NSString *)o2 {
  if ([((NSString *) nil_chk(o1)) isEqual:o2]) return 0;
  if ([o1 isEqual:@"x"]) return -1;
  if ([((NSString *) nil_chk(o2)) isEqual:@"x"]) return 1;
  if ([o1 isEqual:@"y"]) return -1;
  if ([o2 isEqual:@"y"]) return 1;
  if ([o1 isEqual:@"z"]) return -1;
  if ([o2 isEqual:@"z"]) return 1;
  return [o1 compareToWithId:o2];
}

- (instancetype)init {
  GeogebraCommonKernelGeosGeoCasCell_$2_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "compareWithId:withId:", "compare", "I", 0x1, NULL, NULL },
    { "init", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "GeogebraCommonKernelGeosGeoCasCell", "processSolveCommandWithGeogebraCommonKernelArithmeticValidExpression:" };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoCasCell_$2 = { 2, "", "geogebra.common.kernel.geos", "GeoCasCell", 0x8008, 2, methods, 0, NULL, 0, NULL, 0, NULL, &enclosing_method, "Ljava/lang/Object;Ljava/util/Comparator<Ljava/lang/String;>;" };
  return &_GeogebraCommonKernelGeosGeoCasCell_$2;
}

@end

void GeogebraCommonKernelGeosGeoCasCell_$2_init(GeogebraCommonKernelGeosGeoCasCell_$2 *self) {
  NSObject_init(self);
}

GeogebraCommonKernelGeosGeoCasCell_$2 *new_GeogebraCommonKernelGeosGeoCasCell_$2_init() {
  GeogebraCommonKernelGeosGeoCasCell_$2 *self = [GeogebraCommonKernelGeosGeoCasCell_$2 alloc];
  GeogebraCommonKernelGeosGeoCasCell_$2_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoCasCell_$2)
