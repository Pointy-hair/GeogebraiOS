//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/commands/MacroProcessor.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Macro.h"
#include "geogebra/common/kernel/arithmetic/Command.h"
#include "geogebra/common/kernel/commands/CommandProcessor.h"
#include "geogebra/common/kernel/commands/MacroProcessor.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoPolygon.h"
#include "geogebra/common/kernel/geos/Test.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/main/MyError.h"
#include "java/lang/StringBuilder.h"

@implementation GeogebraCommonKernelCommandsMacroProcessor

- (instancetype)initWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  GeogebraCommonKernelCommandsMacroProcessor_initWithGeogebraCommonKernelKernel_(self, kernel);
  return self;
}

- (IOSObjectArray *)processWithGeogebraCommonKernelArithmeticCommand:(GeogebraCommonKernelArithmeticCommand *)c {
  IOSObjectArray *arg = [self resArgsWithGeogebraCommonKernelArithmeticCommand:c];
  GeogebraCommonKernelMacro *macro = [((GeogebraCommonKernelArithmeticCommand *) nil_chk(c)) getMacro];
  IOSObjectArray *macroInputTypes = [((GeogebraCommonKernelMacro *) nil_chk(macro)) getInputTypes];
  if (((IOSObjectArray *) nil_chk(arg))->size_ != ((IOSObjectArray *) nil_chk(macroInputTypes))->size_) {
    jboolean lengthOk = NO;
    if (arg->size_ > 0 && [((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(arg, 0))) isGeoPolygon]) {
      IOSObjectArray *points = [((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(((GeogebraCommonKernelGeosGeoPolygon *) check_class_cast(IOSObjectArray_Get(arg, 0), [GeogebraCommonKernelGeosGeoPolygon class])))) getPoints];
      arg = [IOSObjectArray arrayWithLength:((IOSObjectArray *) nil_chk(points))->size_ type:GeogebraCommonKernelGeosGeoElement_class_()];
      for (jint i = 0; i < points->size_; i++) IOSObjectArray_Set(arg, i, (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, i), [GeogebraCommonKernelGeosGeoElement class]));
      lengthOk = (arg->size_ == macroInputTypes->size_);
    }
    if (!lengthOk) {
      JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
      [sb appendWithNSString:JreStrcat("$C$$", [((GeogebraCommonMainLocalization *) nil_chk(loc_)) getMenuWithNSString:@"Macro"], ' ', [macro getCommandName], @":\n")];
      [sb appendWithNSString:JreStrcat("$$I", [loc_ getErrorWithNSString:@"IllegalArgumentNumber"], @": ", arg->size_)];
      [sb appendWithNSString:JreStrcat("$$", @"\n\nSyntax:\n", [macro description])];
      @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSString_(loc_, [sb description]) autorelease];
    }
  }
  for (jint i = 0; i < macroInputTypes->size_; i++) {
    if (![((GeogebraCommonKernelGeosTestEnum *) nil_chk(IOSObjectArray_Get(macroInputTypes, i))) checkWithId:IOSObjectArray_Get(arg, i)]) {
      JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
      [sb appendWithNSString:JreStrcat("$C$$", [((GeogebraCommonMainLocalization *) nil_chk(loc_)) getPlainWithNSString:@"Macro"], ' ', [macro getCommandName], @":\n")];
      [sb appendWithNSString:JreStrcat("$$", [loc_ getErrorWithNSString:@"IllegalArgument"], @": ")];
      [sb appendWithNSString:[((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(arg, i))) getNameDescription]];
      [sb appendWithNSString:JreStrcat("$$", @"\n\nSyntax:\n", [macro description])];
      @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSString_(loc_, [sb description]) autorelease];
    }
  }
  return [((GeogebraCommonKernelKernel *) nil_chk(kernelA_)) useMacroWithNSStringArray:[c getLabels] withGeogebraCommonKernelMacro:macro withGeogebraCommonKernelGeosGeoElementArray:arg];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelKernel:", "MacroProcessor", NULL, 0x1, NULL, NULL },
    { "processWithGeogebraCommonKernelArithmeticCommand:", "process", "[Lgeogebra.common.kernel.geos.GeoElement;", 0x1, "Lgeogebra.common.main.MyError;", NULL },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelCommandsMacroProcessor = { 2, "MacroProcessor", "geogebra.common.kernel.commands", NULL, 0x1, 2, methods, 0, NULL, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelCommandsMacroProcessor;
}

@end

void GeogebraCommonKernelCommandsMacroProcessor_initWithGeogebraCommonKernelKernel_(GeogebraCommonKernelCommandsMacroProcessor *self, GeogebraCommonKernelKernel *kernel) {
  GeogebraCommonKernelCommandsCommandProcessor_initWithGeogebraCommonKernelKernel_(self, kernel);
}

GeogebraCommonKernelCommandsMacroProcessor *new_GeogebraCommonKernelCommandsMacroProcessor_initWithGeogebraCommonKernelKernel_(GeogebraCommonKernelKernel *kernel) {
  GeogebraCommonKernelCommandsMacroProcessor *self = [GeogebraCommonKernelCommandsMacroProcessor alloc];
  GeogebraCommonKernelCommandsMacroProcessor_initWithGeogebraCommonKernelKernel_(self, kernel);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelCommandsMacroProcessor)
