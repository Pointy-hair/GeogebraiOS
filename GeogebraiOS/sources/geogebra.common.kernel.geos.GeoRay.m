//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/geos/GeoRay.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/PathMover.h"
#include "geogebra/common/kernel/PathMoverGeneric.h"
#include "geogebra/common/kernel/PathParameter.h"
#include "geogebra/common/kernel/Transform.h"
#include "geogebra/common/kernel/algos/AlgoConicPartCircumcircle.h"
#include "geogebra/common/kernel/algos/AlgoDirection.h"
#include "geogebra/common/kernel/algos/AlgoDispatcher.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoJoinPointsRay.h"
#include "geogebra/common/kernel/algos/AlgoRayPointVector.h"
#include "geogebra/common/kernel/algos/AlgoTranslate.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/geos/GeoConicPart.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoRay.h"
#include "geogebra/common/kernel/geos/GeoVec3D.h"
#include "geogebra/common/kernel/geos/GeoVector.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/kernelND/GeoRayND.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "java/lang/Double.h"
#include "java/lang/StringBuilder.h"

@interface GeogebraCommonKernelGeosGeoRay () {
 @public
  jboolean allowOutlyingIntersections__;
  jboolean keepTypeOnGeometricTransform_;
}

@end

@implementation GeogebraCommonKernelGeosGeoRay

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                    withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)A {
  GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoPoint_(self, c, A);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c {
  GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_RAY();
}

- (GeogebraCommonKernelGeosGeoElement *)copyInternalWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons1 {
  GeogebraCommonKernelGeosGeoRay *ray = [new_GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoPoint_(cons1, (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(startPoint_)) copyInternalWithGeogebraCommonKernelConstruction:cons1], [GeogebraCommonKernelGeosGeoPoint class])) autorelease];
  [ray setWithGeogebraCommonKernelGeosGeoElement:self];
  return ray;
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  [super setWithGeogebraCommonKernelGeosGeoElement:geo];
  if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoRay]) return;
  GeogebraCommonKernelGeosGeoRay *ray = (GeogebraCommonKernelGeosGeoRay *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoRay class]);
  keepTypeOnGeometricTransform_ = ray->keepTypeOnGeometricTransform_;
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(startPoint_)) setWithGeogebraCommonKernelGeosGeoElement:ray->startPoint_];
  if ([[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoJoinPointsRay class]] && [[geo getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoJoinPointsRay class]]) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([((GeogebraCommonKernelAlgosAlgoJoinPointsRay *) nil_chk(((GeogebraCommonKernelAlgosAlgoJoinPointsRay *) check_class_cast([self getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoJoinPointsRay class])))) getQ])) setWithGeogebraCommonKernelGeosGeoElement:[((GeogebraCommonKernelAlgosAlgoJoinPointsRay *) nil_chk(((GeogebraCommonKernelAlgosAlgoJoinPointsRay *) check_class_cast([geo getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoJoinPointsRay class])))) getQ]];
  }
  else if ([[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoRayPointVector class]] && [[geo getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoRayPointVector class]]) {
    [((GeogebraCommonKernelGeosGeoVector *) nil_chk([((GeogebraCommonKernelAlgosAlgoRayPointVector *) nil_chk(((GeogebraCommonKernelAlgosAlgoRayPointVector *) check_class_cast([self getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoRayPointVector class])))) getv])) setWithGeogebraCommonKernelGeosGeoElement:[((GeogebraCommonKernelAlgosAlgoRayPointVector *) nil_chk(((GeogebraCommonKernelAlgosAlgoRayPointVector *) check_class_cast([geo getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoRayPointVector class])))) getv]];
  }
}

- (void)setWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)s
           withGeogebraCommonKernelGeosGeoVec3D:(GeogebraCommonKernelGeosGeoVec3D *)direction {
  [super setWithGeogebraCommonKernelGeosGeoElement:direction];
  [self setStartPointWithGeogebraCommonKernelGeosGeoPoint:s];
}

- (void)setVisualStyleWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  [super setVisualStyleWithGeogebraCommonKernelGeosGeoElement:geo];
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoRay]) {
    GeogebraCommonKernelGeosGeoRay *ray = (GeogebraCommonKernelGeosGeoRay *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoRay class]);
    allowOutlyingIntersections__ = ray->allowOutlyingIntersections__;
  }
}

- (void)pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  [super pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
  GeogebraCommonKernelPathParameter *pp = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getPathParameter];
  if (((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_ < 0.0) {
    [P setCoords2DWithDouble:((GeogebraCommonKernelGeosGeoPoint *) nil_chk(startPoint_))->x_ withDouble:startPoint_->y_ withDouble:startPoint_->z_];
    [P updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:nil];
    pp->t_ = 0.0;
  }
}

- (void)pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  if (![((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) usePathAndRegionParametersWithGeogebraCommonKernelKernelNDGeoPointND:PI]) {
    [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:PI];
    return;
  }
  GeogebraCommonKernelGeosGeoPoint *P = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(PI, [GeogebraCommonKernelGeosGeoPoint class]);
  GeogebraCommonKernelPathParameter *pp = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P)) getPathParameter];
  if (((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_ < 0.0) {
    pp->t_ = 0;
  }
  P->x_ = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(startPoint_))->inhomX_ + pp->t_ * y_;
  P->y_ = startPoint_->inhomY_ - pp->t_ * x_;
  P->z_ = 1.0;
}

- (jboolean)allowOutlyingIntersections {
  return allowOutlyingIntersections__;
}

- (void)setAllowOutlyingIntersectionsWithBoolean:(jboolean)flag {
  allowOutlyingIntersections__ = flag;
}

- (jboolean)keepsTypeOnGeometricTransform {
  return keepTypeOnGeometricTransform_;
}

- (void)setKeepTypeOnGeometricTransformWithBoolean:(jboolean)flag {
  keepTypeOnGeometricTransform_ = flag;
}

- (jboolean)isLimitedPath {
  return YES;
}

- (jboolean)isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)p
                                                                 withDouble:(jdouble)eps {
  if (allowOutlyingIntersections__) return [self isOnFullLineWithGeogebraCommonKernelGeosGeoPoint:p withDouble:eps];
  return [self isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:p withDouble:eps];
}

- (jdouble)getMinParameter {
  return 0;
}

- (jdouble)getMaxParameter {
  return JavaLangDouble_POSITIVE_INFINITY;
}

- (id<GeogebraCommonKernelPathMover>)createPathMover {
  return [new_GeogebraCommonKernelPathMoverGeneric_initWithGeogebraCommonKernelPath_(self) autorelease];
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [super getXMLtagsWithJavaLangStringBuilder:sb];
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\t<outlyingIntersections val=\""];
  [sb appendWithBoolean:allowOutlyingIntersections__];
  [sb appendWithNSString:@"\"/>\n"];
  [sb appendWithNSString:@"\t<keepTypeOnTransform val=\""];
  [sb appendWithBoolean:keepTypeOnGeometricTransform_];
  [sb appendWithNSString:@"\"/>\n"];
}

- (IOSObjectArray *)createTransformedObjectWithGeogebraCommonKernelTransform:(GeogebraCommonKernelTransform *)t
                                                                withNSString:(NSString *)transformedLabel {
  GeogebraCommonKernelAlgosAlgoElement *parent = keepTypeOnGeometricTransform_ ? [self getParentAlgorithm] : nil;
  if ([parent isKindOfClass:[GeogebraCommonKernelAlgosAlgoJoinPointsRay class]]) {
    GeogebraCommonKernelAlgosAlgoJoinPointsRay *algo = (GeogebraCommonKernelAlgosAlgoJoinPointsRay *) check_class_cast(parent, [GeogebraCommonKernelAlgosAlgoJoinPointsRay class]);
    IOSObjectArray *points = [IOSObjectArray arrayWithObjects:(id[]){ [algo getP], [algo getQ] } count:2 type:GeogebraCommonKernelKernelNDGeoPointND_class_()];
    points = [((GeogebraCommonKernelTransform *) nil_chk(t)) transformPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:points];
    if ([t isAffine]) {
      GeogebraCommonKernelGeosGeoElement *ray = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) RayNDWithNSString:transformedLabel withGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(nil_chk(points), 0) withGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(points, 1)], [GeogebraCommonKernelGeosGeoElement class]);
      [((GeogebraCommonKernelGeosGeoElement *) nil_chk(ray)) setVisualStyleForTransformationsWithGeogebraCommonKernelGeosGeoElement:self];
      IOSObjectArray *geos = [IOSObjectArray arrayWithObjects:(id[]){ ray, (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, 0), [GeogebraCommonKernelGeosGeoElement class]), (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, 1), [GeogebraCommonKernelGeosGeoElement class]) } count:3 type:GeogebraCommonKernelGeosGeoElement_class_()];
      return geos;
    }
    GeogebraCommonKernelGeosGeoPoint *inf = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_) autorelease];
    [inf setCoordsWithDouble:JavaLangDouble_POSITIVE_INFINITY withDouble:JavaLangDouble_POSITIVE_INFINITY withDouble:1];
    inf = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([t doTransformWithGeogebraCommonKernelGeosGeoElement:inf], [GeogebraCommonKernelGeosGeoPoint class]);
    GeogebraCommonKernelAlgosAlgoConicPartCircumcircle *ae = [new_GeogebraCommonKernelAlgosAlgoConicPartCircumcircle_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withInt_(cons_, GeogebraCommonKernelTransform_transformedGeoLabelWithGeogebraCommonKernelGeosGeoElement_(self), (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk(points), 0), [GeogebraCommonKernelGeosGeoPoint class]), (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(points, 1), [GeogebraCommonKernelGeosGeoPoint class]), inf, GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC) autorelease];
    [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) removeFromAlgorithmListWithGeogebraCommonKernelAlgosAlgoElement:ae];
    GeogebraCommonKernelGeosGeoElement *arc = [ae getConicPart];
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(arc)) setVisualStyleForTransformationsWithGeogebraCommonKernelGeosGeoElement:self];
    IOSObjectArray *geos = [IOSObjectArray arrayWithObjects:(id[]){ arc, (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, 0), [GeogebraCommonKernelGeosGeoElement class]), (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, 1), [GeogebraCommonKernelGeosGeoElement class]) } count:3 type:GeogebraCommonKernelGeosGeoElement_class_()];
    return geos;
  }
  else if ([parent isKindOfClass:[GeogebraCommonKernelAlgosAlgoRayPointVector class]]) {
    IOSObjectArray *points = [IOSObjectArray arrayWithObjects:(id[]){ [self getStartPoint] } count:1 type:GeogebraCommonKernelKernelNDGeoPointND_class_()];
    points = [((GeogebraCommonKernelTransform *) nil_chk(t)) transformPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:points];
    jboolean oldSuppressLabelCreation = [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) isSuppressLabelsActive];
    [cons_ setSuppressLabelCreationWithBoolean:YES];
    GeogebraCommonKernelAlgosAlgoDirection *ad = [new_GeogebraCommonKernelAlgosAlgoDirection_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoLine_(cons_, self) autorelease];
    [cons_ removeFromAlgorithmListWithGeogebraCommonKernelAlgosAlgoElement:ad];
    GeogebraCommonKernelGeosGeoVector *direction = [ad getVector];
    if ([t isAffine]) {
      direction = (GeogebraCommonKernelGeosGeoVector *) check_class_cast([t doTransformWithGeogebraCommonKernelGeosGeoElement:direction], [GeogebraCommonKernelGeosGeoVector class]);
      [cons_ setSuppressLabelCreationWithBoolean:oldSuppressLabelCreation];
      GeogebraCommonKernelGeosGeoElement *ray = [((GeogebraCommonKernelAlgosAlgoDispatcher *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgoDispatcher])) RayWithNSString:transformedLabel withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk(points), 0), [GeogebraCommonKernelGeosGeoPoint class]) withGeogebraCommonKernelGeosGeoVector:direction];
      [((GeogebraCommonKernelGeosGeoElement *) nil_chk(ray)) setVisualStyleForTransformationsWithGeogebraCommonKernelGeosGeoElement:self];
      IOSObjectArray *geos = [IOSObjectArray arrayWithObjects:(id[]){ ray, (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, 0), [GeogebraCommonKernelGeosGeoElement class]) } count:2 type:GeogebraCommonKernelGeosGeoElement_class_()];
      return geos;
    }
    GeogebraCommonKernelAlgosAlgoTranslate *at = [new_GeogebraCommonKernelAlgosAlgoTranslate_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, [self getStartPoint], direction) autorelease];
    [cons_ removeFromAlgorithmListWithGeogebraCommonKernelAlgosAlgoElement:at];
    GeogebraCommonKernelGeosGeoPoint *thirdPoint = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([at getResult], [GeogebraCommonKernelGeosGeoPoint class]);
    GeogebraCommonKernelGeosGeoPoint *inf = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_) autorelease];
    [inf setCoordsWithDouble:JavaLangDouble_POSITIVE_INFINITY withDouble:JavaLangDouble_POSITIVE_INFINITY withDouble:1];
    IOSObjectArray *points2 = [IOSObjectArray arrayWithObjects:(id[]){ thirdPoint, inf } count:2 type:GeogebraCommonKernelKernelNDGeoPointND_class_()];
    points2 = [t transformPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:points2];
    [cons_ setSuppressLabelCreationWithBoolean:oldSuppressLabelCreation];
    GeogebraCommonKernelAlgosAlgoConicPartCircumcircle *ae = [new_GeogebraCommonKernelAlgosAlgoConicPartCircumcircle_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withInt_(cons_, GeogebraCommonKernelTransform_transformedGeoLabelWithGeogebraCommonKernelGeosGeoElement_(self), (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk(points), 0), [GeogebraCommonKernelGeosGeoPoint class]), (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk(points2), 0), [GeogebraCommonKernelGeosGeoPoint class]), (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(points2, 1), [GeogebraCommonKernelGeosGeoPoint class]), GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC) autorelease];
    GeogebraCommonKernelGeosGeoElement *arc = [ae getConicPart];
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(arc)) setVisualStyleForTransformationsWithGeogebraCommonKernelGeosGeoElement:self];
    IOSObjectArray *geos = [IOSObjectArray arrayWithObjects:(id[]){ arc, (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, 0), [GeogebraCommonKernelGeosGeoElement class]) } count:2 type:GeogebraCommonKernelGeosGeoElement_class_()];
    return geos;
  }
  else {
    GeogebraCommonKernelGeosGeoElement *transformedLine = [((GeogebraCommonKernelTransform *) nil_chk(t)) getTransformedLineWithGeogebraCommonKernelKernelNDGeoLineND:self];
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(transformedLine)) setLabelWithNSString:transformedLabel];
    IOSObjectArray *ret = [IOSObjectArray arrayWithObjects:(id[]){ transformedLine } count:1 type:GeogebraCommonKernelGeosGeoElement_class_()];
    return ret;
  }
}

- (jboolean)isGeoRay {
  return YES;
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoRay]) return NO;
  return [self isSameDirectionWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoLine class])] && [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([((GeogebraCommonKernelGeosGeoRay *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoRay class])) getStartPoint])) isEqualWithGeogebraCommonKernelGeosGeoElement:[self getStartPoint]];
}

- (jboolean)isOnPathWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)Pnd
                                              withDouble:(jdouble)eps {
  GeogebraCommonKernelMatrixCoords *P2d = [((GeogebraCommonKernelMatrixCoords *) nil_chk(Pnd)) getCoordsIn2DView];
  if (![super isOnPathWithGeogebraCommonKernelMatrixCoords:P2d withDouble:eps]) return NO;
  return [self respectLimitedPathWithGeogebraCommonKernelMatrixCoords:P2d withDouble:eps];
}

- (jboolean)respectLimitedPathWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)Pnd
                                                        withDouble:(jdouble)eps {
  GeogebraCommonKernelMatrixCoords *P2d = [((GeogebraCommonKernelMatrixCoords *) nil_chk(Pnd)) getCoordsIn2DView];
  GeogebraCommonKernelPathParameter *pp = [self getTempPathParameter];
  [self doPointChangedWithGeogebraCommonKernelMatrixCoords:P2d withGeogebraCommonKernelPathParameter:pp];
  jdouble t = [((GeogebraCommonKernelPathParameter *) nil_chk(pp)) getT];
  return t >= -eps;
}

- (jboolean)isAllEndpointsLabelsSet {
  return [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(startPoint_)) isLabelSet];
}

- (jboolean)respectLimitedPathWithDouble:(jdouble)parameter {
  return GeogebraCommonKernelKernel_isGreaterEqualWithDouble_withDouble_(parameter, 0);
}

- (GeogebraCommonKernelGeosGeoElement *)copyFreeRay {
  GeogebraCommonKernelGeosGeoPoint *startPoint1 = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getStartPoint])) copyInternalWithGeogebraCommonKernelConstruction:cons_], [GeogebraCommonKernelGeosGeoPoint class]);
  IOSDoubleArray *direction = [IOSDoubleArray arrayWithLength:3];
  [self getDirectionWithDoubleArray:direction];
  GeogebraCommonKernelGeosGeoVector *directionVec = [new_GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_(cons_) autorelease];
  [directionVec setCoordsWithDoubleArray:direction];
  GeogebraCommonKernelAlgosAlgoRayPointVector *algo = [new_GeogebraCommonKernelAlgosAlgoRayPointVector_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoVector_(cons_, nil, startPoint1, directionVec) autorelease];
  return [algo getRay];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelGeosGeoPoint:", "GeoRay", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:", "GeoRay", NULL, 0x1, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "copyInternalWithGeogebraCommonKernelConstruction:", "copyInternal", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoVec3D:", "set", "V", 0x1, NULL, NULL },
    { "setVisualStyleWithGeogebraCommonKernelGeosGeoElement:", "setVisualStyle", "V", 0x1, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChanged", "V", 0x1, NULL, NULL },
    { "pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pathChanged", "V", 0x1, NULL, NULL },
    { "allowOutlyingIntersections", NULL, "Z", 0x1, NULL, NULL },
    { "setAllowOutlyingIntersectionsWithBoolean:", "setAllowOutlyingIntersections", "V", 0x1, NULL, NULL },
    { "keepsTypeOnGeometricTransform", NULL, "Z", 0x1, NULL, NULL },
    { "setKeepTypeOnGeometricTransformWithBoolean:", "setKeepTypeOnGeometricTransform", "V", 0x1, NULL, NULL },
    { "isLimitedPath", NULL, "Z", 0x11, NULL, NULL },
    { "isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:withDouble:", "isIntersectionPointIncident", "Z", 0x1, NULL, NULL },
    { "getMinParameter", NULL, "D", 0x1, NULL, NULL },
    { "getMaxParameter", NULL, "D", 0x1, NULL, NULL },
    { "createPathMover", NULL, "Lgeogebra.common.kernel.PathMover;", 0x1, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "createTransformedObjectWithGeogebraCommonKernelTransform:withNSString:", "createTransformedObject", "[Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "isGeoRay", NULL, "Z", 0x1, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x11, NULL, NULL },
    { "isOnPathWithGeogebraCommonKernelMatrixCoords:withDouble:", "isOnPath", "Z", 0x1, NULL, NULL },
    { "respectLimitedPathWithGeogebraCommonKernelMatrixCoords:withDouble:", "respectLimitedPath", "Z", 0x1, NULL, NULL },
    { "isAllEndpointsLabelsSet", NULL, "Z", 0x1, NULL, NULL },
    { "respectLimitedPathWithDouble:", "respectLimitedPath", "Z", 0x1, NULL, NULL },
    { "copyFreeRay", NULL, "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "allowOutlyingIntersections__", "allowOutlyingIntersections", 0x2, "Z", NULL, NULL,  },
    { "keepTypeOnGeometricTransform_", NULL, 0x2, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoRay = { 2, "GeoRay", "geogebra.common.kernel.geos", NULL, 0x11, 27, methods, 2, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoRay;
}

@end

void GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelGeosGeoRay *self, GeogebraCommonKernelConstruction *c, GeogebraCommonKernelGeosGeoPoint *A) {
  GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_(self, c);
  [self setStartPointWithGeogebraCommonKernelGeosGeoPoint:A];
}

GeogebraCommonKernelGeosGeoRay *new_GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelConstruction *c, GeogebraCommonKernelGeosGeoPoint *A) {
  GeogebraCommonKernelGeosGeoRay *self = [GeogebraCommonKernelGeosGeoRay alloc];
  GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoPoint_(self, c, A);
  return self;
}

void GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelGeosGeoRay *self, GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoLine_initWithGeogebraCommonKernelConstruction_(self, c);
  self->allowOutlyingIntersections__ = NO;
  self->keepTypeOnGeometricTransform_ = YES;
  [self setConstructionDefaults];
}

GeogebraCommonKernelGeosGeoRay *new_GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoRay *self = [GeogebraCommonKernelGeosGeoRay alloc];
  GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoRay)
