//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/SharedMinimumSpanningTree.java
//


#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/SharedMinimumSpanningTree.h"
#include "geogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VCluster.h"
#include "geogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VHalfEdge.h"
#include "geogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VVertex.h"
#include "java/lang/Integer.h"
#include "java/lang/RuntimeException.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/Comparator.h"
#include "java/util/Iterator.h"
#include "java/util/TreeMap.h"

@interface GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree ()

+ (jint)determineClusterCutOffByGradientWithJavaUtilTreeMap:(JavaUtilTreeMap *)sortedvalues
                                                    withInt:(jint)gradient_error_allowed;

@end

static id<JavaUtilComparator> GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VERTEX_COMPARATOR_;
J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree, VERTEX_COMPARATOR_, id<JavaUtilComparator>)

static id<JavaUtilComparator> GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_PATH_COMPARATOR_;
J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree, PATH_COMPARATOR_, id<JavaUtilComparator>)

__attribute__((unused)) static jint GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_determineClusterCutOffByGradientWithJavaUtilTreeMap_withInt_(JavaUtilTreeMap *sortedvalues, jint gradient_error_allowed);

#define GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_serialVersionUID 1LL

@interface GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList : JavaUtilTreeMap

- (instancetype)init;

- (jboolean)hasVertexBeenConsideredWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)vertex;

- (void)addVertexWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)vertex;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList)

J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList, serialVersionUID, jlong)

__attribute__((unused)) static void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList *self);

__attribute__((unused)) static GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList)

#define GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_serialVersionUID 1LL

@interface GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList : JavaUtilTreeMap

- (instancetype)init;

- (GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *)popBestNextPath;

- (void)addPathWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *)path;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList)

J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList, serialVersionUID, jlong)

__attribute__((unused)) static void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList *self);

__attribute__((unused)) static GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList)

@interface GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1 : NSObject < JavaUtilComparator >

- (jint)compareWithId:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)v1
               withId:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)v2;

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1)

__attribute__((unused)) static void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1 *self);

__attribute__((unused)) static GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1 *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1)

@interface GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2 : NSObject < JavaUtilComparator >

- (jint)compareWithId:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *)e1
               withId:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *)e2;

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2)

__attribute__((unused)) static void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2 *self);

__attribute__((unused)) static GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2 *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2)

J2OBJC_INITIALIZED_DEFN(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree)

@implementation GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree

+ (jint)determineMSTUsingPrimsAlgorithmWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)startingvertex {
  return GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_determineMSTUsingPrimsAlgorithmWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex_(startingvertex);
}

+ (jint)determineMSTUsingPrimsAlgorithmWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)startingvertex
                                                                                                                     withDouble:(jdouble)gradient_diff_before_cluster_cutoff
                                                                                                          withJavaUtilArrayList:(JavaUtilArrayList *)clusters {
  return GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_determineMSTUsingPrimsAlgorithmWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex_withDouble_withJavaUtilArrayList_(startingvertex, gradient_diff_before_cluster_cutoff, clusters);
}

+ (jint)determineClusterCutOffByGradientWithJavaUtilTreeMap:(JavaUtilTreeMap *)sortedvalues
                                                    withInt:(jint)gradient_error_allowed {
  return GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_determineClusterCutOffByGradientWithJavaUtilTreeMap_withInt_(sortedvalues, gradient_error_allowed);
}

- (instancetype)init {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_init(self);
  return self;
}

+ (void)initialize {
  if (self == [GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree class]) {
    JreStrongAssignAndConsume(&GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VERTEX_COMPARATOR_, nil, new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1_init());
    JreStrongAssignAndConsume(&GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_PATH_COMPARATOR_, nil, new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2_init());
    J2OBJC_SET_INITIALIZED(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "determineMSTUsingPrimsAlgorithmWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:", "determineMSTUsingPrimsAlgorithm", "I", 0x9, NULL, NULL },
    { "determineMSTUsingPrimsAlgorithmWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:withDouble:withJavaUtilArrayList:", "determineMSTUsingPrimsAlgorithm", "I", 0x9, NULL, NULL },
    { "determineClusterCutOffByGradientWithJavaUtilTreeMap:withInt:", "determineClusterCutOffByGradient", "I", 0xa, NULL, NULL },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "VERTEX_COMPARATOR_", NULL, 0x1a, "Ljava.util.Comparator;", &GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VERTEX_COMPARATOR_, "Ljava/util/Comparator<Lgeogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VVertex;>;",  },
    { "PATH_COMPARATOR_", NULL, 0x1a, "Ljava.util.Comparator;", &GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_PATH_COMPARATOR_, "Ljava/util/Comparator<Lgeogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VHalfEdge;>;",  },
  };
  static const char *inner_classes[] = {"Lgeogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$VertexList;", "Lgeogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.SharedMinimumSpanningTree$FuturePathList;"};
  static const J2ObjcClassInfo _GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree = { 2, "SharedMinimumSpanningTree", "geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation", NULL, 0x1, 4, methods, 2, fields, 0, NULL, 2, inner_classes, NULL, NULL };
  return &_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree;
}

@end

jint GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_determineMSTUsingPrimsAlgorithmWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex_(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *startingvertex) {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_initialize();
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList *vertexes = [new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_init() autorelease];
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList *futurepaths = [new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_init() autorelease];
  jint maxpathofminimumspanningtree = -1;
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *minimum = startingvertex;
  do {
    [vertexes addVertexWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:minimum];
    id<JavaUtilIterator> iter = [((id<JavaUtilCollection>) nil_chk([futurepaths values])) iterator];
    while ([((id<JavaUtilIterator>) nil_chk(iter)) hasNext]) {
      GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *path = [iter next];
      if ([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(path)) getConnectedVertex] == minimum) {
        [iter remove];
      }
    }
    for (GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge * __strong path in nil_chk([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *) nil_chk(minimum)) getEdges])) {
      if ([vertexes hasVertexBeenConsideredWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:[((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(path)) getConnectedVertex]]) {
        continue;
      }
      [futurepaths addPathWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge:path];
    }
    if ([futurepaths size] <= 0) {
      return maxpathofminimumspanningtree;
    }
    GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *nextbestpath = [futurepaths popBestNextPath];
    ((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(nextbestpath))->shownonminimumspanningtree_ = YES;
    if ([nextbestpath getLength] > maxpathofminimumspanningtree) {
      maxpathofminimumspanningtree = [nextbestpath getLength];
    }
    minimum = [nextbestpath getConnectedVertex];
  }
  while (YES);
}

jint GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_determineMSTUsingPrimsAlgorithmWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex_withDouble_withJavaUtilArrayList_(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *startingvertex, jdouble gradient_diff_before_cluster_cutoff, JavaUtilArrayList *clusters) {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_initialize();
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList *vertexes = [new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_init() autorelease];
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList *futurepaths = [new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_init() autorelease];
  JavaUtilTreeMap *lengths = [new_JavaUtilTreeMap_init() autorelease];
  jint maxpathofminimumspanningtree = -1;
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *minimum = startingvertex;
  do {
    [vertexes addVertexWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:minimum];
    id<JavaUtilIterator> iter = [((id<JavaUtilCollection>) nil_chk([futurepaths values])) iterator];
    while ([((id<JavaUtilIterator>) nil_chk(iter)) hasNext]) {
      GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *path = [iter next];
      if ([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(path)) getConnectedVertex] == minimum) {
        [iter remove];
      }
    }
    for (GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge * __strong path in nil_chk([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *) nil_chk(minimum)) getEdges])) {
      if ([vertexes hasVertexBeenConsideredWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:[((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(path)) getConnectedVertex]]) {
        continue;
      }
      [futurepaths addPathWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge:path];
    }
    if ([futurepaths size] <= 0) break;
    GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *nextbestpath = [futurepaths popBestNextPath];
    if ([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(nextbestpath)) getLength] > maxpathofminimumspanningtree) {
      maxpathofminimumspanningtree = [nextbestpath getLength];
    }
    JavaLangInteger *length = [new_JavaLangInteger_initWithInt_([nextbestpath getLength]) autorelease];
    [lengths putWithId:length withId:length];
    minimum = [nextbestpath getConnectedVertex];
  }
  while (YES);
  jint clustercutoff = GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_determineClusterCutOffByGradientWithJavaUtilTreeMap_withInt_(lengths, 5);
  [vertexes clear];
  [futurepaths clear];
  minimum = startingvertex;
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVCluster *currentcluster = [new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVCluster_init() autorelease];
  [((JavaUtilArrayList *) nil_chk(clusters)) addWithId:currentcluster];
  do {
    [currentcluster addWithId:minimum];
    [vertexes addVertexWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:minimum];
    id<JavaUtilIterator> iter = [((id<JavaUtilCollection>) nil_chk([futurepaths values])) iterator];
    while ([((id<JavaUtilIterator>) nil_chk(iter)) hasNext]) {
      GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *path = [iter next];
      if ([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(path)) getConnectedVertex] == minimum) {
        [iter remove];
      }
    }
    for (GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge * __strong path in nil_chk([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *) nil_chk(minimum)) getEdges])) {
      if ([vertexes hasVertexBeenConsideredWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:[((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(path)) getConnectedVertex]]) {
        continue;
      }
      [futurepaths addPathWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge:path];
    }
    if ([futurepaths size] <= 0) break;
    GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *nextbestpath = [futurepaths popBestNextPath];
    if ([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(nextbestpath)) getLength] <= clustercutoff) {
      nextbestpath->shownonminimumspanningtree_ = YES;
    }
    else {
      currentcluster = [new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVCluster_init() autorelease];
      [clusters addWithId:currentcluster];
    }
    minimum = [nextbestpath getConnectedVertex];
  }
  while (YES);
  return maxpathofminimumspanningtree;
}

jint GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_determineClusterCutOffByGradientWithJavaUtilTreeMap_withInt_(JavaUtilTreeMap *sortedvalues, jint gradient_error_allowed) {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_initialize();
  id<JavaUtilIterator> iter = [((id<JavaUtilCollection>) nil_chk([((JavaUtilTreeMap *) nil_chk(sortedvalues)) values])) iterator];
  jint prev, curr;
  jint prevgrad, currgrad;
  if (!([((id<JavaUtilIterator>) nil_chk(iter)) hasNext])) return -1;
  prev = [((JavaLangInteger *) nil_chk([iter next])) intValue];
  if (!([iter hasNext])) return prev;
  curr = [((JavaLangInteger *) nil_chk([iter next])) intValue];
  currgrad = curr - prev;
  jint index = 1;
  jint valuesonline = 2;
  jint best_valuesonline = -1;
  jint best_cutoff = -1;
  while ([iter hasNext]) {
    index++;
    prev = curr;
    prevgrad = currgrad;
    curr = [((JavaLangInteger *) nil_chk([iter next])) intValue];
    currgrad = curr - prev;
    if (prevgrad - gradient_error_allowed <= currgrad && currgrad <= prevgrad + gradient_error_allowed) {
      valuesonline++;
    }
    else {
      if (valuesonline >= ([sortedvalues size] - index - 1)) {
        return prev;
      }
      if (valuesonline > best_valuesonline) {
        best_valuesonline = valuesonline;
        best_cutoff = prev;
      }
      else {
      }
      valuesonline = 2;
    }
  }
  if (valuesonline > best_valuesonline) {
    best_cutoff = prev;
  }
  return best_cutoff;
}

void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree *self) {
  NSObject_init(self);
}

GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_init() {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree *self = [GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree alloc];
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree)

@implementation GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList

- (instancetype)init {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_init(self);
  return self;
}

- (jboolean)hasVertexBeenConsideredWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)vertex {
  return ([super getWithId:vertex] != nil);
}

- (void)addVertexWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)vertex {
  [super putWithId:vertex withId:vertex];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "VertexList", NULL, 0x2, NULL, NULL },
    { "hasVertexBeenConsideredWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:", "hasVertexBeenConsidered", "Z", 0x1, NULL, NULL },
    { "addVertexWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex:", "addVertex", "V", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID_", NULL, 0x1a, "J", NULL, NULL, .constantValue.asLong = GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_serialVersionUID },
  };
  static const char *superclass_type_args[] = {"Lgeogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex;", "Lgeogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VVertex;"};
  static const J2ObjcClassInfo _GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList = { 2, "VertexList", "geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation", "SharedMinimumSpanningTree", 0xa, 3, methods, 1, fields, 2, superclass_type_args, 0, NULL, NULL, "Ljava/util/TreeMap<Lgeogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VVertex;Lgeogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VVertex;>;" };
  return &_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList;
}

@end

void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList *self) {
  JavaUtilTreeMap_initWithJavaUtilComparator_(self, GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_get_VERTEX_COMPARATOR_());
}

GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_init() {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList *self = [GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList alloc];
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_VertexList)

@implementation GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList

- (instancetype)init {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_init(self);
  return self;
}

- (GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *)popBestNextPath {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *next = [super firstKey];
  [super removeWithId:next];
  return next;
}

- (void)addPathWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *)path {
  [super putWithId:path withId:path];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "FuturePathList", NULL, 0x2, NULL, NULL },
    { "popBestNextPath", NULL, "Lgeogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge;", 0x1, NULL, NULL },
    { "addPathWithGeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge:", "addPath", "V", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID_", NULL, 0x1a, "J", NULL, NULL, .constantValue.asLong = GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_serialVersionUID },
  };
  static const char *superclass_type_args[] = {"Lgeogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge;", "Lgeogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation.VHalfEdge;"};
  static const J2ObjcClassInfo _GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList = { 2, "FuturePathList", "geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation", "SharedMinimumSpanningTree", 0xa, 3, methods, 1, fields, 2, superclass_type_args, 0, NULL, NULL, "Ljava/util/TreeMap<Lgeogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VHalfEdge;Lgeogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VHalfEdge;>;" };
  return &_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList;
}

@end

void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList *self) {
  JavaUtilTreeMap_initWithJavaUtilComparator_(self, GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_get_PATH_COMPARATOR_());
}

GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_init() {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList *self = [GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList alloc];
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_FuturePathList)

@implementation GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1

- (jint)compareWithId:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)v1
               withId:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *)v2 {
  if (((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *) nil_chk(v1))->y_ < ((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVVertex *) nil_chk(v2))->y_) return -1;
  else if (v1->y_ > v2->y_) return 1;
  else if (v1->x_ < v2->x_) return -1;
  else if (v1->x_ > v2->x_) return 1;
  else if (v1 == v2) return 0;
  else {
    @throw [new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$@", @"No basis for comparing two apparently identical vertexes - ", v1, @" and ", v2)) autorelease];
  }
}

- (instancetype)init {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "compareWithId:withId:", "compare", "I", 0x1, NULL, NULL },
    { "init", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1 = { 2, "", "geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation", "SharedMinimumSpanningTree", 0x8008, 2, methods, 0, NULL, 0, NULL, 0, NULL, NULL, "Ljava/lang/Object;Ljava/util/Comparator<Lgeogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VVertex;>;" };
  return &_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1;
}

@end

void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1 *self) {
  NSObject_init(self);
}

GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1 *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1_init() {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1 *self = [GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1 alloc];
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$1)

@implementation GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2

- (jint)compareWithId:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *)e1
               withId:(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *)e2 {
  if ([((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(e1)) getLength] < [((GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationVHalfEdge *) nil_chk(e2)) getLength]) return -1;
  else if ([e1 getLength] > [e2 getLength]) return 1;
  else {
    if ([e1 getY] < [e2 getY]) return -1;
    else if ([e1 getY] > [e2 getY]) return 1;
    else if ([e1 getX] < [e2 getX]) return -1;
    else if ([e1 getX] > [e2 getX]) return 1;
    else if (e1 == e2) return 0;
    else {
      if (e1->next_ != nil && e2->next_ != nil) {
        if ([e1->next_ getY] < [e2->next_ getY]) return -1;
        else if ([e1->next_ getY] > [e2->next_ getY]) return 1;
        else if ([e1->next_ getX] < [e2->next_ getX]) return -1;
        else if ([e1->next_ getX] > [e2->next_ getX]) return 1;
        else {
          @throw [new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$@", @"No basis for comparing two apparently identical vectors - ", e1, @" and ", e2)) autorelease];
        }
      }
      else if (e1->next_ == nil) {
        return -1;
      }
      else if (e2->next_ == nil) {
        return 1;
      }
      else {
        @throw [new_JavaLangRuntimeException_initWithNSString_(JreStrcat("$@$@", @"No basis for comparing two apparently identical vectors - ", e1, @" and ", e2)) autorelease];
      }
    }
  }
}

- (instancetype)init {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "compareWithId:withId:", "compare", "I", 0x1, NULL, NULL },
    { "init", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2 = { 2, "", "geogebra.common.kernel.discrete.signalprocessor.voronoi.representation.triangulation", "SharedMinimumSpanningTree", 0x8008, 2, methods, 0, NULL, 0, NULL, 0, NULL, NULL, "Ljava/lang/Object;Ljava/util/Comparator<Lgeogebra/common/kernel/discrete/signalprocessor/voronoi/representation/triangulation/VHalfEdge;>;" };
  return &_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2;
}

@end

void GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2_init(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2 *self) {
  NSObject_init(self);
}

GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2 *new_GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2_init() {
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2 *self = [GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2 alloc];
  GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelDiscreteSignalprocessorVoronoiRepresentationTriangulationSharedMinimumSpanningTree_$2)
