//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/locusequ/EquationTranslator.java
//


#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/locusequ/EquationList.h"
#include "geogebra/common/kernel/locusequ/EquationSystem.h"
#include "geogebra/common/kernel/locusequ/EquationTranslator.h"
#include "geogebra/common/kernel/locusequ/arith/EquationExpression.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/Map.h"

@interface GeogebraCommonKernelLocusequEquationTranslator () {
 @public
  id<JavaUtilMap> container_;
  GeogebraCommonKernelLocusequEquationSystem *system_;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelLocusequEquationTranslator, container_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelLocusequEquationTranslator, system_, GeogebraCommonKernelLocusequEquationSystem *)

@implementation GeogebraCommonKernelLocusequEquationTranslator

- (instancetype)init {
  GeogebraCommonKernelLocusequEquationTranslator_init(self);
  return self;
}

- (void)setSystemWithGeogebraCommonKernelLocusequEquationSystem:(GeogebraCommonKernelLocusequEquationSystem *)system {
  GeogebraCommonKernelLocusequEquationTranslator_set_system_(self, system);
}

- (id<JavaUtilCollection>)translateWithGeogebraCommonKernelLocusequEquationSystem:(GeogebraCommonKernelLocusequEquationSystem *)system {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id<JavaUtilMap>)getContainer {
  return self->container_;
}

- (void)setNewContainerWithJavaUtilMap:(id<JavaUtilMap>)newContainer {
  GeogebraCommonKernelLocusequEquationTranslator_set_container_(self, newContainer);
}

- (GeogebraCommonKernelLocusequEquationSystem *)getSystem {
  return self->system_;
}

- (jboolean)containsKeyWithGeogebraCommonKernelLocusequArithEquationExpression:(GeogebraCommonKernelLocusequArithEquationExpression *)equationExpression {
  return [((id<JavaUtilMap>) nil_chk([self getContainer])) containsKeyWithId:equationExpression];
}

- (id)getWithGeogebraCommonKernelLocusequArithEquationExpression:(GeogebraCommonKernelLocusequArithEquationExpression *)equationExpression {
  return [((id<JavaUtilMap>) nil_chk([self getContainer])) getWithId:equationExpression];
}

- (GeogebraCommonKernelLocusequEquationList *)getLocus {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)absWithId:(id)value {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)sumWithId:(id)a
         withId:(id)b {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)diffWithId:(id)a
          withId:(id)b {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)productWithId:(id)a
             withId:(id)b {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)divWithId:(id)num
         withId:(id)denom {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)expWithId:(id)base
       withLong:(jlong)exp {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)inverseWithId:(id)value {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)numberWithDouble:(jdouble)number {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)auxiliarSymbolicWithInt:(jint)id_ {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)specialSymbolicWithInt:(jint)id_ {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)symbolicWithInt:(jint)id_ {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)oppositeWithId:(id)value {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)sqrtWithId:(id)value {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (IOSObjectArray *)eliminateSystemWithGeogebraCommonKernelLocusequEquationSystem:(GeogebraCommonKernelLocusequEquationSystem *)system {
  return [self eliminateWithJavaUtilCollection:[self translateWithGeogebraCommonKernelLocusequEquationSystem:system]];
}

- (IOSObjectArray *)eliminateWithJavaUtilCollection:(id<JavaUtilCollection>)translatedRestrictions {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (void)dealloc {
  RELEASE_(container_);
  RELEASE_(system_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "EquationTranslator", NULL, 0x4, NULL, NULL },
    { "setSystemWithGeogebraCommonKernelLocusequEquationSystem:", "setSystem", "V", 0x4, NULL, NULL },
    { "translateWithGeogebraCommonKernelLocusequEquationSystem:", "translate", "Ljava.util.Collection;", 0x401, NULL, NULL },
    { "getContainer", NULL, "Ljava.util.Map;", 0x4, NULL, NULL },
    { "setNewContainerWithJavaUtilMap:", "setNewContainer", "V", 0x4, NULL, NULL },
    { "getSystem", NULL, "Lgeogebra.common.kernel.locusequ.EquationSystem;", 0x4, NULL, NULL },
    { "containsKeyWithGeogebraCommonKernelLocusequArithEquationExpression:", "containsKey", "Z", 0x1, NULL, NULL },
    { "getWithGeogebraCommonKernelLocusequArithEquationExpression:", "get", "TT;", 0x1, NULL, "(Lgeogebra/common/kernel/locusequ/arith/EquationExpression;)TT;" },
    { "getLocus", NULL, "Lgeogebra.common.kernel.locusequ.EquationList;", 0x401, NULL, NULL },
    { "absWithId:", "abs", "TT;", 0x401, NULL, "(TT;)TT;" },
    { "sumWithId:withId:", "sum", "TT;", 0x401, NULL, "(TT;TT;)TT;" },
    { "diffWithId:withId:", "diff", "TT;", 0x401, NULL, "(TT;TT;)TT;" },
    { "productWithId:withId:", "product", "TT;", 0x401, NULL, "(TT;TT;)TT;" },
    { "divWithId:withId:", "div", "TT;", 0x401, NULL, "(TT;TT;)TT;" },
    { "expWithId:withLong:", "exp", "TT;", 0x401, NULL, "(TT;J)TT;" },
    { "inverseWithId:", "inverse", "TT;", 0x401, NULL, "(TT;)TT;" },
    { "numberWithDouble:", "number", "TT;", 0x401, NULL, "(D)TT;" },
    { "auxiliarSymbolicWithInt:", "auxiliarSymbolic", "TT;", 0x401, NULL, "(I)TT;" },
    { "specialSymbolicWithInt:", "specialSymbolic", "TT;", 0x401, NULL, "(I)TT;" },
    { "symbolicWithInt:", "symbolic", "TT;", 0x401, NULL, "(I)TT;" },
    { "oppositeWithId:", "opposite", "TT;", 0x401, NULL, "(TT;)TT;" },
    { "sqrtWithId:", "sqrt", "TT;", 0x401, NULL, "(TT;)TT;" },
    { "eliminateSystemWithGeogebraCommonKernelLocusequEquationSystem:", "eliminateSystem", "[[D", 0x1, NULL, NULL },
    { "eliminateWithJavaUtilCollection:", "eliminate", "[[D", 0x401, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "container_", NULL, 0x2, "Ljava.util.Map;", NULL, "Ljava/util/Map<Lgeogebra/common/kernel/locusequ/arith/EquationExpression;TT;>;",  },
    { "system_", NULL, 0x2, "Lgeogebra.common.kernel.locusequ.EquationSystem;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelLocusequEquationTranslator = { 2, "EquationTranslator", "geogebra.common.kernel.locusequ", NULL, 0x401, 24, methods, 2, fields, 0, NULL, 0, NULL, NULL, "<T:Ljava/lang/Object;>Ljava/lang/Object;" };
  return &_GeogebraCommonKernelLocusequEquationTranslator;
}

@end

void GeogebraCommonKernelLocusequEquationTranslator_init(GeogebraCommonKernelLocusequEquationTranslator *self) {
  NSObject_init(self);
  GeogebraCommonKernelLocusequEquationTranslator_setAndConsume_container_(self, new_JavaUtilHashMap_init());
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelLocusequEquationTranslator)
