//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/export/pstricks/GeoGebraToPstricks.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GAffineTransform.h"
#include "geogebra/common/awt/GColor.h"
#include "geogebra/common/awt/GFont.h"
#include "geogebra/common/euclidian/DrawableND.h"
#include "geogebra/common/euclidian/EuclidianView.h"
#include "geogebra/common/euclidian/draw/DrawPoint.h"
#include "geogebra/common/export/pstricks/ExportSettings.h"
#include "geogebra/common/export/pstricks/GeoGebraExport.h"
#include "geogebra/common/export/pstricks/GeoGebraToPstricks.h"
#include "geogebra/common/export/pstricks/UnicodeTeX.h"
#include "geogebra/common/factories/AwtFactory.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/MyPoint.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoAngleLines.h"
#include "geogebra/common/kernel/algos/AlgoAnglePoints.h"
#include "geogebra/common/kernel/algos/AlgoAngleVector.h"
#include "geogebra/common/kernel/algos/AlgoAngleVectors.h"
#include "geogebra/common/kernel/algos/AlgoBoxPlot.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoFunctionAreaSums.h"
#include "geogebra/common/kernel/algos/AlgoIntegralFunctions.h"
#include "geogebra/common/kernel/algos/AlgoIntersectAbstract.h"
#include "geogebra/common/kernel/algos/AlgoSlope.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/cas/AlgoIntegralDefinite.h"
#include "geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "geogebra/common/kernel/geos/GeoAngle.h"
#include "geogebra/common/kernel/geos/GeoConic.h"
#include "geogebra/common/kernel/geos/GeoConicPart.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoLocus.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoPolyLine.h"
#include "geogebra/common/kernel/geos/GeoPolygon.h"
#include "geogebra/common/kernel/geos/GeoRay.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/geos/GeoText.h"
#include "geogebra/common/kernel/geos/GeoTransferFunction.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/kernel/geos/GeoVec3D.h"
#include "geogebra/common/kernel/geos/GeoVector.h"
#include "geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/kernelND/GeoVectorND.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/plugin/EuclidianStyleConstants.h"
#include "geogebra/common/util/GStringTokenizer.h"
#include "geogebra/common/util/StringUtil.h"
#include "geogebra/common/util/Unicode.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/Iterator.h"

#define GeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER 1

@interface GeogebraCommonExportPstricksGeoGebraToPstricks () {
 @public
  jboolean eurosym_;
  JavaLangStringBuilder *codeBeginPic_;
}

+ (NSString *)killSpaceWithNSString:(NSString *)name;

+ (void)renameFuncWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                               withNSString:(NSString *)nameFunc
                               withNSString:(NSString *)nameNew;

- (jdouble)maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                       withDouble:(jdouble)a
                                                       withDouble:(jdouble)b;

- (jdouble)firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                         withDouble:(jdouble)a
                                                         withDouble:(jdouble)b;

- (void)drawCircleWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)geo;

- (void)initUnitAndVariable OBJC_METHOD_FAMILY_NONE;

- (void)drawGrid;

- (void)drawAxis;

- (void)PointOptionCodeWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)geo;

- (void)LinestyleCodeWithInt:(jint)linestyle
   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb;

- (void)addTextWithNSString:(NSString *)st
                withBoolean:(jboolean)isLatex
                    withInt:(jint)style
withGeogebraCommonAwtGColor:(GeogebraCommonAwtGColor *)geocolor;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonExportPstricksGeoGebraToPstricks, codeBeginPic_, JavaLangStringBuilder *)

J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonExportPstricksGeoGebraToPstricks, FORMAT_BEAMER, jint)

__attribute__((unused)) static NSString *GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(NSString *name);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(JavaLangStringBuilder *sb, NSString *nameFunc, NSString *nameNew);

__attribute__((unused)) static jdouble GeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b);

__attribute__((unused)) static jdouble GeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPstricks_drawCircleWithGeogebraCommonKernelGeosGeoConic_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonKernelGeosGeoConic *geo);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPstricks_initUnitAndVariable(GeogebraCommonExportPstricksGeoGebraToPstricks *self);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPstricks_drawGrid(GeogebraCommonExportPstricksGeoGebraToPstricks *self);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPstricks_drawAxis(GeogebraCommonExportPstricksGeoGebraToPstricks *self);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPstricks_PointOptionCodeWithGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonKernelGeosGeoPoint *geo);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPstricks_LinestyleCodeWithInt_withJavaLangStringBuilder_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, jint linestyle, JavaLangStringBuilder *sb);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withGeogebraCommonAwtGColor_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, NSString *st, jboolean isLatex, jint style, GeogebraCommonAwtGColor *geocolor);

@implementation GeogebraCommonExportPstricksGeoGebraToPstricks

- (instancetype)initWithGeogebraCommonMainApp:(GeogebraCommonMainApp *)app {
  GeogebraCommonExportPstricksGeoGebraToPstricks_initWithGeogebraCommonMainApp_(self, app);
  return self;
}

- (void)generateAllCode {
  format__ = [((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) getFormat];
  @try {
    xunit_ = [frame_ getXUnit];
    yunit_ = [frame_ getYUnit];
  }
  @catch (JavaLangNullPointerException *e2) {
    xunit_ = 1;
    yunit_ = 1;
  }
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_code_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_codePoint_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_codePreamble_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_codeFilledObject_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_codeBeginDoc_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraToPstricks_setAndConsume_codeBeginPic_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_CustomColor_(self, new_JavaUtilHashMap_init());
  if (format__ == GeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER) {
    [codePreamble_ appendWithNSString:JreStrcat("$I$", @"\\documentclass[", [frame_ getFontSize], @"pt]{beamer}\n")];
  }
  else {
    [codePreamble_ appendWithNSString:JreStrcat("$I$", @"\\documentclass[", [frame_ getFontSize], @"pt]{article}\n")];
  }
  [codePreamble_ appendWithNSString:@"\\usepackage{pstricks-add}\n\\pagestyle{empty}\n"];
  [codeBeginDoc_ appendWithNSString:@"\\begin{document}\n"];
  if (format__ == GeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER) {
    [codeBeginDoc_ appendWithNSString:@"\\begin{frame}\n"];
  }
  GeogebraCommonExportPstricksGeoGebraToPstricks_initUnitAndVariable(self);
  [codeBeginPic_ appendWithNSString:@"\\begin{pspicture*}("];
  [codeBeginPic_ appendWithNSString:[self formatWithDouble:xmin_]];
  [codeBeginPic_ appendWithNSString:@","];
  [codeBeginPic_ appendWithNSString:[self formatWithDouble:ymin_]];
  [codeBeginPic_ appendWithNSString:@")("];
  [codeBeginPic_ appendWithNSString:[self formatWithDouble:xmax_]];
  [codeBeginPic_ appendWithNSString:@","];
  [codeBeginPic_ appendWithNSString:[self formatWithDouble:ymax_]];
  [codeBeginPic_ appendWithNSString:@")\n"];
  if ([((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getShowGrid]) {
    GeogebraCommonExportPstricksGeoGebraToPstricks_drawGrid(self);
  }
  if ([euclidianView_ getShowXaxis] || [euclidianView_ getShowYaxis]) {
    GeogebraCommonExportPstricksGeoGebraToPstricks_drawAxis(self);
  }
  [self drawAllElements];
  if ([codePoint_ length] != 0) {
    [codePoint_ insertWithInt:0 withNSString:@"\\begin{scriptsize}\n"];
    [codePoint_ appendWithNSString:@"\\end{scriptsize}\n"];
  }
  [code_ appendWithJavaLangCharSequence:codePoint_];
  [code_ appendWithNSString:@"\\end{pspicture*}\n"];
  [code_ insertWithInt:0 withNSString:JreStrcat("@", codeFilledObject_)];
  [code_ insertWithInt:0 withNSString:JreStrcat("@", codeBeginPic_)];
  [code_ insertWithInt:0 withNSString:JreStrcat("@", codeBeginDoc_)];
  [code_ insertWithInt:0 withNSString:JreStrcat("@", codePreamble_)];
  if (format__ == GeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER) {
    [code_ appendWithNSString:@"\\end{frame}\n"];
  }
  [code_ appendWithNSString:@"\\end{document}"];
  [frame_ writeWithJavaLangStringBuilder:code_];
}

- (void)drawLocusWithGeogebraCommonKernelGeosGeoLocus:(GeogebraCommonKernelGeosGeoLocus *)g {
  JavaUtilArrayList *ll = [((GeogebraCommonKernelGeosGeoLocus *) nil_chk(g)) getPoints];
  id<JavaUtilIterator> it = [((JavaUtilArrayList *) nil_chk(ll)) iterator];
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\pscustom"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:g withBoolean:YES]];
  [code_ appendWithNSString:@"{"];
  jboolean first = YES;
  jboolean out = NO;
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    GeogebraCommonKernelMyPoint *mp = [it next];
    if (((GeogebraCommonKernelMyPoint *) nil_chk(mp))->x_ > xmin_ && mp->x_ < xmax_ && mp->y_ > ymin_ && mp->y_ < ymax_) {
      NSString *x = [self formatWithDouble:mp->x_];
      NSString *y = [self formatWithDouble:mp->y_];
      jboolean b = mp->lineTo_;
      if (first) {
        [code_ appendWithNSString:@"\\moveto("];
        first = NO;
      }
      else if (b) [code_ appendWithNSString:@"\\lineto("];
      else [code_ appendWithNSString:@"\\moveto("];
      [code_ appendWithNSString:x];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:y];
      [code_ appendWithNSString:@")\n"];
      out = NO;
    }
    else if (!first && mp->lineTo_ && !out) {
      out = YES;
      NSString *x = [self formatWithDouble:mp->x_];
      NSString *y = [self formatWithDouble:mp->y_];
      [code_ appendWithNSString:@"\\lineto("];
      [code_ appendWithNSString:x];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:y];
      [code_ appendWithNSString:@")\n"];
    }
    else {
      first = YES;
      out = NO;
    }
  }
  [code_ appendWithNSString:@"}\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawBoxPlotWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelAlgosAlgoBoxPlot *algo = ((GeogebraCommonKernelAlgosAlgoBoxPlot *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoBoxPlot class]));
  jdouble y = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([((GeogebraCommonKernelAlgosAlgoBoxPlot *) nil_chk(algo)) getA])) getDouble];
  jdouble height = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble];
  IOSDoubleArray *lf = [algo getLeftBorders];
  jdouble min = IOSDoubleArray_Get(nil_chk(lf), 0);
  jdouble q1 = IOSDoubleArray_Get(lf, 1);
  jdouble med = IOSDoubleArray_Get(lf, 2);
  jdouble q3 = IOSDoubleArray_Get(lf, 3);
  jdouble max = IOSDoubleArray_Get(lf, 4);
  [self startBeamerWithJavaLangStringBuilder:code_];
  [self drawLineWithDouble:min withDouble:y - height withDouble:min withDouble:y + height withGeogebraCommonKernelGeosGeoElement:geo];
  [self drawLineWithDouble:max withDouble:y - height withDouble:max withDouble:y + height withGeogebraCommonKernelGeosGeoElement:geo];
  [self drawLineWithDouble:med withDouble:y - height withDouble:med withDouble:y + height withGeogebraCommonKernelGeosGeoElement:geo];
  [self drawLineWithDouble:min withDouble:y withDouble:q1 withDouble:y withGeogebraCommonKernelGeosGeoElement:geo];
  [self drawLineWithDouble:q3 withDouble:y withDouble:max withDouble:y withGeogebraCommonKernelGeosGeoElement:geo];
  [self endBeamerWithJavaLangStringBuilder:code_];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\psframe"];
  [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  [codeFilledObject_ appendWithNSString:@"("];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:q1]];
  [codeFilledObject_ appendWithNSString:@","];
  [codeFilledObject_ appendWithDouble:y - height];
  [codeFilledObject_ appendWithNSString:@")("];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:q3]];
  [codeFilledObject_ appendWithNSString:@","];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:y + height]];
  [codeFilledObject_ appendWithNSString:@")\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawSumTrapezoidalWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelAlgosAlgoFunctionAreaSums *algo = (GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoFunctionAreaSums class]);
  jint n = [((GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) nil_chk(algo)) getIntervals];
  IOSDoubleArray *y = [algo getValues];
  IOSDoubleArray *x = [algo getLeftBorder];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  for (jint i = 0; i < n; i++) {
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pspolygon"];
    [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    [codeFilledObject_ appendWithNSString:@"("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(x), i)]];
    [codeFilledObject_ appendWithNSString:@",0)("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1)]];
    [codeFilledObject_ appendWithNSString:@",0)("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1)]];
    [codeFilledObject_ appendWithNSString:@","];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(y), i + 1)]];
    [codeFilledObject_ appendWithNSString:@")("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i)]];
    [codeFilledObject_ appendWithNSString:@","];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(y, i)]];
    [codeFilledObject_ appendWithNSString:@")\n"];
    if (i != n - 1 && isBeamer_) [codeFilledObject_ appendWithNSString:@"  "];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawSumUpperLowerWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelAlgosAlgoFunctionAreaSums *algo = (GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoFunctionAreaSums class]);
  jint n = [((GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) nil_chk(algo)) getIntervals];
  jdouble step = [algo getStep];
  IOSDoubleArray *y = [algo getValues];
  IOSDoubleArray *x = [algo getLeftBorder];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  for (jint i = 0; i < n; i++) {
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\psframe"];
    [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    [codeFilledObject_ appendWithNSString:@"("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(x), i)]];
    [codeFilledObject_ appendWithNSString:@",0)("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i) + step]];
    [codeFilledObject_ appendWithNSString:@","];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(y), i)]];
    [codeFilledObject_ appendWithNSString:@")\n"];
    if (i != n - 1 && isBeamer_) [codeFilledObject_ appendWithNSString:@"  "];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawIntegralFunctionsWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelAlgosAlgoIntegralFunctions *algo = (GeogebraCommonKernelAlgosAlgoIntegralFunctions *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoIntegralFunctions class]);
  GeogebraCommonKernelGeosGeoFunction *f = [((GeogebraCommonKernelAlgosAlgoIntegralFunctions *) nil_chk(algo)) getF];
  GeogebraCommonKernelGeosGeoFunction *g = [algo getG];
  jdouble a = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getA])) getDouble];
  jdouble b = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble];
  NSString *sa = [self formatWithDouble:a];
  NSString *sb = [self formatWithDouble:b];
  NSString *valueF = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  valueF = GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(valueF, YES));
  NSString *valueG = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(g)) toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  valueG = GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(valueG, YES));
  NSString *fa = [self formatWithDouble:[f evaluateWithDouble:a]];
  NSString *gb = [self formatWithDouble:[g evaluateWithDouble:b]];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pscustom"];
  [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  [codeFilledObject_ appendWithNSString:@"{\\psplot{"];
  [codeFilledObject_ appendWithNSString:sa];
  [codeFilledObject_ appendWithNSString:@"}{"];
  [codeFilledObject_ appendWithNSString:sb];
  [codeFilledObject_ appendWithNSString:@"}{"];
  [codeFilledObject_ appendWithNSString:valueF];
  [codeFilledObject_ appendWithNSString:@"}\\lineto("];
  [codeFilledObject_ appendWithNSString:sb];
  [codeFilledObject_ appendWithNSString:@","];
  [codeFilledObject_ appendWithNSString:gb];
  [codeFilledObject_ appendWithNSString:@")\\psplot{"];
  [codeFilledObject_ appendWithNSString:sb];
  [codeFilledObject_ appendWithNSString:@"}{"];
  [codeFilledObject_ appendWithNSString:sa];
  [codeFilledObject_ appendWithNSString:@"}{"];
  [codeFilledObject_ appendWithNSString:valueG];
  [codeFilledObject_ appendWithNSString:@"}\\lineto("];
  [codeFilledObject_ appendWithNSString:sa];
  [codeFilledObject_ appendWithNSString:@","];
  [codeFilledObject_ appendWithNSString:fa];
  [codeFilledObject_ appendWithNSString:@")\\closepath}\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawIntegralWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelCasAlgoIntegralDefinite *algo = (GeogebraCommonKernelCasAlgoIntegralDefinite *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelCasAlgoIntegralDefinite class]);
  GeogebraCommonKernelGeosGeoFunction *f = [((GeogebraCommonKernelCasAlgoIntegralDefinite *) nil_chk(algo)) getFunction];
  NSString *a = [self formatWithDouble:[((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getA])) getDouble]];
  NSString *b = [self formatWithDouble:[((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble]];
  NSString *value = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  value = GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(value, YES));
  if ([((NSString *) nil_chk([a substring:((jint) [((NSString *) nil_chk(a)) length]) - 1])) isEqual:JreStrcat("C", GeogebraCommonUtilUnicode_Infinity)]) {
    a = [self formatWithDouble:xmin_];
  }
  if ([((NSString *) nil_chk([b substring:((jint) [((NSString *) nil_chk(b)) length]) - 1])) isEqual:JreStrcat("C", GeogebraCommonUtilUnicode_Infinity)]) {
    b = [self formatWithDouble:xmax_];
  }
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  if (![self isLatexFunctionWithNSString:[f toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()]]) {
    jdouble af = xmin_;
    jdouble bf = xmax_;
    if ([f hasInterval]) {
      af = [f getIntervalMin];
      bf = [f getIntervalMax];
    }
    [f setIntervalWithDouble:[((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:a] withDouble:[((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) evaluateToDoubleWithNSString:b]];
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\pscustom"];
    [f setIntervalWithDouble:[((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getA])) getDouble] withDouble:[((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble]];
    [self drawFunctionWithGeogebraCommonKernelGeosGeoFunction:f withBoolean:YES withGeogebraCommonKernelGeosGeoNumeric:geo];
    [f setIntervalWithDouble:af withDouble:bf];
    if ([f isEuclidianVisible]) {
      [self drawFunctionWithGeogebraCommonKernelGeosGeoFunction:f withBoolean:NO withGeogebraCommonKernelGeosGeoNumeric:geo];
    }
  }
  else {
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pscustom"];
    [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    [codeFilledObject_ appendWithNSString:@"{\\psplot{"];
    [codeFilledObject_ appendWithNSString:a];
    [codeFilledObject_ appendWithNSString:@"}{"];
    [codeFilledObject_ appendWithNSString:b];
    [codeFilledObject_ appendWithNSString:@"}{"];
    [codeFilledObject_ appendWithNSString:value];
    [codeFilledObject_ appendWithNSString:@"}\\lineto("];
    [codeFilledObject_ appendWithNSString:b];
    [codeFilledObject_ appendWithNSString:@",0)\\lineto("];
    [codeFilledObject_ appendWithNSString:a];
    [codeFilledObject_ appendWithNSString:@",0)\\closepath}\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawSlopeWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  jint slopeTriangleSize = [((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getSlopeTriangleSize];
  jdouble rwHeight = [geo getValue] * slopeTriangleSize;
  jdouble height = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getYscale] * rwHeight;
  IOSDoubleArray *coords = [IOSDoubleArray arrayWithLength:2];
  if (JavaLangMath_absWithDouble_(height) > JavaLangFloat_MAX_VALUE) {
    return;
  }
  GeogebraCommonKernelGeosGeoLine *g = [((GeogebraCommonKernelAlgosAlgoSlope *) nil_chk(((GeogebraCommonKernelAlgosAlgoSlope *) check_class_cast([geo getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoSlope class])))) getg];
  [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g)) getInhomPointOnLineWithDoubleArray:coords];
  jfloat x = (jfloat) IOSDoubleArray_Get(coords, 0);
  jfloat y = (jfloat) IOSDoubleArray_Get(coords, 1);
  jfloat xright = x + slopeTriangleSize;
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pspolygon"];
  [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  [codeFilledObject_ appendWithNSString:@"("];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:x]];
  [codeFilledObject_ appendWithNSString:@","];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:y]];
  [codeFilledObject_ appendWithNSString:@")"];
  [codeFilledObject_ appendWithNSString:@"("];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:xright]];
  [codeFilledObject_ appendWithNSString:@","];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:y]];
  [codeFilledObject_ appendWithNSString:@")"];
  [codeFilledObject_ appendWithNSString:@"("];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:xright]];
  [codeFilledObject_ appendWithNSString:@","];
  [codeFilledObject_ appendWithNSString:[self formatWithDouble:y + rwHeight]];
  [codeFilledObject_ appendWithNSString:@")"];
  [codeFilledObject_ appendWithNSString:@"\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
  jfloat xLabelHor = (x + xright) / 2;
  jfloat yLabelHor = y - (jfloat) (([((GeogebraCommonAwtGFont *) nil_chk([euclidianView_ getFont])) getSize] + 2) / [euclidianView_ getYscale]);
  GeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
  [self startBeamerWithJavaLangStringBuilder:codePoint_];
  [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\rput[bl]("];
  [codePoint_ appendWithNSString:[self formatWithDouble:xLabelHor]];
  [codePoint_ appendWithNSString:@","];
  [codePoint_ appendWithNSString:[self formatWithDouble:yLabelHor]];
  [codePoint_ appendWithNSString:@"){"];
  if (![((GeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
    [codePoint_ appendWithNSString:@"\\"];
    [self ColorCodeWithGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:codePoint_];
    [codePoint_ appendWithNSString:@"{"];
  }
  [codePoint_ appendWithInt:slopeTriangleSize];
  if (![geocolor isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
    [codePoint_ appendWithNSString:@"}"];
  }
  [codePoint_ appendWithNSString:@"}\n"];
  [self endBeamerWithJavaLangStringBuilder:codePoint_];
}

- (void)drawAngleWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo {
  jint arcSize = [((GeogebraCommonKernelGeosGeoAngle *) nil_chk(geo)) getArcSize];
  GeogebraCommonKernelAlgosAlgoElement *algo = [geo getParentAlgorithm];
  id<GeogebraCommonKernelKernelNDGeoPointND> vertex, point;
  id<GeogebraCommonKernelKernelNDGeoVectorND> v;
  GeogebraCommonKernelGeosGeoLine *line, *line2;
  GeogebraCommonKernelGeosGeoPoint *tempPoint = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(construction_) autorelease];
  [tempPoint setCoordsWithDouble:0.0 withDouble:0.0 withDouble:1.0];
  IOSDoubleArray *firstVec = [IOSDoubleArray arrayWithLength:2];
  IOSDoubleArray *m = [IOSDoubleArray arrayWithLength:2];
  if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoAnglePoints class]]) {
    GeogebraCommonKernelAlgosAlgoAnglePoints *pa = (GeogebraCommonKernelAlgosAlgoAnglePoints *) check_class_cast(algo, [GeogebraCommonKernelAlgosAlgoAnglePoints class]);
    vertex = [((GeogebraCommonKernelAlgosAlgoAnglePoints *) nil_chk(pa)) getB];
    point = [pa getA];
    [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(point)) getInhomCoordsInD3];
    *IOSDoubleArray_GetRef(firstVec, 0) = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] - IOSDoubleArray_Get(m, 0);
    *IOSDoubleArray_GetRef(firstVec, 1) = [coords getY] - IOSDoubleArray_Get(m, 1);
  }
  else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoAngleVectors class]]) {
    GeogebraCommonKernelAlgosAlgoAngleVectors *va = (GeogebraCommonKernelAlgosAlgoAngleVectors *) check_class_cast(algo, [GeogebraCommonKernelAlgosAlgoAngleVectors class]);
    v = [((GeogebraCommonKernelAlgosAlgoAngleVectors *) nil_chk(va)) getv];
    vertex = [((id<GeogebraCommonKernelKernelNDGeoVectorND>) nil_chk(v)) getStartPoint];
    if (vertex == nil) vertex = tempPoint;
    [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    [v getInhomCoordsWithDoubleArray:firstVec];
  }
  else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoAngleLines class]]) {
    GeogebraCommonKernelAlgosAlgoAngleLines *la = (GeogebraCommonKernelAlgosAlgoAngleLines *) check_class_cast(algo, [GeogebraCommonKernelAlgosAlgoAngleLines class]);
    vertex = tempPoint;
    [((GeogebraCommonKernelAlgosAlgoAngleLines *) nil_chk(la)) updateDrawInfoWithDoubleArray:m withDoubleArray:firstVec withGeogebraCommonEuclidianDrawDrawAngle:nil];
  }
  else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoAngleVector class]]) {
    GeogebraCommonKernelAlgosAlgoAngleVector *va = (GeogebraCommonKernelAlgosAlgoAngleVector *) check_class_cast(algo, [GeogebraCommonKernelAlgosAlgoAngleVector class]);
    GeogebraCommonKernelGeosGeoVec3D *vec = [((GeogebraCommonKernelAlgosAlgoAngleVector *) nil_chk(va)) getVec3D];
    if ([vec isKindOfClass:[GeogebraCommonKernelGeosGeoVector class]]) {
      v = (GeogebraCommonKernelGeosGeoVector *) check_class_cast(vec, [GeogebraCommonKernelGeosGeoVector class]);
      vertex = [((id<GeogebraCommonKernelKernelNDGeoVectorND>) nil_chk(v)) getStartPoint];
      if (vertex == nil) vertex = tempPoint;
      [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    }
    else if ([vec isKindOfClass:[GeogebraCommonKernelGeosGeoPoint class]]) {
      point = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(vec, [GeogebraCommonKernelGeosGeoPoint class]);
      vertex = tempPoint;
      [vertex getInhomCoordsWithDoubleArray:m];
    }
    *IOSDoubleArray_GetRef(firstVec, 0) = 1;
    *IOSDoubleArray_GetRef(firstVec, 1) = 0;
  }
  [tempPoint remove];
  jdouble angSt = JavaLangMath_atan2WithDouble_withDouble_(IOSDoubleArray_Get(firstVec, 1), IOSDoubleArray_Get(firstVec, 0));
  jdouble angExt = [geo getRawAngle];
  if (angExt > JavaLangMath_PI * 2) angExt -= JavaLangMath_PI * 2;
  if ([geo getAngleStyle] == GeogebraCommonKernelGeosGeoAngle_AngleStyleEnum_get_NOTREFLEX()) {
    if (angExt > JavaLangMath_PI) {
      angSt += angExt;
      angExt = 2.0 * JavaLangMath_PI - angExt;
    }
  }
  if ([geo getAngleStyle] == GeogebraCommonKernelGeosGeoAngle_AngleStyleEnum_get_ISREFLEX()) {
    if (angExt < JavaLangMath_PI) {
      angSt += angExt;
      angExt = 2.0 * JavaLangMath_PI - angExt;
    }
  }
  angExt += angSt;
  jdouble r = arcSize / [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXscale];
  if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([geo getValue], GeogebraCommonKernelKernel_PI_HALF) && [geo isEmphasizeRightAngle] && [euclidianView_ getRightAngleStyle] == GeogebraCommonPluginEuclidianStyleConstants_RIGHT_ANGLE_STYLE_SQUARE) {
    r = r / JavaLangMath_sqrtWithDouble_(2);
    IOSDoubleArray *x = [IOSDoubleArray arrayWithLength:8];
    *IOSDoubleArray_GetRef(x, 0) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_cosWithDouble_(angSt);
    *IOSDoubleArray_GetRef(x, 1) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sinWithDouble_(angSt);
    *IOSDoubleArray_GetRef(x, 2) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_sqrtWithDouble_(2) * JavaLangMath_cosWithDouble_(angSt + GeogebraCommonKernelKernel_PI_HALF / 2);
    *IOSDoubleArray_GetRef(x, 3) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sqrtWithDouble_(2) * JavaLangMath_sinWithDouble_(angSt + GeogebraCommonKernelKernel_PI_HALF / 2);
    *IOSDoubleArray_GetRef(x, 4) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_cosWithDouble_(angSt + GeogebraCommonKernelKernel_PI_HALF);
    *IOSDoubleArray_GetRef(x, 5) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sinWithDouble_(angSt + GeogebraCommonKernelKernel_PI_HALF);
    *IOSDoubleArray_GetRef(x, 6) = IOSDoubleArray_Get(m, 0);
    *IOSDoubleArray_GetRef(x, 7) = IOSDoubleArray_Get(m, 1);
    [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pspolygon"];
    [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    for (jint i = 0; i < 4; i++) {
      [codeFilledObject_ appendWithNSString:@"("];
      [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, 2 * i)]];
      [codeFilledObject_ appendWithNSString:@","];
      [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, 2 * i + 1)]];
      [codeFilledObject_ appendWithNSString:@")"];
    }
    [codeFilledObject_ appendWithNSString:@"\n"];
    [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
  }
  else {
    GeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
    [self startBeamerWithJavaLangStringBuilder:code_];
    if (![((GeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\pscustom"];
      [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      [code_ appendWithNSString:@"{\n"];
    }
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\parametricplot{"];
    [code_ appendWithDouble:angSt];
    [code_ appendWithNSString:@"}{"];
    [code_ appendWithDouble:angExt];
    [code_ appendWithNSString:@"}{"];
    [code_ appendWithNSString:[self formatWithDouble:r]];
    [code_ appendWithNSString:@"*cos(t)+"];
    [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(m, 0)]];
    [code_ appendWithNSString:@"|"];
    [code_ appendWithNSString:[self formatWithDouble:r]];
    [code_ appendWithNSString:@"*sin(t)+"];
    [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(m, 1)]];
    [code_ appendWithNSString:@"}\n"];
    if (![geocolor isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
      [code_ appendWithNSString:@"\\lineto("];
      [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(m, 0)]];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(m, 1)]];
      [code_ appendWithNSString:@")\\closepath}\n"];
    }
    [self endBeamerWithJavaLangStringBuilder:code_];
    if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([geo getValue], GeogebraCommonKernelKernel_PI_HALF) && [geo isEmphasizeRightAngle] && [euclidianView_ getRightAngleStyle] == GeogebraCommonPluginEuclidianStyleConstants_RIGHT_ANGLE_STYLE_DOT) {
      jdouble diameter = geo->lineThickness_ / [euclidianView_ getXscale];
      jdouble radius = arcSize / [euclidianView_ getXscale] / 1.7;
      jdouble labelAngle = (angSt + angExt) / 2.0;
      jdouble x1 = IOSDoubleArray_Get(m, 0) + radius * JavaLangMath_cosWithDouble_(labelAngle);
      jdouble x2 = IOSDoubleArray_Get(m, 1) + radius * JavaLangMath_sinWithDouble_(labelAngle);
      [self startBeamerWithJavaLangStringBuilder:code_];
      [code_ appendWithNSString:@"\\psellipse*"];
      [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      [code_ appendWithNSString:@"("];
      [code_ appendWithNSString:[self formatWithDouble:x1]];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:[self formatWithDouble:x2]];
      [code_ appendWithNSString:@")("];
      [code_ appendWithNSString:[self formatWithDouble:diameter]];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:[self formatWithDouble:diameter]];
      [code_ appendWithNSString:@")\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
    }
  }
  jint deco = geo->decorationType_;
  if (deco != GeogebraCommonKernelGeosGeoElement_DECORATION_NONE) {
    [self startBeamerWithJavaLangStringBuilder:code_];
    [self markAngleWithGeogebraCommonKernelGeosGeoAngle:geo withDouble:r withDoubleArray:m withDouble:angSt withDouble:angExt];
    [self endBeamerWithJavaLangStringBuilder:code_];
  }
}

- (void)drawArrowArcWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                         withDoubleArray:(IOSDoubleArray *)vertex
                                              withDouble:(jdouble)angSt
                                              withDouble:(jdouble)angEnd
                                              withDouble:(jdouble)r
                                             withBoolean:(jboolean)anticlockwise {
  jdouble arrowHeight = (((GeogebraCommonKernelGeosGeoAngle *) nil_chk(geo))->lineThickness_ * 0.8 + 3) * 1.4 * 3 / 4;
  jdouble angle = JavaLangMath_asinWithDouble_(arrowHeight / 2 / [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXscale] / r);
  angEnd = angEnd - angle;
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psellipticarc"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO]];
  if (anticlockwise) [code_ appendWithNSString:@"{->}("];
  else [code_ appendWithNSString:@"{<-}("];
  [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(vertex), 0)]];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(vertex, 1)]];
  [code_ appendWithNSString:@")("];
  [code_ appendWithNSString:[self formatWithDouble:r]];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:[self formatWithDouble:r]];
  [code_ appendWithNSString:@"){"];
  [code_ appendWithNSString:[self formatWithDouble:JavaLangMath_toDegreesWithDouble_(angSt)]];
  [code_ appendWithNSString:@"}{"];
  [code_ appendWithNSString:[self formatWithDouble:JavaLangMath_toDegreesWithDouble_(angEnd)]];
  [code_ appendWithNSString:@"}\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawArcWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                    withDoubleArray:(IOSDoubleArray *)vertex
                                         withDouble:(jdouble)angSt
                                         withDouble:(jdouble)angEnd
                                         withDouble:(jdouble)r {
  if (isBeamer_) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\parametricplot"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO]];
  [code_ appendWithNSString:@"{"];
  [code_ appendWithDouble:angSt];
  [code_ appendWithNSString:@"}{"];
  [code_ appendWithDouble:angEnd];
  [code_ appendWithNSString:@"}{"];
  [code_ appendWithNSString:[self formatWithDouble:r]];
  [code_ appendWithNSString:@"*cos(t)+"];
  [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(vertex), 0)]];
  [code_ appendWithNSString:@"|"];
  [code_ appendWithNSString:[self formatWithDouble:r]];
  [code_ appendWithNSString:@"*sin(t)+"];
  [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(vertex, 1)]];
  [code_ appendWithNSString:@"}\n"];
}

- (void)drawTickWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                     withDoubleArray:(IOSDoubleArray *)vertex
                                          withDouble:(jdouble)angle {
  angle = -angle;
  jdouble radius = [((GeogebraCommonKernelGeosGeoAngle *) nil_chk(geo)) getArcSize];
  jdouble diff = 2.5 + geo->lineThickness_ / 4.0;
  jdouble x1 = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:IOSDoubleArray_Get(nil_chk(vertex), 0) + (radius - diff) * JavaLangMath_cosWithDouble_(angle)];
  jdouble x2 = [euclidianView_ toRealWorldCoordXWithDouble:IOSDoubleArray_Get(vertex, 0) + (radius + diff) * JavaLangMath_cosWithDouble_(angle)];
  jdouble y1 = [euclidianView_ toRealWorldCoordYWithDouble:IOSDoubleArray_Get(vertex, 1) + (radius - diff) * JavaLangMath_sinWithDouble_(angle) * [euclidianView_ getScaleRatio]];
  jdouble y2 = [euclidianView_ toRealWorldCoordYWithDouble:IOSDoubleArray_Get(vertex, 1) + (radius + diff) * JavaLangMath_sinWithDouble_(angle) * [euclidianView_ getScaleRatio]];
  if (isBeamer_) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO]];
  [code_ appendWithNSString:@"("];
  [code_ appendWithNSString:[self formatWithDouble:x1]];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:[self formatWithDouble:y1]];
  [code_ appendWithNSString:@")("];
  [code_ appendWithNSString:[self formatWithDouble:x2]];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:[self formatWithDouble:y2]];
  [code_ appendWithNSString:@")\n"];
}

- (void)drawSliderWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  jboolean horizontal = [((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) isSliderHorizontal];
  jdouble max = [geo getIntervalMax];
  jdouble min = [geo getIntervalMin];
  jdouble value = [geo getValue];
  jdouble width = [geo getSliderWidth];
  jdouble x = [geo getSliderX];
  jdouble y = [geo getSliderY];
  if ([geo isAbsoluteScreenLocActive]) {
    x = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:x];
    y = [euclidianView_ toRealWorldCoordYWithDouble:y];
    width = horizontal ? width / [euclidianView_ getXscale] : width / [euclidianView_ getYscale];
  }
  GeogebraCommonKernelGeosGeoPoint *geoPoint = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(construction_) autorelease];
  [geoPoint setObjColorWithGeogebraCommonAwtGColor:[geo getObjectColor]];
  NSString *label = GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_([geo getLabelDescription], YES);
  [geoPoint setLabelWithNSString:label];
  jdouble param = (value - min) / (max - min);
  [geoPoint setPointSizeWithInt:2 + (geo->lineThickness_ + 1) / 3];
  [geoPoint setLabelVisibleWithBoolean:[geo isLabelVisible]];
  if (horizontal) [geoPoint setCoordsWithDouble:x + width * param withDouble:y withDouble:1.0];
  else [geoPoint setCoordsWithDouble:x withDouble:y + width * param withDouble:1.0];
  GeogebraCommonEuclidianDrawDrawPoint *drawPoint = [new_GeogebraCommonEuclidianDrawDrawPoint_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelKernelNDGeoPointND_(euclidianView_, geoPoint) autorelease];
  [drawPoint setGeoElementWithGeogebraCommonKernelGeosGeoElement:geo];
  if ([geo isLabelVisible]) {
    if (horizontal) {
      drawPoint->xLabel_ -= 15;
      drawPoint->yLabel_ -= 5;
    }
    else {
      drawPoint->xLabel_ += 5;
      drawPoint->yLabel_ += 2 * [geoPoint getPointSize] + 4;
    }
  }
  [self drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:geoPoint];
  [self drawLabelWithGeogebraCommonKernelGeosGeoElement:geoPoint withGeogebraCommonEuclidianDrawableND:drawPoint];
  [geoPoint remove];
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  [code_ appendWithNSString:@"("];
  [code_ appendWithNSString:[self formatWithDouble:x]];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:[self formatWithDouble:y]];
  [code_ appendWithNSString:@")("];
  if (horizontal) x += width;
  else y += width;
  [code_ appendWithNSString:[self formatWithDouble:x]];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:[self formatWithDouble:y]];
  [code_ appendWithNSString:@")\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawPolygonWithGeogebraCommonKernelGeosGeoPolygon:(GeogebraCommonKernelGeosGeoPolygon *)geo {
  jfloat alpha = [((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(geo)) getAlphaValue];
  if (alpha == 0.0f && [geo getFillType] == GeogebraCommonKernelGeosGeoElement_FillTypeEnum_get_IMAGE()) return;
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pspolygon"];
  [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  IOSObjectArray *points = [geo getPoints];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(points))->size_; i++) {
    GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(points, i))) getCoordsInD2];
    jdouble x = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX], y = [coords getY], z = [coords getZ];
    x = x / z;
    y = y / z;
    [codeFilledObject_ appendWithNSString:@"("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:x]];
    [codeFilledObject_ appendWithNSString:@","];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:y]];
    [codeFilledObject_ appendWithNSString:@")"];
  }
  [codeFilledObject_ appendWithNSString:@"\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawTextWithGeogebraCommonKernelGeosGeoText:(GeogebraCommonKernelGeosGeoText *)geo {
  jboolean isLatex = [((GeogebraCommonKernelGeosGeoText *) nil_chk(geo)) isLaTeX];
  NSString *st = [geo getTextString];
  GeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
  jint style = [geo getFontStyle];
  jint size = J2ObjCFpToInt(([geo getFontSizeMultiplier] * [((GeogebraCommonMainApp *) nil_chk([self getApp])) getFontSize]));
  GeogebraCommonKernelGeosGeoPoint *gp;
  jdouble x, y;
  if ([geo isAbsoluteScreenLocActive]) {
    x = [geo getAbsoluteScreenLocX];
    y = [geo getAbsoluteScreenLocY];
  }
  else {
    gp = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([geo getStartPoint], [GeogebraCommonKernelGeosGeoPoint class]);
    if (gp == nil) {
      x = J2ObjCFpToInt([((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXZero]);
      y = J2ObjCFpToInt([euclidianView_ getYZero]);
    }
    else {
      if (![gp isDefined]) {
        return;
      }
      x = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordXWithDouble:gp->inhomX_];
      y = [euclidianView_ toScreenCoordYWithDouble:gp->inhomY_];
    }
    x += geo->labelOffsetX_;
    y += geo->labelOffsetY_;
  }
  x = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:x];
  y = [euclidianView_ toRealWorldCoordYWithDouble:y - [((GeogebraCommonAwtGFont *) nil_chk([euclidianView_ getFont])) getSize]];
  jint id_ = [((NSString *) nil_chk(st)) indexOfString:@"\n"];
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (id_ == -1) {
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput[tl]("];
    [code_ appendWithNSString:[self formatWithDouble:x]];
    [code_ appendWithNSString:@","];
    [code_ appendWithNSString:[self formatWithDouble:y]];
    [code_ appendWithNSString:@"){"];
    GeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withGeogebraCommonAwtGColor_(self, st, isLatex, style, geocolor);
    [code_ appendWithNSString:@"}\n"];
  }
  else {
    JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
    GeogebraCommonUtilGStringTokenizer *stk = [new_GeogebraCommonUtilGStringTokenizer_initWithNSString_withChar_(st, 0x000a) autorelease];
    jint width = 0;
    GeogebraCommonAwtGFont *font = [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newFontWithNSString:[geo isSerifFont] ? @"Serif" : @"SansSerif" withInt:style withInt:size];
    while ([stk hasMoreTokens]) {
      NSString *line = [stk nextToken];
      width = JavaLangMath_maxWithInt_withInt_(width, J2ObjCFpToInt(JavaLangMath_ceilWithDouble_(GeogebraCommonUtilStringUtil_estimateLengthWithNSString_withGeogebraCommonAwtGFont_(line, font))));
      [sb appendWithNSString:line];
      if ([stk hasMoreTokens]) [sb appendWithNSString:@" \\\\ "];
    }
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput[lt]("];
    [code_ appendWithNSString:[self formatWithDouble:x]];
    [code_ appendWithNSString:@","];
    [code_ appendWithNSString:[self formatWithDouble:y]];
    [code_ appendWithNSString:@"){\\parbox{"];
    [code_ appendWithNSString:[self formatWithDouble:width * (xmax_ - xmin_) * xunit_ / [euclidianView_ getWidth] + 1]];
    [code_ appendWithNSString:@" cm}{"];
    GeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withGeogebraCommonAwtGColor_(self, [NSString stringWithJavaLangStringBuilder:sb], isLatex, style, geocolor);
    [code_ appendWithNSString:@"}}\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawGeoConicPartWithGeogebraCommonKernelGeosGeoConicPart:(GeogebraCommonKernelGeosGeoConicPart *)geo {
  jdouble r1 = IOSDoubleArray_Get(nil_chk([((GeogebraCommonKernelGeosGeoConicPart *) nil_chk(geo)) getHalfAxes]), 0);
  jdouble r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
  jdouble startAngle = [geo getParameterStart];
  jdouble endAngle = [geo getParameterEnd];
  id<GeogebraCommonAwtGAffineTransform> af = [geo getAffineTransform];
  jdouble m11 = [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(af)) getScaleX];
  jdouble m22 = [af getScaleY];
  jdouble m12 = [af getShearX];
  jdouble m21 = [af getShearY];
  jdouble tx = [af getTranslateX];
  jdouble ty = [af getTranslateY];
  [self startBeamerWithJavaLangStringBuilder:code_];
  if ([geo getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR) {
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\pscustom"];
    [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    [code_ appendWithNSString:@"{\\parametricplot{"];
  }
  else if ([geo getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC) {
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\parametricplot"];
    [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    [code_ appendWithNSString:@"{"];
  }
  if (startAngle > endAngle) {
    startAngle -= JavaLangMath_PI * 2;
  }
  JavaLangStringBuilder *sb1 = [new_JavaLangStringBuilder_init() autorelease];
  [sb1 appendWithNSString:[self formatWithDouble:r1]];
  [sb1 appendWithNSString:@"*cos(t)"];
  JavaLangStringBuilder *sb2 = [new_JavaLangStringBuilder_init() autorelease];
  [sb2 appendWithNSString:[self formatWithDouble:r2]];
  [sb2 appendWithNSString:@"*sin(t)"];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithDouble:startAngle];
  [code_ appendWithNSString:@"}{"];
  [code_ appendWithDouble:endAngle];
  [code_ appendWithNSString:@"}{"];
  [code_ appendWithNSString:[self formatWithDouble:m11]];
  [code_ appendWithNSString:@"*"];
  [code_ appendWithJavaLangCharSequence:sb1];
  [code_ appendWithNSString:@"+"];
  [code_ appendWithNSString:[self formatWithDouble:m12]];
  [code_ appendWithNSString:@"*"];
  [code_ appendWithJavaLangCharSequence:sb2];
  [code_ appendWithNSString:@"+"];
  [code_ appendWithNSString:[self formatWithDouble:tx]];
  [code_ appendWithNSString:@"|"];
  [code_ appendWithNSString:[self formatWithDouble:m21]];
  [code_ appendWithNSString:@"*"];
  [code_ appendWithJavaLangCharSequence:sb1];
  [code_ appendWithNSString:@"+"];
  [code_ appendWithNSString:[self formatWithDouble:m22]];
  [code_ appendWithNSString:@"*"];
  [code_ appendWithJavaLangCharSequence:sb2];
  [code_ appendWithNSString:@"+"];
  [code_ appendWithNSString:[self formatWithDouble:ty]];
  [code_ appendWithNSString:@"}"];
  if ([geo getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR) {
    [code_ appendWithNSString:@"\\lineto("];
    [code_ appendWithNSString:[self formatWithDouble:tx]];
    [code_ appendWithNSString:@","];
    [code_ appendWithNSString:[self formatWithDouble:ty]];
    [code_ appendWithNSString:@")\\closepath}"];
  }
  [code_ appendWithNSString:@"\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)geo
                                                                  withBoolean:(jboolean)trasparency {
  jdouble start = [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(geo)) getMinParameter];
  jdouble end = [geo getMaxParameter];
  NSString *fx = [geo getFunXWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  fx = GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(fx, YES));
  NSString *fy = [geo getFunYWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  fy = GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(fy, YES));
  NSString *variable = [geo getVarStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  jboolean warning = !([((NSString *) nil_chk(variable)) isEqual:@"t"]);
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (warning) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"% WARNING: You have to use the special variable t in parametric plot"];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\parametricplot"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:trasparency]];
  jint index = [code_ lastIndexOfWithNSString:@"]"];
  if (index == [code_ length] - 1) {
    [code_ deleteCharAtWithInt:index];
    [code_ appendWithNSString:@"]{"];
  }
  else [code_ appendWithNSString:@"{"];
  [code_ appendWithDouble:start];
  [code_ appendWithNSString:@"}{"];
  [code_ appendWithDouble:end];
  [code_ appendWithNSString:@"}{"];
  [code_ appendWithNSString:fx];
  [code_ appendWithNSString:@"|"];
  [code_ appendWithNSString:fy];
  [code_ appendWithNSString:@"}\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo {
  [self drawFunctionWithGeogebraCommonKernelGeosGeoFunction:geo withBoolean:NO withGeogebraCommonKernelGeosGeoNumeric:nil];
}

- (void)drawFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                                withBoolean:(jboolean)integral
                     withGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo1 {
  JavaLangStringBuilder *line = [new_JavaLangStringBuilder_init() autorelease];
  GeogebraCommonKernelArithmeticFunction *f = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(geo)) getFunction];
  if (nil == f) return;
  NSString *value = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f)) toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  value = GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(value, YES));
  jdouble a = xmin_;
  jdouble b = xmax_;
  if ([geo hasInterval]) {
    a = JavaLangMath_maxWithDouble_withDouble_(a, [geo getIntervalMin]);
    b = JavaLangMath_minWithDouble_withDouble_(b, [geo getIntervalMax]);
  }
  jdouble xrangemax = a, xrangemin = a;
  while (xrangemax < b) {
    xrangemin = GeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, geo, a, b);
    if (xrangemin == b) break;
    xrangemax = GeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, geo, xrangemin, b);
    [self startBeamerWithJavaLangStringBuilder:code_];
    [line appendWithNSString:@"\\psplot"];
    NSString *liopco = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    jint index = [((NSString *) nil_chk(liopco)) lastIndexOfString:@"]"];
    if (index != -1 && index == ((jint) [liopco length]) - 1) {
      liopco = [liopco substring:0 endIndex:((jint) [liopco length]) - 1];
      liopco = JreStrcat("$$", liopco, @",plotpoints=200]{");
    }
    else liopco = JreStrcat("$$", liopco, @"[plotpoints=200]{");
    [line appendWithNSString:liopco];
    [line appendWithDouble:xrangemin];
    [line appendWithNSString:@"}{"];
    [line appendWithDouble:xrangemax];
    [line appendWithNSString:@"}{"];
    [line appendWithNSString:value];
    [line appendWithNSString:@"}\n"];
    xrangemax += PRECISION_XRANGE_FUNCTION_;
    NSString *s = [line description];
    if (![self isLatexFunctionWithNSString:[f toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()]]) {
      liopco = [((NSString *) nil_chk(liopco)) replace:@",plotpoints=200]{" withSequence:@"]"];
      liopco = [((NSString *) nil_chk(liopco)) replace:@"[plotpoints=200]{" withSequence:@""];
      NSString *pre = @"";
      NSString *post = @"";
      NSString *template_ = JreStrcat("$$$", @"\\psline", liopco, @"(%0,%1)(%2,%3)\n");
      JavaLangStringBuilder *lineBuilder = [self drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction:geo withDouble:xrangemax withDouble:xrangemin withInt:200 withNSString:template_];
      s = [((JavaLangStringBuilder *) nil_chk(lineBuilder)) description];
      if (integral) {
        [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo1 withBoolean:YES]];
        pre = @"{";
        NSString *end = [s substring:[((NSString *) nil_chk(s)) lastIndexOfString:@"("]];
        post = JreStrcat("CDCD$D$", '(', b, ',', [f evaluateWithDouble:b], @")(", b, @",0)\n");
        post = JreStrcat("$$", post, JreStrcat("CD$D$", '(', b, @",0)(", a, @",0)\n"));
        post = JreStrcat("$$", post, JreStrcat("CD$DCD$", '(', a, @",0)(", a, ',', [f evaluateWithDouble:a], @")}\n"));
      }
      s = JreStrcat("$$$", pre, s, post);
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:s];
    }
    else {
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:line];
    }
    a = xrangemax;
    [self endBeamerWithJavaLangStringBuilder:code_];
  }
}

+ (NSString *)killSpaceWithNSString:(NSString *)name {
  return GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(name);
}

+ (void)renameFuncWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                               withNSString:(NSString *)nameFunc
                               withNSString:(NSString *)nameNew {
  GeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, nameFunc, nameNew);
}

- (jdouble)maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                       withDouble:(jdouble)a
                                                       withDouble:(jdouble)b {
  return GeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, a, b);
}

- (jdouble)firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                         withDouble:(jdouble)a
                                                         withDouble:(jdouble)b {
  return GeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, a, b);
}

- (void)drawGeoVectorWithGeogebraCommonKernelGeosGeoVector:(GeogebraCommonKernelGeosGeoVector *)geo {
  id<GeogebraCommonKernelKernelNDGeoPointND> pointStart = [((GeogebraCommonKernelGeosGeoVector *) nil_chk(geo)) getStartPoint];
  NSString *x1, *y1;
  if (nil == pointStart) {
    x1 = @"0";
    y1 = @"0";
  }
  else {
    GeogebraCommonKernelMatrixCoords *c = [pointStart getCoords];
    x1 = [self formatWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(c)) getX] / [c getZ]];
    y1 = [self formatWithDouble:[c getY] / [c getZ]];
  }
  IOSDoubleArray *coord = [IOSDoubleArray arrayWithLength:3];
  [geo getCoordsWithDoubleArray:coord];
  NSString *x2 = [self formatWithDouble:IOSDoubleArray_Get(coord, 0) + [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:x1]];
  NSString *y2 = [self formatWithDouble:IOSDoubleArray_Get(coord, 1) + [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) evaluateToDoubleWithNSString:y1]];
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  [code_ appendWithNSString:@"{->}("];
  [code_ appendWithNSString:x1];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:y1];
  [code_ appendWithNSString:@")("];
  [code_ appendWithNSString:x2];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:y2];
  [code_ appendWithNSString:@")\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawCircleWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)geo {
  GeogebraCommonExportPstricksGeoGebraToPstricks_drawCircleWithGeogebraCommonKernelGeosGeoConic_(self, geo);
}

- (void)drawGeoConicWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)geo {
  {
    id<GeogebraCommonAwtGAffineTransform> at;
    jdouble eigenvecX;
    jdouble eigenvecY;
    jdouble x1;
    jdouble y1;
    jdouble r1;
    jdouble r2;
    jdouble angle;
    jdouble p;
    jdouble x0;
    jint i;
    jint k2;
    switch ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getType]) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
      GeogebraCommonExportPstricksGeoGebraToPstricks_drawCircleWithGeogebraCommonKernelGeosGeoConic_(self, geo);
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
      at = [geo getAffineTransform];
      eigenvecX = [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
      r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX));
      [self startBeamerWithJavaLangStringBuilder:code_];
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput{"];
      [code_ appendWithNSString:[self formatWithDouble:angle]];
      [code_ appendWithNSString:@"}("];
      [code_ appendWithNSString:[self formatWithDouble:x1]];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:[self formatWithDouble:y1]];
      [code_ appendWithNSString:@"){\\psellipse"];
      [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      [code_ appendWithNSString:@"(0,0)("];
      [code_ appendWithNSString:[self formatWithDouble:r1]];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:[self formatWithDouble:r2]];
      [code_ appendWithNSString:@")}\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
      p = geo->p_;
      at = [geo getAffineTransform];
      eigenvecX = [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      x0 = JavaLangMath_maxWithDouble_withDouble_(JavaLangMath_absWithDouble_(x1 - xmin_), JavaLangMath_absWithDouble_(x1 - xmax_));
      x0 = JavaLangMath_maxWithDouble_withDouble_(x0, JavaLangMath_absWithDouble_(y1 - ymin_));
      x0 = JavaLangMath_maxWithDouble_withDouble_(x0, JavaLangMath_absWithDouble_(y1 - ymax_));
      x0 = 4 * x0 / p;
      i = 4;
      k2 = 16;
      while (k2 < x0) {
        i += 2;
        k2 = i * i;
      }
      x0 = i * p;
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX)) - 90;
      [self startBeamerWithJavaLangStringBuilder:code_];
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput{"];
      [code_ appendWithNSString:[self formatWithDouble:angle]];
      [code_ appendWithNSString:@"}("];
      [code_ appendWithNSString:[self formatWithDouble:x1]];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:[self formatWithDouble:y1]];
      [code_ appendWithNSString:@"){\\psplot"];
      [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      [code_ appendWithNSString:@"{"];
      [code_ appendWithNSString:[self formatWithDouble:-x0]];
      [code_ appendWithNSString:@"}{"];
      [code_ appendWithNSString:[self formatWithDouble:x0]];
      [code_ appendWithNSString:@"}"];
      [code_ appendWithNSString:@"{x^2/2/"];
      [code_ appendWithNSString:[self formatWithDouble:p]];
      [code_ appendWithNSString:@"}}\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
      at = [geo getAffineTransform];
      eigenvecX = [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
      r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX));
      [self startBeamerWithJavaLangStringBuilder:code_];
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput{"];
      [code_ appendWithNSString:[self formatWithDouble:angle]];
      [code_ appendWithNSString:@"}("];
      [code_ appendWithNSString:[self formatWithDouble:x1]];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:[self formatWithDouble:y1]];
      [code_ appendWithNSString:@"){\\parametricplot"];
      [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      [code_ appendWithNSString:@"{-0.99}{0.99}{"];
      [code_ appendWithNSString:[self formatWithDouble:r1]];
      [code_ appendWithNSString:@"*(1+t^2)/(1-t^2)|"];
      [code_ appendWithNSString:[self formatWithDouble:r2]];
      [code_ appendWithNSString:@"*2*t/(1-t^2)"];
      [code_ appendWithNSString:@"}}\n"];
      [code_ appendWithNSString:@"\\rput{"];
      [code_ appendWithNSString:[self formatWithDouble:angle]];
      [code_ appendWithNSString:@"}("];
      [code_ appendWithNSString:[self formatWithDouble:x1]];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:[self formatWithDouble:y1]];
      [code_ appendWithNSString:@"){\\parametricplot"];
      [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      [code_ appendWithNSString:@"{-0.99}{0.99}{"];
      [code_ appendWithNSString:[self formatWithDouble:r1]];
      [code_ appendWithNSString:@"*(-1-t^2)/(1-t^2)|"];
      [code_ appendWithNSString:[self formatWithDouble:r2]];
      [code_ appendWithNSString:@"*(-2)*t/(1-t^2)"];
      [code_ appendWithNSString:@"}}\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
    }
  }
}

- (void)drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)gp {
  if ([((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) getExportPointSymbol]) {
    [self startBeamerWithJavaLangStringBuilder:codePoint_];
    jdouble x = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(gp)) getX];
    jdouble y = [gp getY];
    jdouble z = [gp getZ];
    x = x / z;
    y = y / z;
    [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\psdots"];
    GeogebraCommonExportPstricksGeoGebraToPstricks_PointOptionCodeWithGeogebraCommonKernelGeosGeoPoint_(self, gp);
    [codePoint_ appendWithNSString:@"("];
    [codePoint_ appendWithNSString:[self formatWithDouble:x]];
    [codePoint_ appendWithNSString:@","];
    [codePoint_ appendWithNSString:[self formatWithDouble:y]];
    [codePoint_ appendWithNSString:@")\n"];
    [self endBeamerWithJavaLangStringBuilder:codePoint_];
  }
  if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(gp)) getShowTrimmedIntersectionLines]) {
    GeogebraCommonKernelAlgosAlgoElement *algo = [gp getParentAlgorithm];
    if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoIntersectAbstract class]]) {
      IOSObjectArray *geos = [((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(algo)) getInput];
      jdouble x1 = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordXdWithDouble:[gp getInhomX]];
      jdouble y1 = [euclidianView_ toScreenCoordYdWithDouble:[gp getInhomY]];
      jdouble x2 = [euclidianView_ toScreenCoordXdWithDouble:[gp getInhomX]] + 30;
      jdouble y2 = [euclidianView_ toScreenCoordYdWithDouble:[gp getInhomY]] + 30;
      x1 = [euclidianView_ toRealWorldCoordXWithDouble:x1];
      x2 = [euclidianView_ toRealWorldCoordXWithDouble:x2];
      y1 = [euclidianView_ toRealWorldCoordYWithDouble:y1];
      y2 = [euclidianView_ toRealWorldCoordYWithDouble:y2];
      jdouble r1 = JavaLangMath_absWithDouble_(x2 - x1);
      jdouble r2 = JavaLangMath_absWithDouble_(y2 - y1);
      JavaLangStringBuilder *s = [new_JavaLangStringBuilder_initWithNSString_(@"\\psclip{\\psellipse[linestyle=none](") autorelease];
      [s appendWithNSString:[self formatWithDouble:x1]];
      [s appendWithNSString:@","];
      [s appendWithNSString:[self formatWithDouble:y1]];
      [s appendWithNSString:@")("];
      [s appendWithNSString:[self formatWithDouble:r1]];
      [s appendWithNSString:@","];
      [s appendWithNSString:[self formatWithDouble:r2]];
      [s appendWithNSString:@")}\n"];
      NSString *end = @"\\endpsclip\n";
      jboolean fill1 = NO;
      jboolean draw = ![((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(nil_chk(geos), 0))) isEuclidianVisible];
      if (draw) {
        fill1 = ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 0))) isFillable] && [((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 0))) getAlphaValue] > 0.0f);
        if (fill1) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
        else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
        [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 0) withBoolean:NO withBoolean:YES];
      }
      if (geos->size_ > 1 && ![((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) isEuclidianVisible]) {
        jboolean fill2 = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) isFillable] && ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) getAlphaValue] > 0.0f);
        if (draw) {
          if (fill1 == fill2) {
            [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
            if (fill1) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
          }
          else {
            if (fill1) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
            if (fill2) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
            else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
            [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
            if (fill2) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
          }
        }
        else {
          if (fill2) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
          else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
          [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
          if (fill2) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
          else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
        }
      }
      else if (draw) {
        if (fill1) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
        else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
      }
    }
  }
}

- (void)drawGeoLineWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)geo {
  jdouble x = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(geo)) getX];
  jdouble y = [geo getY];
  jdouble z = [geo getZ];
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (y != 0) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psplot"];
  else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  if (y != 0) {
    [code_ appendWithNSString:@"{"];
    [code_ appendWithNSString:[self formatWithDouble:xmin_]];
    [code_ appendWithNSString:@"}{"];
    [code_ appendWithNSString:[self formatWithDouble:xmax_]];
    [code_ appendWithNSString:@"}{(-"];
    [code_ appendWithNSString:[self formatWithDouble:z]];
    [code_ appendWithNSString:@"-"];
    [code_ appendWithNSString:[self formatWithDouble:x]];
    [code_ appendWithNSString:@"*x)/"];
    NSString *tmpy = [self formatWithDouble:y];
    if ([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpy] != 0) [code_ appendWithNSString:tmpy];
    else [code_ appendWithDouble:y];
    [code_ appendWithNSString:@"}\n"];
  }
  else {
    NSString *s = [self formatWithDouble:-z / x];
    [code_ appendWithNSString:@"("];
    [code_ appendWithNSString:s];
    [code_ appendWithNSString:@","];
    [code_ appendWithNSString:[self formatWithDouble:ymin_]];
    [code_ appendWithNSString:@")("];
    [code_ appendWithNSString:s];
    [code_ appendWithNSString:@","];
    [code_ appendWithNSString:[self formatWithDouble:ymax_]];
    [code_ appendWithNSString:@")\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawGeoSegmentWithGeogebraCommonKernelGeosGeoSegment:(GeogebraCommonKernelGeosGeoSegment *)geo {
  IOSDoubleArray *A = [IOSDoubleArray arrayWithLength:2];
  IOSDoubleArray *B = [IOSDoubleArray arrayWithLength:2];
  GeogebraCommonKernelGeosGeoPoint *pointStart = ((GeogebraCommonKernelGeosGeoPoint *) [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(geo)) getStartPoint]);
  GeogebraCommonKernelGeosGeoPoint *pointEnd = ((GeogebraCommonKernelGeosGeoPoint *) [geo getEndPoint]);
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(pointStart)) getInhomCoordsWithDoubleArray:A];
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(pointEnd)) getInhomCoordsWithDoubleArray:B];
  NSString *x1 = [self formatWithDouble:IOSDoubleArray_Get(A, 0)];
  NSString *y1 = [self formatWithDouble:IOSDoubleArray_Get(A, 1)];
  NSString *x2 = [self formatWithDouble:IOSDoubleArray_Get(B, 0)];
  NSString *y2 = [self formatWithDouble:IOSDoubleArray_Get(B, 1)];
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  [code_ appendWithNSString:@"("];
  [code_ appendWithNSString:x1];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:y1];
  [code_ appendWithNSString:@")("];
  [code_ appendWithNSString:x2];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:y2];
  [code_ appendWithNSString:@")\n"];
  jint deco = geo->decorationType_;
  if (deco != GeogebraCommonKernelGeosGeoElement_DECORATION_NONE) [self markWithDoubleArray:A withDoubleArray:B withInt:deco withGeogebraCommonKernelGeosGeoElement:geo];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawLineWithDouble:(jdouble)x1
                withDouble:(jdouble)y1
                withDouble:(jdouble)x2
                withDouble:(jdouble)y2
withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  NSString *sx1 = [self formatWithDouble:x1];
  NSString *sy1 = [self formatWithDouble:y1];
  NSString *sx2 = [self formatWithDouble:x2];
  NSString *sy2 = [self formatWithDouble:y2];
  if (isBeamer_) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  [code_ appendWithNSString:@"("];
  [code_ appendWithNSString:sx1];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:sy1];
  [code_ appendWithNSString:@")("];
  [code_ appendWithNSString:sx2];
  [code_ appendWithNSString:@","];
  [code_ appendWithNSString:sy2];
  [code_ appendWithNSString:@")\n"];
}

- (void)drawGeoRayWithGeogebraCommonKernelGeosGeoRay:(GeogebraCommonKernelGeosGeoRay *)geo {
  GeogebraCommonKernelGeosGeoPoint *pointStart = ((GeogebraCommonKernelGeosGeoPoint *) [((GeogebraCommonKernelGeosGeoRay *) nil_chk(geo)) getStartPoint]);
  jdouble x1 = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(pointStart)) getX];
  jdouble z1 = [pointStart getZ];
  x1 = x1 / z1;
  NSString *y1 = [self formatWithDouble:[pointStart getY] / z1];
  jdouble x = [geo getX];
  jdouble y = [geo getY];
  jdouble z = [geo getZ];
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (y != 0) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psplot"];
  else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  jdouble inf = xmin_, sup = xmax_;
  if (y > 0) {
    inf = x1;
  }
  else {
    sup = x1;
  }
  if (y != 0) {
    [code_ appendWithNSString:@"{"];
    [code_ appendWithNSString:[self formatWithDouble:inf]];
    [code_ appendWithNSString:@"}{"];
    [code_ appendWithNSString:[self formatWithDouble:sup]];
    [code_ appendWithNSString:@"}{(-"];
    [code_ appendWithNSString:[self formatWithDouble:z]];
    [code_ appendWithNSString:@"-"];
    [code_ appendWithNSString:[self formatWithDouble:x]];
    [code_ appendWithNSString:@"*x)/"];
    NSString *tmpy = [self formatWithDouble:y];
    if ([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpy] != 0) [code_ appendWithNSString:tmpy];
    else [code_ appendWithDouble:y];
    [code_ appendWithNSString:@"}\n"];
  }
  else {
    if (-x > 0) sup = ymax_;
    else sup = ymin_;
    [code_ appendWithNSString:@"("];
    [code_ appendWithNSString:[self formatWithDouble:x1]];
    [code_ appendWithNSString:@","];
    [code_ appendWithNSString:y1];
    [code_ appendWithNSString:@")("];
    [code_ appendWithNSString:[self formatWithDouble:x1]];
    [code_ appendWithNSString:@","];
    [code_ appendWithNSString:[self formatWithDouble:sup]];
    [code_ appendWithNSString:@")\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)initUnitAndVariable {
  GeogebraCommonExportPstricksGeoGebraToPstricks_initUnitAndVariable(self);
}

- (void)drawLabelWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo
                  withGeogebraCommonEuclidianDrawableND:(GeogebraCommonEuclidianDrawableND *)drawGeo {
  @try {
    if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isLabelVisible]) {
      NSString *name = [geo getLabelDescription];
      if ([geo getLabelMode] == GeogebraCommonKernelGeosGeoElement_LABEL_CAPTION) {
        NSString *nameSym = name;
        for (jint i = 0; i < ((jint) [((NSString *) nil_chk(name)) length]); i++) {
          NSString *uCode = JreStrcat("C", [name charAtWithInt:i]);
          if ([((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
            nameSym = [((NSString *) nil_chk(nameSym)) replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$$", @"\\$\\\\", [((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode], @"\\$")];
          }
        }
        nameSym = [((NSString *) nil_chk(nameSym)) replace:@"$\\euro$" withSequence:@"\\euro"];
        name = nameSym;
        if (!eurosym_ && [((NSString *) nil_chk(name)) contains:@"\\euro"]) [((JavaLangStringBuilder *) nil_chk(codePreamble_)) appendWithNSString:@"\\usepackage{eurosym}\n"];
        if ([((NSString *) nil_chk(name)) contains:@"_"]) {
          name = JreStrcat("C$C", '$', name, '$');
        }
      }
      else {
        name = JreStrcat("C$C", '$', GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_([geo getLabelDescription], YES), '$');
      }
      if ([((NSString *) nil_chk(name)) indexOfString:@"\u00b0"] != -1) {
        name = [name replaceAll:@"\u00b0" withReplacement:@"\\\\textrm{\\\\degre}"];
        if ([((JavaLangStringBuilder *) nil_chk(codePreamble_)) indexOfWithNSString:@"\\degre"] == -1) [codePreamble_ appendWithNSString:@"\\newcommand{\\degre}{\\ensuremath{^\\circ}}\n"];
      }
      if (nil == drawGeo) drawGeo = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getDrawableForWithGeogebraCommonKernelGeosGeoElement:geo];
      jdouble xLabel = [((GeogebraCommonEuclidianDrawableND *) nil_chk(drawGeo)) getxLabel];
      jdouble yLabel = [drawGeo getyLabel];
      xLabel = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:JavaLangMath_roundWithDouble_(xLabel)];
      yLabel = [euclidianView_ toRealWorldCoordYWithDouble:JavaLangMath_roundWithDouble_(yLabel)];
      GeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
      [self startBeamerWithJavaLangStringBuilder:codePoint_];
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\rput[bl]("];
      [codePoint_ appendWithNSString:[self formatWithDouble:xLabel]];
      [codePoint_ appendWithNSString:@","];
      [codePoint_ appendWithNSString:[self formatWithDouble:yLabel]];
      [codePoint_ appendWithNSString:@"){"];
      if (![((GeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
        [codePoint_ appendWithNSString:@"\\"];
        [self ColorCodeWithGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:codePoint_];
        [codePoint_ appendWithNSString:@"{"];
      }
      [codePoint_ appendWithNSString:name];
      if (![geocolor isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
        [codePoint_ appendWithNSString:@"}"];
      }
      [codePoint_ appendWithNSString:@"}\n"];
      [self endBeamerWithJavaLangStringBuilder:codePoint_];
    }
  }
  @catch (JavaLangNullPointerException *e) {
  }
}

- (void)drawGrid {
  GeogebraCommonExportPstricksGeoGebraToPstricks_drawGrid(self);
}

- (void)drawAxis {
  GeogebraCommonExportPstricksGeoGebraToPstricks_drawAxis(self);
}

- (void)PointOptionCodeWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)geo {
  GeogebraCommonExportPstricksGeoGebraToPstricks_PointOptionCodeWithGeogebraCommonKernelGeosGeoPoint_(self, geo);
}

- (NSString *)LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo
                                                       withBoolean:(jboolean)transparency {
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  jint linethickness = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getLineThickness];
  jint linestyle = [geo getLineType];
  GeogebraCommonExportPstricksGeoGebraExport_Info *info = [new_GeogebraCommonExportPstricksGeoGebraExport_Info_initWithGeogebraCommonExportPstricksGeoGebraExport_withGeogebraCommonKernelGeosGeoElement_(self, geo) autorelease];
  jboolean coma = NO;
  jboolean bracket = NO;
  if (linethickness != GeogebraCommonPluginEuclidianStyleConstants_DEFAULT_LINE_THICKNESS) {
    coma = YES;
    bracket = YES;
    [sb appendWithNSString:@"[linewidth="];
    [sb appendWithNSString:[self formatWithDouble:linethickness / 2.0 * 0.8]];
    [sb appendWithNSString:@"pt"];
  }
  if (linestyle != GeogebraCommonPluginEuclidianStyleConstants_DEFAULT_LINE_TYPE) {
    if (coma) [sb appendWithNSString:@","];
    else coma = YES;
    if (!bracket) [sb appendWithNSString:@"["];
    bracket = YES;
    GeogebraCommonExportPstricksGeoGebraToPstricks_LinestyleCodeWithInt_withJavaLangStringBuilder_(self, linestyle, sb);
  }
  if (![((GeogebraCommonAwtGColor *) nil_chk([info getLinecolor])) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
    if (coma) [sb appendWithNSString:@","];
    else coma = YES;
    if (!bracket) [sb appendWithNSString:@"["];
    bracket = YES;
    [sb appendWithNSString:@"linecolor="];
    [self ColorCodeWithGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
  }
  if ([geo isFillable] && transparency) {
    jboolean dotted = NO;
    NSString *style = @",fillstyle=hlines,hatchangle=";
    {
      jdouble y0;
      jdouble y;
      switch ([[info getFillType] ordinal]) {
        case GeogebraCommonKernelGeosGeoElement_FillType_STANDARD:
        if ([info getAlpha] > 0.0f) {
          if (coma) [sb appendWithNSString:@","];
          else coma = YES;
          if (!bracket) [sb appendWithNSString:@"["];
          bracket = YES;
          [sb appendWithNSString:@"fillcolor="];
          [self ColorCodeWithGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
          [sb appendWithNSString:@",fillstyle=solid,opacity="];
          [sb appendWithFloat:[info getAlpha]];
        }
        break;
        case GeogebraCommonKernelGeosGeoElement_FillType_SYMBOLS:
        case GeogebraCommonKernelGeosGeoElement_FillType_CHESSBOARD:
        case GeogebraCommonKernelGeosGeoElement_FillType_HONEYCOMB:
        case GeogebraCommonKernelGeosGeoElement_FillType_BRICK:
        case GeogebraCommonKernelGeosGeoElement_FillType_DOTTED:
        dotted = YES;
        case GeogebraCommonKernelGeosGeoElement_FillType_CROSSHATCHED:
        style = @",fillstyle=crosshatch,hatchangle=";
        case GeogebraCommonKernelGeosGeoElement_FillType_HATCH:
        if (coma) [sb appendWithNSString:@","];
        else coma = YES;
        if (!bracket) [sb appendWithNSString:@"["];
        bracket = YES;
        [sb appendWithNSString:@"hatchcolor="];
        [self ColorCodeWithGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
        if (dotted) {
          style = @",fillstyle=dots*,hatchangle=";
        }
        [sb appendWithNSString:style];
        [sb appendWithDouble:[info getAngle]];
        [sb appendWithNSString:@",hatchsep="];
        y0 = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordYWithDouble:0];
        y = [euclidianView_ toRealWorldCoordYWithDouble:[info getY]];
        [sb appendWithNSString:[self formatWithDouble:JavaLangMath_absWithDouble_((y - y0))]];
        break;
      }
    }
  }
  if (bracket) [sb appendWithNSString:@"]"];
  return [NSString stringWithJavaLangStringBuilder:sb];
}

- (void)LinestyleCodeWithInt:(jint)linestyle
   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  GeogebraCommonExportPstricksGeoGebraToPstricks_LinestyleCodeWithInt_withJavaLangStringBuilder_(self, linestyle, sb);
}

- (void)ColorCodeWithGeogebraCommonAwtGColor:(GeogebraCommonAwtGColor *)c
                   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  if ([((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) isGrayscale]) {
    NSString *colorname = @"";
    jint red = [((GeogebraCommonAwtGColor *) nil_chk(c)) getRed];
    jint green = [c getGreen];
    jint blue = [c getBlue];
    jint grayscale = (red + green + blue) / 3;
    c = [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newColorWithInt:grayscale withInt:grayscale withInt:grayscale];
    if ([((JavaUtilHashMap *) nil_chk(CustomColor_)) containsKeyWithId:c]) {
      colorname = [((NSString *) nil_chk([CustomColor_ getWithId:c])) description];
    }
    else {
      colorname = [self createCustomColorWithInt:grayscale withInt:grayscale withInt:grayscale];
      [((JavaLangStringBuilder *) nil_chk(codeBeginDoc_)) appendWithNSString:JreStrcat("$$$$C$C$$", @"\\newrgbcolor{", colorname, @"}{", [self formatWithDouble:grayscale / 255.0], ' ', [self formatWithDouble:grayscale / 255.0], ' ', [self formatWithDouble:grayscale / 255.0], @"}\n")];
      [CustomColor_ putWithId:c withId:colorname];
    }
    if ([((GeogebraCommonAwtGColor *) nil_chk(c)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"black"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_DARK_GRAY_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"darkgray"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_GRAY_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"gray"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_LIGHT_GRAY_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"lightgray"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_WHITE_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"white"];
    else [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:colorname];
  }
  else {
    if ([((GeogebraCommonAwtGColor *) nil_chk(c)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"black"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_DARK_GRAY_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"darkgray"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_GRAY_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"gray"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_LIGHT_GRAY_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"lightgray"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_WHITE_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"white"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_RED_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"red"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_GREEN_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"green"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_BLUE_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"blue"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_CYAN_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"cyan"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_MAGENTA_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"magenta"];
    else if ([c isEqual:GeogebraCommonAwtGColor_get_YELLOW_()]) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"yellow"];
    else {
      NSString *colorname = @"";
      if ([((JavaUtilHashMap *) nil_chk(CustomColor_)) containsKeyWithId:c]) {
        colorname = [((NSString *) nil_chk([CustomColor_ getWithId:c])) description];
      }
      else {
        jint red = [c getRed];
        jint green = [c getGreen];
        jint blue = [c getBlue];
        colorname = [self createCustomColorWithInt:red withInt:green withInt:blue];
        [((JavaLangStringBuilder *) nil_chk(codeBeginDoc_)) appendWithNSString:JreStrcat("$$$$C$C$$", @"\\newrgbcolor{", colorname, @"}{", [self formatWithDouble:red / 255.0], ' ', [self formatWithDouble:green / 255.0], ' ', [self formatWithDouble:blue / 255.0], @"}\n")];
        [CustomColor_ putWithId:c withId:colorname];
      }
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:colorname];
    }
  }
}

- (void)addTextWithNSString:(NSString *)st
                withBoolean:(jboolean)isLatex
                    withInt:(jint)style
withGeogebraCommonAwtGColor:(GeogebraCommonAwtGColor *)geocolor {
  GeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withGeogebraCommonAwtGColor_(self, st, isLatex, style, geocolor);
}

- (void)drawImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:(GeogebraCommonKernelImplicitGeoImplicitPoly *)geo {
  if ([((JavaLangStringBuilder *) nil_chk(codePreamble_)) indexOfWithNSString:@"pst-func"] == -1) {
    [codePreamble_ appendWithNSString:@"\\usepackage{pst-func}\n"];
  }
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psplotImp"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  [code_ appendWithNSString:@"("];
  [code_ appendWithDouble:JavaLangMath_floorWithDouble_(xmin_) - 1];
  [code_ appendWithNSString:@","];
  [code_ appendWithDouble:JavaLangMath_floorWithDouble_(ymin_) - 1];
  [code_ appendWithNSString:@")("];
  [code_ appendWithDouble:JavaLangMath_floorWithDouble_(xmax_) + 1];
  [code_ appendWithNSString:@","];
  [code_ appendWithDouble:JavaLangMath_floorWithDouble_(ymax_) + 1];
  [code_ appendWithNSString:@"){"];
  [code_ appendWithNSString:[self getImplicitExprWithGeogebraCommonKernelImplicitGeoImplicitPoly:geo]];
  [code_ appendWithNSString:@"}\n"];
}

- (void)drawPolyLineWithGeogebraCommonKernelGeosGeoPolyLine:(GeogebraCommonKernelGeosGeoPolyLine *)geo {
  IOSObjectArray *path = [((GeogebraCommonKernelGeosGeoPolyLine *) nil_chk(geo)) getPoints];
  if (((IOSObjectArray *) nil_chk(path))->size_ < 2) return;
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  for (jint i = 0; i < path->size_; i++) {
    GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(path, i))) getInhomCoords];
    NSString *x1 = [self formatWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX]];
    NSString *y1 = [self formatWithDouble:[coords getY]];
    if ([((NSString *) nil_chk(x1)) contains:@"?"] || [((NSString *) nil_chk(y1)) contains:@"?"]) {
      [code_ appendWithNSString:@"\n\\psline"];
      [code_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    }
    else {
      [code_ appendWithNSString:@"("];
      [code_ appendWithNSString:x1];
      [code_ appendWithNSString:@","];
      [code_ appendWithNSString:y1];
      [code_ appendWithNSString:@")"];
    }
  }
  [code_ appendWithNSString:@"\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawHistogramOrBarChartBoxWithDoubleArray:(IOSDoubleArray *)y
                                  withDoubleArray:(IOSDoubleArray *)x
                                          withInt:(jint)length
                                       withDouble:(jdouble)width
           withGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)g {
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  for (jint i = 0; i < length; i++) {
    barNumber_ = i + 1;
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\psframe"];
    [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:g withBoolean:YES]];
    [codeFilledObject_ appendWithNSString:@"("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(x), i)]];
    [codeFilledObject_ appendWithNSString:@",0)("];
    if (x->size_ == length) {
      [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i) + width]];
    }
    else {
      [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1)]];
    }
    [codeFilledObject_ appendWithNSString:@","];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(y), i)]];
    [codeFilledObject_ appendWithNSString:@")\n"];
    if (i != x->size_ - 2 && isBeamer_) [codeFilledObject_ appendWithNSString:@"  "];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawNyquistWithGeogebraCommonKernelGeosGeoTransferFunction:(GeogebraCommonKernelGeosGeoTransferFunction *)g {
  [self startBeamerWithJavaLangStringBuilder:code_];
  NSString *liopco = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:g withBoolean:YES];
  NSString *template_ = JreStrcat("$$$", @"\\psline", liopco, @"\u00a7arrows\u00a7(%0,%1)(%2,%3)\n");
  JavaLangStringBuilder *lineBuilder = [self drawNyquistDiagramWithGeogebraCommonKernelGeosGeoTransferFunction:g withNSString:template_ withNSString:@"\u00a7arrows\u00a7" withNSString:@"{<-}" withNSString:@"{->}"];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:[((JavaLangStringBuilder *) nil_chk(lineBuilder)) description]];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (jboolean)fillSplineWithGeogebraCommonKernelGeosGeoCurveCartesianArray:(IOSObjectArray *)curves {
  NSString *liopco = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(nil_chk(curves), 0) withBoolean:YES];
  if (![((NSString *) nil_chk(liopco)) contains:@"fill"]) {
    return NO;
  }
  JavaLangStringBuilder *fill = [new_JavaLangStringBuilder_initWithNSString_(@"\\pscustom") autorelease];
  [fill appendWithNSString:liopco];
  [fill appendWithNSString:@"\n{\n"];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:fill];
  for (jint i = 0; i < curves->size_; i++) [self drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:IOSObjectArray_Get(curves, i) withBoolean:NO];
  [code_ appendWithNSString:@"}\n"];
  return YES;
}

- (void)dealloc {
  RELEASE_(codeBeginPic_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonMainApp:", "GeoGebraToPstricks", NULL, 0x1, NULL, NULL },
    { "generateAllCode", NULL, "V", 0x1, NULL, NULL },
    { "drawLocusWithGeogebraCommonKernelGeosGeoLocus:", "drawLocus", "V", 0x4, NULL, NULL },
    { "drawBoxPlotWithGeogebraCommonKernelGeosGeoNumeric:", "drawBoxPlot", "V", 0x4, NULL, NULL },
    { "drawSumTrapezoidalWithGeogebraCommonKernelGeosGeoNumeric:", "drawSumTrapezoidal", "V", 0x4, NULL, NULL },
    { "drawSumUpperLowerWithGeogebraCommonKernelGeosGeoNumeric:", "drawSumUpperLower", "V", 0x4, NULL, NULL },
    { "drawIntegralFunctionsWithGeogebraCommonKernelGeosGeoNumeric:", "drawIntegralFunctions", "V", 0x4, NULL, NULL },
    { "drawIntegralWithGeogebraCommonKernelGeosGeoNumeric:", "drawIntegral", "V", 0x4, NULL, NULL },
    { "drawSlopeWithGeogebraCommonKernelGeosGeoNumeric:", "drawSlope", "V", 0x4, NULL, NULL },
    { "drawAngleWithGeogebraCommonKernelGeosGeoAngle:", "drawAngle", "V", 0x4, NULL, NULL },
    { "drawArrowArcWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:withDouble:withDouble:withBoolean:", "drawArrowArc", "V", 0x4, NULL, NULL },
    { "drawArcWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:withDouble:withDouble:", "drawArc", "V", 0x4, NULL, NULL },
    { "drawTickWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:", "drawTick", "V", 0x4, NULL, NULL },
    { "drawSliderWithGeogebraCommonKernelGeosGeoNumeric:", "drawSlider", "V", 0x4, NULL, NULL },
    { "drawPolygonWithGeogebraCommonKernelGeosGeoPolygon:", "drawPolygon", "V", 0x4, NULL, NULL },
    { "drawTextWithGeogebraCommonKernelGeosGeoText:", "drawText", "V", 0x4, NULL, NULL },
    { "drawGeoConicPartWithGeogebraCommonKernelGeosGeoConicPart:", "drawGeoConicPart", "V", 0x4, NULL, NULL },
    { "drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:withBoolean:", "drawSingleCurveCartesian", "V", 0x4, NULL, NULL },
    { "drawFunctionWithGeogebraCommonKernelGeosGeoFunction:", "drawFunction", "V", 0x4, NULL, NULL },
    { "drawFunctionWithGeogebraCommonKernelGeosGeoFunction:withBoolean:withGeogebraCommonKernelGeosGeoNumeric:", "drawFunction", "V", 0x4, NULL, NULL },
    { "killSpaceWithNSString:", "killSpace", "Ljava.lang.String;", 0xa, NULL, NULL },
    { "renameFuncWithJavaLangStringBuilder:withNSString:withNSString:", "renameFunc", "V", 0xa, NULL, NULL },
    { "maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction:withDouble:withDouble:", "maxDefinedValue", "D", 0x2, NULL, NULL },
    { "firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction:withDouble:withDouble:", "firstDefinedValue", "D", 0x2, NULL, NULL },
    { "drawGeoVectorWithGeogebraCommonKernelGeosGeoVector:", "drawGeoVector", "V", 0x4, NULL, NULL },
    { "drawCircleWithGeogebraCommonKernelGeosGeoConic:", "drawCircle", "V", 0x2, NULL, NULL },
    { "drawGeoConicWithGeogebraCommonKernelGeosGeoConic:", "drawGeoConic", "V", 0x4, NULL, NULL },
    { "drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:", "drawGeoPoint", "V", 0x4, NULL, NULL },
    { "drawGeoLineWithGeogebraCommonKernelGeosGeoLine:", "drawGeoLine", "V", 0x4, NULL, NULL },
    { "drawGeoSegmentWithGeogebraCommonKernelGeosGeoSegment:", "drawGeoSegment", "V", 0x4, NULL, NULL },
    { "drawLineWithDouble:withDouble:withDouble:withDouble:withGeogebraCommonKernelGeosGeoElement:", "drawLine", "V", 0x4, NULL, NULL },
    { "drawGeoRayWithGeogebraCommonKernelGeosGeoRay:", "drawGeoRay", "V", 0x4, NULL, NULL },
    { "initUnitAndVariable", NULL, "V", 0x2, NULL, NULL },
    { "drawLabelWithGeogebraCommonKernelGeosGeoElement:withGeogebraCommonEuclidianDrawableND:", "drawLabel", "V", 0x4, NULL, NULL },
    { "drawGrid", NULL, "V", 0x2, NULL, NULL },
    { "drawAxis", NULL, "V", 0x2, NULL, NULL },
    { "PointOptionCodeWithGeogebraCommonKernelGeosGeoPoint:", "PointOptionCode", "V", 0x2, NULL, NULL },
    { "LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:withBoolean:", "LineOptionCode", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "LinestyleCodeWithInt:withJavaLangStringBuilder:", "LinestyleCode", "V", 0x2, NULL, NULL },
    { "ColorCodeWithGeogebraCommonAwtGColor:withJavaLangStringBuilder:", "ColorCode", "V", 0x4, NULL, NULL },
    { "addTextWithNSString:withBoolean:withInt:withGeogebraCommonAwtGColor:", "addText", "V", 0x2, NULL, NULL },
    { "drawImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:", "drawImplicitPoly", "V", 0x4, NULL, NULL },
    { "drawPolyLineWithGeogebraCommonKernelGeosGeoPolyLine:", "drawPolyLine", "V", 0x4, NULL, NULL },
    { "drawHistogramOrBarChartBoxWithDoubleArray:withDoubleArray:withInt:withDouble:withGeogebraCommonKernelGeosGeoNumeric:", "drawHistogramOrBarChartBox", "V", 0x4, NULL, NULL },
    { "drawNyquistWithGeogebraCommonKernelGeosGeoTransferFunction:", "drawNyquist", "V", 0x4, NULL, NULL },
    { "fillSplineWithGeogebraCommonKernelGeosGeoCurveCartesianArray:", "fillSpline", "Z", 0x4, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "eurosym_", NULL, 0x2, "Z", NULL, NULL,  },
    { "FORMAT_BEAMER_", NULL, 0x1a, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER },
    { "codeBeginPic_", NULL, 0x2, "Ljava.lang.StringBuilder;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonExportPstricksGeoGebraToPstricks = { 2, "GeoGebraToPstricks", "geogebra.common.export.pstricks", NULL, 0x401, 46, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonExportPstricksGeoGebraToPstricks;
}

@end

void GeogebraCommonExportPstricksGeoGebraToPstricks_initWithGeogebraCommonMainApp_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonMainApp *app) {
  GeogebraCommonExportPstricksGeoGebraExport_initWithGeogebraCommonMainApp_(self, app);
  self->eurosym_ = NO;
}

NSString *GeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(NSString *name) {
  GeogebraCommonExportPstricksGeoGebraToPstricks_initialize();
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  jboolean operand = NO;
  jboolean space = NO;
  for (jint i = 0; i < ((jint) [((NSString *) nil_chk(name)) length]); i++) {
    jchar c = [name charAtWithInt:i];
    if ([@"*/+-" indexOf:c] != -1) {
      [sb appendWithChar:c];
      operand = YES;
      space = NO;
    }
    else if (c == ' ') {
      if (!operand) space = YES;
      else {
        space = NO;
        operand = NO;
      }
    }
    else {
      if (space && ![name contains:@"If"]) [sb appendWithNSString:@"*"];
      [sb appendWithChar:c];
      space = NO;
      operand = NO;
    }
  }
  GeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, GeogebraCommonUtilUnicode_get_EULER_STRING_(), @"2.718281828");
  GeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, @"\\pi", @"PI");
  return [NSString stringWithJavaLangStringBuilder:sb];
}

void GeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(JavaLangStringBuilder *sb, NSString *nameFunc, NSString *nameNew) {
  GeogebraCommonExportPstricksGeoGebraToPstricks_initialize();
  jint ind = [((JavaLangStringBuilder *) nil_chk(sb)) indexOfWithNSString:nameFunc];
  while (ind > -1) {
    [sb replaceWithInt:ind withInt:ind + ((jint) [((NSString *) nil_chk(nameFunc)) length]) withNSString:nameNew];
    ind = [sb indexOfWithNSString:nameFunc];
  }
}

jdouble GeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b) {
  jdouble x = a;
  jdouble step = (b - a) / 100;
  while (x <= b) {
    jdouble y = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) evaluateWithDouble:x];
    if (JavaLangDouble_isNaNWithDouble_(y)) {
      if (step < self->PRECISION_XRANGE_FUNCTION_) return x - step;
      return GeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, x - step, x);
    }
    x += step;
  }
  return b;
}

jdouble GeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b) {
  jdouble x = a;
  jdouble step = (b - a) / 100;
  while (x <= b) {
    jdouble y = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) evaluateWithDouble:x];
    if (!JavaLangDouble_isNaNWithDouble_(y)) {
      if (x == a) return a;
      else if (step < self->PRECISION_XRANGE_FUNCTION_) return x;
      else return GeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, x - step, x);
    }
    x += step;
  }
  return b;
}

void GeogebraCommonExportPstricksGeoGebraToPstricks_drawCircleWithGeogebraCommonKernelGeosGeoConic_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonKernelGeosGeoConic *geo) {
  JavaLangStringBuilder *s = [new_JavaLangStringBuilder_init() autorelease];
  if (self->xunit_ == self->yunit_) {
    jdouble x = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((GeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getTranslationVector])) getX];
    jdouble y = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
    jdouble r = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
    [self startBeamerWithJavaLangStringBuilder:s];
    [s appendWithNSString:@"\\pscircle"];
    [s appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    [s appendWithNSString:@"("];
    [s appendWithNSString:[self formatWithDouble:x]];
    [s appendWithNSString:@","];
    [s appendWithNSString:[self formatWithDouble:y]];
    [s appendWithNSString:@"){"];
    NSString *tmpr = [self formatWithDouble:r * self->xunit_];
    if ([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpr] != 0) [s appendWithNSString:tmpr];
    else [s appendWithDouble:r];
    [s appendWithNSString:@"}\n"];
    [self endBeamerWithJavaLangStringBuilder:s];
  }
  else {
    jdouble x1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((GeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getTranslationVector])) getX];
    jdouble y1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
    jdouble r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
    jdouble r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
    [self startBeamerWithJavaLangStringBuilder:s];
    [s appendWithNSString:@"\\psellipse"];
    [s appendWithNSString:[self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    [s appendWithNSString:@"("];
    [s appendWithNSString:[self formatWithDouble:x1]];
    [s appendWithNSString:@","];
    [s appendWithNSString:[self formatWithDouble:y1]];
    [s appendWithNSString:@")("];
    [s appendWithNSString:[self formatWithDouble:r1]];
    [s appendWithNSString:@","];
    [s appendWithNSString:[self formatWithDouble:r2]];
    [s appendWithNSString:@")\n"];
    [self endBeamerWithJavaLangStringBuilder:s];
  }
  if ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getAlphaValue] > 0.0f) [((JavaLangStringBuilder *) nil_chk(self->codeFilledObject_)) appendWithJavaLangCharSequence:s];
  else [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithJavaLangCharSequence:s];
}

void GeogebraCommonExportPstricksGeoGebraToPstricks_initUnitAndVariable(GeogebraCommonExportPstricksGeoGebraToPstricks *self) {
  [((JavaLangStringBuilder *) nil_chk(self->codeBeginPic_)) appendWithNSString:@"\\psset{xunit="];
  [self->codeBeginPic_ appendWithNSString:[self sci2decWithDouble:self->xunit_]];
  [self->codeBeginPic_ appendWithNSString:@"cm,yunit="];
  [self->codeBeginPic_ appendWithNSString:[self sci2decWithDouble:self->yunit_]];
  [self->codeBeginPic_ appendWithNSString:@"cm,algebraic=true,dimen=middle,dotstyle=o,dotsize="];
  [self->codeBeginPic_ appendWithInt:GeogebraCommonPluginEuclidianStyleConstants_DEFAULT_POINT_SIZE];
  [self->codeBeginPic_ appendWithNSString:@"pt 0"];
  [self->codeBeginPic_ appendWithNSString:@",linewidth="];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:GeogebraCommonPluginEuclidianStyleConstants_DEFAULT_LINE_THICKNESS / 2 * 0.8]];
  [self->codeBeginPic_ appendWithNSString:@"pt,arrowsize=3pt 2,arrowinset=0.25}\n"];
}

void GeogebraCommonExportPstricksGeoGebraToPstricks_drawGrid(GeogebraCommonExportPstricksGeoGebraToPstricks *self) {
  GeogebraCommonAwtGColor *GridCol = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->euclidianView_)) getGridColor];
  IOSDoubleArray *GridDist = [self->euclidianView_ getGridDistances];
  jdouble myx = self->xmin_;
  jlong truncx = J2ObjCFpToLong(myx);
  jdouble myy = self->ymin_;
  jlong truncy = J2ObjCFpToLong(myy);
  jdouble RX = JavaLangMath_absWithDouble_(self->xmax_ - self->xmin_) / IOSDoubleArray_Get(nil_chk(GridDist), 0) + 1;
  jlong repx = J2ObjCFpToLong(RX);
  jdouble RY = JavaLangMath_absWithDouble_(self->ymax_ - self->ymin_) / IOSDoubleArray_Get(GridDist, 1) + 1;
  jlong repy = J2ObjCFpToLong(RY);
  [((JavaLangStringBuilder *) nil_chk(self->codeBeginPic_)) appendWithNSString:@"\\multips(0,"];
  [self->codeBeginPic_ appendWithLong:truncy];
  [self->codeBeginPic_ appendWithNSString:@")(0,"];
  [self->codeBeginPic_ appendWithNSString:[self sci2decWithDouble:IOSDoubleArray_Get(GridDist, 1)]];
  [self->codeBeginPic_ appendWithNSString:@"){"];
  [self->codeBeginPic_ appendWithLong:repy];
  [self->codeBeginPic_ appendWithNSString:@"}{\\psline[linestyle=dashed,linecap=1,dash=1.5pt 1.5pt,linewidth=0.4pt,linecolor="];
  [self ColorCodeWithGeogebraCommonAwtGColor:GridCol withJavaLangStringBuilder:self->codeBeginPic_];
  [self->codeBeginPic_ appendWithNSString:@"]{c-c}("];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->xmin_]];
  [self->codeBeginPic_ appendWithNSString:@",0)("];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->xmax_]];
  [self->codeBeginPic_ appendWithNSString:@",0)}\n"];
  [self->codeBeginPic_ appendWithNSString:@"\\multips("];
  [self->codeBeginPic_ appendWithLong:truncx];
  [self->codeBeginPic_ appendWithNSString:@",0)("];
  [self->codeBeginPic_ appendWithNSString:[self sci2decWithDouble:IOSDoubleArray_Get(GridDist, 0)]];
  [self->codeBeginPic_ appendWithNSString:@",0){"];
  [self->codeBeginPic_ appendWithLong:repx];
  [self->codeBeginPic_ appendWithNSString:@"}{\\psline[linestyle=dashed,linecap=1,dash=1.5pt 1.5pt,linewidth=0.4pt,linecolor="];
  [self ColorCodeWithGeogebraCommonAwtGColor:GridCol withJavaLangStringBuilder:self->codeBeginPic_];
  [self->codeBeginPic_ appendWithNSString:@"]{c-c}(0,"];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->ymin_]];
  [self->codeBeginPic_ appendWithNSString:@")(0,"];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->ymax_]];
  [self->codeBeginPic_ appendWithNSString:@")}\n"];
}

void GeogebraCommonExportPstricksGeoGebraToPstricks_drawAxis(GeogebraCommonExportPstricksGeoGebraToPstricks *self) {
  IOSBooleanArray *positiveOnly = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->euclidianView_)) getPositiveAxes];
  jboolean xAxis = [self->euclidianView_ getShowXaxis];
  jboolean yAxis = [self->euclidianView_ getShowYaxis];
  jdouble Dx = IOSDoubleArray_Get(nil_chk([self->euclidianView_ getAxesNumberingDistances]), 0);
  jdouble Dy = IOSDoubleArray_Get(nil_chk([self->euclidianView_ getAxesNumberingDistances]), 1);
  IOSObjectArray *label = [self->euclidianView_ getAxesLabelsWithBoolean:NO];
  NSString *styleAx = @"";
  if (([self->euclidianView_ getAxesLineStyle] & GeogebraCommonPluginEuclidianStyleConstants_AXES_BOLD) == GeogebraCommonPluginEuclidianStyleConstants_AXES_BOLD) {
    styleAx = @"linewidth=1.4pt,";
  }
  [((JavaLangStringBuilder *) nil_chk(self->codeBeginPic_)) appendWithNSString:JreStrcat("$$$", @"\\psaxes[", styleAx, @"labelFontSize=\\scriptstyle,xAxis=")];
  [self->codeBeginPic_ appendWithBoolean:xAxis];
  [self->codeBeginPic_ appendWithNSString:@",yAxis="];
  [self->codeBeginPic_ appendWithBoolean:yAxis];
  [self->codeBeginPic_ appendWithChar:','];
  jboolean bx = IOSBooleanArray_Get(nil_chk([self->euclidianView_ getShowAxesNumbers]), 0);
  jboolean by = IOSBooleanArray_Get(nil_chk([self->euclidianView_ getShowAxesNumbers]), 1);
  if (!bx && !by) [self->codeBeginPic_ appendWithNSString:@"labels=none,"];
  else if (bx && !by) [self->codeBeginPic_ appendWithNSString:@"labels=x,"];
  else if (!bx && by) [self->codeBeginPic_ appendWithNSString:@"labels=y,"];
  [self->codeBeginPic_ appendWithNSString:@"Dx="];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:Dx]];
  [self->codeBeginPic_ appendWithNSString:@",Dy="];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:Dy]];
  [self->codeBeginPic_ appendWithNSString:@",ticksize=-2pt 0,subticks=2]{"];
  styleAx = @"";
  if (([self->euclidianView_ getAxesLineStyle] & GeogebraCommonPluginEuclidianStyleConstants_AXES_RIGHT_ARROW) == GeogebraCommonPluginEuclidianStyleConstants_AXES_RIGHT_ARROW) {
    styleAx = @"->";
  }
  if (([self->euclidianView_ getAxesLineStyle] & GeogebraCommonPluginEuclidianStyleConstants_AXES_LEFT_ARROW) == GeogebraCommonPluginEuclidianStyleConstants_AXES_LEFT_ARROW) {
    styleAx = JreStrcat("C$", '<', styleAx);
    ;
  }
  [self->codeBeginPic_ appendWithNSString:styleAx];
  [self->codeBeginPic_ appendWithNSString:@"}(0,0)("];
  jdouble assignMin = self->xmin_;
  if (IOSBooleanArray_Get(nil_chk(positiveOnly), 0)) {
    assignMin = 0;
  }
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:assignMin]];
  [self->codeBeginPic_ appendWithNSString:@","];
  assignMin = self->ymin_;
  if (IOSBooleanArray_Get(positiveOnly, 0)) {
    assignMin = 0;
  }
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:assignMin]];
  [self->codeBeginPic_ appendWithNSString:@")("];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->xmax_]];
  [self->codeBeginPic_ appendWithNSString:@","];
  [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->ymax_]];
  [self->codeBeginPic_ appendWithNSString:@")"];
  if (nil != IOSObjectArray_Get(nil_chk(label), 0) || nil != IOSObjectArray_Get(label, 1)) {
    [self->codeBeginPic_ appendWithNSString:@"["];
    if (nil != IOSObjectArray_Get(label, 0)) [self->codeBeginPic_ appendWithNSString:IOSObjectArray_Get(label, 0)];
    [self->codeBeginPic_ appendWithNSString:@",140] ["];
    if (nil != IOSObjectArray_Get(label, 1)) [self->codeBeginPic_ appendWithNSString:IOSObjectArray_Get(label, 1)];
    [self->codeBeginPic_ appendWithNSString:@",-40]"];
  }
  [self->codeBeginPic_ appendWithNSString:@"\n"];
}

void GeogebraCommonExportPstricksGeoGebraToPstricks_PointOptionCodeWithGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, GeogebraCommonKernelGeosGeoPoint *geo) {
  GeogebraCommonAwtGColor *dotcolor = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(geo)) getObjectColor];
  jint dotsize = [geo getPointSize];
  jint dotstyle = [geo getPointStyle];
  if (dotstyle == -1) {
    dotstyle = GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_DOT;
  }
  jboolean coma = NO;
  jboolean bracket = NO;
  if (dotsize != GeogebraCommonPluginEuclidianStyleConstants_DEFAULT_POINT_SIZE) {
    coma = YES;
    bracket = YES;
    [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"[dotsize="];
    [self->codePoint_ appendWithInt:dotsize];
    [self->codePoint_ appendWithNSString:@"pt 0"];
  }
  if (dotstyle != GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_CIRCLE) {
    if (coma) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@","];
    if (!bracket) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"["];
    coma = YES;
    bracket = YES;
    [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"dotstyle="];
    switch (dotstyle) {
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_CROSS:
      [self->codePoint_ appendWithNSString:@"x"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_DOT:
      [self->codePoint_ appendWithNSString:@"*"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_EMPTY_DIAMOND:
      [self->codePoint_ appendWithNSString:@"square,dotangle=45"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_FILLED_DIAMOND:
      [self->codePoint_ appendWithNSString:@"square*,dotangle=45"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_PLUS:
      [self->codePoint_ appendWithNSString:@"+"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_EAST:
      [self->codePoint_ appendWithNSString:@"triangle*,dotangle=270"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_NORTH:
      [self->codePoint_ appendWithNSString:@"triangle*"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_SOUTH:
      [self->codePoint_ appendWithNSString:@"triangle*,dotangle=180"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_WEST:
      [self->codePoint_ appendWithNSString:@"triangle*,dotangle=90"];
      break;
      default:
      [self->codePoint_ appendWithNSString:@"*"];
      break;
    }
  }
  if (![((GeogebraCommonAwtGColor *) nil_chk(dotcolor)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
    if (coma) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@","];
    if (!bracket) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"["];
    bracket = YES;
    [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"linecolor="];
    [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:self->codePoint_];
  }
  if (bracket) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"]"];
}

void GeogebraCommonExportPstricksGeoGebraToPstricks_LinestyleCodeWithInt_withJavaLangStringBuilder_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, jint linestyle, JavaLangStringBuilder *sb) {
  {
    jint size;
    jint size1;
    jint size2;
    jint size3;
    switch (linestyle) {
      case GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DOTTED:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"linestyle=dotted"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_SHORT:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"linestyle=dashed,dash="];
      size = [self resizePtWithInt:4];
      [sb appendWithInt:size];
      [sb appendWithNSString:@"pt "];
      [sb appendWithInt:size];
      [sb appendWithNSString:@"pt"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_LONG:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"linestyle=dashed,dash="];
      size = [self resizePtWithInt:8];
      [sb appendWithInt:size];
      [sb appendWithNSString:@"pt "];
      [sb appendWithInt:size];
      [sb appendWithNSString:@"pt"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_DOTTED:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"linestyle=dashed,dash="];
      size1 = [self resizePtWithInt:1];
      size2 = [self resizePtWithInt:4];
      size3 = [self resizePtWithInt:8];
      [sb appendWithInt:size1];
      [sb appendWithNSString:@"pt "];
      [sb appendWithInt:size2];
      [sb appendWithNSString:@"pt "];
      [sb appendWithInt:size3];
      [sb appendWithNSString:@"pt "];
      [sb appendWithInt:size2];
      [sb appendWithNSString:@"pt "];
      break;
    }
  }
}

void GeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withGeogebraCommonAwtGColor_(GeogebraCommonExportPstricksGeoGebraToPstricks *self, NSString *st, jboolean isLatex, jint style, GeogebraCommonAwtGColor *geocolor) {
  if (isLatex) {
    if (![((NSString *) nil_chk(st)) hasPrefix:@"$"]) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"$"];
    NSString *stSym = st;
    for (jint i = 0; i < ((jint) [st length]); i++) {
      NSString *uCode = JreStrcat("C", [st charAtWithInt:i]);
      if ([((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
        [self addTextPackage];
        stSym = [stSym replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$C", @"\\\\", [((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode], ' ')];
      }
    }
    st = stSym;
  }
  else {
    st = [((NSString *) nil_chk(st)) replaceAll:@"\\\\" withReplacement:@"\\\\textbackslash "];
    NSString *stSym = st;
    for (jint i = 0; i < ((jint) [((NSString *) nil_chk(st)) length]); i++) {
      NSString *uCode = JreStrcat("C", [st charAtWithInt:i]);
      if ([((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
        [self addTextPackage];
        stSym = [((NSString *) nil_chk(stSym)) replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$$", @"\\$\\\\", [((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode], @"\\$ ")];
      }
    }
    st = stSym;
    if (!self->eurosym_ && [((NSString *) nil_chk(st)) contains:@"$\\euro$"]) {
      [((JavaLangStringBuilder *) nil_chk(self->codePreamble_)) appendWithNSString:@"\\usepackage{eurosym}\n"];
      st = [st replace:@"$\\euro$" withSequence:@"\\euro"];
    }
  }
  switch (style) {
    case 1:
    if (isLatex) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathbf{"];
    else [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textbf{"];
    break;
    case 2:
    if (isLatex) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathit{"];
    else [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textit{"];
    break;
    case 3:
    if (isLatex) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathit{\\mathbf{"];
    else [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textit{\\textbf{"];
    break;
  }
  if (![((GeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
    [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\"];
    [self ColorCodeWithGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:self->code_];
    [self->code_ appendWithNSString:@"{"];
  }
  [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:st];
  if (![geocolor isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
    [self->code_ appendWithNSString:@"}"];
  }
  switch (style) {
    case 1:
    case 2:
    [self->code_ appendWithNSString:@"}"];
    break;
    case 3:
    [self->code_ appendWithNSString:@"}}"];
    break;
  }
  if (isLatex && ![((NSString *) nil_chk(st)) hasSuffix:@"$"]) [self->code_ appendWithNSString:@"$"];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonExportPstricksGeoGebraToPstricks)
