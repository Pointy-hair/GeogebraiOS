//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/edu/uci/ics/jung/algorithms/util/KMeansClusterer.java
//


#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "edu/uci/ics/jung/algorithms/util/DiscreteDistribution.h"
#include "edu/uci/ics/jung/algorithms/util/KMeansClusterer.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/Map.h"
#include "java/util/Random.h"
#include "java/util/Set.h"

@implementation EduUciIcsJungAlgorithmsUtilKMeansClusterer

- (instancetype)initWithInt:(jint)max_iterations
                 withDouble:(jdouble)convergence_threshold {
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_initWithInt_withDouble_(self, max_iterations, convergence_threshold);
  return self;
}

- (instancetype)init {
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_init(self);
  return self;
}

- (jint)getMaxIterations {
  return max_iterations_;
}

- (void)setMaxIterationsWithInt:(jint)max_iterations {
  if (max_iterations < 0) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"max iterations must be >= 0") autorelease];
  self->max_iterations_ = max_iterations;
}

- (jdouble)getConvergenceThreshold {
  return convergence_threshold_;
}

- (void)setConvergenceThresholdWithDouble:(jdouble)convergence_threshold {
  if (convergence_threshold <= 0) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"convergence threshold must be > 0") autorelease];
  self->convergence_threshold_ = convergence_threshold;
}

- (id<JavaUtilCollection>)clusterWithJavaUtilMap:(id<JavaUtilMap>)object_locations
                                         withInt:(jint)num_clusters {
  if (object_locations == nil || [object_locations isEmpty]) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"'objects' must be non-empty") autorelease];
  if (num_clusters < 2 || num_clusters > [((id<JavaUtilMap>) nil_chk(object_locations)) size]) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$IC", @"number of clusters must be >= 2 and <= number of objects (", [((id<JavaUtilMap>) nil_chk(object_locations)) size], ')')) autorelease];
  id<JavaUtilSet> centroids = [new_JavaUtilHashSet_init() autorelease];
  IOSObjectArray *obj_array = [((id<JavaUtilSet>) nil_chk([((id<JavaUtilMap>) nil_chk(object_locations)) keySet])) toArray];
  id<JavaUtilSet> tried = [new_JavaUtilHashSet_init() autorelease];
  while ([centroids size] < num_clusters && [tried size] < [object_locations size]) {
    id o = (id) IOSObjectArray_Get(obj_array, J2ObjCFpToInt(([((JavaUtilRandom *) nil_chk(rand_)) nextDouble] * ((IOSObjectArray *) nil_chk(obj_array))->size_)));
    [tried addWithId:o];
    IOSDoubleArray *mean_value = [object_locations getWithId:o];
    jboolean duplicate = NO;
    for (IOSDoubleArray * __strong cur in centroids) {
      if (JavaUtilArrays_equalsWithDoubleArray_withDoubleArray_(mean_value, cur)) duplicate = YES;
    }
    if (!duplicate) [centroids addWithId:mean_value];
  }
  if ([tried size] >= [object_locations size]) @throw [new_EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException_init() autorelease];
  id<JavaUtilMap> clusterMap = [self assignToClustersWithJavaUtilMap:object_locations withJavaUtilSet:centroids];
  jint iterations = 0;
  jdouble max_movement = JavaLangDouble_POSITIVE_INFINITY;
  while (iterations++ < max_iterations_ && max_movement > convergence_threshold_) {
    max_movement = 0;
    id<JavaUtilSet> new_centroids = [new_JavaUtilHashSet_init() autorelease];
    for (id<JavaUtilMap_Entry> __strong entry_ in nil_chk([((id<JavaUtilMap>) nil_chk(clusterMap)) entrySet])) {
      IOSDoubleArray *centroid = [((id<JavaUtilMap_Entry>) nil_chk(entry_)) getKey];
      id<JavaUtilMap> elements = [entry_ getValue];
      JavaUtilArrayList *locations = [new_JavaUtilArrayList_initWithJavaUtilCollection_([((id<JavaUtilMap>) nil_chk(elements)) values]) autorelease];
      IOSDoubleArray *mean = EduUciIcsJungAlgorithmsUtilDiscreteDistribution_meanWithJavaUtilCollection_(locations);
      max_movement = JavaLangMath_maxWithDouble_withDouble_(max_movement, JavaLangMath_sqrtWithDouble_(EduUciIcsJungAlgorithmsUtilDiscreteDistribution_squaredErrorWithDoubleArray_withDoubleArray_(centroid, mean)));
      [new_centroids addWithId:mean];
    }
    clusterMap = [self assignToClustersWithJavaUtilMap:object_locations withJavaUtilSet:new_centroids];
  }
  return [((id<JavaUtilMap>) nil_chk(clusterMap)) values];
}

- (id<JavaUtilMap>)assignToClustersWithJavaUtilMap:(id<JavaUtilMap>)object_locations
                                   withJavaUtilSet:(id<JavaUtilSet>)centroids {
  id<JavaUtilMap> clusterMap = [new_JavaUtilHashMap_init() autorelease];
  for (IOSDoubleArray * __strong centroid in nil_chk(centroids)) [clusterMap putWithId:centroid withId:[new_JavaUtilHashMap_init() autorelease]];
  for (id<JavaUtilMap_Entry> __strong object_location in nil_chk([((id<JavaUtilMap>) nil_chk(object_locations)) entrySet])) {
    id object = [((id<JavaUtilMap_Entry>) nil_chk(object_location)) getKey];
    IOSDoubleArray *location = [object_location getValue];
    id<JavaUtilIterator> c_iter = [centroids iterator];
    IOSDoubleArray *closest = [((id<JavaUtilIterator>) nil_chk(c_iter)) next];
    jdouble distance = EduUciIcsJungAlgorithmsUtilDiscreteDistribution_squaredErrorWithDoubleArray_withDoubleArray_(location, closest);
    while ([c_iter hasNext]) {
      IOSDoubleArray *centroid = [c_iter next];
      jdouble dist_cur = EduUciIcsJungAlgorithmsUtilDiscreteDistribution_squaredErrorWithDoubleArray_withDoubleArray_(location, centroid);
      if (dist_cur < distance) {
        distance = dist_cur;
        closest = centroid;
      }
    }
    [((id<JavaUtilMap>) nil_chk([clusterMap getWithId:closest])) putWithId:object withId:location];
  }
  return clusterMap;
}

- (void)setSeedWithInt:(jint)random_seed {
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_setAndConsume_rand_(self, new_JavaUtilRandom_initWithLong_(random_seed));
}

- (void)dealloc {
  RELEASE_(rand_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:withDouble:", "KMeansClusterer", NULL, 0x1, NULL, NULL },
    { "init", "KMeansClusterer", NULL, 0x1, NULL, NULL },
    { "getMaxIterations", NULL, "I", 0x1, NULL, NULL },
    { "setMaxIterationsWithInt:", "setMaxIterations", "V", 0x1, NULL, NULL },
    { "getConvergenceThreshold", NULL, "D", 0x1, NULL, NULL },
    { "setConvergenceThresholdWithDouble:", "setConvergenceThreshold", "V", 0x1, NULL, NULL },
    { "clusterWithJavaUtilMap:withInt:", "cluster", "Ljava.util.Collection;", 0x1, NULL, NULL },
    { "assignToClustersWithJavaUtilMap:withJavaUtilSet:", "assignToClusters", "Ljava.util.Map;", 0x4, NULL, NULL },
    { "setSeedWithInt:", "setSeed", "V", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "max_iterations_", NULL, 0x4, "I", NULL, NULL,  },
    { "convergence_threshold_", NULL, 0x4, "D", NULL, NULL,  },
    { "rand_", NULL, 0x4, "Ljava.util.Random;", NULL, NULL,  },
  };
  static const char *inner_classes[] = {"Ledu.uci.ics.jung.algorithms.util.KMeansClusterer$NotEnoughClustersException;"};
  static const J2ObjcClassInfo _EduUciIcsJungAlgorithmsUtilKMeansClusterer = { 2, "KMeansClusterer", "edu.uci.ics.jung.algorithms.util", NULL, 0x1, 9, methods, 3, fields, 0, NULL, 1, inner_classes, NULL, "<T:Ljava/lang/Object;>Ljava/lang/Object;" };
  return &_EduUciIcsJungAlgorithmsUtilKMeansClusterer;
}

@end

void EduUciIcsJungAlgorithmsUtilKMeansClusterer_initWithInt_withDouble_(EduUciIcsJungAlgorithmsUtilKMeansClusterer *self, jint max_iterations, jdouble convergence_threshold) {
  NSObject_init(self);
  self->max_iterations_ = max_iterations;
  self->convergence_threshold_ = convergence_threshold;
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_setAndConsume_rand_(self, new_JavaUtilRandom_init());
}

EduUciIcsJungAlgorithmsUtilKMeansClusterer *new_EduUciIcsJungAlgorithmsUtilKMeansClusterer_initWithInt_withDouble_(jint max_iterations, jdouble convergence_threshold) {
  EduUciIcsJungAlgorithmsUtilKMeansClusterer *self = [EduUciIcsJungAlgorithmsUtilKMeansClusterer alloc];
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_initWithInt_withDouble_(self, max_iterations, convergence_threshold);
  return self;
}

void EduUciIcsJungAlgorithmsUtilKMeansClusterer_init(EduUciIcsJungAlgorithmsUtilKMeansClusterer *self) {
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_initWithInt_withDouble_(self, 100, 0.001);
}

EduUciIcsJungAlgorithmsUtilKMeansClusterer *new_EduUciIcsJungAlgorithmsUtilKMeansClusterer_init() {
  EduUciIcsJungAlgorithmsUtilKMeansClusterer *self = [EduUciIcsJungAlgorithmsUtilKMeansClusterer alloc];
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduUciIcsJungAlgorithmsUtilKMeansClusterer)

@implementation EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException

- (NSString *)getMessage {
  return @"Not enough distinct points in the input data set to form the requested number of clusters";
}

- (instancetype)init {
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getMessage", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcClassInfo _EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException = { 2, "NotEnoughClustersException", "edu.uci.ics.jung.algorithms.util", "KMeansClusterer", 0x9, 2, methods, 0, NULL, 0, NULL, 0, NULL, NULL, NULL };
  return &_EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException;
}

@end

void EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException_init(EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException *self) {
  JavaLangRuntimeException_init(self);
}

EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException *new_EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException_init() {
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException *self = [EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException alloc];
  EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduUciIcsJungAlgorithmsUtilKMeansClusterer_NotEnoughClustersException)
