//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/euclidian/draw/DrawPolygon.java
//


#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GArea.h"
#include "geogebra/common/awt/GColor.h"
#include "geogebra/common/awt/GFont.h"
#include "geogebra/common/awt/GGraphics2D.h"
#include "geogebra/common/awt/GPoint2D.h"
#include "geogebra/common/awt/GRectangle.h"
#include "geogebra/common/awt/GShape.h"
#include "geogebra/common/euclidian/Drawable.h"
#include "geogebra/common/euclidian/EuclidianController.h"
#include "geogebra/common/euclidian/EuclidianView.h"
#include "geogebra/common/euclidian/GeneralPathClipped.h"
#include "geogebra/common/euclidian/draw/DrawPolygon.h"
#include "geogebra/common/factories/AwtFactory.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/ConstructionDefaults.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoPolygon.h"
#include "geogebra/common/kernel/geos/GeoVec3D.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/util/MyMath.h"
#include "java/lang/Double.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"

@interface GeogebraCommonEuclidianDrawDrawPolygon () {
 @public
  GeogebraCommonKernelGeosGeoPolygon *poly_;
  jboolean isVisible_, labelVisible_;
  GeogebraCommonEuclidianGeneralPathClipped *gp_;
  IOSDoubleArray *coords_;
  JavaUtilArrayList *points_;
  GeogebraCommonAwtGPoint2D *endPoint_;
}

- (GeogebraCommonKernelMatrixCoords *)getCoordsWithInt:(jint)i;

- (jboolean)addPointsToPathWithInt:(jint)length;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonEuclidianDrawDrawPolygon, poly_, GeogebraCommonKernelGeosGeoPolygon *)
J2OBJC_FIELD_SETTER(GeogebraCommonEuclidianDrawDrawPolygon, gp_, GeogebraCommonEuclidianGeneralPathClipped *)
J2OBJC_FIELD_SETTER(GeogebraCommonEuclidianDrawDrawPolygon, coords_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonEuclidianDrawDrawPolygon, points_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(GeogebraCommonEuclidianDrawDrawPolygon, endPoint_, GeogebraCommonAwtGPoint2D *)

__attribute__((unused)) static void GeogebraCommonEuclidianDrawDrawPolygon_update(GeogebraCommonEuclidianDrawDrawPolygon *self);

__attribute__((unused)) static GeogebraCommonKernelMatrixCoords *GeogebraCommonEuclidianDrawDrawPolygon_getCoordsWithInt_(GeogebraCommonEuclidianDrawDrawPolygon *self, jint i);

__attribute__((unused)) static jboolean GeogebraCommonEuclidianDrawDrawPolygon_addPointsToPathWithInt_(GeogebraCommonEuclidianDrawDrawPolygon *self, jint length);

__attribute__((unused)) static void GeogebraCommonEuclidianDrawDrawPolygon_updatePreview(GeogebraCommonEuclidianDrawDrawPolygon *self);

@implementation GeogebraCommonEuclidianDrawDrawPolygon

- (instancetype)initWithGeogebraCommonEuclidianEuclidianView:(GeogebraCommonEuclidianEuclidianView *)view
                      withGeogebraCommonKernelGeosGeoPolygon:(GeogebraCommonKernelGeosGeoPolygon *)poly {
  GeogebraCommonEuclidianDrawDrawPolygon_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelGeosGeoPolygon_(self, view, poly);
  return self;
}

- (instancetype)initWithGeogebraCommonEuclidianEuclidianView:(GeogebraCommonEuclidianEuclidianView *)view
                                       withJavaUtilArrayList:(JavaUtilArrayList *)points {
  GeogebraCommonEuclidianDrawDrawPolygon_initWithGeogebraCommonEuclidianEuclidianView_withJavaUtilArrayList_(self, view, points);
  return self;
}

- (void)update {
  GeogebraCommonEuclidianDrawDrawPolygon_update(self);
}

- (GeogebraCommonKernelMatrixCoords *)getCoordsWithInt:(jint)i {
  return GeogebraCommonEuclidianDrawDrawPolygon_getCoordsWithInt_(self, i);
}

- (jboolean)addPointsToPathWithInt:(jint)length {
  return GeogebraCommonEuclidianDrawDrawPolygon_addPointsToPathWithInt_(self, length);
}

- (void)drawWithGeogebraCommonAwtGGraphics2D:(id<GeogebraCommonAwtGGraphics2D>)g2 {
  if (isVisible_) {
    [self fillWithGeogebraCommonAwtGGraphics2D:g2 withGeogebraCommonAwtGShape:([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo_)) isInverseFill] ? ((id) [self getShape]) : gp_) withBoolean:NO];
    if ([geo_ doHighlighting]) {
      [((id<GeogebraCommonAwtGGraphics2D>) nil_chk(g2)) setPaintWithGeogebraCommonAwtGPaint:[((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(poly_)) getSelColor]];
      [g2 setStrokeWithGeogebraCommonAwtGBasicStroke:selStroke_];
      [g2 drawWithGeogebraCommonAwtGShape:gp_];
    }
    else if (![((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(poly_)) wasInitLabelsCalled] && poly_->lineThickness_ > 0) {
      [((id<GeogebraCommonAwtGGraphics2D>) nil_chk(g2)) setPaintWithGeogebraCommonAwtGPaint:[self getObjectColor]];
      [g2 setStrokeWithGeogebraCommonAwtGBasicStroke:objStroke_];
      [g2 drawWithGeogebraCommonAwtGShape:gp_];
    }
    if (labelVisible_) {
      [((id<GeogebraCommonAwtGGraphics2D>) nil_chk(g2)) setPaintWithGeogebraCommonAwtGPaint:[((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(poly_)) getLabelColor]];
      [g2 setFontWithGeogebraCommonAwtGFont:[((GeogebraCommonEuclidianEuclidianView *) nil_chk(view_)) getFontPoint]];
      [self drawLabelWithGeogebraCommonAwtGGraphics2D:g2];
    }
  }
}

- (void)updatePreview {
  GeogebraCommonEuclidianDrawDrawPolygon_updatePreview(self);
}

- (void)updateMousePosWithDouble:(jdouble)mouseRWx
                      withDouble:(jdouble)mouseRWy {
  jdouble xRW = mouseRWx;
  jdouble yRW = mouseRWy;
  if (isVisible_) {
    jint mx = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(view_)) toScreenCoordXWithDouble:xRW];
    jint my = [view_ toScreenCoordYWithDouble:yRW];
    if ([((GeogebraCommonEuclidianEuclidianController *) nil_chk([view_ getEuclidianController])) isAltDown]) {
      GeogebraCommonKernelGeosGeoPoint *p = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([points_ getWithInt:[((JavaUtilArrayList *) nil_chk(points_)) size] - 1], [GeogebraCommonKernelGeosGeoPoint class]);
      jdouble px = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p))->inhomX_;
      jdouble py = p->inhomY_;
      if ([points_ size] > 1) {
        GeogebraCommonKernelConstruction *cons = [((GeogebraCommonKernelKernel *) nil_chk([view_ getKernel])) getConstruction];
        GeogebraCommonKernelGeosGeoPoint *intersection = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons) autorelease];
        GeogebraCommonKernelGeosGeoLine *l = [new_GeogebraCommonKernelGeosGeoLine_initWithGeogebraCommonKernelConstruction_(cons) autorelease];
        GeogebraCommonKernelGeosGeoLine *l2 = [new_GeogebraCommonKernelGeosGeoLine_initWithGeogebraCommonKernelConstruction_(cons) autorelease];
        GeogebraCommonKernelGeosGeoPoint *p2 = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([points_ getWithInt:0], [GeogebraCommonKernelGeosGeoPoint class]);
        jdouble px2 = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p2))->inhomX_;
        jdouble py2 = p2->inhomY_;
        jdouble nearestX = JavaLangDouble_MAX_VALUE;
        jdouble nearestY = JavaLangDouble_MAX_VALUE;
        jdouble dist = JavaLangDouble_MAX_VALUE;
        for (jdouble angle = 0; angle < 180; angle += 15) {
          if (angle == 90) {
            [l setCoordsWithDouble:1 withDouble:0 withDouble:-px];
          }
          else {
            jdouble gradient = JavaLangMath_tanWithDouble_(angle * JavaLangMath_PI / 180.0);
            [l setCoordsWithDouble:gradient withDouble:-1.0 withDouble:py - gradient * px];
          }
          for (jdouble ang2 = 0; ang2 < 180; ang2 += 15) {
            if (ang2 == angle) {
              continue;
            }
            else if (ang2 == 90) {
              [l2 setCoordsWithDouble:1.0 withDouble:0 withDouble:-px2];
            }
            else {
              jdouble gradient2 = JavaLangMath_tanWithDouble_(ang2 * JavaLangMath_PI / 180.0);
              [l2 setCoordsWithDouble:gradient2 withDouble:-1.0 withDouble:py2 - gradient2 * px2];
            }
            GeogebraCommonKernelGeosGeoVec3D_crossWithGeogebraCommonKernelGeosGeoVec3D_withGeogebraCommonKernelGeosGeoVec3D_withGeogebraCommonKernelGeosGeoVec3D_(l, l2, intersection);
            jdouble x1 = intersection->x_ / intersection->z_;
            jdouble y1 = intersection->y_ / intersection->z_;
            jdouble d = GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_(x1 - xRW, y1 - yRW);
            if (d < dist) {
              nearestX = x1;
              nearestY = y1;
              dist = d;
            }
          }
        }
        xRW = nearestX;
        yRW = nearestY;
      }
      else {
        jdouble angle = JavaLangMath_atan2WithDouble_withDouble_(yRW - py, xRW - px) * 180 / JavaLangMath_PI;
        jdouble radius = JavaLangMath_sqrtWithDouble_((py - yRW) * (py - yRW) + (px - xRW) * (px - xRW));
        angle = JavaLangMath_roundWithDouble_(angle / 15) * 15;
        xRW = px + radius * JavaLangMath_cosWithDouble_(angle * JavaLangMath_PI / 180);
        yRW = py + radius * JavaLangMath_sinWithDouble_(angle * JavaLangMath_PI / 180);
      }
      mx = [view_ toScreenCoordXWithDouble:xRW];
      my = [view_ toScreenCoordYWithDouble:yRW];
      [((GeogebraCommonAwtGPoint2D *) nil_chk(endPoint_)) setXWithDouble:xRW];
      [endPoint_ setYWithDouble:yRW];
      [((GeogebraCommonEuclidianEuclidianController *) nil_chk([view_ getEuclidianController])) setLineEndPointWithGeogebraCommonAwtGPoint2D:endPoint_];
      [((GeogebraCommonEuclidianGeneralPathClipped *) nil_chk(gp_)) lineToWithDouble:mx withDouble:my];
    }
    else [((GeogebraCommonEuclidianEuclidianController *) nil_chk([view_ getEuclidianController])) setLineEndPointWithGeogebraCommonAwtGPoint2D_Double:nil];
    [((GeogebraCommonEuclidianGeneralPathClipped *) nil_chk(gp_)) lineToWithDouble:[view_ toScreenCoordXWithDouble:xRW] withDouble:[view_ toScreenCoordYWithDouble:yRW]];
  }
}

- (void)drawPreviewWithGeogebraCommonAwtGGraphics2D:(id<GeogebraCommonAwtGGraphics2D>)g2 {
  if (isVisible_) {
    [self fillWithGeogebraCommonAwtGGraphics2D:g2 withGeogebraCommonAwtGShape:([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo_)) isInverseFill] ? ((id) [self getShape]) : gp_) withBoolean:NO];
    [((id<GeogebraCommonAwtGGraphics2D>) nil_chk(g2)) setPaintWithGeogebraCommonAwtGPaint:[self getObjectColor]];
    [self updateStrokesWithGeogebraCommonKernelKernelNDGeoElementND:geo_];
    [g2 setStrokeWithGeogebraCommonAwtGBasicStroke:objStroke_];
    [g2 drawWithGeogebraCommonAwtGShape:gp_];
  }
}

- (void)disposePreview {
}

- (jboolean)hitWithInt:(jint)x
               withInt:(jint)y
               withInt:(jint)hitThreshold {
  id<GeogebraCommonAwtGShape> t = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo_)) isInverseFill] ? ((id) [self getShape]) : gp_;
  return t != nil && ([t containsWithInt:x withInt:y] || [t intersectsWithInt:x - hitThreshold withInt:y - hitThreshold withInt:2 * hitThreshold withInt:2 * hitThreshold]);
}

- (jboolean)isInsideWithGeogebraCommonAwtGRectangle:(id<GeogebraCommonAwtGRectangle>)rect {
  return gp_ != nil && [gp_ getBounds] != nil && [((id<GeogebraCommonAwtGRectangle>) nil_chk(rect)) containsWithGeogebraCommonAwtGRectangle2D:[gp_ getBounds]];
}

- (GeogebraCommonKernelGeosGeoElement *)getGeoElement {
  return geo_;
}

- (void)setGeoElementWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  GeogebraCommonEuclidianDrawable_set_geo_(self, geo);
}

- (id<GeogebraCommonAwtGRectangle>)getBounds {
  if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo_)) isDefined] || ![geo_ isEuclidianVisible]) {
    return nil;
  }
  return [((GeogebraCommonEuclidianGeneralPathClipped *) nil_chk(gp_)) getBounds];
}

- (id<GeogebraCommonAwtGArea>)getShape {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo_)) isInverseFill] || [super getShape] != nil) return [super getShape];
  [self setShapeWithGeogebraCommonAwtGArea:[((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newAreaWithGeogebraCommonAwtGShape:gp_]];
  return [super getShape];
}

- (void)dealloc {
  RELEASE_(poly_);
  RELEASE_(gp_);
  RELEASE_(coords_);
  RELEASE_(points_);
  RELEASE_(endPoint_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonEuclidianEuclidianView:withGeogebraCommonKernelGeosGeoPolygon:", "DrawPolygon", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonEuclidianEuclidianView:withJavaUtilArrayList:", "DrawPolygon", NULL, 0x1, NULL, NULL },
    { "update", NULL, "V", 0x11, NULL, NULL },
    { "getCoordsWithInt:", "getCoords", "Lgeogebra.common.kernel.Matrix.Coords;", 0x2, NULL, NULL },
    { "addPointsToPathWithInt:", "addPointsToPath", "Z", 0x2, NULL, NULL },
    { "drawWithGeogebraCommonAwtGGraphics2D:", "draw", "V", 0x11, NULL, NULL },
    { "updatePreview", NULL, "V", 0x11, NULL, NULL },
    { "updateMousePosWithDouble:withDouble:", "updateMousePos", "V", 0x11, NULL, NULL },
    { "drawPreviewWithGeogebraCommonAwtGGraphics2D:", "drawPreview", "V", 0x11, NULL, NULL },
    { "disposePreview", NULL, "V", 0x1, NULL, NULL },
    { "hitWithInt:withInt:withInt:", "hit", "Z", 0x11, NULL, NULL },
    { "isInsideWithGeogebraCommonAwtGRectangle:", "isInside", "Z", 0x11, NULL, NULL },
    { "getGeoElement", NULL, "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "setGeoElementWithGeogebraCommonKernelGeosGeoElement:", "setGeoElement", "V", 0x1, NULL, NULL },
    { "getBounds", NULL, "Lgeogebra.common.awt.GRectangle;", 0x11, NULL, NULL },
    { "getShape", NULL, "Lgeogebra.common.awt.GArea;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "poly_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoPolygon;", NULL, NULL,  },
    { "isVisible_", NULL, 0x2, "Z", NULL, NULL,  },
    { "labelVisible_", NULL, 0x2, "Z", NULL, NULL,  },
    { "gp_", NULL, 0x2, "Lgeogebra.common.euclidian.GeneralPathClipped;", NULL, NULL,  },
    { "coords_", NULL, 0x2, "[D", NULL, NULL,  },
    { "points_", NULL, 0x2, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/kernelND/GeoPointND;>;",  },
    { "endPoint_", NULL, 0x2, "Lgeogebra.common.awt.GPoint2D;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonEuclidianDrawDrawPolygon = { 2, "DrawPolygon", "geogebra.common.euclidian.draw", NULL, 0x1, 16, methods, 7, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonEuclidianDrawDrawPolygon;
}

@end

void GeogebraCommonEuclidianDrawDrawPolygon_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelGeosGeoPolygon_(GeogebraCommonEuclidianDrawDrawPolygon *self, GeogebraCommonEuclidianEuclidianView *view, GeogebraCommonKernelGeosGeoPolygon *poly) {
  GeogebraCommonEuclidianDrawable_init(self);
  GeogebraCommonEuclidianDrawDrawPolygon_setAndConsume_coords_(self, [IOSDoubleArray newArrayWithLength:2]);
  GeogebraCommonEuclidianDrawDrawPolygon_set_endPoint_(self, [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newPoint2D]);
  GeogebraCommonEuclidianDrawable_set_view_(self, view);
  GeogebraCommonEuclidianDrawDrawPolygon_set_poly_(self, poly);
  GeogebraCommonEuclidianDrawable_set_geo_(self, poly);
  GeogebraCommonEuclidianDrawDrawPolygon_update(self);
}

GeogebraCommonEuclidianDrawDrawPolygon *new_GeogebraCommonEuclidianDrawDrawPolygon_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelGeosGeoPolygon_(GeogebraCommonEuclidianEuclidianView *view, GeogebraCommonKernelGeosGeoPolygon *poly) {
  GeogebraCommonEuclidianDrawDrawPolygon *self = [GeogebraCommonEuclidianDrawDrawPolygon alloc];
  GeogebraCommonEuclidianDrawDrawPolygon_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelGeosGeoPolygon_(self, view, poly);
  return self;
}

void GeogebraCommonEuclidianDrawDrawPolygon_initWithGeogebraCommonEuclidianEuclidianView_withJavaUtilArrayList_(GeogebraCommonEuclidianDrawDrawPolygon *self, GeogebraCommonEuclidianEuclidianView *view, JavaUtilArrayList *points) {
  GeogebraCommonEuclidianDrawable_init(self);
  GeogebraCommonEuclidianDrawDrawPolygon_setAndConsume_coords_(self, [IOSDoubleArray newArrayWithLength:2]);
  GeogebraCommonEuclidianDrawDrawPolygon_set_endPoint_(self, [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newPoint2D]);
  GeogebraCommonEuclidianDrawable_set_view_(self, view);
  GeogebraCommonEuclidianDrawDrawPolygon_set_points_(self, points);
  GeogebraCommonEuclidianDrawable_set_geo_(self, [((GeogebraCommonKernelConstructionDefaults *) nil_chk([((GeogebraCommonKernelConstruction *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonEuclidianEuclidianView *) nil_chk(view)) getKernel])) getConstruction])) getConstructionDefaults])) getDefaultGeoWithInt:GeogebraCommonKernelConstructionDefaults_DEFAULT_POLYGON]);
  GeogebraCommonEuclidianDrawDrawPolygon_updatePreview(self);
}

GeogebraCommonEuclidianDrawDrawPolygon *new_GeogebraCommonEuclidianDrawDrawPolygon_initWithGeogebraCommonEuclidianEuclidianView_withJavaUtilArrayList_(GeogebraCommonEuclidianEuclidianView *view, JavaUtilArrayList *points) {
  GeogebraCommonEuclidianDrawDrawPolygon *self = [GeogebraCommonEuclidianDrawDrawPolygon alloc];
  GeogebraCommonEuclidianDrawDrawPolygon_initWithGeogebraCommonEuclidianEuclidianView_withJavaUtilArrayList_(self, view, points);
  return self;
}

void GeogebraCommonEuclidianDrawDrawPolygon_update(GeogebraCommonEuclidianDrawDrawPolygon *self) {
  self->isVisible_ = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->geo_)) isEuclidianVisible];
  if (self->isVisible_) {
    self->labelVisible_ = [self->geo_ isLabelVisible];
    [self updateStrokesWithGeogebraCommonKernelKernelNDGeoElementND:self->poly_];
    self->isVisible_ = GeogebraCommonEuclidianDrawDrawPolygon_addPointsToPathWithInt_(self, [((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(self->poly_)) getPointsLength]);
    if (!self->isVisible_) return;
    [((GeogebraCommonEuclidianGeneralPathClipped *) nil_chk(self->gp_)) closePath];
    if ([self->geo_ isInverseFill]) {
      [self setShapeWithGeogebraCommonAwtGArea:[((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newAreaWithGeogebraCommonAwtGShape:[((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->view_)) getBoundingPath]]];
      [((id<GeogebraCommonAwtGArea>) nil_chk([self getShape])) subtractWithGeogebraCommonAwtGArea:[GeogebraCommonFactoriesAwtFactory_get_prototype_() newAreaWithGeogebraCommonAwtGShape:self->gp_]];
    }
    if (![self->gp_ intersectsWithInt:0 withInt:0 withInt:[((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->view_)) getWidth] withInt:[self->view_ getHeight]] && ![self->geo_ isInverseFill]) {
      self->isVisible_ = NO;
    }
    if ([self->poly_ getTrace]) {
      self->isTracing__ = YES;
      id<GeogebraCommonAwtGGraphics2D> g2 = [self->view_ getBackgroundGraphics];
      if (g2 != nil) [self fillWithGeogebraCommonAwtGGraphics2D:g2 withGeogebraCommonAwtGShape:self->gp_ withBoolean:NO];
    }
    else {
      if (self->isTracing__) {
        self->isTracing__ = NO;
      }
    }
  }
}

GeogebraCommonKernelMatrixCoords *GeogebraCommonEuclidianDrawDrawPolygon_getCoordsWithInt_(GeogebraCommonEuclidianDrawDrawPolygon *self, jint i) {
  if (self->poly_ != nil) {
    return [((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->view_)) getCoordsForViewWithGeogebraCommonKernelMatrixCoords:[self->poly_ getPoint3DWithInt:i]];
  }
  return [((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->view_)) getCoordsForViewWithGeogebraCommonKernelMatrixCoords:[((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk([((JavaUtilArrayList *) nil_chk(self->points_)) getWithInt:i])) getInhomCoordsInD3]];
}

jboolean GeogebraCommonEuclidianDrawDrawPolygon_addPointsToPathWithInt_(GeogebraCommonEuclidianDrawDrawPolygon *self, jint length) {
  if (self->gp_ == nil) GeogebraCommonEuclidianDrawDrawPolygon_setAndConsume_gp_(self, new_GeogebraCommonEuclidianGeneralPathClipped_initWithGeogebraCommonEuclidianEuclidianViewInterfaceSlim_(self->view_));
  else [self->gp_ reset];
  if (length <= 0) return NO;
  GeogebraCommonKernelMatrixCoords *v = GeogebraCommonEuclidianDrawDrawPolygon_getCoordsWithInt_(self, 0);
  if (!GeogebraCommonKernelKernel_isZeroWithDouble_([((GeogebraCommonKernelMatrixCoords *) nil_chk(v)) getZ])) return NO;
  *IOSDoubleArray_GetRef(nil_chk(self->coords_), 0) = [v getX];
  *IOSDoubleArray_GetRef(self->coords_, 1) = [v getY];
  [((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->view_)) toScreenCoordsWithDoubleArray:self->coords_];
  [((GeogebraCommonEuclidianGeneralPathClipped *) nil_chk(self->gp_)) moveToWithDouble:IOSDoubleArray_Get(self->coords_, 0) withDouble:IOSDoubleArray_Get(self->coords_, 1)];
  jdouble xsum = IOSDoubleArray_Get(self->coords_, 0);
  jdouble ysum = IOSDoubleArray_Get(self->coords_, 1);
  for (jint i = 1; i < length; i++) {
    v = GeogebraCommonEuclidianDrawDrawPolygon_getCoordsWithInt_(self, i);
    if (!GeogebraCommonKernelKernel_isZeroWithDouble_([((GeogebraCommonKernelMatrixCoords *) nil_chk(v)) getZ])) {
      return NO;
    }
    *IOSDoubleArray_GetRef(self->coords_, 0) = [v getX];
    *IOSDoubleArray_GetRef(self->coords_, 1) = [v getY];
    [self->view_ toScreenCoordsWithDoubleArray:self->coords_];
    if (self->labelVisible_) {
      xsum += IOSDoubleArray_Get(self->coords_, 0);
      ysum += IOSDoubleArray_Get(self->coords_, 1);
    }
    [self->gp_ lineToWithDouble:IOSDoubleArray_Get(self->coords_, 0) withDouble:IOSDoubleArray_Get(self->coords_, 1)];
  }
  if (self->labelVisible_) {
    GeogebraCommonEuclidianDrawable_set_labelDesc_(self, [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->geo_)) getLabelDescription]);
    self->xLabel_ = J2ObjCFpToInt((xsum / length));
    self->yLabel_ = J2ObjCFpToInt((ysum / length));
    [self addLabelOffset];
  }
  return YES;
}

void GeogebraCommonEuclidianDrawDrawPolygon_updatePreview(GeogebraCommonEuclidianDrawDrawPolygon *self) {
  jint size = [((JavaUtilArrayList *) nil_chk(self->points_)) size];
  self->isVisible_ = (size > 0);
  if (self->isVisible_) {
    GeogebraCommonEuclidianDrawDrawPolygon_addPointsToPathWithInt_(self, size);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonEuclidianDrawDrawPolygon)
