//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/algos/AlgoIntersectLineConic.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/euclidian/EuclidianConstants.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/LocusEquation.h"
#include "geogebra/common/kernel/PointPairList.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoIntersect.h"
#include "geogebra/common/kernel/algos/AlgoIntersectConics.h"
#include "geogebra/common/kernel/algos/AlgoIntersectLineConic.h"
#include "geogebra/common/kernel/algos/EquationElementInterface.h"
#include "geogebra/common/kernel/algos/EquationScopeInterface.h"
#include "geogebra/common/kernel/algos/TangentAlgo.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoConic.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/kernelND/AlgoIntersectND.h"
#include "geogebra/common/kernel/kernelND/GeoConicND.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/prover/NoSymbolicParametersException.h"
#include "geogebra/common/kernel/prover/polynomial/Polynomial.h"
#include "geogebra/common/kernel/prover/polynomial/Variable.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/Iterator.h"
#include "java/util/Set.h"

@interface GeogebraCommonKernelAlgosAlgoIntersectLineConic () {
 @public
  IOSObjectArray *D_;
  JavaUtilHashMap *botanaPolynomials_;
  JavaUtilHashMap *botanaVars_;
  IOSIntArray *age_;
  IOSIntArray *permutation_;
  IOSObjectArray *distTable_;
  IOSBooleanArray *isQonPath_;
  IOSBooleanArray *isPalive_;
  jboolean isDefinedAsTangent_;
  jboolean firstIntersection_;
  jboolean isPermutationNeeded_;
  id<GeogebraCommonKernelKernelNDGeoPointND> tangentPoint_;
  GeogebraCommonKernelPointPairList *pointList_;
  jboolean isLimitedPathSituation_;
}

- (void)addIncidence;

- (jboolean)handleSpecialCase;

- (jboolean)handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)p;

- (void)computeNonContinous;

- (void)computeContinous;

- (void)handleLimitedPaths;

- (void)updateQonPath;

- (jboolean)pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)P;

- (jint)intersectWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c
            withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)sol;

+ (jboolean)testPointsWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)g
                     withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c
                withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)P
                                               withDouble:(jdouble)eps;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, D_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, botanaPolynomials_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, botanaVars_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, age_, IOSIntArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, permutation_, IOSIntArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, distTable_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, isQonPath_, IOSBooleanArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, isPalive_, IOSBooleanArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, tangentPoint_, id<GeogebraCommonKernelKernelNDGeoPointND>)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, pointList_, GeogebraCommonKernelPointPairList *)

static IOSDoubleArray *GeogebraCommonKernelAlgosAlgoIntersectLineConic_xyz_;
J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, xyz_, IOSDoubleArray *)
J2OBJC_STATIC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConic, xyz_, IOSDoubleArray *)

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectLineConic_addIncidence(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectLineConic_initForNearToRelationship(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCase(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self, GeogebraCommonKernelGeosGeoPoint *p);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectLineConic_computeNonContinous(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectLineConic_computeContinous(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleLimitedPaths(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectLineConic_updateQonPath(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConic_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self, GeogebraCommonKernelGeosGeoPoint *P);

__attribute__((unused)) static jint GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self, GeogebraCommonKernelGeosGeoConic *c, IOSObjectArray *sol);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConic_testPointsWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelGeosGeoLine *g, GeogebraCommonKernelGeosGeoConic *c, IOSObjectArray *P, jdouble eps);

J2OBJC_INITIALIZED_DEFN(GeogebraCommonKernelAlgosAlgoIntersectLineConic)

@implementation GeogebraCommonKernelAlgosAlgoIntersectLineConic

- (GeogebraCommonKernelCommandsCommandsEnum *)getClassName {
  return GeogebraCommonKernelCommandsCommandsEnum_get_Intersect();
}

- (jint)getRelatedModeID {
  return GeogebraCommonEuclidianEuclidianConstants_MODE_INTERSECT;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                     withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)g
                    withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(self, cons, g, c);
  return self;
}

- (void)addIncidence {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_addIncidence(self);
}

- (void)initElements {
  if (isDefinedAsTangent_) {
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_P_(self, [IOSObjectArray newArrayWithLength:1 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
    IOSObjectArray_SetAndConsume(P_, 0, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_));
  }
  else {
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_P_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_D_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_Q_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_distTable_(self, [IOSDoubleArray newArrayWithDimensions:2 lengths:(jint[]){ 2, 2 }]);
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_age_(self, [IOSIntArray newArrayWithLength:2]);
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_permutation_(self, [IOSIntArray newArrayWithLength:2]);
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_isQonPath_(self, [IOSBooleanArray newArrayWithLength:2]);
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_isPalive_(self, [IOSBooleanArray newArrayWithLength:2]);
    for (jint i = 0; i < 2; i++) {
      IOSObjectArray_SetAndConsume(Q_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_));
      IOSObjectArray_SetAndConsume(P_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_));
      IOSObjectArray_SetAndConsume(D_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_));
    }
    possibleSpecialCase_ = GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCase(self);
  }
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_setAndConsume_input_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoElement_class_()]);
  IOSObjectArray_Set(input_, 0, c_);
  IOSObjectArray_Set(input_, 1, g_);
  [super setOutputWithGeogebraCommonKernelGeosGeoElementArray:P_];
  [self noUndefinedPointsInAlgebraView];
  [self setDependencies];
}

- (IOSObjectArray *)getIntersectionPoints {
  return P_;
}

- (GeogebraCommonKernelGeosGeoLine *)getLine {
  return g_;
}

- (GeogebraCommonKernelGeosGeoConic *)getConic {
  return c_;
}

- (IOSObjectArray *)getLastDefinedIntersectionPoints {
  return D_;
}

- (jboolean)isNearToAlgorithm {
  return YES;
}

- (void)initForNearToRelationship {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_initForNearToRelationship(self);
}

- (void)compute {
  if (isDefinedAsTangent_) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(P_), 0))) setCoordsFromPointWithGeogebraCommonKernelKernelNDGeoPointND:tangentPoint_];
    return;
  }
  if (possibleSpecialCase_) {
    if (GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCase(self)) return;
  }
  jboolean continous = isPermutationNeeded_ || [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) isContinuous] || [kernel_ getLoadingMode];
  if (continous) {
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_computeContinous(self);
  }
  else {
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_computeNonContinous(self);
  }
  [self avoidDoubleTangentPoint];
}

- (jboolean)handleSpecialCase {
  return GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCase(self);
}

- (jboolean)handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)p {
  return GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint_(self, p);
}

- (void)computeNonContinous {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_computeNonContinous(self);
}

- (void)computeContinous {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_computeContinous(self);
}

- (void)handleLimitedPaths {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleLimitedPaths(self);
}

- (void)updateQonPath {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_updateQonPath(self);
}

- (jboolean)pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)P {
  return GeogebraCommonKernelAlgosAlgoIntersectLineConic_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, P);
}

- (jint)intersectWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c
            withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)sol {
  return GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(self, c, sol);
}

+ (jint)intersectLineConicWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)g
                   withGeogebraCommonKernelKernelNDGeoConicND:(GeogebraCommonKernelKernelNDGeoConicND *)c
                    withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)sol
                                                   withDouble:(jdouble)eps {
  return GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectLineConicWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelKernelNDGeoConicND_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(g, c, sol, eps);
}

+ (jboolean)testPointsWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)g
                     withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c
                withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)P
                                               withDouble:(jdouble)eps {
  return GeogebraCommonKernelAlgosAlgoIntersectLineConic_testPointsWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(g, c, P, eps);
}

- (IOSObjectArray *)getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  return [((JavaUtilHashMap *) nil_chk(botanaVars_)) getWithId:geo];
}

- (IOSObjectArray *)getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (botanaPolynomials_ != nil) {
    IOSObjectArray *ret = [botanaPolynomials_ getWithId:geo];
    if (ret != nil) return ret;
  }
  if (g_ != nil && c_ != nil && [c_ isCircle]) {
    IOSObjectArray *botanaVarsThis = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
    if (botanaVars_ == nil) {
      GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_botanaVars_(self, new_JavaUtilHashMap_init());
    }
    if ([((JavaUtilHashMap *) nil_chk(botanaVars_)) containsKeyWithId:geo]) {
      botanaVarsThis = [botanaVars_ getWithId:geo];
    }
    else {
      botanaVarsThis = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
      IOSObjectArray_SetAndConsume(botanaVarsThis, 0, new_GeogebraCommonKernelProverPolynomialVariable_init());
      IOSObjectArray_SetAndConsume(botanaVarsThis, 1, new_GeogebraCommonKernelProverPolynomialVariable_init());
      [botanaVars_ putWithId:geo withId:botanaVarsThis];
    }
    IOSObjectArray *botanaPolynomialsThis = nil;
    IOSObjectArray *botanaVarsOther = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
    id<JavaUtilIterator> it = [((id<JavaUtilSet>) nil_chk([botanaVars_ keySet])) iterator];
    jboolean found = NO;
    while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
      GeogebraCommonKernelGeosGeoElement *otherGeo = [it next];
      if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(otherGeo)) isEqual:geo]) {
        botanaPolynomialsThis = [IOSObjectArray arrayWithLength:3 type:GeogebraCommonKernelProverPolynomialPolynomial_class_()];
        botanaVarsOther = [botanaVars_ getWithId:otherGeo];
        IOSObjectArray_Set(botanaPolynomialsThis, 2, [((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(GeogebraCommonKernelProverPolynomialPolynomial_sqrDistanceWithGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_(IOSObjectArray_Get(nil_chk(botanaVarsThis), 0), IOSObjectArray_Get(botanaVarsThis, 1), IOSObjectArray_Get(nil_chk(botanaVarsOther), 0), IOSObjectArray_Get(botanaVarsOther, 1)))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:[new_GeogebraCommonKernelProverPolynomialPolynomial_initWithGeogebraCommonKernelProverPolynomialVariable_([new_GeogebraCommonKernelProverPolynomialVariable_init() autorelease]) autorelease]]))) subtractWithGeogebraCommonKernelProverPolynomialPolynomial:[new_GeogebraCommonKernelProverPolynomialPolynomial_initWithInt_(1) autorelease]]);
        found = YES;
      }
    }
    if (!found) {
      botanaPolynomialsThis = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialPolynomial_class_()];
    }
    IOSObjectArray *vg = [g_ getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
    IOSObjectArray *vc = [c_ getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
    IOSObjectArray_Set(nil_chk(botanaPolynomialsThis), 0, GeogebraCommonKernelProverPolynomialPolynomial_collinearWithGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_(IOSObjectArray_Get(nil_chk(vg), 0), IOSObjectArray_Get(vg, 1), IOSObjectArray_Get(vg, 2), IOSObjectArray_Get(vg, 3), IOSObjectArray_Get(nil_chk(botanaVarsThis), 0), IOSObjectArray_Get(botanaVarsThis, 1)));
    IOSObjectArray_Set(botanaPolynomialsThis, 1, GeogebraCommonKernelProverPolynomialPolynomial_equidistantWithGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_(IOSObjectArray_Get(nil_chk(vc), 2), IOSObjectArray_Get(vc, 3), IOSObjectArray_Get(vc, 0), IOSObjectArray_Get(vc, 1), IOSObjectArray_Get(botanaVarsThis, 0), IOSObjectArray_Get(botanaVarsThis, 1)));
    if (botanaPolynomials_ == nil) {
      GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_botanaPolynomials_(self, new_JavaUtilHashMap_init());
    }
    [((JavaUtilHashMap *) nil_chk(botanaPolynomials_)) putWithId:geo withId:botanaPolynomialsThis];
    return botanaPolynomialsThis;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (jboolean)isLocusEquable {
  return YES;
}

- (id<GeogebraCommonKernelAlgosEquationElementInterface>)buildEquationElementForGeoWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo
                                                                      withGeogebraCommonKernelAlgosEquationScopeInterface:(id<GeogebraCommonKernelAlgosEquationScopeInterface>)scope {
  return GeogebraCommonKernelLocusEquation_eqnIntersectLineConicWithGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelAlgosAlgoElement_withGeogebraCommonKernelAlgosEquationScopeInterface_(geo, self, scope);
}

- (void)dealloc {
  RELEASE_(g_);
  RELEASE_(c_);
  RELEASE_(D_);
  RELEASE_(P_);
  RELEASE_(Q_);
  RELEASE_(botanaPolynomials_);
  RELEASE_(botanaVars_);
  RELEASE_(age_);
  RELEASE_(permutation_);
  RELEASE_(distTable_);
  RELEASE_(isQonPath_);
  RELEASE_(isPalive_);
  RELEASE_(tangentPoint_);
  RELEASE_(pointList_);
  [super dealloc];
}

+ (void)initialize {
  if (self == [GeogebraCommonKernelAlgosAlgoIntersectLineConic class]) {
    JreStrongAssignAndConsume(&GeogebraCommonKernelAlgosAlgoIntersectLineConic_xyz_, nil, [IOSDoubleArray newArrayWithLength:3]);
    J2OBJC_SET_INITIALIZED(GeogebraCommonKernelAlgosAlgoIntersectLineConic)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getClassName", NULL, "Lgeogebra.common.kernel.commands.Commands;", 0x1, NULL, NULL },
    { "getRelatedModeID", NULL, "I", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelGeosGeoLine:withGeogebraCommonKernelGeosGeoConic:", "AlgoIntersectLineConic", NULL, 0x1, NULL, NULL },
    { "addIncidence", NULL, "V", 0x2, NULL, NULL },
    { "initElements", NULL, "V", 0x4, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x1, NULL, NULL },
    { "getIntersectionPoints", NULL, "[Lgeogebra.common.kernel.geos.GeoPoint;", 0x11, NULL, NULL },
    { "getLine", NULL, "Lgeogebra.common.kernel.geos.GeoLine;", 0x1, NULL, NULL },
    { "getConic", NULL, "Lgeogebra.common.kernel.geos.GeoConic;", 0x1, NULL, NULL },
    { "getLastDefinedIntersectionPoints", NULL, "[Lgeogebra.common.kernel.geos.GeoPoint;", 0x4, NULL, NULL },
    { "isNearToAlgorithm", NULL, "Z", 0x1, NULL, NULL },
    { "initForNearToRelationship", NULL, "V", 0x11, NULL, NULL },
    { "compute", NULL, "V", 0x1, NULL, NULL },
    { "handleSpecialCase", NULL, "Z", 0x2, NULL, NULL },
    { "handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint:", "handleSpecialCasePoint", "Z", 0x2, NULL, NULL },
    { "computeNonContinous", NULL, "V", 0x2, NULL, NULL },
    { "computeContinous", NULL, "V", 0x2, NULL, NULL },
    { "handleLimitedPaths", NULL, "V", 0x2, NULL, NULL },
    { "updateQonPath", NULL, "V", 0x2, NULL, NULL },
    { "pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint:", "pointLiesOnBothPaths", "Z", 0x2, NULL, NULL },
    { "intersectWithGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoPointArray:", "intersect", "I", 0x2, NULL, NULL },
    { "intersectLineConicWithGeogebraCommonKernelGeosGeoLine:withGeogebraCommonKernelKernelNDGeoConicND:withGeogebraCommonKernelGeosGeoPointArray:withDouble:", "intersectLineConic", "I", 0x39, NULL, NULL },
    { "testPointsWithGeogebraCommonKernelGeosGeoLine:withGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoPointArray:withDouble:", "testPoints", "Z", 0x1a, NULL, NULL },
    { "getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:", "getBotanaVars", "[Lgeogebra.common.kernel.prover.polynomial.Variable;", 0x1, NULL, NULL },
    { "getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:", "getBotanaPolynomials", "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "isLocusEquable", NULL, "Z", 0x1, NULL, NULL },
    { "buildEquationElementForGeoWithGeogebraCommonKernelGeosGeoElement:withGeogebraCommonKernelAlgosEquationScopeInterface:", "buildEquationElementForGeo", "Lgeogebra.common.kernel.algos.EquationElementInterface;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "g_", NULL, 0x4, "Lgeogebra.common.kernel.geos.GeoLine;", NULL, NULL,  },
    { "c_", NULL, 0x4, "Lgeogebra.common.kernel.geos.GeoConic;", NULL, NULL,  },
    { "D_", NULL, 0x2, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "P_", NULL, 0x4, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "Q_", NULL, 0x4, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "intersectionType_", NULL, 0x4, "I", NULL, NULL,  },
    { "botanaPolynomials_", NULL, 0x2, "Ljava.util.HashMap;", NULL, "Ljava/util/HashMap<Lgeogebra/common/kernel/geos/GeoElement;L[Lgeogebra/common/kernel/prover/polynomial/Polynomial;;>;",  },
    { "botanaVars_", NULL, 0x2, "Ljava.util.HashMap;", NULL, "Ljava/util/HashMap<Lgeogebra/common/kernel/geos/GeoElement;L[Lgeogebra/common/kernel/prover/polynomial/Variable;;>;",  },
    { "age_", NULL, 0x2, "[I", NULL, NULL,  },
    { "permutation_", NULL, 0x2, "[I", NULL, NULL,  },
    { "distTable_", NULL, 0x2, "[[D", NULL, NULL,  },
    { "isQonPath_", NULL, 0x2, "[Z", NULL, NULL,  },
    { "isPalive_", NULL, 0x2, "[Z", NULL, NULL,  },
    { "isDefinedAsTangent_", NULL, 0x2, "Z", NULL, NULL,  },
    { "firstIntersection_", NULL, 0x2, "Z", NULL, NULL,  },
    { "isPermutationNeeded_", NULL, 0x2, "Z", NULL, NULL,  },
    { "tangentPoint_", NULL, 0x2, "Lgeogebra.common.kernel.kernelND.GeoPointND;", NULL, NULL,  },
    { "pointList_", NULL, 0x2, "Lgeogebra.common.kernel.PointPairList;", NULL, NULL,  },
    { "isLimitedPathSituation_", NULL, 0x2, "Z", NULL, NULL,  },
    { "possibleSpecialCase_", NULL, 0x4, "Z", NULL, NULL,  },
    { "specialCasePointOnCircleIndex_", NULL, 0x4, "I", NULL, NULL,  },
    { "INTERSECTION_PRODUCING_LINE_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PRODUCING_LINE },
    { "INTERSECTION_ASYMPTOTIC_LINE_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_ASYMPTOTIC_LINE },
    { "INTERSECTION_MEETING_LINE_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_MEETING_LINE },
    { "INTERSECTION_TANGENT_LINE_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_TANGENT_LINE },
    { "INTERSECTION_SECANT_LINE_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_SECANT_LINE },
    { "INTERSECTION_PASSING_LINE_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PASSING_LINE },
    { "xyz_", NULL, 0xa, "[D", &GeogebraCommonKernelAlgosAlgoIntersectLineConic_xyz_, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelAlgosAlgoIntersectLineConic = { 2, "AlgoIntersectLineConic", "geogebra.common.kernel.algos", NULL, 0x1, 27, methods, 28, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelAlgosAlgoIntersectLineConic;
}

@end

void GeogebraCommonKernelAlgosAlgoIntersectLineConic_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self, GeogebraCommonKernelConstruction *cons, GeogebraCommonKernelGeosGeoLine *g, GeogebraCommonKernelGeosGeoConic *c) {
  GeogebraCommonKernelAlgosAlgoIntersect_initWithGeogebraCommonKernelConstruction_(self, cons);
  self->firstIntersection_ = YES;
  self->isPermutationNeeded_ = YES;
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_setAndConsume_pointList_(self, new_GeogebraCommonKernelPointPairList_init());
  self->possibleSpecialCase_ = NO;
  self->specialCasePointOnCircleIndex_ = 0;
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_set_g_(self, g);
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_set_c_(self, c);
  self->isLimitedPathSituation_ = ([((GeogebraCommonKernelGeosGeoLine *) nil_chk(g)) isLimitedPath] || [((GeogebraCommonKernelGeosGeoConic *) nil_chk(c)) isLimitedPath]);
  if ([GeogebraCommonKernelAlgosTangentAlgo_class_() isInstance:[g getParentAlgorithm]]) {
    id<GeogebraCommonKernelAlgosTangentAlgo> algo = (id<GeogebraCommonKernelAlgosTangentAlgo>) check_protocol_cast([g getParentAlgorithm], @protocol(GeogebraCommonKernelAlgosTangentAlgo));
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_set_tangentPoint_(self, [((id<GeogebraCommonKernelAlgosTangentAlgo>) nil_chk(algo)) getTangentPointWithGeogebraCommonKernelGeosGeoElement:c withGeogebraCommonKernelGeosGeoLine:g]);
    self->isDefinedAsTangent_ = (self->tangentPoint_ != nil);
  }
  [self initElements];
  [self setInputOutput];
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_initForNearToRelationship(self);
  [self compute];
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_addIncidence(self);
}

GeogebraCommonKernelAlgosAlgoIntersectLineConic *new_GeogebraCommonKernelAlgosAlgoIntersectLineConic_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(GeogebraCommonKernelConstruction *cons, GeogebraCommonKernelGeosGeoLine *g, GeogebraCommonKernelGeosGeoConic *c) {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic *self = [GeogebraCommonKernelAlgosAlgoIntersectLineConic alloc];
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(self, cons, g, c);
  return self;
}

void GeogebraCommonKernelAlgosAlgoIntersectLineConic_addIncidence(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self) {
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->P_))->size_; ++i) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) addIncidenceWithGeogebraCommonKernelGeosGeoElement:self->g_ withBoolean:NO];
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) addIncidenceWithGeogebraCommonKernelGeosGeoElement:self->c_ withBoolean:NO];
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectLineConic_initForNearToRelationship(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self) {
  if (self->isDefinedAsTangent_) return;
  self->isPermutationNeeded_ = YES;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->P_))->size_; i++) {
    *IOSIntArray_GetRef(nil_chk(self->age_), i) = 0;
    *IOSBooleanArray_GetRef(nil_chk(self->isQonPath_), i) = YES;
    *IOSBooleanArray_GetRef(nil_chk(self->isPalive_), i) = NO;
  }
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCase(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self) {
  id<GeogebraCommonKernelKernelNDGeoPointND> existingIntersection = nil;
  JavaUtilArrayList *pointsOnConic = [((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->c_)) getPointsOnConic];
  if (pointsOnConic != nil) {
    for (jint i = 0; i < [pointsOnConic size]; ++i) {
      id<GeogebraCommonKernelKernelNDGeoPointND> p = [pointsOnConic getWithInt:i];
      if ([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(p)) isLabelSet]) {
        if ([p getIncidenceList] != nil && [((JavaUtilArrayList *) nil_chk([p getIncidenceList])) containsWithId:self->g_]) {
          existingIntersection = p;
          break;
        }
      }
    }
  }
  if (existingIntersection == nil) {
    if (GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint_(self, [((GeogebraCommonKernelGeosGeoLine *) nil_chk(self->g_)) getStartPoint])) {
      existingIntersection = [self->g_ getStartPoint];
    }
    else if (GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint_(self, [self->g_ getEndPoint])) {
      existingIntersection = [self->g_ getEndPoint];
    }
  }
  if (existingIntersection == nil) {
    JavaUtilArrayList *pointsOnLine = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(self->g_)) getPointsOnLine];
    if (pointsOnLine != nil) {
      for (jint i = 0; i < [pointsOnLine size]; ++i) {
        if (GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint_(self, [pointsOnLine getWithInt:i])) {
          existingIntersection = [pointsOnLine getWithInt:i];
          break;
        }
      }
    }
  }
  if (existingIntersection == nil) {
    return NO;
  }
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(self, self->c_, self->Q_);
  jint firstIndex = self->specialCasePointOnCircleIndex_;
  jint secondIndex = 1 - firstIndex;
  if (self->firstIntersection_ && [self didSetIntersectionPointWithInt:firstIndex]) {
    if (![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), firstIndex))) isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *) check_class_cast(existingIntersection, [GeogebraCommonKernelGeosGeoElement class])]) {
      jint temp = firstIndex;
      firstIndex = secondIndex;
      secondIndex = temp;
      self->specialCasePointOnCircleIndex_ = firstIndex;
    }
    self->firstIntersection_ = NO;
  }
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), firstIndex))) setCoordsFromPointWithGeogebraCommonKernelKernelNDGeoPointND:existingIntersection];
  jboolean didSetP1 = NO;
  for (jint i = 0; i < 2; i++) {
    if (![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->Q_), i))) isEqualWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(self->P_, firstIndex)]) {
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, secondIndex))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->Q_, i)];
      didSetP1 = YES;
      break;
    }
  }
  if (!didSetP1) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, secondIndex))) setCoordsFromPointWithGeogebraCommonKernelKernelNDGeoPointND:existingIntersection];
  if (self->isLimitedPathSituation_) {
    for (jint i = 0; i < 2; i++) {
      if (!GeogebraCommonKernelAlgosAlgoIntersectLineConic_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->P_, i))) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setUndefined];
    }
  }
  return YES;
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleSpecialCasePointWithGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self, GeogebraCommonKernelGeosGeoPoint *p) {
  if (p == nil) {
    return NO;
  }
  if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p)) isLabelSet]) {
    if ([p getIncidenceList] != nil && [((JavaUtilArrayList *) nil_chk([p getIncidenceList])) containsWithId:self->c_]) {
      return YES;
    }
  }
  return NO;
}

void GeogebraCommonKernelAlgosAlgoIntersectLineConic_computeNonContinous(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self) {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(self, self->c_, self->Q_);
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->P_))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(nil_chk(self->Q_), IOSIntArray_Get(nil_chk(self->permutation_), i))];
  }
  if (self->isLimitedPathSituation_) {
    for (jint i = 0; i < self->P_->size_; i++) {
      if (!GeogebraCommonKernelAlgosAlgoIntersectLineConic_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->P_, i))) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setUndefined];
    }
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectLineConic_computeContinous(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self) {
  jboolean noSingularity = ![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), 0))) isEqualWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(self->P_, 1)];
  for (jint i = 0; i < 2; i++) {
    jboolean finite = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) isFinite];
    if (noSingularity && finite) {
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->D_), i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->P_, i)];
      *IOSIntArray_GetRef(nil_chk(self->age_), i) = 0;
    }
    else {
      (*IOSIntArray_GetRef(nil_chk(self->age_), i))++;
    }
    *IOSBooleanArray_GetRef(nil_chk(self->isPalive_), i) = (IOSBooleanArray_Get(self->isPalive_, i) || finite || ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i)))->labelSet_);
  }
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(self, self->c_, self->Q_);
  if (self->isLimitedPathSituation_) {
    GeogebraCommonKernelAlgosAlgoIntersectLineConic_updateQonPath(self);
  }
  if (self->firstIntersection_) {
    jint count = 0;
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->Q_))->size_; i++) {
      if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->Q_, i))) isDefined] && GeogebraCommonKernelAlgosAlgoIntersectLineConic_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->Q_, i))) {
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, count))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->Q_, i)];
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->D_), count))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->P_, count)];
        self->firstIntersection_ = NO;
        count++;
      }
    }
    return;
  }
  GeogebraCommonKernelAlgosAlgoIntersectConics_distanceTableWithGeogebraCommonKernelGeosGeoPointArray_withIntArray_withGeogebraCommonKernelGeosGeoPointArray_withDoubleArray2_(self->D_, self->age_, self->Q_, self->distTable_);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setNearToWithGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withDoubleArray2_withGeogebraCommonKernelPointPairList_withIntArray_withBoolean_withDouble_(self->P_, self->isPalive_, self->Q_, self->isQonPath_, self->distTable_, self->pointList_, self->permutation_, !self->isPermutationNeeded_, 0.000001);
  self->isPermutationNeeded_ = NO;
  if (self->isLimitedPathSituation_) GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleLimitedPaths(self);
}

void GeogebraCommonKernelAlgosAlgoIntersectLineConic_handleLimitedPaths(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self) {
  jboolean noSingularity = ![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), 0))) isEqualWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(self->P_, 1)];
  for (jint i = 0; i < self->P_->size_; i++) {
    if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) isDefined]) {
      if (!GeogebraCommonKernelAlgosAlgoIntersectLineConic_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->P_, i))) {
        if (noSingularity && [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) isFinite]) {
          [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->D_), i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->P_, i)];
          *IOSIntArray_GetRef(nil_chk(self->age_), i) = -1;
        }
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setUndefined];
      }
    }
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectLineConic_updateQonPath(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self) {
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->Q_))->size_; i++) {
    *IOSBooleanArray_GetRef(nil_chk(self->isQonPath_), i) = GeogebraCommonKernelAlgosAlgoIntersectLineConic_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->Q_, i));
  }
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConic_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self, GeogebraCommonKernelGeosGeoPoint *P) {
  return [((GeogebraCommonKernelGeosGeoLine *) nil_chk(self->g_)) isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:P withDouble:GeogebraCommonKernelKernel_MIN_PRECISION] && [((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->c_)) isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:P withDouble:GeogebraCommonKernelKernel_MIN_PRECISION];
}

jint GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(GeogebraCommonKernelAlgosAlgoIntersectLineConic *self, GeogebraCommonKernelGeosGeoConic *c, IOSObjectArray *sol) {
  jboolean ok = NO;
  jint ret = GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PASSING_LINE;
  if ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(c)) isDefined] && [((GeogebraCommonKernelGeosGeoLine *) nil_chk(self->g_)) isDefined]) {
    jdouble epsilon = 1E-15;
    while (epsilon <= GeogebraCommonKernelKernel_MIN_PRECISION) {
      ret = GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectLineConicWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelKernelNDGeoConicND_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self->g_, c, sol, epsilon);
      ok = GeogebraCommonKernelAlgosAlgoIntersectLineConic_testPointsWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self->g_, c, sol, GeogebraCommonKernelKernel_MIN_PRECISION);
      if (ok) {
        break;
      }
      epsilon *= 10.0;
    }
  }
  if (!ok) {
    for (jint i = 0; i < 2; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), i))) setUndefined];
  }
  self->intersectionType_ = ret;
  return ret;
}

jint GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectLineConicWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelKernelNDGeoConicND_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelGeosGeoLine *g, GeogebraCommonKernelKernelNDGeoConicND *c, IOSObjectArray *sol, jdouble eps) {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_initialize();
  @synchronized(GeogebraCommonKernelAlgosAlgoIntersectLineConic_class_()) {
    IOSDoubleArray *A = [((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(c)) getFlatMatrix];
    [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g)) getnormalizedCoefficientsWithDoubleArray:GeogebraCommonKernelAlgosAlgoIntersectLineConic_xyz_];
    jdouble x = IOSDoubleArray_Get(nil_chk(GeogebraCommonKernelAlgosAlgoIntersectLineConic_xyz_), 0);
    jdouble y = IOSDoubleArray_Get(GeogebraCommonKernelAlgosAlgoIntersectLineConic_xyz_, 1);
    jdouble z = IOSDoubleArray_Get(GeogebraCommonKernelAlgosAlgoIntersectLineConic_xyz_, 2);
    jdouble px, py;
    if (JavaLangMath_absWithDouble_(x) > JavaLangMath_absWithDouble_(y)) {
      px = -z / x;
      py = 0.0;
    }
    else {
      px = 0.0;
      py = -z / y;
    }
    jdouble SvX = IOSDoubleArray_Get(nil_chk(A), 0) * y - IOSDoubleArray_Get(A, 3) * x;
    jdouble SvY = IOSDoubleArray_Get(A, 3) * y - IOSDoubleArray_Get(A, 1) * x;
    jdouble u = y * SvX - x * SvY;
    jdouble d = px * SvX + py * SvY + IOSDoubleArray_Get(A, 4) * y - IOSDoubleArray_Get(A, 5) * x;
    jdouble w = [c evaluateWithDouble:px withDouble:py];
    jdouble delta = JavaLangMath_minWithDouble_withDouble_(GeogebraCommonKernelKernel_MIN_PRECISION, JavaLangMath_maxWithDouble_withDouble_(1, JavaLangMath_absWithDouble_(2 * d) + JavaLangMath_absWithDouble_(u) + JavaLangMath_absWithDouble_(w)) * eps);
    if (GeogebraCommonKernelKernel_isZeroWithDouble_withDouble_(u, eps)) {
      if (GeogebraCommonKernelKernel_isZeroWithDouble_withDouble_(d, eps)) {
        if (GeogebraCommonKernelKernel_isZeroWithDouble_withDouble_(w, eps)) {
          [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), 0))) setUndefined];
          [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(sol, 1))) setUndefined];
          return GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PRODUCING_LINE;
        }
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), 0))) setUndefined];
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(sol, 1))) setUndefined];
        return GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_ASYMPTOTIC_LINE;
      }
      jdouble t0 = -w / (2.0 * d);
      if (d < 0) {
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), 0))) setCoordsWithDouble:px + t0 * y withDouble:py - t0 * x withDouble:1.0];
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(sol, 1))) setUndefined];
      }
      else {
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), 0))) setUndefined];
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(sol, 1))) setCoordsWithDouble:px + t0 * y withDouble:py - t0 * x withDouble:1.0];
      }
      return GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_MEETING_LINE;
    }
    jdouble dis = d * d - u * w;
    if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_(dis, 0, delta)) {
      jdouble t1 = -d / u;
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), 0))) setCoordsWithDouble:px + t1 * y withDouble:py - t1 * x withDouble:1.0];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(sol, 1))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(sol, 0)];
      return GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_TANGENT_LINE;
    }
    if (c->type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE) {
      jdouble t1 = -d / u;
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), 0))) setCoordsWithDouble:px + t1 * y withDouble:py - t1 * x withDouble:1.0];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(sol, 1))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(sol, 0)];
      return GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_SECANT_LINE;
    }
    if (dis > 0) {
      dis = JavaLangMath_sqrtWithDouble_(dis);
      jboolean swap = d < 0.0;
      if (swap) {
        dis = -dis;
      }
      jdouble q = -(d + dis);
      jdouble t1 = swap ? w / q : q / u;
      jdouble t2 = swap ? q / u : w / q;
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), 0))) setCoordsWithDouble:px + t1 * y withDouble:py - t1 * x withDouble:1.0];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(sol, 1))) setCoordsWithDouble:px + t2 * y withDouble:py - t2 * x withDouble:1.0];
      return GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_SECANT_LINE;
    }
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(sol), 0))) setUndefined];
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(sol, 1))) setUndefined];
    return GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PASSING_LINE;
  }
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConic_testPointsWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelGeosGeoLine *g, GeogebraCommonKernelGeosGeoConic *c, IOSObjectArray *P, jdouble eps) {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_initialize();
  jboolean foundPoint = NO;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(P))->size_; i++) {
    if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(P, i))) isDefined]) {
      if (!([((GeogebraCommonKernelGeosGeoConic *) nil_chk(c)) isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(P, i) withDouble:eps] && [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g)) isOnFullLineWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(P, i) withDouble:eps])) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(P, i))) setUndefined];
      else foundPoint = YES;
    }
  }
  return foundPoint;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelAlgosAlgoIntersectLineConic)
