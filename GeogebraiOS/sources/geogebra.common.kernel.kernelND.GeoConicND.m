//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/kernelND/GeoConicND.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GAffineTransform.h"
#include "geogebra/common/factories/AwtFactory.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/EquationSolver.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/CoordMatrix.h"
#include "geogebra/common/kernel/Matrix/CoordMatrix4x4.h"
#include "geogebra/common/kernel/Matrix/CoordSys.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/Path.h"
#include "geogebra/common/kernel/PathMover.h"
#include "geogebra/common/kernel/PathMoverGeneric.h"
#include "geogebra/common/kernel/PathNormalizer.h"
#include "geogebra/common/kernel/PathParameter.h"
#include "geogebra/common/kernel/RegionParameters.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoConicFivePoints.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoEllipseFociLength.h"
#include "geogebra/common/kernel/algos/AlgoEllipseHyperbolaFociPoint.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionVariable.h"
#include "geogebra/common/kernel/arithmetic/MyDouble.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/kernel/geos/GeoVector.h"
#include "geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "geogebra/common/kernel/kernelND/GeoConicND.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/kernelND/GeoQuadricND.h"
#include "geogebra/common/kernel/kernelND/GeoSegmentND.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/util/GgbMat.h"
#include "geogebra/common/util/MyMath.h"
#include "java/lang/Double.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/TreeSet.h"

#pragma clang diagnostic ignored "-Wprotocol"

@interface GeogebraCommonKernelKernelNDGeoConicND () {
 @public
  jdouble detS_, length_, temp_, temp1_, temp2_, nx_, ny_, lambda_;
  jint index_;
  GeogebraCommonKernelGeosGeoVec2D *c_;
  IOSDoubleArray *coeffs_;
  jboolean eigenvectorsSetOnLoad_;
  GeogebraCommonUtilGgbMat *polarMatrix_;
  jdouble area_;
  jboolean isEndOfQuadric__;
  GeogebraCommonKernelGeosGeoElement_HitTypeEnum *lastHitType_;
  GeogebraCommonKernelMatrixCoords *labelPosition_;
  GeogebraCommonKernelPathParameter *labelParameter_;
  JavaUtilTreeSet *metas_;
}

- (IOSDoubleArray *)getPerpendicularParamsWithDouble:(jdouble)abspx
                                          withDouble:(jdouble)abspy;

- (jboolean)compatibleTypeWithInt:(jint)t;

- (void)coordsRWtoEVWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P;

- (void)translateByCenterWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P;

- (void)setLinesWithGeogebraCommonKernelKernelNDGeoConicND:(GeogebraCommonKernelKernelNDGeoConicND *)co;

- (jboolean)checkDefined;

- (void)rotateWithDouble:(jdouble)phi;

- (void)setParabolicEigenvectors;

- (void)makePathParametersInvalid;

- (jboolean)isDetSzero;

- (void)classifyMidpointConicWithBoolean:(jboolean)degenerate;

- (void)intersectingLinesWithDoubleArray:(IOSDoubleArray *)mu1;

- (void)ellipseWithDoubleArray:(IOSDoubleArray *)mu1;

- (void)hyperbolaWithDoubleArray:(IOSDoubleArray *)mu1;

- (void)classifyParabolicConicWithBoolean:(jboolean)degenerate;

- (void)doubleLine;

- (void)handleSzero;

- (void)setStartPointsForLines;

- (void)setStartPointsForDoubleLine;

- (void)parabola;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelKernelNDGeoConicND, c_, GeogebraCommonKernelGeosGeoVec2D *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelKernelNDGeoConicND, coeffs_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelKernelNDGeoConicND, polarMatrix_, GeogebraCommonUtilGgbMat *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelKernelNDGeoConicND, lastHitType_, GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelKernelNDGeoConicND, labelPosition_, GeogebraCommonKernelMatrixCoords *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelKernelNDGeoConicND, labelParameter_, GeogebraCommonKernelPathParameter *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelKernelNDGeoConicND, metas_, JavaUtilTreeSet *)

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setCircleWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelGeosGeoPoint *M, GeogebraCommonKernelGeosGeoPoint *P);

__attribute__((unused)) static IOSDoubleArray *GeogebraCommonKernelKernelNDGeoConicND_getPerpendicularParamsWithDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble abspx, jdouble abspy);

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoConicND_compatibleTypeWithInt_(GeogebraCommonKernelKernelNDGeoConicND *self, jint t);

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, id<GeogebraCommonKernelKernelNDGeoPointND> P, jdouble eps);

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelMatrixCoords_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelMatrixCoords *P, jdouble eps);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelMatrixCoords *P);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelMatrixCoords *P);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_translateByCenterWithGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelMatrixCoords *P);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setLinesWithGeogebraCommonKernelKernelNDGeoConicND_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelKernelNDGeoConicND *co);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setToStringModeWithInt_(GeogebraCommonKernelKernelNDGeoConicND *self, jint mode);

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoConicND_isSpecificPossible(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoConicND_isExplicitPossible(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoConicND_checkDefined(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setCoeffsWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble a, jdouble b, jdouble c, jdouble d, jdouble e, jdouble f);

__attribute__((unused)) static IOSObjectArray *GeogebraCommonKernelKernelNDGeoConicND_getLines(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static id<GeogebraCommonAwtGAffineTransform> GeogebraCommonKernelKernelNDGeoConicND_getAffineTransform(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setCircleWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoSegment_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelGeosGeoPoint *M, GeogebraCommonKernelGeosGeoSegment *geoSegment);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_doTranslateWithDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble vx, jdouble vy);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_rotateWithDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble phi);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_doDilateWithDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble factor);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_updateDegenerates(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setParabolicEigenvectors(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_makePathParametersInvalid(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoConicND_isDetSzero(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_classifyMidpointConicWithBoolean_(GeogebraCommonKernelKernelNDGeoConicND *self, jboolean degenerate);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_singlePoint(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_intersectingLinesWithDoubleArray_(GeogebraCommonKernelKernelNDGeoConicND *self, IOSDoubleArray *mu1);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_ellipseWithDoubleArray_(GeogebraCommonKernelKernelNDGeoConicND *self, IOSDoubleArray *mu1);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_hyperbolaWithDoubleArray_(GeogebraCommonKernelKernelNDGeoConicND *self, IOSDoubleArray *mu1);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_classifyParabolicConicWithBoolean_(GeogebraCommonKernelKernelNDGeoConicND *self, jboolean degenerate);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_doubleLine(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_handleSzero(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_parallelLinesWithDoubleArray_(GeogebraCommonKernelKernelNDGeoConicND *self, IOSDoubleArray *mu1);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForLines(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForDoubleLine(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_parabola(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoConicND_hasPositiveEigenvectorOrientation(GeogebraCommonKernelKernelNDGeoConicND *self);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_setPositiveEigenvectorOrientationWithBoolean_(GeogebraCommonKernelKernelNDGeoConicND *self, jboolean flag);

__attribute__((unused)) static jdouble GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble x, jdouble y);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_polarPointWithDouble_withDouble_withDouble_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble x, jdouble y, jdouble z, GeogebraCommonKernelGeosGeoPoint *polar);

__attribute__((unused)) static void GeogebraCommonKernelKernelNDGeoConicND_diameterLineWithDouble_withDouble_withGeogebraCommonKernelGeosGeoLine_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble vx, jdouble vy, GeogebraCommonKernelGeosGeoLine *diameter);

J2OBJC_INITIALIZED_DEFN(GeogebraCommonKernelKernelNDGeoConicND)

IOSObjectArray *GeogebraCommonKernelKernelNDGeoConicND_vars_;
IOSObjectArray *GeogebraCommonKernelKernelNDGeoConicND_varsLateX_;
IOSObjectArray *GeogebraCommonKernelKernelNDGeoConicND_varsCAS_;
jboolean GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ = NO;

@implementation GeogebraCommonKernelKernelNDGeoConicND

- (GeogebraCommonKernelMatrixCoords *)getEigenvecWithInt:(jint)i {
  return [new_GeogebraCommonKernelMatrixCoords_initWithDoubleArray_([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), i))) getCoords]) autorelease];
}

- (GeogebraCommonKernelMatrixCoords *)getEigenvec3DWithInt:(jint)i {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (GeogebraCommonKernelMatrixCoordSys *)getCoordSys {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (GeogebraCommonKernelMatrixCoords *)getDirection3DWithInt:(jint)i {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (GeogebraCommonKernelMatrixCoords *)getOrigin3DWithInt:(jint)i {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                                                 withInt:(jint)dimension {
  GeogebraCommonKernelKernelNDGeoConicND_initWithGeogebraCommonKernelConstruction_withInt_(self, c, dimension);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                                                 withInt:(jint)dimension
                                             withBoolean:(jboolean)isIntersection {
  GeogebraCommonKernelKernelNDGeoConicND_initWithGeogebraCommonKernelConstruction_withInt_withBoolean_(self, c, dimension, isIntersection);
  return self;
}

- (GeogebraCommonKernelMatrixCoordMatrix *)getSymetricMatrixWithDoubleArray:(IOSDoubleArray *)vals {
  GeogebraCommonKernelMatrixCoordMatrix *ret = [new_GeogebraCommonKernelMatrixCoordMatrix_initWithInt_withInt_(3, 3) autorelease];
  [ret setWithInt:1 withInt:1 withDouble:IOSDoubleArray_Get(nil_chk(vals), 0)];
  [ret setWithInt:2 withInt:2 withDouble:IOSDoubleArray_Get(vals, 1)];
  [ret setWithInt:3 withInt:3 withDouble:IOSDoubleArray_Get(vals, 2)];
  [ret setWithInt:1 withInt:2 withDouble:IOSDoubleArray_Get(vals, 3)];
  [ret setWithInt:2 withInt:1 withDouble:IOSDoubleArray_Get(vals, 3)];
  [ret setWithInt:1 withInt:3 withDouble:IOSDoubleArray_Get(vals, 4)];
  [ret setWithInt:3 withInt:1 withDouble:IOSDoubleArray_Get(vals, 4)];
  [ret setWithInt:2 withInt:3 withDouble:IOSDoubleArray_Get(vals, 5)];
  [ret setWithInt:3 withInt:2 withDouble:IOSDoubleArray_Get(vals, 5)];
  return ret;
}

- (void)setCircleWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)M
                                           withDouble:(jdouble)r {
  [self setSphereNDWithGeogebraCommonKernelKernelNDGeoPointND:M withDouble:r];
}

- (void)setCircleWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)M
                 withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)P {
  GeogebraCommonKernelKernelNDGeoConicND_setCircleWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(self, M, P);
}

- (void)setSphereNDWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)M
                                                   withDouble:(jdouble)r {
  defined_ = ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast(M, [GeogebraCommonKernelGeosGeoElement class])))) isDefined] && ![((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(M)) isInfinite]);
  [self setSphereNDWithGeogebraCommonKernelMatrixCoords:[((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(M)) getInhomCoordsInD2] withDouble:r];
}

- (jboolean)isPath {
  return YES;
}

- (void)pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getCoordsInD2WithGeogebraCommonKernelMatrixCoordSys:[self getCoordSys]];
  GeogebraCommonKernelPathParameter *pp = [P getPathParameter];
  [self pointChangedWithGeogebraCommonKernelMatrixCoords:coords withGeogebraCommonKernelPathParameter:pp];
  [P setCoords2DWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] withDouble:[coords getY] withDouble:[coords getZ]];
  [P updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:[self getCoordSys]];
  [P updateCoords];
}

- (void)pointChangedWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                   withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp {
  [self pointChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp withBoolean:YES];
}

- (void)pointChangedWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                   withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp
                                             withBoolean:(jboolean)checkSection {
  jdouble px, py, ha, hb, hc_2;
  jdouble abspx, abspy;
  jdouble tolerance = GeogebraCommonKernelKernel_STANDARD_PRECISION;
  [((GeogebraCommonKernelPathParameter *) nil_chk(pp)) setPathTypeWithInt:type_];
  {
    jboolean firstLine;
    GeogebraCommonKernelGeosGeoLine *line;
    jdouble s;
    switch (type_) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY:
      [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setXWithDouble:JavaLangDouble_NaN];
      [P setYWithDouble:JavaLangDouble_NaN];
      [P setZWithDouble:JavaLangDouble_NaN];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
      [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setXWithDouble:((GeogebraCommonKernelGeosGeoPoint *) nil_chk(singlePoint__))->x_];
      [P setYWithDouble:singlePoint__->y_];
      [P setZWithDouble:singlePoint__->z_];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
      firstLine = ([((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) distanceHomWithGeogebraCommonKernelMatrixCoords:P] <= [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) distanceHomWithGeogebraCommonKernelMatrixCoords:P]);
      line = firstLine ? IOSObjectArray_Get(lines_, 0) : IOSObjectArray_Get(lines_, 1);
      [line doPointChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
      [pp setTWithDouble:GeogebraCommonKernelPathNormalizer_inverseInfFunctionWithDouble_([pp getT])];
      if (!firstLine) {
        [pp setTWithDouble:[pp getT] + 2];
      }
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
      GeogebraCommonKernelKernelNDGeoConicND_getLines(self);
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) doPointChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
      GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(self, P);
      px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX] / [P getZ];
      py = [P getY] / [P getZ];
      [pp setTWithDouble:JavaLangMath_atan2WithDouble_withDouble_(IOSDoubleArray_Get(nil_chk(halfAxes_), 0) * py, IOSDoubleArray_Get(halfAxes_, 1) * px)];
      [P setXWithDouble:IOSDoubleArray_Get(halfAxes_, 0) * JavaLangMath_cosWithDouble_([pp getT])];
      [P setYWithDouble:IOSDoubleArray_Get(halfAxes_, 1) * JavaLangMath_sinWithDouble_([pp getT])];
      [P setZWithDouble:1.0];
      GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
      GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(self, P);
      px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX] / [P getZ];
      py = [P getY] / [P getZ];
      abspx = JavaLangMath_absWithDouble_(px);
      abspy = JavaLangMath_absWithDouble_(py);
      ha = IOSDoubleArray_Get(nil_chk(halfAxes_), 0);
      hb = IOSDoubleArray_Get(halfAxes_, 1);
      hc_2 = ha * ha - hb * hb;
      if (abspx < GeogebraCommonKernelKernel_STANDARD_PRECISION) {
        if (abspy < GeogebraCommonKernelKernel_STANDARD_PRECISION) {
          if (hb < ha) {
            [pp setTWithDouble:JavaLangMath_PI / 2];
          }
          else {
            [pp setTWithDouble:0];
          }
        }
        else {
          if (hb < ha) {
            [pp setTWithDouble:JavaLangMath_PI / 2];
          }
          else {
            if (abspy * hb < hc_2) {
              [pp setTWithDouble:JavaLangMath_asinWithDouble_(hb * abspy / hc_2)];
            }
            else {
              [pp setTWithDouble:JavaLangMath_PI / 2];
            }
          }
        }
      }
      else if (abspy < GeogebraCommonKernelKernel_STANDARD_PRECISION) {
        if (ha < hb) {
          [pp setTWithDouble:0];
        }
        else {
          if (abspx * ha < hc_2) {
            [pp setTWithDouble:JavaLangMath_acosWithDouble_(ha * abspx / hc_2)];
          }
          else {
            [pp setTWithDouble:0];
          }
        }
      }
      else {
        IOSDoubleArray *roots = GeogebraCommonKernelKernelNDGeoConicND_getPerpendicularParamsWithDouble_withDouble_(self, abspx, abspy);
        if (IOSDoubleArray_Get(nil_chk(roots), 0) > 0) {
          [pp setTWithDouble:JavaLangMath_asinWithDouble_(IOSDoubleArray_Get(roots, 0))];
        }
        else if (IOSDoubleArray_Get(roots, 1) > 0) {
          [pp setTWithDouble:JavaLangMath_asinWithDouble_(IOSDoubleArray_Get(roots, 1))];
        }
        else if (IOSDoubleArray_Get(roots, 2) > 0) {
          [pp setTWithDouble:JavaLangMath_asinWithDouble_(IOSDoubleArray_Get(roots, 2))];
        }
        else {
          [pp setTWithDouble:JavaLangMath_asinWithDouble_(IOSDoubleArray_Get(roots, 3))];
        }
      }
      if (px < 0) {
        [pp setTWithDouble:JavaLangMath_PI - [pp getT]];
      }
      if (py < 0) {
        [pp setTWithDouble:-[pp getT]];
      }
      [P setXWithDouble:ha * JavaLangMath_cosWithDouble_([pp getT])];
      [P setYWithDouble:hb * JavaLangMath_sinWithDouble_([pp getT])];
      [P setZWithDouble:1.0];
      GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
      GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(self, P);
      px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX] / [P getZ];
      py = [P getY] / [P getZ];
      abspx = JavaLangMath_absWithDouble_(px);
      abspy = JavaLangMath_absWithDouble_(py);
      ha = IOSDoubleArray_Get(nil_chk(halfAxes_), 0);
      hb = IOSDoubleArray_Get(halfAxes_, 1);
      hc_2 = ha * ha + hb * hb;
      if (abspy < GeogebraCommonKernelKernel_STANDARD_PRECISION) {
        s = GeogebraCommonUtilMyMath_acoshWithDouble_(JavaLangMath_maxWithDouble_withDouble_(1, ha * abspx / hc_2));
      }
      else {
        IOSDoubleArray *roots = GeogebraCommonKernelKernelNDGeoConicND_getPerpendicularParamsWithDouble_withDouble_(self, abspx, abspy);
        if (IOSDoubleArray_Get(nil_chk(roots), 0) > 0) {
          s = GeogebraCommonUtilMyMath_asinhWithDouble_(IOSDoubleArray_Get(roots, 0));
        }
        else if (IOSDoubleArray_Get(roots, 1) > 0) {
          s = GeogebraCommonUtilMyMath_asinhWithDouble_(IOSDoubleArray_Get(roots, 1));
        }
        else if (IOSDoubleArray_Get(roots, 2) > 0) {
          s = GeogebraCommonUtilMyMath_asinhWithDouble_(IOSDoubleArray_Get(roots, 2));
        }
        else {
          s = GeogebraCommonUtilMyMath_asinhWithDouble_(IOSDoubleArray_Get(roots, 3));
        }
      }
      if (py < 0) {
        s = -s;
      }
      [pp setTWithDouble:GeogebraCommonKernelPathNormalizer_inverseInfFunctionWithDouble_(s)];
      [P setXWithDouble:ha * JavaLangMath_coshWithDouble_(s)];
      [P setYWithDouble:hb * JavaLangMath_sinhWithDouble_(s)];
      [P setZWithDouble:1.0];
      if (px < 0) {
        [pp setTWithDouble:[pp getT] + 2];
        [P setXWithDouble:-[P getX]];
      }
      GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
      GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(self, P);
      px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX] / [P getZ];
      py = [P getY] / [P getZ];
      abspy = JavaLangMath_absWithDouble_(py);
      if (abspy < tolerance) {
        [pp setTWithDouble:JavaLangMath_sqrtWithDouble_(JavaLangMath_maxWithDouble_withDouble_(0, 2 * (px - p_) / p_))];
      }
      else {
        IOSDoubleArray *eqn = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ abspy, -p_ + px, 0, -p_ / 2 } count:4];
        IOSDoubleArray *roots = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ 0, 0, 0 } count:3];
        [((GeogebraCommonKernelEquationSolver *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonKernelConstruction *) nil_chk(cons_)) getKernel])) getEquationSolver])) solveCubicWithDoubleArray:eqn withDoubleArray:roots withDouble:GeogebraCommonKernelKernel_STANDARD_PRECISION];
        if (IOSDoubleArray_Get(roots, 0) > 0) {
          [pp setTWithDouble:IOSDoubleArray_Get(roots, 0)];
        }
        else if (IOSDoubleArray_Get(roots, 1) > 0) {
          [pp setTWithDouble:IOSDoubleArray_Get(roots, 1)];
        }
        else {
          [pp setTWithDouble:IOSDoubleArray_Get(roots, 2)];
        }
        if (py < 0) {
          [pp setTWithDouble:-[pp getT]];
        }
      }
      [P setXWithDouble:p_ * [pp getT] * [pp getT] / 2.0];
      [P setYWithDouble:p_ * [pp getT]];
      [P setZWithDouble:1.0];
      GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
      break;
    }
  }
}

- (IOSDoubleArray *)getPerpendicularParamsWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(self, P);
  jdouble px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX] / [P getZ];
  jdouble py = [P getY] / [P getZ];
  jdouble abspx = JavaLangMath_absWithDouble_(px);
  jdouble abspy = JavaLangMath_absWithDouble_(py);
  return GeogebraCommonKernelKernelNDGeoConicND_getPerpendicularParamsWithDouble_withDouble_(self, abspx, abspy);
}

- (IOSDoubleArray *)getPerpendicularParamsWithDouble:(jdouble)abspx
                                          withDouble:(jdouble)abspy {
  return GeogebraCommonKernelKernelNDGeoConicND_getPerpendicularParamsWithDouble_withDouble_(self, abspx, abspy);
}

- (void)pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  if (![((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) usePathAndRegionParametersWithGeogebraCommonKernelKernelNDGeoPointND:P]) {
    [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
    return;
  }
  GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getCoordsInD2WithGeogebraCommonKernelMatrixCoordSys:[self getCoordSys]];
  GeogebraCommonKernelPathParameter *pp = [P getPathParameter];
  [self pathChangedWithGeogebraCommonKernelMatrixCoords:coords withGeogebraCommonKernelPathParameter:pp];
  [P setCoords2DWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] withDouble:[coords getY] withDouble:[coords getZ]];
  [P updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:[self getCoordSys]];
}

- (jboolean)compatibleTypeWithInt:(jint)t {
  return GeogebraCommonKernelKernelNDGeoConicND_compatibleTypeWithInt_(self, t);
}

- (void)pathChangedWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                  withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp {
  if (!GeogebraCommonKernelKernelNDGeoConicND_compatibleTypeWithInt_(self, [((GeogebraCommonKernelPathParameter *) nil_chk(pp)) getPathType]) || JavaLangDouble_isNaNWithDouble_([pp getT])) {
    [self pointChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
    return;
  }
  [self pathChangedWithoutCheckWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp withBoolean:YES];
}

- (void)pathChangedWithoutCheckEllipseWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                                     withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp
                                                               withBoolean:(jboolean)checkSection {
  [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setXWithDouble:IOSDoubleArray_Get(nil_chk(halfAxes_), 0) * JavaLangMath_cosWithDouble_([((GeogebraCommonKernelPathParameter *) nil_chk(pp)) getT])];
  [P setYWithDouble:IOSDoubleArray_Get(halfAxes_, 1) * JavaLangMath_sinWithDouble_([pp getT])];
  [P setZWithDouble:1.0];
  GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
}

- (void)pathChangedWithoutCheckParabolaWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                                      withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp
                                                                withBoolean:(jboolean)checkSection {
  [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setYWithDouble:p_ * [((GeogebraCommonKernelPathParameter *) nil_chk(pp)) getT]];
  [P setXWithDouble:[P getY] * [pp getT] / 2.0];
  [P setZWithDouble:1.0];
  GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
}

- (void)pathChangedWithoutCheckHyperbolaWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                                       withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp
                                                                 withBoolean:(jboolean)checkSection {
  jboolean leftBranch = [((GeogebraCommonKernelPathParameter *) nil_chk(pp)) getT] > 1;
  jdouble t = leftBranch ? [pp getT] - 2 : [pp getT];
  jdouble s = t / (1 - JavaLangMath_absWithDouble_(t));
  [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setXWithDouble:IOSDoubleArray_Get(nil_chk(halfAxes_), 0) * GeogebraCommonUtilMyMath_coshWithDouble_(s)];
  [P setYWithDouble:IOSDoubleArray_Get(halfAxes_, 1) * GeogebraCommonUtilMyMath_sinhWithDouble_(s)];
  [P setZWithDouble:1.0];
  if (leftBranch) [P setXWithDouble:-[P getX]];
  GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
}

- (void)pathChangedWithoutCheckWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                              withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp
                                                        withBoolean:(jboolean)checkSection {
  {
    jdouble pathParam;
    jboolean leftBranch;
    switch (type_) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY:
      [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setXWithDouble:JavaLangDouble_NaN];
      [P setYWithDouble:JavaLangDouble_NaN];
      [P setZWithDouble:JavaLangDouble_NaN];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
      [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setXWithDouble:((GeogebraCommonKernelGeosGeoPoint *) nil_chk(singlePoint__))->x_];
      [P setYWithDouble:singlePoint__->y_];
      [P setZWithDouble:singlePoint__->z_];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
      pathParam = [((GeogebraCommonKernelPathParameter *) nil_chk(pp)) getT];
      leftBranch = (pathParam > 1);
      [pp setTWithDouble:leftBranch ? pathParam - 2 : pathParam];
      [pp setTWithDouble:[pp getT] / (1 - JavaLangMath_absWithDouble_([pp getT]))];
      if (leftBranch) {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 1))) pathChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
      }
      else {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) pathChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
      }
      [pp setTWithDouble:pathParam];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) pathChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
      [self pathChangedWithoutCheckEllipseWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp withBoolean:checkSection];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
      [self pathChangedWithoutCheckHyperbolaWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp withBoolean:checkSection];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
      [self pathChangedWithoutCheckParabolaWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp withBoolean:checkSection];
      break;
    }
  }
}

- (jdouble)getMaxParameter {
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
    return JavaLangDouble_POSITIVE_INFINITY;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
    return JavaLangMath_PI;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
    return 3;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
    default:
    return 0;
  }
}

- (jdouble)getMinParameter {
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
    return JavaLangDouble_NEGATIVE_INFINITY;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
    return -1;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
    return -JavaLangMath_PI;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
    default:
    return 0;
  }
}

- (jboolean)isClosedPath {
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
    return YES;
    default:
    return NO;
  }
}

- (jboolean)isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P
                                                    withDouble:(jdouble)eps {
  if ([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getPath] == self) return YES;
  return GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND_withDouble_(self, P, eps);
}

- (jboolean)isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P
                                                         withDouble:(jdouble)eps {
  return GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND_withDouble_(self, P, eps);
}

- (jboolean)isOnFullConicWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                                                   withDouble:(jdouble)eps {
  return GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelMatrixCoords_withDouble_(self, P, eps);
}

- (id<GeogebraCommonKernelPathMover>)createPathMover {
  return [new_GeogebraCommonKernelPathMoverGeneric_initWithGeogebraCommonKernelPath_(self) autorelease];
}

- (void)coordsEVtoRWWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
}

- (void)coordsRWtoEVWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(self, P);
}

- (void)translateByCenterWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  GeogebraCommonKernelKernelNDGeoConicND_translateByCenterWithGeogebraCommonKernelMatrixCoords_(self, P);
}

- (jboolean)isFillable {
  return YES;
}

- (void)setMatrixWithGeogebraCommonKernelMatrixCoordMatrix:(GeogebraCommonKernelMatrixCoordMatrix *)m {
  *IOSDoubleArray_GetRef(nil_chk(matrix_), 0) = [((GeogebraCommonKernelMatrixCoordMatrix *) nil_chk(m)) getWithInt:1 withInt:1];
  *IOSDoubleArray_GetRef(matrix_, 1) = [m getWithInt:2 withInt:2];
  *IOSDoubleArray_GetRef(matrix_, 2) = [m getWithInt:3 withInt:3];
  *IOSDoubleArray_GetRef(matrix_, 3) = ([m getWithInt:1 withInt:2] + [m getWithInt:2 withInt:1]) / 2.0;
  *IOSDoubleArray_GetRef(matrix_, 4) = ([m getWithInt:1 withInt:3] + [m getWithInt:3 withInt:1]) / 2.0;
  *IOSDoubleArray_GetRef(matrix_, 5) = ([m getWithInt:2 withInt:3] + [m getWithInt:3 withInt:2]) / 2.0;
  [self classifyConic];
}

- (JavaUtilArrayList *)getPointsOnConic {
  return pointsOnConic_;
}

- (void)setPointsOnConicWithJavaUtilArrayList:(JavaUtilArrayList *)points {
  GeogebraCommonKernelKernelNDGeoConicND_set_pointsOnConic_(self, points);
}

- (void)addPointOnConicWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)pt {
  if (pointsOnConic_ == nil) GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_pointsOnConic_(self, new_JavaUtilArrayList_init());
  if (![((JavaUtilArrayList *) nil_chk(pointsOnConic_)) containsWithId:pt]) [pointsOnConic_ addWithId:pt];
}

- (void)removePointOnConicWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)pt {
  if (pointsOnConic_ != nil) [pointsOnConic_ removeWithId:pt];
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([geo isKindOfClass:[GeogebraCommonKernelGeosGeoLine class]]) {
    GeogebraCommonKernelGeosGeoLine *line = (GeogebraCommonKernelGeosGeoLine *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoLine class]);
    GeogebraCommonKernelKernelNDGeoConicND_setCoeffsWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_(self, 0, 0, 0, [((GeogebraCommonKernelGeosGeoLine *) nil_chk(line)) getX], [line getY], [line getZ]);
    return;
  }
  GeogebraCommonKernelKernelNDGeoConicND *co = (GeogebraCommonKernelKernelNDGeoConicND *) check_class_cast(geo, [GeogebraCommonKernelKernelNDGeoConicND class]);
  toStringMode_ = ((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(co))->toStringMode_;
  type_ = co->type_;
  for (jint i = 0; i < 6; i++) *IOSDoubleArray_GetRef(nil_chk(matrix_), i) = IOSDoubleArray_Get(co->matrix_, i);
  if (co->transform_ != nil) {
    id<GeogebraCommonAwtGAffineTransform> at = GeogebraCommonKernelKernelNDGeoConicND_getAffineTransform(self);
    [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(at)) setTransformWithGeogebraCommonAwtGAffineTransform:co->transform_];
  }
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) setCoordsWithGeogebraCommonKernelGeosGeoVec2D:IOSObjectArray_Get(co->eigenvec_, 0)];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) setCoordsWithGeogebraCommonKernelGeosGeoVec2D:IOSObjectArray_Get(co->eigenvec_, 1)];
  [self setMidpointWithDoubleArray:[((GeogebraCommonKernelMatrixCoords *) nil_chk([co getMidpoint])) get]];
  *IOSDoubleArray_GetRef(nil_chk(halfAxes_), 0) = IOSDoubleArray_Get(co->halfAxes_, 0);
  *IOSDoubleArray_GetRef(halfAxes_, 1) = IOSDoubleArray_Get(co->halfAxes_, 1);
  linearEccentricity_ = co->linearEccentricity_;
  eccentricity_ = co->eccentricity_;
  p_ = co->p_;
  *IOSDoubleArray_GetRef(nil_chk(mu_), 0) = IOSDoubleArray_Get(co->mu_, 0);
  *IOSDoubleArray_GetRef(mu_, 1) = IOSDoubleArray_Get(co->mu_, 1);
  GeogebraCommonKernelKernelNDGeoConicND_setLinesWithGeogebraCommonKernelKernelNDGeoConicND_(self, co);
  if (co->singlePoint__ != nil) {
    if (singlePoint__ == nil) GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_singlePoint__(self, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_));
    [singlePoint__ setCoordsWithGeogebraCommonKernelGeosGeoVec3D:co->singlePoint__];
  }
  if (co->startPoints_ != nil) {
    if (startPoints_ == nil) {
      GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_startPoints_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
      for (jint i = 0; i < 2; i++) {
        IOSObjectArray_SetAndConsume(startPoints_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_));
      }
    }
    for (jint i = 0; i < 2; i++) {
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(startPoints_, i))) setWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(co->startPoints_, i)];
    }
  }
  defined_ = co->defined_;
  [super setWithGeogebraCommonKernelGeosGeoElement:geo];
}

- (void)setLinesWithGeogebraCommonKernelKernelNDGeoConicND:(GeogebraCommonKernelKernelNDGeoConicND *)co {
  GeogebraCommonKernelKernelNDGeoConicND_setLinesWithGeogebraCommonKernelKernelNDGeoConicND_(self, co);
}

- (void)update {
  GeogebraCommonKernelKernelNDGeoConicND_makePathParametersInvalid(self);
  [super update];
}

- (void)setToStringModeWithInt:(jint)mode {
  GeogebraCommonKernelKernelNDGeoConicND_setToStringModeWithInt_(self, mode);
}

- (jint)getToStringMode {
  return toStringMode_;
}

- (jboolean)isCircle {
  return type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE;
}

- (void)setToSpecific {
  GeogebraCommonKernelKernelNDGeoConicND_setToStringModeWithInt_(self, GeogebraCommonKernelKernelNDGeoConicND_EQUATION_SPECIFIC);
}

- (void)setToImplicit {
  GeogebraCommonKernelKernelNDGeoConicND_setToStringModeWithInt_(self, GeogebraCommonKernelKernelNDGeoConicND_EQUATION_IMPLICIT);
}

- (void)setToExplicit {
  GeogebraCommonKernelKernelNDGeoConicND_setToStringModeWithInt_(self, GeogebraCommonKernelKernelNDGeoConicND_EQUATION_EXPLICIT);
}

- (jboolean)isSpecificPossible {
  return GeogebraCommonKernelKernelNDGeoConicND_isSpecificPossible(self);
}

- (jboolean)isExplicitPossible {
  return GeogebraCommonKernelKernelNDGeoConicND_isExplicitPossible(self);
}

- (jboolean)checkDefined {
  return GeogebraCommonKernelKernelNDGeoConicND_checkDefined(self);
}

- (jboolean)showInEuclidianView {
  return [self isDefined] && (type_ != GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY || [self isInverseFill]);
}

- (jboolean)showInAlgebraView {
  return YES;
}

- (jboolean)isLineConic {
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
    return YES;
    default:
    return NO;
  }
}

- (jboolean)isDegenerate {
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
    return NO;
    default:
    return YES;
  }
}

- (void)setCoeffsWithDoubleArray:(IOSDoubleArray *)coeffs {
  GeogebraCommonKernelKernelNDGeoConicND_setCoeffsWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_(self, IOSDoubleArray_Get(nil_chk(coeffs), 0), IOSDoubleArray_Get(coeffs, 1), IOSDoubleArray_Get(coeffs, 2), IOSDoubleArray_Get(coeffs, 3), IOSDoubleArray_Get(coeffs, 4), IOSDoubleArray_Get(coeffs, 5));
}

- (void)setCoeffsWithDouble:(jdouble)a
                 withDouble:(jdouble)b
                 withDouble:(jdouble)c
                 withDouble:(jdouble)d
                 withDouble:(jdouble)e
                 withDouble:(jdouble)f {
  GeogebraCommonKernelKernelNDGeoConicND_setCoeffsWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_(self, a, b, c, d, e, f);
}

- (NSString *)toValueStringMinimalWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [self getXMLtagsMinimal];
}

- (NSString *)toStringMinimalWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [self getXMLtagsMinimal];
}

- (NSString *)getXMLtagsMinimal {
  JavaLangStringBuffer *sb = [new_JavaLangStringBuffer_init() autorelease];
  for (jint i = 0; i < 5; i++) [sb appendWithNSString:JreStrcat("$C", [self regrFormatWithDouble:IOSDoubleArray_Get(nil_chk(matrix_), i)], ' ')];
  [sb appendWithNSString:[self regrFormatWithDouble:IOSDoubleArray_Get(nil_chk(matrix_), 5)]];
  return [sb description];
}

- (JavaLangStringBuilder *)buildValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [self buildValueStringWithGeogebraCommonKernelStringTemplate:tpl withDoubleArray:matrix_];
}

- (JavaLangStringBuilder *)buildValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                                  withDoubleArray:(IOSDoubleArray *)matrix1 {
  JavaLangStringBuilder *sbToValueString = [new_JavaLangStringBuilder_init() autorelease];
  if (![self isDefined]) {
    [sbToValueString appendWithNSString:@"?"];
    return sbToValueString;
  }
  *IOSDoubleArray_GetRef(nil_chk(coeffs_), 0) = IOSDoubleArray_Get(nil_chk(matrix1), 0);
  *IOSDoubleArray_GetRef(coeffs_, 2) = IOSDoubleArray_Get(matrix1, 1);
  *IOSDoubleArray_GetRef(coeffs_, 5) = IOSDoubleArray_Get(matrix1, 2);
  *IOSDoubleArray_GetRef(coeffs_, 1) = 2 * IOSDoubleArray_Get(matrix1, 3);
  *IOSDoubleArray_GetRef(coeffs_, 3) = 2 * IOSDoubleArray_Get(matrix1, 4);
  *IOSDoubleArray_GetRef(coeffs_, 4) = 2 * IOSDoubleArray_Get(matrix1, 5);
  if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
    JavaLangStringBuilder *sb = sbToValueString;
    [sb setLengthWithInt:0];
    NSString *x = [tpl printVariableNameWithNSString:@"x"];
    NSString *y = [tpl printVariableNameWithNSString:@"y"];
    [sb appendWithNSString:@"("];
    [sb appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatWithDouble:IOSDoubleArray_Get(coeffs_, 0) withGeogebraCommonKernelStringTemplate:tpl]];
    [sb appendWithNSString:@")*"];
    [sb appendWithNSString:x];
    [sb appendWithNSString:@"^2+("];
    [sb appendWithNSString:[kernel_ formatWithDouble:IOSDoubleArray_Get(coeffs_, 1) withGeogebraCommonKernelStringTemplate:tpl]];
    [sb appendWithNSString:@")*"];
    [sb appendWithNSString:x];
    [sb appendWithNSString:@"*"];
    [sb appendWithNSString:y];
    [sb appendWithNSString:@"+("];
    [sb appendWithNSString:[kernel_ formatWithDouble:IOSDoubleArray_Get(coeffs_, 2) withGeogebraCommonKernelStringTemplate:tpl]];
    [sb appendWithNSString:@")*"];
    [sb appendWithNSString:y];
    [sb appendWithNSString:@"^2+("];
    [sb appendWithNSString:[kernel_ formatWithDouble:IOSDoubleArray_Get(coeffs_, 3) withGeogebraCommonKernelStringTemplate:tpl]];
    [sb appendWithNSString:@")*"];
    [sb appendWithNSString:x];
    [sb appendWithNSString:@"+("];
    [sb appendWithNSString:[kernel_ formatWithDouble:IOSDoubleArray_Get(coeffs_, 4) withGeogebraCommonKernelStringTemplate:tpl]];
    [sb appendWithNSString:@")*"];
    [sb appendWithNSString:y];
    [sb appendWithNSString:@"="];
    [sb appendWithNSString:[kernel_ formatWithDouble:-IOSDoubleArray_Get(coeffs_, 5) withGeogebraCommonKernelStringTemplate:tpl]];
    return sb;
  }
  if (type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE) {
    [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) toStringLHSWithJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
    [sbToValueString appendWithNSString:@" = 0"];
    return sbToValueString;
  }
  NSString *squared;
  IOSObjectArray *myVars;
  switch ([[tpl getStringType] ordinal]) {
    case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_LATEX:
    squared = @"^{2}";
    myVars = GeogebraCommonKernelKernelNDGeoConicND_varsLateX_;
    break;
    case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
    squared = @"^2";
    myVars = GeogebraCommonKernelKernelNDGeoConicND_varsCAS_;
    break;
    default:
    squared = @"\u00b2";
    myVars = GeogebraCommonKernelKernelNDGeoConicND_vars_;
  }
  switch (toStringMode_) {
    case GeogebraCommonKernelKernelNDGeoConicND_EQUATION_SPECIFIC:
    if (!GeogebraCommonKernelKernelNDGeoConicND_isSpecificPossible(self)) return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) buildImplicitEquationWithDoubleArray:coeffs_ withNSStringArray:myVars withBoolean:GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ withBoolean:YES withBoolean:NO withChar:'=' withGeogebraCommonKernelStringTemplate:tpl];
    switch (type_) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
      [self buildSphereNDStringWithJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
      return sbToValueString;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
      if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(coeffs_, 1))) {
        jdouble coeff0, coeff1;
        if (GeogebraCommonKernelKernel_isZeroWithDouble_([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) getY])) {
          coeff0 = IOSDoubleArray_Get(nil_chk(halfAxes_), 0);
          coeff1 = IOSDoubleArray_Get(halfAxes_, 1);
        }
        else {
          coeff0 = IOSDoubleArray_Get(nil_chk(halfAxes_), 1);
          coeff1 = IOSDoubleArray_Get(halfAxes_, 0);
        }
        if (GeogebraCommonKernelKernel_isZeroWithDouble_([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX])) {
          [sbToValueString appendWithNSString:@"x"];
          [sbToValueString appendWithNSString:squared];
        }
        else {
          [sbToValueString appendWithNSString:@"(x "];
          [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatSignedWithDouble:-[b_ getX] withJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
          [sbToValueString appendWithNSString:@")"];
          [sbToValueString appendWithNSString:squared];
        }
        [sbToValueString appendWithNSString:@" / "];
        [sbToValueString appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatWithDouble:coeff0 * coeff0 withGeogebraCommonKernelStringTemplate:tpl]];
        [sbToValueString appendWithNSString:@" + "];
        if (GeogebraCommonKernelKernel_isZeroWithDouble_([b_ getY])) {
          [sbToValueString appendWithNSString:@"y"];
          [sbToValueString appendWithNSString:squared];
        }
        else {
          [sbToValueString appendWithNSString:@"(y "];
          [kernel_ formatSignedWithDouble:-[b_ getY] withJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
          [sbToValueString appendWithNSString:@")"];
          [sbToValueString appendWithNSString:squared];
        }
        [sbToValueString appendWithNSString:@" / "];
        [sbToValueString appendWithNSString:[kernel_ formatWithDouble:coeff1 * coeff1 withGeogebraCommonKernelStringTemplate:tpl]];
        [sbToValueString appendWithNSString:@" = 1"];
        return sbToValueString;
      }
      return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) buildImplicitEquationWithDoubleArray:coeffs_ withNSStringArray:myVars withBoolean:GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ withBoolean:YES withBoolean:NO withChar:'=' withGeogebraCommonKernelStringTemplate:tpl];
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
      if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(coeffs_, 1))) {
        jchar firstVar, secondVar;
        jdouble b1, b2;
        if (GeogebraCommonKernelKernel_isZeroWithDouble_([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) getY])) {
          firstVar = 'x';
          secondVar = 'y';
          b1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX];
          b2 = [b_ getY];
        }
        else {
          firstVar = 'y';
          secondVar = 'x';
          b1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getY];
          b2 = [b_ getX];
        }
        if (GeogebraCommonKernelKernel_isZeroWithDouble_(b1)) {
          [sbToValueString appendWithChar:firstVar];
          [sbToValueString appendWithNSString:squared];
        }
        else {
          [sbToValueString appendWithChar:'('];
          [sbToValueString appendWithChar:firstVar];
          [sbToValueString appendWithChar:' '];
          [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatSignedWithDouble:-b1 withJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
          [sbToValueString appendWithNSString:@")"];
          [sbToValueString appendWithNSString:squared];
        }
        [sbToValueString appendWithNSString:@" / "];
        [sbToValueString appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatWithDouble:IOSDoubleArray_Get(nil_chk(halfAxes_), 0) * IOSDoubleArray_Get(halfAxes_, 0) withGeogebraCommonKernelStringTemplate:tpl]];
        [sbToValueString appendWithNSString:@" - "];
        if (GeogebraCommonKernelKernel_isZeroWithDouble_(b2)) {
          [sbToValueString appendWithChar:secondVar];
          [sbToValueString appendWithNSString:squared];
        }
        else {
          [sbToValueString appendWithChar:'('];
          [sbToValueString appendWithChar:secondVar];
          [sbToValueString appendWithChar:' '];
          [kernel_ formatSignedWithDouble:-b2 withJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
          [sbToValueString appendWithNSString:@")"];
          [sbToValueString appendWithNSString:squared];
        }
        [sbToValueString appendWithNSString:@" / "];
        [sbToValueString appendWithNSString:[kernel_ formatWithDouble:IOSDoubleArray_Get(halfAxes_, 1) * IOSDoubleArray_Get(halfAxes_, 1) withGeogebraCommonKernelStringTemplate:tpl]];
        [sbToValueString appendWithNSString:@" = 1"];
        return sbToValueString;
      }
      return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) buildImplicitEquationWithDoubleArray:coeffs_ withNSStringArray:myVars withBoolean:GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ withBoolean:YES withBoolean:NO withChar:'=' withGeogebraCommonKernelStringTemplate:tpl];
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
      if (!GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(coeffs_, 2))) return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) buildExplicitConicEquationWithDoubleArray:coeffs_ withNSStringArray:myVars withInt:2 withBoolean:GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ withGeogebraCommonKernelStringTemplate:tpl];
      else if (!GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(coeffs_, 0))) return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) buildExplicitConicEquationWithDoubleArray:coeffs_ withNSStringArray:myVars withInt:0 withBoolean:GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ withGeogebraCommonKernelStringTemplate:tpl];
      else return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) buildImplicitEquationWithDoubleArray:coeffs_ withNSStringArray:myVars withBoolean:GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ withBoolean:YES withBoolean:NO withChar:'=' withGeogebraCommonKernelStringTemplate:tpl];
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
      [sbToValueString appendWithChar:'('];
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) toStringLHSWithJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
      [sbToValueString appendWithNSString:@")"];
      [sbToValueString appendWithNSString:squared];
      [sbToValueString appendWithNSString:@" = 0"];
      return sbToValueString;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
      [sbToValueString appendWithChar:'('];
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) toStringLHSWithJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
      [sbToValueString appendWithNSString:@") ("];
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) toStringLHSWithJavaLangStringBuilder:sbToValueString withGeogebraCommonKernelStringTemplate:tpl];
      [sbToValueString appendWithNSString:@") = 0"];
      return sbToValueString;
    }
    case GeogebraCommonKernelKernelNDGeoConicND_EQUATION_EXPLICIT:
    if (GeogebraCommonKernelKernelNDGeoConicND_isExplicitPossible(self)) return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) buildExplicitConicEquationWithDoubleArray:coeffs_ withNSStringArray:myVars withInt:4 withBoolean:GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ withGeogebraCommonKernelStringTemplate:tpl];
    default:
    return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) buildImplicitEquationWithDoubleArray:coeffs_ withNSStringArray:myVars withBoolean:GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_ withBoolean:YES withBoolean:NO withChar:'=' withGeogebraCommonKernelStringTemplate:tpl];
  }
}

- (IOSDoubleArray *)getHalfAxes {
  return halfAxes_;
}

- (IOSObjectArray *)getLines {
  return GeogebraCommonKernelKernelNDGeoConicND_getLines(self);
}

- (GeogebraCommonKernelGeosGeoPoint *)getSinglePoint {
  return singlePoint__;
}

- (id<GeogebraCommonAwtGAffineTransform>)getAffineTransform {
  return GeogebraCommonKernelKernelNDGeoConicND_getAffineTransform(self);
}

- (void)setAffineTransform {
  GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
}

- (GeogebraCommonKernelGeosGeoVec2D *)getTranslationVector {
  return b_;
}

- (jdouble)getCircleRadius {
  return [self getHalfAxisWithInt:0];
}

- (void)coordsEVtoRWWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)P {
  jdouble px = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P))->x_;
  P->x_ = px * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) getX] + P->y_ * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) getX];
  P->y_ = px * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) getY] + P->y_ * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) getY];
  P->x_ = P->x_ + P->z_ * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX];
  P->y_ = P->y_ + P->z_ * [b_ getY];
}

- (IOSDoubleArray *)getMatrix {
  IOSDoubleArray *ret = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ IOSDoubleArray_Get(nil_chk(matrix_), 0), IOSDoubleArray_Get(matrix_, 1), IOSDoubleArray_Get(matrix_, 2), IOSDoubleArray_Get(matrix_, 3), IOSDoubleArray_Get(matrix_, 4), IOSDoubleArray_Get(matrix_, 5) } count:6];
  return ret;
}

- (void)getMatrixWithDoubleArray:(IOSDoubleArray *)outArg {
  for (jint i = 0; i < 6; i++) {
    *IOSDoubleArray_GetRef(nil_chk(outArg), i) = IOSDoubleArray_Get(nil_chk(matrix_), i);
  }
}

- (void)setMatrixWithDoubleArray:(IOSDoubleArray *)matrix {
  for (jint i = 0; i < 6; i++) {
    *IOSDoubleArray_GetRef(nil_chk(self->matrix_), i) = IOSDoubleArray_Get(nil_chk(matrix), i);
  }
  [self classifyConic];
}

- (void)setDegenerateMatrixFromArrayWithDoubleArray:(IOSDoubleArray *)matrix {
  for (jint i = 0; i < 6; i++) {
    *IOSDoubleArray_GetRef(nil_chk(self->matrix_), i) = IOSDoubleArray_Get(nil_chk(matrix), i);
  }
  [self classifyConicWithBoolean:YES];
}

- (void)setMatrixWithDoubleArray2:(IOSObjectArray *)C {
  *IOSDoubleArray_GetRef(nil_chk(matrix_), 0) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(C), 0)), 0);
  *IOSDoubleArray_GetRef(matrix_, 1) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(C, 1)), 1);
  *IOSDoubleArray_GetRef(matrix_, 2) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(C, 2)), 2);
  *IOSDoubleArray_GetRef(matrix_, 3) = (IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(C, 0)), 1) + IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(C, 1)), 0)) / 2.0;
  *IOSDoubleArray_GetRef(matrix_, 4) = (IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(C, 0)), 2) + IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(C, 2)), 0)) / 2.0;
  *IOSDoubleArray_GetRef(matrix_, 5) = (IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(C, 1)), 2) + IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(C, 2)), 1)) / 2.0;
  [self classifyConic];
}

- (void)setCircleWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)M
                 withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)B
                 withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)C {
  defined_ = ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(M)) isDefined] && ![M isInfinite] && [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(B)) isDefined] && ![B isInfinite] && [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(C)) isDefined] && ![C isInfinite]);
  jdouble r = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(B)) distanceWithGeogebraCommonKernelGeosGeoPoint:C];
  if (GeogebraCommonKernelKernel_isZeroWithDouble_(r)) {
    r = 0;
  }
  else if (r < 0) {
    defined_ = NO;
  }
  if (defined_) {
    [self setCircleMatrixWithGeogebraCommonKernelGeosGeoPoint:M withDouble:r];
    GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
  }
}

- (void)setSphereNDWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)M
                 withGeogebraCommonKernelKernelNDGeoSegmentND:(id<GeogebraCommonKernelKernelNDGeoSegmentND>)segment {
  GeogebraCommonKernelKernelNDGeoConicND_setCircleWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoSegment_(self, (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(M, [GeogebraCommonKernelGeosGeoPoint class]), (GeogebraCommonKernelGeosGeoSegment *) check_class_cast(segment, [GeogebraCommonKernelGeosGeoSegment class]));
}

- (void)setCircleWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)M
               withGeogebraCommonKernelGeosGeoSegment:(GeogebraCommonKernelGeosGeoSegment *)geoSegment {
  GeogebraCommonKernelKernelNDGeoConicND_setCircleWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoSegment_(self, M, geoSegment);
}

- (void)setSphereNDWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)M
                   withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  GeogebraCommonKernelKernelNDGeoConicND_setCircleWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(self, (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(M, [GeogebraCommonKernelGeosGeoPoint class]), (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(P, [GeogebraCommonKernelGeosGeoPoint class]));
}

- (void)setCircleMatrixWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)M
                                                 withDouble:(jdouble)r {
  [self setSphereNDMatrixWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk(M)) getInhomCoordsInD2] withDouble:r];
}

- (void)setParabolaWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)F
                    withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)g {
  defined_ = ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(F)) isDefined] && ![F isInfinite] && [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g)) isDefined]);
  if (!defined_) return;
  jdouble fx = F->inhomX_;
  jdouble fy = F->inhomY_;
  *IOSDoubleArray_GetRef(nil_chk(matrix_), 0) = ((GeogebraCommonKernelGeosGeoLine *) nil_chk(g))->y_ * g->y_;
  *IOSDoubleArray_GetRef(matrix_, 1) = g->x_ * g->x_;
  jdouble lsq = IOSDoubleArray_Get(matrix_, 0) + IOSDoubleArray_Get(matrix_, 1);
  *IOSDoubleArray_GetRef(matrix_, 2) = lsq * (fx * fx + fy * fy) - g->z_ * g->z_;
  *IOSDoubleArray_GetRef(matrix_, 3) = -g->x_ * g->y_;
  *IOSDoubleArray_GetRef(matrix_, 4) = -(lsq * fx + g->x_ * g->z_);
  *IOSDoubleArray_GetRef(matrix_, 5) = -(lsq * fy + g->y_ * g->z_);
  [self classifyConic];
}

- (void)setParabolaWithDouble:(jdouble)y0 {
  *IOSDoubleArray_GetRef(nil_chk(matrix_), 0) = 1;
  *IOSDoubleArray_GetRef(matrix_, 1) = 0;
  *IOSDoubleArray_GetRef(matrix_, 2) = -y0 * y0;
  *IOSDoubleArray_GetRef(matrix_, 3) = 0;
  *IOSDoubleArray_GetRef(matrix_, 4) = 0;
  *IOSDoubleArray_GetRef(matrix_, 5) = y0;
  [self classifyConic];
}

- (void)setEllipseHyperbolaWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)B
                           withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)C
                                                     withDouble:(jdouble)a {
  if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(B)) isInfinite] || [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(C)) isInfinite] || a < -GeogebraCommonKernelKernel_STANDARD_PRECISION) {
    defined_ = NO;
    return;
  }
  else {
    defined_ = YES;
  }
  jdouble b1 = B->inhomX_;
  jdouble b2 = B->inhomY_;
  jdouble c1 = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(C))->inhomX_;
  jdouble c2 = C->inhomY_;
  jdouble diff1 = b1 - c1;
  jdouble diff2 = b2 - c2;
  jdouble sqsumb = b1 * b1 + b2 * b2;
  jdouble sqsumc = c1 * c1 + c2 * c2;
  jdouble sqsumdiff = sqsumb - sqsumc;
  jdouble a2 = 2.0 * a;
  jdouble asq4 = a2 * a2;
  jdouble asq = a * a;
  jdouble afo = asq * asq;
  *IOSDoubleArray_GetRef(nil_chk(matrix_), 0) = 4.0 * (a2 - diff1) * (a2 + diff1);
  *IOSDoubleArray_GetRef(matrix_, 3) = -4.0 * diff1 * diff2;
  *IOSDoubleArray_GetRef(matrix_, 1) = 4.0 * (a2 - diff2) * (a2 + diff2);
  *IOSDoubleArray_GetRef(matrix_, 4) = -2.0 * (asq4 * (b1 + c1) - diff1 * sqsumdiff);
  *IOSDoubleArray_GetRef(matrix_, 5) = -2.0 * (asq4 * (b2 + c2) - diff2 * sqsumdiff);
  *IOSDoubleArray_GetRef(matrix_, 2) = -16.0 * afo - sqsumdiff * sqsumdiff + 8.0 * asq * (sqsumb + sqsumc);
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) setXWithDouble:c1 - b1];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) setYWithDouble:c2 - b2];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) setXWithDouble:-[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) getY]];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) setYWithDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) getX]];
  [self classifyConic];
  if (!(type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA || type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE || type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE || type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE)) {
    defined_ = NO;
  }
}

- (void)translateWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)v {
  [self doTranslateWithGeogebraCommonKernelMatrixCoords:v];
  GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
  GeogebraCommonKernelKernelNDGeoConicND_updateDegenerates(self);
}

- (jboolean)isTranslateable {
  return YES;
}

- (void)translateWithDouble:(jdouble)vx
                 withDouble:(jdouble)vy {
  GeogebraCommonKernelKernelNDGeoConicND_doTranslateWithDouble_withDouble_(self, vx, vy);
  GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
  GeogebraCommonKernelKernelNDGeoConicND_updateDegenerates(self);
}

- (void)doTranslateWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)v {
  GeogebraCommonKernelKernelNDGeoConicND_doTranslateWithDouble_withDouble_(self, [((GeogebraCommonKernelMatrixCoords *) nil_chk(v)) getX], [v getY]);
}

- (void)doTranslateWithDouble:(jdouble)vx
                   withDouble:(jdouble)vy {
  GeogebraCommonKernelKernelNDGeoConicND_doTranslateWithDouble_withDouble_(self, vx, vy);
}

- (void)translateMatrixWithDoubleArray:(IOSDoubleArray *)mat
                            withDouble:(jdouble)vx
                            withDouble:(jdouble)vy {
  *IOSDoubleArray_GetRef(nil_chk(mat), 2) = IOSDoubleArray_Get(mat, 2) + vx * (IOSDoubleArray_Get(mat, 0) * vx - 2.0 * IOSDoubleArray_Get(mat, 4)) + vy * (IOSDoubleArray_Get(mat, 1) * vy - 2.0 * IOSDoubleArray_Get(mat, 5) + 2.0 * IOSDoubleArray_Get(mat, 3) * vx);
  *IOSDoubleArray_GetRef(mat, 4) = IOSDoubleArray_Get(mat, 4) - IOSDoubleArray_Get(mat, 0) * vx - IOSDoubleArray_Get(mat, 3) * vy;
  *IOSDoubleArray_GetRef(mat, 5) = IOSDoubleArray_Get(mat, 5) - IOSDoubleArray_Get(mat, 3) * vx - IOSDoubleArray_Get(mat, 1) * vy;
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phiVal {
  jdouble phi = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(phiVal)) getDouble];
  GeogebraCommonKernelKernelNDGeoConicND_rotateWithDouble_(self, phi);
  GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
  GeogebraCommonKernelKernelNDGeoConicND_updateDegenerates(self);
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phiVal
                 withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)point {
  GeogebraCommonKernelMatrixCoords *Q = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(point)) getInhomCoords];
  jdouble phi = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(phiVal)) getDouble];
  jdouble qx = [((GeogebraCommonKernelMatrixCoords *) nil_chk(Q)) getX];
  jdouble qy = [Q getY];
  GeogebraCommonKernelKernelNDGeoConicND_doTranslateWithDouble_withDouble_(self, -qx, -qy);
  GeogebraCommonKernelKernelNDGeoConicND_rotateWithDouble_(self, phi);
  GeogebraCommonKernelKernelNDGeoConicND_doTranslateWithDouble_withDouble_(self, qx, qy);
  GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
  GeogebraCommonKernelKernelNDGeoConicND_updateDegenerates(self);
}

- (jboolean)isMatrixTransformable {
  return YES;
}

- (void)matrixTransformWithDouble:(jdouble)a00
                       withDouble:(jdouble)a01
                       withDouble:(jdouble)a10
                       withDouble:(jdouble)a11 {
  jdouble det = a00 * a11 - a01 * a10;
  jdouble det2 = det * det;
  jdouble A0 = a11 * (a11 * IOSDoubleArray_Get(nil_chk(matrix_), 0) - a10 * IOSDoubleArray_Get(matrix_, 3)) - a10 * (a11 * IOSDoubleArray_Get(matrix_, 3) - a10 * IOSDoubleArray_Get(matrix_, 1));
  jdouble A3 = a00 * (a11 * IOSDoubleArray_Get(matrix_, 3) - a10 * IOSDoubleArray_Get(matrix_, 1)) - a01 * (a11 * IOSDoubleArray_Get(matrix_, 0) - a10 * IOSDoubleArray_Get(matrix_, 3));
  jdouble A1 = a00 * (a00 * IOSDoubleArray_Get(matrix_, 1) - a01 * IOSDoubleArray_Get(matrix_, 3)) - a01 * (a00 * IOSDoubleArray_Get(matrix_, 3) - a01 * IOSDoubleArray_Get(matrix_, 0));
  jdouble A4 = a11 * IOSDoubleArray_Get(matrix_, 4) - a10 * IOSDoubleArray_Get(matrix_, 5);
  *IOSDoubleArray_GetRef(matrix_, 5) = (a00 * IOSDoubleArray_Get(matrix_, 5) - a01 * IOSDoubleArray_Get(matrix_, 4)) / det;
  *IOSDoubleArray_GetRef(matrix_, 0) = A0 / det2;
  *IOSDoubleArray_GetRef(matrix_, 1) = A1 / det2;
  *IOSDoubleArray_GetRef(matrix_, 3) = A3 / det2;
  *IOSDoubleArray_GetRef(matrix_, 4) = A4 / det;
  [self classifyConic];
}

- (void)rotateWithDouble:(jdouble)phi {
  GeogebraCommonKernelKernelNDGeoConicND_rotateWithDouble_(self, phi);
}

+ (void)rotateMatrixWithDoubleArray:(IOSDoubleArray *)matrix
                         withDouble:(jdouble)phi {
  GeogebraCommonKernelKernelNDGeoConicND_rotateMatrixWithDoubleArray_withDouble_(matrix, phi);
}

- (void)dilateWithDouble:(jdouble)r {
  jboolean oldOrientation = GeogebraCommonKernelKernelNDGeoConicND_hasPositiveEigenvectorOrientation(self);
  GeogebraCommonKernelKernelNDGeoConicND_doDilateWithDouble_(self, r);
  [self classifyConic];
  GeogebraCommonKernelKernelNDGeoConicND_setPositiveEigenvectorOrientationWithBoolean_(self, oldOrientation);
}

- (void)doDilateWithDouble:(jdouble)factor {
  GeogebraCommonKernelKernelNDGeoConicND_doDilateWithDouble_(self, factor);
}

- (void)updateDegenerates {
  GeogebraCommonKernelKernelNDGeoConicND_updateDegenerates(self);
}

- (void)setEigenvectorsWithDouble:(jdouble)x0
                       withDouble:(jdouble)y0
                       withDouble:(jdouble)z0
                       withDouble:(jdouble)x1
                       withDouble:(jdouble)y1
                       withDouble:(jdouble)z1 {
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) setXWithDouble:x0 / z0];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) setYWithDouble:y0 / z0];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) setXWithDouble:x1 / z1];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) setYWithDouble:y1 / z1];
  eigenvectorsSetOnLoad_ = YES;
}

- (void)setFirstEigenvectorWithDoubleArray:(IOSDoubleArray *)coords {
  eigenvecX_ = IOSDoubleArray_Get(nil_chk(coords), 0);
  eigenvecY_ = IOSDoubleArray_Get(coords, 1);
}

- (void)setEigenvectors {
  GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(self);
}

- (void)setParabolicEigenvectors {
  GeogebraCommonKernelKernelNDGeoConicND_setParabolicEigenvectors(self);
}

- (void)makePathParametersInvalid {
  GeogebraCommonKernelKernelNDGeoConicND_makePathParametersInvalid(self);
}

- (void)classifyConic {
  [self classifyConicWithBoolean:NO];
}

- (void)classifyConicWithBoolean:(jboolean)degenerate {
  defined_ = (degenerate || GeogebraCommonKernelKernelNDGeoConicND_checkDefined(self));
  if (!defined_) return;
  if (GeogebraCommonKernelKernelNDGeoConicND_isDetSzero(self)) {
    GeogebraCommonKernelKernelNDGeoConicND_classifyParabolicConicWithBoolean_(self, degenerate);
  }
  else {
    detS_ = IOSDoubleArray_Get(nil_chk(matrix_), 0) * IOSDoubleArray_Get(matrix_, 1) - IOSDoubleArray_Get(matrix_, 3) * IOSDoubleArray_Get(matrix_, 3);
    GeogebraCommonKernelKernelNDGeoConicND_classifyMidpointConicWithBoolean_(self, degenerate);
  }
  GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
}

- (jboolean)isDetSzero {
  return GeogebraCommonKernelKernelNDGeoConicND_isDetSzero(self);
}

- (void)classifyMidpointConicWithBoolean:(jboolean)degenerate {
  GeogebraCommonKernelKernelNDGeoConicND_classifyMidpointConicWithBoolean_(self, degenerate);
}

- (void)singlePoint {
  GeogebraCommonKernelKernelNDGeoConicND_singlePoint(self);
}

- (void)intersectingLinesWithDoubleArray:(IOSDoubleArray *)mu1 {
  GeogebraCommonKernelKernelNDGeoConicND_intersectingLinesWithDoubleArray_(self, mu1);
}

- (void)ellipseWithDoubleArray:(IOSDoubleArray *)mu1 {
  GeogebraCommonKernelKernelNDGeoConicND_ellipseWithDoubleArray_(self, mu1);
}

- (void)hyperbolaWithDoubleArray:(IOSDoubleArray *)mu1 {
  GeogebraCommonKernelKernelNDGeoConicND_hyperbolaWithDoubleArray_(self, mu1);
}

- (void)classifyParabolicConicWithBoolean:(jboolean)degenerate {
  GeogebraCommonKernelKernelNDGeoConicND_classifyParabolicConicWithBoolean_(self, degenerate);
}

- (void)doubleLine {
  GeogebraCommonKernelKernelNDGeoConicND_doubleLine(self);
}

- (void)enforceDoubleLine {
  defined_ = YES;
  GeogebraCommonKernelKernelNDGeoConicND_doubleLine(self);
}

- (void)handleSzero {
  GeogebraCommonKernelKernelNDGeoConicND_handleSzero(self);
}

- (void)parallelLinesWithDoubleArray:(IOSDoubleArray *)mu1 {
  GeogebraCommonKernelKernelNDGeoConicND_parallelLinesWithDoubleArray_(self, mu1);
}

- (void)setStartPointsForLines {
  GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForLines(self);
}

- (void)setStartPointsForDoubleLine {
  GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForDoubleLine(self);
}

- (void)parabola {
  GeogebraCommonKernelKernelNDGeoConicND_parabola(self);
}

+ (jdouble)detWithDoubleArray:(IOSDoubleArray *)matrix {
  return GeogebraCommonKernelKernelNDGeoConicND_detWithDoubleArray_(matrix);
}

- (jboolean)hasPositiveEigenvectorOrientation {
  return GeogebraCommonKernelKernelNDGeoConicND_hasPositiveEigenvectorOrientation(self);
}

- (void)setPositiveEigenvectorOrientationWithBoolean:(jboolean)flag {
  GeogebraCommonKernelKernelNDGeoConicND_setPositiveEigenvectorOrientationWithBoolean_(self, flag);
}

- (jboolean)isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)P
                                                                 withDouble:(jdouble)eps {
  return GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND_withDouble_(self, P, eps);
}

- (jboolean)isIntersectionPointIncidentWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                                                                 withDouble:(jdouble)eps {
  return GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelMatrixCoords_withDouble_(self, P, eps);
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoConic]) return NO;
  GeogebraCommonKernelKernelNDGeoConicND *conic = (GeogebraCommonKernelKernelNDGeoConicND *) check_class_cast(geo, [GeogebraCommonKernelKernelNDGeoConicND class]);
  IOSDoubleArray *B = conic->matrix_;
  jdouble lambda1 = 0.0;
  jboolean aZero, bZero, equal = YES;
  for (jint i = 0; i < 6; i++) {
    aZero = GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(nil_chk(matrix_), i));
    bZero = GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(nil_chk(B), i));
    if (aZero && !bZero) equal = NO;
    else if (bZero && !aZero) equal = NO;
    else if (!aZero && !bZero) {
      if (lambda1 == 0.0) lambda1 = IOSDoubleArray_Get(matrix_, i) / IOSDoubleArray_Get(B, i);
      else equal = GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(IOSDoubleArray_Get(matrix_, i), lambda1 * IOSDoubleArray_Get(B, i));
    }
    if (!equal) break;
  }
  return equal;
}

- (jdouble)evaluateWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)P {
  return ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P))->x_ * (IOSDoubleArray_Get(nil_chk(matrix_), 0) * P->x_ + IOSDoubleArray_Get(matrix_, 3) * P->y_ + IOSDoubleArray_Get(matrix_, 4) * P->z_) + P->y_ * (IOSDoubleArray_Get(matrix_, 3) * P->x_ + IOSDoubleArray_Get(matrix_, 1) * P->y_ + IOSDoubleArray_Get(matrix_, 5) * P->z_) + P->z_ * (IOSDoubleArray_Get(matrix_, 4) * P->x_ + IOSDoubleArray_Get(matrix_, 5) * P->y_ + IOSDoubleArray_Get(matrix_, 2) * P->z_);
}

- (jdouble)evaluateWithGeogebraCommonKernelGeosGeoVec2D:(GeogebraCommonKernelGeosGeoVec2D *)pt {
  return IOSDoubleArray_Get(nil_chk(matrix_), 2) + IOSDoubleArray_Get(matrix_, 4) * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(pt)) getX] + IOSDoubleArray_Get(matrix_, 5) * [pt getY] + [pt getY] * (IOSDoubleArray_Get(matrix_, 5) + IOSDoubleArray_Get(matrix_, 3) * [pt getX] + IOSDoubleArray_Get(matrix_, 1) * [pt getY]) + [pt getX] * (IOSDoubleArray_Get(matrix_, 4) + IOSDoubleArray_Get(matrix_, 0) * [pt getX] + IOSDoubleArray_Get(matrix_, 3) * [pt getY]);
}

- (jdouble)evaluateWithDouble:(jdouble)x
                   withDouble:(jdouble)y {
  return GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(self, x, y);
}

- (void)polarLineWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)P
                  withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)polar {
  if (![self isDefined]) {
    [((GeogebraCommonKernelGeosGeoLine *) nil_chk(polar)) setUndefined];
  }
  else {
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(polar))->x_ = IOSDoubleArray_Get(nil_chk(matrix_), 0) * ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P))->x_ + IOSDoubleArray_Get(matrix_, 3) * P->y_ + IOSDoubleArray_Get(matrix_, 4) * P->z_;
    polar->y_ = IOSDoubleArray_Get(matrix_, 3) * P->x_ + IOSDoubleArray_Get(matrix_, 1) * P->y_ + IOSDoubleArray_Get(matrix_, 5) * P->z_;
    polar->z_ = IOSDoubleArray_Get(matrix_, 4) * P->x_ + IOSDoubleArray_Get(matrix_, 5) * P->y_ + IOSDoubleArray_Get(matrix_, 2) * P->z_;
  }
}

- (void)polarPointWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)line
                 withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)polar {
  GeogebraCommonKernelKernelNDGeoConicND_polarPointWithDouble_withDouble_withDouble_withGeogebraCommonKernelGeosGeoPoint_(self, ((GeogebraCommonKernelGeosGeoLine *) nil_chk(line))->x_, line->y_, line->z_, polar);
}

- (void)polarPointWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)equation
                  withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)polar {
  GeogebraCommonKernelKernelNDGeoConicND_polarPointWithDouble_withDouble_withDouble_withGeogebraCommonKernelGeosGeoPoint_(self, [((GeogebraCommonKernelMatrixCoords *) nil_chk(equation)) getX], [equation getY], [equation getZ], polar);
}

- (void)polarPointWithDouble:(jdouble)x
                  withDouble:(jdouble)y
                  withDouble:(jdouble)z
withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)polar {
  GeogebraCommonKernelKernelNDGeoConicND_polarPointWithDouble_withDouble_withDouble_withGeogebraCommonKernelGeosGeoPoint_(self, x, y, z, polar);
}

- (void)polarLineWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)project
                  withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)polar {
  if (![self isDefined]) {
    [((GeogebraCommonKernelGeosGeoLine *) nil_chk(polar)) setUndefined];
  }
  else {
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(polar))->x_ = IOSDoubleArray_Get(nil_chk(matrix_), 0) * [((GeogebraCommonKernelMatrixCoords *) nil_chk(project)) getX] + IOSDoubleArray_Get(matrix_, 3) * [project getY] + IOSDoubleArray_Get(matrix_, 4) * [project getZ];
    polar->y_ = IOSDoubleArray_Get(matrix_, 3) * [project getX] + IOSDoubleArray_Get(matrix_, 1) * [project getY] + IOSDoubleArray_Get(matrix_, 5) * [project getZ];
    polar->z_ = IOSDoubleArray_Get(matrix_, 4) * [project getX] + IOSDoubleArray_Get(matrix_, 5) * [project getY] + IOSDoubleArray_Get(matrix_, 2) * [project getZ];
  }
}

- (void)diameterLineWithGeogebraCommonKernelGeosGeoVector:(GeogebraCommonKernelGeosGeoVector *)v
                      withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)diameter {
  GeogebraCommonKernelKernelNDGeoConicND_diameterLineWithDouble_withDouble_withGeogebraCommonKernelGeosGeoLine_(self, ((GeogebraCommonKernelGeosGeoVector *) nil_chk(v))->x_, v->y_, diameter);
}

- (void)diameterLineWithDouble:(jdouble)vx
                    withDouble:(jdouble)vy
withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)diameter {
  GeogebraCommonKernelKernelNDGeoConicND_diameterLineWithDouble_withDouble_withGeogebraCommonKernelGeosGeoLine_(self, vx, vy, diameter);
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [super getXMLtagsWithJavaLangStringBuilder:sb];
  [self getLineStyleXMLWithJavaLangStringBuilder:sb];
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\t<eigenvectors "];
  [sb appendWithNSString:JreStrcat("$DC", @" x0=\"", [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) getX], '"')];
  [sb appendWithNSString:JreStrcat("$DC", @" y0=\"", [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) getY], '"')];
  [sb appendWithNSString:@" z0=\"1.0\""];
  [sb appendWithNSString:JreStrcat("$DC", @" x1=\"", [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) getX], '"')];
  [sb appendWithNSString:JreStrcat("$DC", @" y1=\"", [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 1))) getY], '"')];
  [sb appendWithNSString:@" z1=\"1.0\""];
  [sb appendWithNSString:@"/>\n"];
  [sb appendWithNSString:@"\t<matrix"];
  for (jint i = 0; i < 6; i++) [sb appendWithNSString:JreStrcat("$I$DC", @" A", i, @"=\"", IOSDoubleArray_Get(nil_chk(matrix_), i), '"')];
  [sb appendWithNSString:@"/>\n"];
  switch (toStringMode_) {
    case GeogebraCommonKernelKernelNDGeoConicND_EQUATION_SPECIFIC:
    [sb appendWithNSString:@"\t<eqnStyle style=\"specific\"/>\n"];
    break;
    case GeogebraCommonKernelKernelNDGeoConicND_EQUATION_EXPLICIT:
    [sb appendWithNSString:@"\t<eqnStyle style=\"explicit\"/>\n"];
    break;
    default:
    [sb appendWithNSString:@"\t<eqnStyle style=\"implicit\"/>\n"];
  }
}

- (NSString *)getSpecificEquation {
  NSString *ret = nil;
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
    ret = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"CircleEquation"];
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
    ret = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"EllipseEquation"];
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
    ret = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"HyperbolaEquation"];
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
    ret = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"ParabolaEquation"];
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
    ret = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"DoubleLineEquation"];
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    ret = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"ConicLinesEquation"];
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
    ret = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"DoubleLineEquation"];
    break;
  }
  return ret;
}

- (jboolean)isNumberValue {
  return NO;
}

- (jboolean)isGeoConic {
  return YES;
}

- (void)setZero {
  GeogebraCommonKernelKernelNDGeoConicND_setCoeffsWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_(self, 1, 0, 1, 0, 0, 0);
}

- (void)setMidpointWithDoubleArray:(IOSDoubleArray *)coords {
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) setXWithDouble:IOSDoubleArray_Get(nil_chk(coords), 0)];
  [b_ setYWithDouble:IOSDoubleArray_Get(coords, 1)];
  [super setMidpointWithDouble:IOSDoubleArray_Get(coords, 0) withDouble:IOSDoubleArray_Get(coords, 1)];
}

- (void)setMidpointWithDouble:(jdouble)x
                   withDouble:(jdouble)y {
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) setXWithDouble:x];
  [b_ setYWithDouble:y];
  [super setMidpointWithDouble:x withDouble:y];
}

- (NSString *)getAssignmentOperator {
  return @": ";
}

- (jboolean)isRegion {
  return YES;
}

- (jboolean)isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(PI)) getCoordsInD2WithGeogebraCommonKernelMatrixCoordSys:[self getCoordSys]];
  return [self isInRegionWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] withDouble:[coords getY]];
}

- (jboolean)isInRegionWithDouble:(jdouble)x0
                      withDouble:(jdouble)y0 {
  return GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(self, x0, y0) * [self evaluateInSignificantPoint] >= 0;
}

- (jdouble)evaluateInSignificantPoint {
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    return GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(self, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX] + ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0)))->x_ + ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1)))->x_, [b_ getY] + ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 0)))->y_ + ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1)))->y_);
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
    return -GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(self, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX], [b_ getY]);
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
    return GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(self, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX] + p_ * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) getX], [b_ getY] + p_ * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) getY]);
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
    return GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(self, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX] + 1, [b_ getY]);
    default:
    return GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(self, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX], [b_ getY]);
  }
}

- (void)pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(PI)) updateCoords2D];
  GeogebraCommonKernelRegionParameters *rp = [PI getRegionParameters];
  if (![self isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:PI]) {
    [self moveBackToRegionWithGeogebraCommonKernelKernelNDGeoPointND:PI withGeogebraCommonKernelRegionParameters:rp];
  }
  else {
    GeogebraCommonKernelMatrixCoords *coords = [PI getCoordsInD2WithGeogebraCommonKernelMatrixCoordSys:[self getCoordSys]];
    [((GeogebraCommonKernelRegionParameters *) nil_chk(rp)) setIsOnPathWithBoolean:NO];
    GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(self, coords);
    if (type_ != GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA) {
      [rp setT1WithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] / IOSDoubleArray_Get(nil_chk(self->halfAxes_), 0)];
      [rp setT2WithDouble:[coords getY] / IOSDoubleArray_Get(self->halfAxes_, 1)];
    }
    else {
      [rp setT1WithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX]];
      [rp setT2WithDouble:[coords getY] / JavaLangMath_sqrtWithDouble_(self->p_)];
    }
    GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, coords);
  }
  [PI updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:nil];
}

- (void)moveBackToRegionWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)pi
                          withGeogebraCommonKernelRegionParameters:(GeogebraCommonKernelRegionParameters *)rp {
  [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:pi];
  [((GeogebraCommonKernelRegionParameters *) nil_chk(rp)) setIsOnPathWithBoolean:YES];
}

- (void)regionChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  if (![((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) usePathAndRegionParametersWithGeogebraCommonKernelKernelNDGeoPointND:PI]) {
    [self pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:PI];
    return;
  }
  GeogebraCommonKernelRegionParameters *rp = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(PI)) getRegionParameters];
  if ([((GeogebraCommonKernelRegionParameters *) nil_chk(rp)) isOnPath]) [self pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:PI];
  else {
    GeogebraCommonKernelMatrixCoords *P = [new_GeogebraCommonKernelMatrixCoords_initWithInt_(3) autorelease];
    if ([P isDefined]) {
      if (type_ != GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA) {
        [P setXWithDouble:[rp getT1] * IOSDoubleArray_Get(nil_chk(halfAxes_), 0)];
        [P setYWithDouble:[rp getT2] * IOSDoubleArray_Get(halfAxes_, 1)];
      }
      else {
        [P setXWithDouble:[rp getT1]];
        [P setYWithDouble:[rp getT2] * JavaLangMath_sqrtWithDouble_(self->p_)];
      }
      [P setZWithDouble:1.0];
      GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(self, P);
      [PI setCoords2DWithDouble:[P getX] withDouble:[P getY] withDouble:[P getZ]];
      [PI updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:[self getCoordSys]];
    }
    if (![self isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:PI]) {
      [self moveBackToRegionWithGeogebraCommonKernelKernelNDGeoPointND:PI withGeogebraCommonKernelRegionParameters:rp];
    }
  }
}

- (void)toGeoCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)curve {
  GeogebraCommonKernelArithmeticFunctionVariable *fv = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(kernel_, @"t") autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *evX = nil, *evY = nil;
  jdouble min = 0, max = 0;
  if (type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE) {
    evX = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv, GeogebraCommonPluginOperationEnum_get_COS(), nil) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, IOSDoubleArray_Get(nil_chk(halfAxes_), 0)) autorelease]) autorelease];
    evY = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv, GeogebraCommonPluginOperationEnum_get_SIN(), nil) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, IOSDoubleArray_Get(halfAxes_, 1)) autorelease]) autorelease];
    GeogebraCommonKernelArithmeticExpressionNode *rwX = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, evX, GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX]) autorelease]) autorelease];
    GeogebraCommonKernelArithmeticExpressionNode *rwY = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, evY, GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [b_ getY]) autorelease]) autorelease];
    [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(curve)) setFunctionXWithGeogebraCommonKernelArithmeticFunction:[new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(rwX, fv) autorelease]];
    [curve setFunctionYWithGeogebraCommonKernelArithmeticFunction:[new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(rwY, fv) autorelease]];
    [curve setIntervalWithDouble:0 withDouble:2 * JavaLangMath_PI];
    return;
  }
  if (type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE) {
    evX = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv, GeogebraCommonPluginOperationEnum_get_COS(), nil) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, -IOSDoubleArray_Get(nil_chk(halfAxes_), 0)) autorelease]) autorelease];
    evY = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv, GeogebraCommonPluginOperationEnum_get_SIN(), nil) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, IOSDoubleArray_Get(halfAxes_, 1)) autorelease]) autorelease];
    min = 0;
    max = 2 * JavaLangMath_PI;
  }
  else if (type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA) {
    evX = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv, GeogebraCommonPluginOperationEnum_get_COSH(), nil) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, IOSDoubleArray_Get(nil_chk(halfAxes_), 0)) autorelease]) autorelease];
    evY = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv, GeogebraCommonPluginOperationEnum_get_SINH(), nil) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, IOSDoubleArray_Get(halfAxes_, 1)) autorelease]) autorelease];
    min = -2 * JavaLangMath_PI;
    max = 2 * JavaLangMath_PI;
  }
  else if (type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA) {
    evY = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, JavaLangMath_sqrtWithDouble_(2 * p_)) autorelease]) autorelease];
    evX = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, fv, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), fv) autorelease];
    min = [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getXminForFunctions];
    max = [kernel_ getXmaxForFunctions];
  }
  else return;
  GeogebraCommonKernelArithmeticExpressionNode *rwX = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, evX, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(eigenvec_), 0))) getX]) autorelease]) autorelease], GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, evY, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) getY]) autorelease]) autorelease]) autorelease], GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(b_)) getX]) autorelease]) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *rwY = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, evX, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) getY]) autorelease]) autorelease], GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, evY, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, -[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(eigenvec_, 0))) getX]) autorelease]) autorelease]) autorelease], GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [b_ getY]) autorelease]) autorelease];
  [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(curve)) setFunctionXWithGeogebraCommonKernelArithmeticFunction:[new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(rwX, fv) autorelease]];
  [curve setFunctionYWithGeogebraCommonKernelArithmeticFunction:[new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(rwY, fv) autorelease]];
  [curve setIntervalWithDouble:min withDouble:max];
}

- (void)toGeoImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:(GeogebraCommonKernelImplicitGeoImplicitPoly *)implicitPoly {
  IOSObjectArray *coeff = [IOSDoubleArray arrayWithDimensions:2 lengths:(jint[]){ 3, 3 }];
  *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 0)), 0) = IOSDoubleArray_Get(nil_chk(matrix_), 2);
  *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 1)), 1) = 2 * IOSDoubleArray_Get(matrix_, 3);
  *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 2)), 2) = 0;
  *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 1)), 0) = 2 * IOSDoubleArray_Get(matrix_, 4);
  *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 0)), 1) = 2 * IOSDoubleArray_Get(matrix_, 5);
  *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 2)), 0) = IOSDoubleArray_Get(matrix_, 0);
  *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 0)), 2) = IOSDoubleArray_Get(matrix_, 1);
  *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 2)), 1) = *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(coeff, 1)), 2) = 0;
  [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(implicitPoly)) setCoeffWithDoubleArray2:coeff];
}

- (jboolean)keepsType {
  if ([self getParentAlgorithm] == nil) return YES;
  if ([[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoConicFivePoints class]]) return NO;
  if ([[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoEllipseHyperbolaFociPoint class]]) return NO;
  if ([[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoEllipseFociLength class]]) return NO;
  return YES;
}

- (jdouble)distanceWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)pt {
  jboolean tempLabeling = [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) isSuppressLabelsActive];
  [cons_ setSuppressLabelCreationWithBoolean:YES];
  GeogebraCommonKernelGeosGeoPoint *closestPoint = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_withNSString_withDouble_withDouble_withDouble_(cons_, nil, ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(pt))->x_, pt->y_, pt->z_) autorelease];
  [cons_ setSuppressLabelCreationWithBoolean:tempLabeling];
  [closestPoint setPathWithGeogebraCommonKernelPath:self];
  [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:closestPoint];
  [closestPoint updateCoords];
  return [pt distanceWithGeogebraCommonKernelGeosGeoPoint:closestPoint];
}

- (NSString *)getTypeString {
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
    return @"Circle";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
    return @"DoubleLine";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
    return @"Ellipse";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY:
    return @"EmptySet";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
    return @"Hyperbola";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    return @"IntersectingLines";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
    return @"Line";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
    return @"Parabola";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
    return @"ParallelLines";
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
    return @"Point";
    default:
    return @"Conic";
  }
}

- (void)calcArea {
  switch (type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
    area_ = [self getHalfAxisWithInt:0] * [self getHalfAxisWithInt:0] * JavaLangMath_PI;
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
    area_ = 0;
    break;
    default:
    GeogebraCommonMainApp_printStacktraceWithId_(JreStrcat("$IC", @"TODO (type=", type_, ')'));
  }
}

- (jdouble)getArea {
  if (defined_) return area_;
  GeogebraCommonMainApp_printStacktraceWithId_(JreStrcat("$IC", @"TODO ? (type=", type_, ')'));
  return JavaLangDouble_NaN;
}

- (void)setIsEndOfQuadricWithBoolean:(jboolean)flag {
  isEndOfQuadric__ = flag;
}

- (jboolean)isEndOfQuadric {
  return isEndOfQuadric__;
}

- (void)doRemove {
  if (pointsOnConic_ != nil) {
    for (jint i = 0; i < [pointsOnConic_ size]; ++i) {
      id<GeogebraCommonKernelKernelNDGeoPointND> pt = [pointsOnConic_ getWithInt:i];
      [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(pt)) removeIncidenceWithGeogebraCommonKernelGeosGeoElement:self];
    }
  }
  [super doRemove];
}

- (void)setLastHitTypeWithGeogebraCommonKernelGeosGeoElement_HitTypeEnum:(GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)type {
  GeogebraCommonKernelKernelNDGeoConicND_set_lastHitType_(self, type);
}

- (GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)getLastHitType {
  return lastHitType_;
}

- (NSString *)getTypeStringForAlgebraView {
  return @"Conic";
}

- (GeogebraCommonKernelMatrixCoords *)getLabelPosition {
  if (labelPosition_ == nil) {
    GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_labelPosition_(self, new_GeogebraCommonKernelMatrixCoords_initWithDouble_withDouble_withDouble_(0, 0, 1));
    GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_labelParameter_(self, new_GeogebraCommonKernelPathParameter_initWithDouble_(0));
  }
  [self pathChangedWithoutCheckWithGeogebraCommonKernelMatrixCoords:labelPosition_ withGeogebraCommonKernelPathParameter:labelParameter_ withBoolean:YES];
  return [((GeogebraCommonKernelMatrixCoordSys *) nil_chk([self getCoordSys])) getPointWithGeogebraCommonKernelMatrixCoords:labelPosition_];
}

- (IOSObjectArray *)getNormalProjectionWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)coords {
  return [((GeogebraCommonKernelMatrixCoordSys *) nil_chk([self getCoordSys])) getNormalProjectionWithGeogebraCommonKernelMatrixCoords:coords];
}

- (GeogebraCommonKernelMatrixCoords *)getPointWithDouble:(jdouble)x2d
                                              withDouble:(jdouble)y2d {
  return [((GeogebraCommonKernelMatrixCoordSys *) nil_chk([self getCoordSys])) getPointWithDouble:x2d withDouble:y2d];
}

- (IOSObjectArray *)getProjectionWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)oldCoords
                                 withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)willingCoords
                                 withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)willingDirection {
  IOSObjectArray *result = [IOSObjectArray arrayWithObjects:(id[]){ [new_GeogebraCommonKernelMatrixCoords_initWithInt_(4) autorelease], [new_GeogebraCommonKernelMatrixCoords_initWithInt_(4) autorelease] } count:2 type:GeogebraCommonKernelMatrixCoords_class_()];
  [((GeogebraCommonKernelMatrixCoords *) nil_chk(willingCoords)) projectPlaneThruVIfPossibleWithGeogebraCommonKernelMatrixCoordMatrix:[((GeogebraCommonKernelMatrixCoordSys *) nil_chk([self getCoordSys])) getMatrixOrthonormal] withGeogebraCommonKernelMatrixCoords:oldCoords withGeogebraCommonKernelMatrixCoords:willingDirection withGeogebraCommonKernelMatrixCoords:IOSObjectArray_Get(result, 0) withGeogebraCommonKernelMatrixCoords:IOSObjectArray_Get(result, 1)];
  return result;
}

- (jint)getMetasLength {
  if (metas_ == nil) {
    return 0;
  }
  return [((JavaUtilTreeSet *) nil_chk(metas_)) size];
}

- (IOSObjectArray *)getMetas {
  IOSObjectArray *ret = [IOSObjectArray arrayWithLength:[((JavaUtilTreeSet *) nil_chk(metas_)) size] type:GeogebraCommonKernelGeosGeoElement_class_()];
  [metas_ toArrayWithNSObjectArray:ret];
  return ret;
}

- (void)addMetaWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)limitedQuadric {
  if (metas_ == nil) {
    GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_metas_(self, new_JavaUtilTreeSet_init());
  }
  [((JavaUtilTreeSet *) nil_chk(metas_)) addWithId:limitedQuadric];
}

- (void)removeMetaWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)limitedQuadric {
  if (metas_ != nil) {
    [metas_ removeWithId:limitedQuadric];
  }
}

- (GeogebraCommonKernelMatrixCoords *)getMidpointND {
  return [self getMidpoint2D];
}

- (void)dealloc {
  RELEASE_(singlePoint__);
  RELEASE_(lines_);
  RELEASE_(eigenvec_);
  RELEASE_(transform_);
  RELEASE_(oldTransform_);
  RELEASE_(b_);
  RELEASE_(startPoints_);
  RELEASE_(pointsOnConic_);
  RELEASE_(c_);
  RELEASE_(coeffs_);
  RELEASE_(polarMatrix_);
  RELEASE_(lastHitType_);
  RELEASE_(labelPosition_);
  RELEASE_(labelParameter_);
  RELEASE_(metas_);
  [super dealloc];
}

+ (void)initialize {
  if (self == [GeogebraCommonKernelKernelNDGeoConicND class]) {
    JreStrongAssignAndConsume(&GeogebraCommonKernelKernelNDGeoConicND_vars_, nil, [IOSObjectArray newArrayWithObjects:(id[]){ @"x\u00b2", @"x y", @"y\u00b2", @"x", @"y" } count:5 type:NSString_class_()]);
    JreStrongAssignAndConsume(&GeogebraCommonKernelKernelNDGeoConicND_varsLateX_, nil, [IOSObjectArray newArrayWithObjects:(id[]){ @"x^{2}", @"x y", @"y^{2}", @"x", @"y" } count:5 type:NSString_class_()]);
    JreStrongAssignAndConsume(&GeogebraCommonKernelKernelNDGeoConicND_varsCAS_, nil, [IOSObjectArray newArrayWithObjects:(id[]){ @"x^2", @"x*y", @"y^2", @"x", @"y" } count:5 type:NSString_class_()]);
    J2OBJC_SET_INITIALIZED(GeogebraCommonKernelKernelNDGeoConicND)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getEigenvecWithInt:", "getEigenvec", "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getEigenvec3DWithInt:", "getEigenvec3D", "Lgeogebra.common.kernel.Matrix.Coords;", 0x401, NULL, NULL },
    { "getCoordSys", NULL, "Lgeogebra.common.kernel.Matrix.CoordSys;", 0x401, NULL, NULL },
    { "getDirection3DWithInt:", "getDirection3D", "Lgeogebra.common.kernel.Matrix.Coords;", 0x401, NULL, NULL },
    { "getOrigin3DWithInt:", "getOrigin3D", "Lgeogebra.common.kernel.Matrix.Coords;", 0x401, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withInt:", "GeoConicND", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withInt:withBoolean:", "GeoConicND", NULL, 0x1, NULL, NULL },
    { "getSymetricMatrixWithDoubleArray:", "getSymetricMatrix", "Lgeogebra.common.kernel.Matrix.CoordMatrix;", 0x4, NULL, NULL },
    { "setCircleWithGeogebraCommonKernelGeosGeoPoint:withDouble:", "setCircle", "V", 0x11, NULL, NULL },
    { "setCircleWithGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoPoint:", "setCircle", "V", 0x11, NULL, NULL },
    { "setSphereNDWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "setSphereND", "V", 0x1, NULL, NULL },
    { "isPath", NULL, "Z", 0x1, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChanged", "V", 0x1, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:", "pointChanged", "V", 0x1, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:withBoolean:", "pointChanged", "V", 0x1, NULL, NULL },
    { "getPerpendicularParamsWithGeogebraCommonKernelMatrixCoords:", "getPerpendicularParams", "[D", 0x1, NULL, NULL },
    { "getPerpendicularParamsWithDouble:withDouble:", "getPerpendicularParams", "[D", 0x2, NULL, NULL },
    { "pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pathChanged", "V", 0x1, NULL, NULL },
    { "compatibleTypeWithInt:", "compatibleType", "Z", 0x2, NULL, NULL },
    { "pathChangedWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:", "pathChanged", "V", 0x4, NULL, NULL },
    { "pathChangedWithoutCheckEllipseWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:withBoolean:", "pathChangedWithoutCheckEllipse", "V", 0x4, NULL, NULL },
    { "pathChangedWithoutCheckParabolaWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:withBoolean:", "pathChangedWithoutCheckParabola", "V", 0x4, NULL, NULL },
    { "pathChangedWithoutCheckHyperbolaWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:withBoolean:", "pathChangedWithoutCheckHyperbola", "V", 0x4, NULL, NULL },
    { "pathChangedWithoutCheckWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:withBoolean:", "pathChangedWithoutCheck", "V", 0x1, NULL, NULL },
    { "getMaxParameter", NULL, "D", 0x1, NULL, NULL },
    { "getMinParameter", NULL, "D", 0x1, NULL, NULL },
    { "isClosedPath", NULL, "Z", 0x1, NULL, NULL },
    { "isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "isOnPath", "Z", 0x1, NULL, NULL },
    { "isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "isOnFullConic", "Z", 0x11, NULL, NULL },
    { "isOnFullConicWithGeogebraCommonKernelMatrixCoords:withDouble:", "isOnFullConic", "Z", 0x11, NULL, NULL },
    { "createPathMover", NULL, "Lgeogebra.common.kernel.PathMover;", 0x1, NULL, NULL },
    { "coordsEVtoRWWithGeogebraCommonKernelMatrixCoords:", "coordsEVtoRW", "V", 0x14, NULL, NULL },
    { "coordsRWtoEVWithGeogebraCommonKernelMatrixCoords:", "coordsRWtoEV", "V", 0x2, NULL, NULL },
    { "translateByCenterWithGeogebraCommonKernelMatrixCoords:", "translateByCenter", "V", 0x2, NULL, NULL },
    { "isFillable", NULL, "Z", 0x1, NULL, NULL },
    { "setMatrixWithGeogebraCommonKernelMatrixCoordMatrix:", "setMatrix", "V", 0x11, NULL, NULL },
    { "getPointsOnConic", NULL, "Ljava.util.ArrayList;", 0x11, NULL, NULL },
    { "setPointsOnConicWithJavaUtilArrayList:", "setPointsOnConic", "V", 0x11, NULL, NULL },
    { "addPointOnConicWithGeogebraCommonKernelKernelNDGeoPointND:", "addPointOnConic", "V", 0x11, NULL, NULL },
    { "removePointOnConicWithGeogebraCommonKernelKernelNDGeoPointND:", "removePointOnConic", "V", 0x11, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "setLinesWithGeogebraCommonKernelKernelNDGeoConicND:", "setLines", "V", 0x2, NULL, NULL },
    { "update", NULL, "V", 0x1, NULL, NULL },
    { "setToStringModeWithInt:", "setToStringMode", "V", 0x11, NULL, NULL },
    { "getToStringMode", NULL, "I", 0x11, NULL, NULL },
    { "isCircle", NULL, "Z", 0x1, NULL, NULL },
    { "setToSpecific", NULL, "V", 0x11, NULL, NULL },
    { "setToImplicit", NULL, "V", 0x11, NULL, NULL },
    { "setToExplicit", NULL, "V", 0x11, NULL, NULL },
    { "isSpecificPossible", NULL, "Z", 0x11, NULL, NULL },
    { "isExplicitPossible", NULL, "Z", 0x11, NULL, NULL },
    { "checkDefined", NULL, "Z", 0x12, NULL, NULL },
    { "showInEuclidianView", NULL, "Z", 0x14, NULL, NULL },
    { "showInAlgebraView", NULL, "Z", 0x11, NULL, NULL },
    { "isLineConic", NULL, "Z", 0x11, NULL, NULL },
    { "isDegenerate", NULL, "Z", 0x11, NULL, NULL },
    { "setCoeffsWithDoubleArray:", "setCoeffs", "V", 0x11, NULL, NULL },
    { "setCoeffsWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "setCoeffs", "V", 0x11, NULL, NULL },
    { "toValueStringMinimalWithGeogebraCommonKernelStringTemplate:", "toValueStringMinimal", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toStringMinimalWithGeogebraCommonKernelStringTemplate:", "toStringMinimal", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getXMLtagsMinimal", NULL, "Ljava.lang.String;", 0x4, NULL, NULL },
    { "buildValueStringWithGeogebraCommonKernelStringTemplate:", "buildValueString", "Ljava.lang.StringBuilder;", 0x4, NULL, NULL },
    { "buildValueStringWithGeogebraCommonKernelStringTemplate:withDoubleArray:", "buildValueString", "Ljava.lang.StringBuilder;", 0x4, NULL, NULL },
    { "getHalfAxes", NULL, "[D", 0x11, NULL, NULL },
    { "getLines", NULL, "[Lgeogebra.common.kernel.geos.GeoLine;", 0x11, NULL, NULL },
    { "getSinglePoint", NULL, "Lgeogebra.common.kernel.geos.GeoPoint;", 0x11, NULL, NULL },
    { "getAffineTransform", NULL, "Lgeogebra.common.awt.GAffineTransform;", 0x11, NULL, NULL },
    { "setAffineTransform", NULL, "V", 0x14, NULL, NULL },
    { "getTranslationVector", NULL, "Lgeogebra.common.kernel.geos.GeoVec2D;", 0x11, NULL, NULL },
    { "getCircleRadius", NULL, "D", 0x11, NULL, NULL },
    { "coordsEVtoRWWithGeogebraCommonKernelGeosGeoPoint:", "coordsEVtoRW", "V", 0x14, NULL, NULL },
    { "getMatrix", NULL, "[D", 0x11, NULL, NULL },
    { "getMatrixWithDoubleArray:", "getMatrix", "V", 0x11, NULL, NULL },
    { "setMatrixWithDoubleArray:", "setMatrix", "V", 0x11, NULL, NULL },
    { "setDegenerateMatrixFromArrayWithDoubleArray:", "setDegenerateMatrixFromArray", "V", 0x11, NULL, NULL },
    { "setMatrixWithDoubleArray2:", "setMatrix", "V", 0x11, NULL, NULL },
    { "setCircleWithGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoPoint:", "setCircle", "V", 0x11, NULL, NULL },
    { "setSphereNDWithGeogebraCommonKernelKernelNDGeoPointND:withGeogebraCommonKernelKernelNDGeoSegmentND:", "setSphereND", "V", 0x1, NULL, NULL },
    { "setCircleWithGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoSegment:", "setCircle", "V", 0x11, NULL, NULL },
    { "setSphereNDWithGeogebraCommonKernelKernelNDGeoPointND:withGeogebraCommonKernelKernelNDGeoPointND:", "setSphereND", "V", 0x1, NULL, NULL },
    { "setCircleMatrixWithGeogebraCommonKernelGeosGeoPoint:withDouble:", "setCircleMatrix", "V", 0x4, NULL, NULL },
    { "setParabolaWithGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoLine:", "setParabola", "V", 0x11, NULL, NULL },
    { "setParabolaWithDouble:", "setParabola", "V", 0x11, NULL, NULL },
    { "setEllipseHyperbolaWithGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoPoint:withDouble:", "setEllipseHyperbola", "V", 0x11, NULL, NULL },
    { "translateWithGeogebraCommonKernelMatrixCoords:", "translate", "V", 0x1, NULL, NULL },
    { "isTranslateable", NULL, "Z", 0x11, NULL, NULL },
    { "translateWithDouble:withDouble:", "translate", "V", 0x11, NULL, NULL },
    { "doTranslateWithGeogebraCommonKernelMatrixCoords:", "doTranslate", "V", 0x4, NULL, NULL },
    { "doTranslateWithDouble:withDouble:", "doTranslate", "V", 0x14, NULL, NULL },
    { "translateMatrixWithDoubleArray:withDouble:withDouble:", "translateMatrix", "V", 0x4, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:", "rotate", "V", 0x1, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelKernelNDGeoPointND:", "rotate", "V", 0x1, NULL, NULL },
    { "isMatrixTransformable", NULL, "Z", 0x1, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "rotateWithDouble:", "rotate", "V", 0x12, NULL, NULL },
    { "rotateMatrixWithDoubleArray:withDouble:", "rotateMatrix", "V", 0x1c, NULL, NULL },
    { "dilateWithDouble:", "dilate", "V", 0x14, NULL, NULL },
    { "doDilateWithDouble:", "doDilate", "V", 0x14, NULL, NULL },
    { "updateDegenerates", NULL, "V", 0x14, NULL, NULL },
    { "setEigenvectorsWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "setEigenvectors", "V", 0x11, NULL, NULL },
    { "setFirstEigenvectorWithDoubleArray:", "setFirstEigenvector", "V", 0x4, NULL, NULL },
    { "setEigenvectors", NULL, "V", 0x14, NULL, NULL },
    { "setParabolicEigenvectors", NULL, "V", 0x12, NULL, NULL },
    { "makePathParametersInvalid", NULL, "V", 0x2, NULL, NULL },
    { "classifyConic", NULL, "V", 0x4, NULL, NULL },
    { "classifyConicWithBoolean:", "classifyConic", "V", 0x1, NULL, NULL },
    { "isDetSzero", NULL, "Z", 0x2, NULL, NULL },
    { "classifyMidpointConicWithBoolean:", "classifyMidpointConic", "V", 0x12, NULL, NULL },
    { "singlePoint", NULL, "V", 0x14, NULL, NULL },
    { "intersectingLinesWithDoubleArray:", "intersectingLines", "V", 0x12, NULL, NULL },
    { "ellipseWithDoubleArray:", "ellipse", "V", 0x12, NULL, NULL },
    { "hyperbolaWithDoubleArray:", "hyperbola", "V", 0x12, NULL, NULL },
    { "classifyParabolicConicWithBoolean:", "classifyParabolicConic", "V", 0x12, NULL, NULL },
    { "doubleLine", NULL, "V", 0x12, NULL, NULL },
    { "enforceDoubleLine", NULL, "V", 0x11, NULL, NULL },
    { "handleSzero", NULL, "V", 0x12, NULL, NULL },
    { "parallelLinesWithDoubleArray:", "parallelLines", "V", 0x14, NULL, NULL },
    { "setStartPointsForLines", NULL, "V", 0x2, NULL, NULL },
    { "setStartPointsForDoubleLine", NULL, "V", 0x2, NULL, NULL },
    { "parabola", NULL, "V", 0x12, NULL, NULL },
    { "detWithDoubleArray:", "det", "D", 0x9, NULL, NULL },
    { "hasPositiveEigenvectorOrientation", NULL, "Z", 0x14, NULL, NULL },
    { "setPositiveEigenvectorOrientationWithBoolean:", "setPositiveEigenvectorOrientation", "V", 0x14, NULL, NULL },
    { "isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:withDouble:", "isIntersectionPointIncident", "Z", 0x1, NULL, NULL },
    { "isIntersectionPointIncidentWithGeogebraCommonKernelMatrixCoords:withDouble:", "isIntersectionPointIncident", "Z", 0x1, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x1, NULL, NULL },
    { "evaluateWithGeogebraCommonKernelGeosGeoPoint:", "evaluate", "D", 0x11, NULL, NULL },
    { "evaluateWithGeogebraCommonKernelGeosGeoVec2D:", "evaluate", "D", 0x11, NULL, NULL },
    { "evaluateWithDouble:withDouble:", "evaluate", "D", 0x11, NULL, NULL },
    { "polarLineWithGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoLine:", "polarLine", "V", 0x11, NULL, NULL },
    { "polarPointWithGeogebraCommonKernelGeosGeoLine:withGeogebraCommonKernelGeosGeoPoint:", "polarPoint", "V", 0x11, NULL, NULL },
    { "polarPointWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelGeosGeoPoint:", "polarPoint", "V", 0x11, NULL, NULL },
    { "polarPointWithDouble:withDouble:withDouble:withGeogebraCommonKernelGeosGeoPoint:", "polarPoint", "V", 0x11, NULL, NULL },
    { "polarLineWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelGeosGeoLine:", "polarLine", "V", 0x11, NULL, NULL },
    { "diameterLineWithGeogebraCommonKernelGeosGeoVector:withGeogebraCommonKernelGeosGeoLine:", "diameterLine", "V", 0x11, NULL, NULL },
    { "diameterLineWithDouble:withDouble:withGeogebraCommonKernelGeosGeoLine:", "diameterLine", "V", 0x11, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "getSpecificEquation", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "isNumberValue", NULL, "Z", 0x1, NULL, NULL },
    { "isGeoConic", NULL, "Z", 0x11, NULL, NULL },
    { "setZero", NULL, "V", 0x1, NULL, NULL },
    { "setMidpointWithDoubleArray:", "setMidpoint", "V", 0x4, NULL, NULL },
    { "setMidpointWithDouble:withDouble:", "setMidpoint", "V", 0x4, NULL, NULL },
    { "getAssignmentOperator", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "isRegion", NULL, "Z", 0x1, NULL, NULL },
    { "isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:", "isInRegion", "Z", 0x1, NULL, NULL },
    { "isInRegionWithDouble:withDouble:", "isInRegion", "Z", 0x1, NULL, NULL },
    { "evaluateInSignificantPoint", NULL, "D", 0x1, NULL, NULL },
    { "pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChangedForRegion", "V", 0x1, NULL, NULL },
    { "moveBackToRegionWithGeogebraCommonKernelKernelNDGeoPointND:withGeogebraCommonKernelRegionParameters:", "moveBackToRegion", "V", 0x4, NULL, NULL },
    { "regionChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "regionChanged", "V", 0x1, NULL, NULL },
    { "toGeoCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:", "toGeoCurveCartesian", "V", 0x1, NULL, NULL },
    { "toGeoImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:", "toGeoImplicitPoly", "V", 0x1, NULL, NULL },
    { "keepsType", NULL, "Z", 0x1, NULL, NULL },
    { "distanceWithGeogebraCommonKernelGeosGeoPoint:", "distance", "D", 0x1, NULL, NULL },
    { "getTypeString", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "calcArea", NULL, "V", 0x1, NULL, NULL },
    { "getArea", NULL, "D", 0x1, NULL, NULL },
    { "setIsEndOfQuadricWithBoolean:", "setIsEndOfQuadric", "V", 0x1, NULL, NULL },
    { "isEndOfQuadric", NULL, "Z", 0x1, NULL, NULL },
    { "doRemove", NULL, "V", 0x1, NULL, NULL },
    { "setLastHitTypeWithGeogebraCommonKernelGeosGeoElement_HitTypeEnum:", "setLastHitType", "V", 0x11, NULL, NULL },
    { "getLastHitType", NULL, "Lgeogebra.common.kernel.geos.GeoElement$HitType;", 0x11, NULL, NULL },
    { "getTypeStringForAlgebraView", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getLabelPosition", NULL, "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getNormalProjectionWithGeogebraCommonKernelMatrixCoords:", "getNormalProjection", "[Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getPointWithDouble:withDouble:", "getPoint", "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getProjectionWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelMatrixCoords:", "getProjection", "[Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getMetasLength", NULL, "I", 0x1, NULL, NULL },
    { "getMetas", NULL, "[Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "addMetaWithGeogebraCommonKernelGeosGeoElement:", "addMeta", "V", 0x1, NULL, NULL },
    { "removeMetaWithGeogebraCommonKernelGeosGeoElement:", "removeMeta", "V", 0x1, NULL, NULL },
    { "getMidpointND", NULL, "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "MAX_COEFFICIENT_SIZE_", NULL, 0x1c, "D", NULL, NULL, .constantValue.asDouble = GeogebraCommonKernelKernelNDGeoConicND_MAX_COEFFICIENT_SIZE },
    { "MIN_COEFFICIENT_SIZE_", NULL, 0x1c, "D", NULL, NULL, .constantValue.asDouble = GeogebraCommonKernelKernelNDGeoConicND_MIN_COEFFICIENT_SIZE },
    { "EQUATION_IMPLICIT_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelKernelNDGeoConicND_EQUATION_IMPLICIT },
    { "EQUATION_EXPLICIT_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelKernelNDGeoConicND_EQUATION_EXPLICIT },
    { "EQUATION_SPECIFIC_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelKernelNDGeoConicND_EQUATION_SPECIFIC },
    { "vars_", NULL, 0xc, "[Ljava.lang.String;", &GeogebraCommonKernelKernelNDGeoConicND_vars_, NULL,  },
    { "varsLateX_", NULL, 0xc, "[Ljava.lang.String;", &GeogebraCommonKernelKernelNDGeoConicND_varsLateX_, NULL,  },
    { "varsCAS_", NULL, 0xc, "[Ljava.lang.String;", &GeogebraCommonKernelKernelNDGeoConicND_varsCAS_, NULL,  },
    { "KEEP_LEADING_SIGN_", NULL, 0xc, "Z", &GeogebraCommonKernelKernelNDGeoConicND_KEEP_LEADING_SIGN_, NULL,  },
    { "singlePoint__", "singlePoint", 0x4, "Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "lines_", NULL, 0x1, "[Lgeogebra.common.kernel.geos.GeoLine;", NULL, NULL,  },
    { "eigenvec_", NULL, 0x1, "[Lgeogebra.common.kernel.geos.GeoVec2D;", NULL, NULL,  },
    { "eigenvecX_", NULL, 0x4, "D", NULL, NULL,  },
    { "eigenvecY_", NULL, 0x4, "D", NULL, NULL,  },
    { "transform_", NULL, 0x4, "Lgeogebra.common.awt.GAffineTransform;", NULL, NULL,  },
    { "oldTransform_", NULL, 0x4, "Lgeogebra.common.awt.GAffineTransform;", NULL, NULL,  },
    { "b_", NULL, 0x1, "Lgeogebra.common.kernel.geos.GeoVec2D;", NULL, NULL,  },
    { "startPoints_", NULL, 0x4, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "pointsOnConic_", NULL, 0x4, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/kernelND/GeoPointND;>;",  },
    { "detS_", NULL, 0x82, "D", NULL, NULL,  },
    { "length_", NULL, 0x82, "D", NULL, NULL,  },
    { "temp_", NULL, 0x82, "D", NULL, NULL,  },
    { "temp1_", NULL, 0x82, "D", NULL, NULL,  },
    { "temp2_", NULL, 0x82, "D", NULL, NULL,  },
    { "nx_", NULL, 0x82, "D", NULL, NULL,  },
    { "ny_", NULL, 0x82, "D", NULL, NULL,  },
    { "lambda_", NULL, 0x82, "D", NULL, NULL,  },
    { "index_", NULL, 0x2, "I", NULL, NULL,  },
    { "c_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoVec2D;", NULL, NULL,  },
    { "errDetS_", NULL, 0x1, "D", NULL, NULL,  },
    { "coeffs_", NULL, 0x2, "[D", NULL, NULL,  },
    { "eigenvectorsSetOnLoad_", NULL, 0x2, "Z", NULL, NULL,  },
    { "polarMatrix_", NULL, 0x2, "Lgeogebra.common.util.GgbMat;", NULL, NULL,  },
    { "area_", NULL, 0x2, "D", NULL, NULL,  },
    { "isEndOfQuadric__", "isEndOfQuadric", 0x2, "Z", NULL, NULL,  },
    { "lastHitType_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoElement$HitType;", NULL, NULL,  },
    { "labelPosition_", NULL, 0x2, "Lgeogebra.common.kernel.Matrix.Coords;", NULL, NULL,  },
    { "labelParameter_", NULL, 0x2, "Lgeogebra.common.kernel.PathParameter;", NULL, NULL,  },
    { "metas_", NULL, 0x2, "Ljava.util.TreeSet;", NULL, "Ljava/util/TreeSet<Lgeogebra/common/kernel/geos/GeoElement;>;",  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelKernelNDGeoConicND = { 2, "GeoConicND", "geogebra.common.kernel.kernelND", NULL, 0x401, 173, methods, 39, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelKernelNDGeoConicND;
}

@end

void GeogebraCommonKernelKernelNDGeoConicND_initWithGeogebraCommonKernelConstruction_withInt_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelConstruction *c, jint dimension) {
  GeogebraCommonKernelKernelNDGeoConicND_initWithGeogebraCommonKernelConstruction_withInt_withBoolean_(self, c, dimension, NO);
}

void GeogebraCommonKernelKernelNDGeoConicND_initWithGeogebraCommonKernelConstruction_withInt_withBoolean_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelConstruction *c, jint dimension, jboolean isIntersection) {
  GeogebraCommonKernelKernelNDGeoQuadricND_initWithGeogebraCommonKernelConstruction_withInt_withBoolean_(self, c, dimension, isIntersection);
  GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_eigenvec_(self, [IOSObjectArray newArrayWithObjects:(id[]){ [new_GeogebraCommonKernelGeosGeoVec2D_initWithGeogebraCommonKernelKernel_withDouble_withDouble_(self->kernel_, 1, 0) autorelease], [new_GeogebraCommonKernelGeosGeoVec2D_initWithGeogebraCommonKernelKernel_withDouble_withDouble_(self->kernel_, 0, 1) autorelease] } count:2 type:GeogebraCommonKernelGeosGeoVec2D_class_()]);
  GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_b_(self, new_GeogebraCommonKernelGeosGeoVec2D_initWithGeogebraCommonKernelKernel_(self->kernel_));
  self->index_ = 0;
  GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_c_(self, new_GeogebraCommonKernelGeosGeoVec2D_initWithGeogebraCommonKernelKernel_(self->kernel_));
  self->errDetS_ = GeogebraCommonKernelKernel_STANDARD_PRECISION;
  GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_coeffs_(self, [IOSDoubleArray newArrayWithLength:6]);
  self->eigenvectorsSetOnLoad_ = NO;
  self->isEndOfQuadric__ = NO;
  GeogebraCommonKernelKernelNDGeoConicND_set_lastHitType_(self, GeogebraCommonKernelGeosGeoElement_HitTypeEnum_get_NONE());
  self->toStringMode_ = GeogebraCommonKernelKernelNDGeoConicND_EQUATION_IMPLICIT;
}

void GeogebraCommonKernelKernelNDGeoConicND_setCircleWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelGeosGeoPoint *M, GeogebraCommonKernelGeosGeoPoint *P) {
  self->defined_ = ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(M)) isDefined] && [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P)) isDefined] && ![P isInfinite]);
  if (!self->defined_) {
    return;
  }
  if ([M isInfinite]) {
    IOSDoubleArray *coords = [IOSDoubleArray arrayWithLength:3];
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P)) getCoordsWithDoubleArray:coords];
    [self setMidpointWithDoubleArray:coords];
    self->eigenvecX_ = -M->y_;
    self->eigenvecY_ = M->x_;
    GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(self);
    *IOSDoubleArray_GetRef(nil_chk(self->halfAxes_), 0) = JavaLangDouble_POSITIVE_INFINITY;
    *IOSDoubleArray_GetRef(self->halfAxes_, 1) = JavaLangDouble_POSITIVE_INFINITY;
    *IOSDoubleArray_GetRef(nil_chk(self->mu_), 0) = 0.0;
    GeogebraCommonKernelKernelNDGeoConicND_parallelLinesWithDoubleArray_(self, self->mu_);
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(self->lines_), 1)))->x_ = JavaLangDouble_NaN;
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->y_ = JavaLangDouble_NaN;
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->z_ = JavaLangDouble_NaN;
    *IOSDoubleArray_GetRef(nil_chk(self->matrix_), 0) = 0.0;
    *IOSDoubleArray_GetRef(self->matrix_, 1) = 0.0;
    *IOSDoubleArray_GetRef(self->matrix_, 2) = ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->z_;
    *IOSDoubleArray_GetRef(self->matrix_, 3) = 0.0;
    *IOSDoubleArray_GetRef(self->matrix_, 4) = ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->x_ / 2.0;
    *IOSDoubleArray_GetRef(self->matrix_, 5) = ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->y_ / 2.0;
  }
  else {
    [self setCircleMatrixWithGeogebraCommonKernelGeosGeoPoint:M withDouble:[M distanceWithGeogebraCommonKernelGeosGeoPoint:P]];
  }
  GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
}

IOSDoubleArray *GeogebraCommonKernelKernelNDGeoConicND_getPerpendicularParamsWithDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble abspx, jdouble abspy) {
  jdouble ha = IOSDoubleArray_Get(nil_chk(self->halfAxes_), 0);
  jdouble hb = IOSDoubleArray_Get(self->halfAxes_, 1);
  jdouble bpy = hb * abspy;
  IOSDoubleArray *roots = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ 0, 0, 0, 0 } count:4];
  IOSDoubleArray *eqn;
  if (self->type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE) {
    jdouble hc_2 = ha * ha - hb * hb;
    eqn = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ bpy * bpy, 2 * bpy * hc_2, -bpy * bpy + hc_2 * hc_2 - ha * ha * abspx * abspx, -2 * bpy * hc_2, -hc_2 * hc_2 } count:5];
  }
  else {
    jdouble hc_2 = ha * ha + hb * hb;
    eqn = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ bpy * bpy, -2 * bpy * hc_2, bpy * bpy + hc_2 * hc_2 - ha * ha * abspx * abspx, -2 * bpy * hc_2, hc_2 * hc_2 } count:5];
  }
  [((GeogebraCommonKernelEquationSolver *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) getKernel])) getEquationSolver])) solveQuarticWithDoubleArray:eqn withDoubleArray:roots withDouble:GeogebraCommonKernelKernel_STANDARD_PRECISION];
  return roots;
}

jboolean GeogebraCommonKernelKernelNDGeoConicND_compatibleTypeWithInt_(GeogebraCommonKernelKernelNDGeoConicND *self, jint t) {
  if (self->type_ == t) return YES;
  if (t == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY || t == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT) return YES;
  return NO;
}

jboolean GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, id<GeogebraCommonKernelKernelNDGeoPointND> P, jdouble eps) {
  if (![((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) isDefined]) return NO;
  return GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelMatrixCoords_withDouble_(self, [P getCoordsInD2], eps);
}

jboolean GeogebraCommonKernelKernelNDGeoConicND_isOnFullConicWithGeogebraCommonKernelMatrixCoords_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelMatrixCoords *P, jdouble eps) {
  {
    GeogebraCommonKernelMatrixCoords *singlePointCoords;
    switch (self->type_) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
      singlePointCoords = [new_GeogebraCommonKernelMatrixCoords_initWithDouble_withDouble_withDouble_(((GeogebraCommonKernelGeosGeoPoint *) nil_chk(self->singlePoint__))->x_, self->singlePoint__->y_, self->singlePoint__->z_) autorelease];
      return [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) distanceWithGeogebraCommonKernelMatrixCoords:singlePointCoords] < eps;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
      return [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(self->lines_), 0))) isOnFullLineWithGeogebraCommonKernelMatrixCoords:P withDouble:eps] || [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1))) isOnFullLineWithGeogebraCommonKernelMatrixCoords:P withDouble:eps];
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
      return [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(self->lines_), 0))) isOnFullLineWithGeogebraCommonKernelMatrixCoords:P withDouble:eps];
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY:
      return NO;
    }
  }
  jdouble Px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX];
  jdouble Py = [P getY];
  jdouble Pz = [P getZ];
  if (self->type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE) {
    GeogebraCommonKernelKernelNDGeoConicND_translateByCenterWithGeogebraCommonKernelMatrixCoords_(self, P);
  }
  else {
    GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(self, P);
  }
  jdouble px = [P getX] / [P getZ];
  jdouble py = [P getY] / [P getZ];
  jboolean result = NO;
  {
    jdouble radius2;
    switch (self->type_) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
      radius2 = IOSDoubleArray_Get(nil_chk(self->halfAxes_), 0) * IOSDoubleArray_Get(self->halfAxes_, 0);
      result = GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_(px * px / radius2 + py * py / radius2, 1, eps);
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
      result = GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_(px * px / (IOSDoubleArray_Get(nil_chk(self->halfAxes_), 0) * IOSDoubleArray_Get(self->halfAxes_, 0)) + py * py / (IOSDoubleArray_Get(self->halfAxes_, 1) * IOSDoubleArray_Get(self->halfAxes_, 1)), 1, eps);
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
      result = GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_(px * px / (IOSDoubleArray_Get(nil_chk(self->halfAxes_), 0) * IOSDoubleArray_Get(self->halfAxes_, 0)), 1 + py * py / (IOSDoubleArray_Get(self->halfAxes_, 1) * IOSDoubleArray_Get(self->halfAxes_, 1)), eps);
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
      result = GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_(py * py, 2 * self->p_ * px, eps);
      break;
    }
  }
  [P setXWithDouble:Px];
  [P setYWithDouble:Py];
  [P setZWithDouble:Pz];
  return result;
}

void GeogebraCommonKernelKernelNDGeoConicND_coordsEVtoRWWithGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelMatrixCoords *P) {
  jdouble px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX];
  jdouble py = [P getY];
  GeogebraCommonKernelMatrixCoords *eigenvec0 = [self getEigenvecWithInt:0];
  GeogebraCommonKernelMatrixCoords *eigenvec1 = [self getEigenvecWithInt:1];
  [P setXWithDouble:px * [((GeogebraCommonKernelMatrixCoords *) nil_chk(eigenvec0)) getX] + py * [((GeogebraCommonKernelMatrixCoords *) nil_chk(eigenvec1)) getX]];
  [P setYWithDouble:px * [eigenvec0 getY] + py * [eigenvec1 getY]];
  GeogebraCommonKernelMatrixCoords *mid = [self getMidpoint];
  [P setXWithDouble:[P getX] + [P getZ] * [((GeogebraCommonKernelMatrixCoords *) nil_chk(mid)) getX]];
  [P setYWithDouble:[P getY] + [P getZ] * [mid getY]];
}

void GeogebraCommonKernelKernelNDGeoConicND_coordsRWtoEVWithGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelMatrixCoords *P) {
  GeogebraCommonKernelMatrixCoords *mid = [self getMidpoint];
  [P setXWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX] - [P getZ] * [((GeogebraCommonKernelMatrixCoords *) nil_chk(mid)) getX]];
  [P setYWithDouble:[P getY] - [P getZ] * [mid getY]];
  jdouble px = [P getX];
  jdouble py = [P getY];
  GeogebraCommonKernelMatrixCoords *eigenvec0 = [self getEigenvecWithInt:0];
  GeogebraCommonKernelMatrixCoords *eigenvec1 = [self getEigenvecWithInt:1];
  [P setXWithDouble:px * [((GeogebraCommonKernelMatrixCoords *) nil_chk(eigenvec0)) getX] + py * [eigenvec0 getY]];
  [P setYWithDouble:px * [((GeogebraCommonKernelMatrixCoords *) nil_chk(eigenvec1)) getX] + py * [eigenvec1 getY]];
}

void GeogebraCommonKernelKernelNDGeoConicND_translateByCenterWithGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelMatrixCoords *P) {
  GeogebraCommonKernelMatrixCoords *mid = [self getMidpoint];
  [P setXWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX] - [P getZ] * [((GeogebraCommonKernelMatrixCoords *) nil_chk(mid)) getX]];
  [P setYWithDouble:[P getY] - [P getZ] * [mid getY]];
}

void GeogebraCommonKernelKernelNDGeoConicND_setLinesWithGeogebraCommonKernelKernelNDGeoConicND_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelKernelNDGeoConicND *co) {
  if (((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(co))->lines_ != nil) {
    GeogebraCommonKernelKernelNDGeoConicND_getLines(self);
    for (jint i = 0; i < 2; i++) {
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(co->lines_, i)];
      if (((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(co->lines_, i)))->startPoint_ != nil) {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, i))) setStartPointWithGeogebraCommonKernelGeosGeoPoint:[((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(co->lines_, i)))->startPoint_ copy__]];
      }
      if (((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(co->lines_, i)))->endPoint_ != nil) {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, i))) setEndPointWithGeogebraCommonKernelGeosGeoPoint:[((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(co->lines_, i)))->endPoint_ copy__]];
      }
    }
  }
}

void GeogebraCommonKernelKernelNDGeoConicND_setToStringModeWithInt_(GeogebraCommonKernelKernelNDGeoConicND *self, jint mode) {
  switch (mode) {
    case GeogebraCommonKernelKernelNDGeoConicND_EQUATION_SPECIFIC:
    self->toStringMode_ = GeogebraCommonKernelKernelNDGeoConicND_EQUATION_SPECIFIC;
    break;
    case GeogebraCommonKernelKernelNDGeoConicND_EQUATION_EXPLICIT:
    self->toStringMode_ = GeogebraCommonKernelKernelNDGeoConicND_EQUATION_EXPLICIT;
    break;
    default:
    self->toStringMode_ = GeogebraCommonKernelKernelNDGeoConicND_EQUATION_IMPLICIT;
  }
}

jboolean GeogebraCommonKernelKernelNDGeoConicND_isSpecificPossible(GeogebraCommonKernelKernelNDGeoConicND *self) {
  switch (self->type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
    return YES;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
    return (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(nil_chk(self->matrix_), 3)));
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
    return GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(nil_chk(self->matrix_), 0)) || GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(self->matrix_, 1));
    default:
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE:
    return NO;
  }
}

jboolean GeogebraCommonKernelKernelNDGeoConicND_isExplicitPossible(GeogebraCommonKernelKernelNDGeoConicND *self) {
  if (self->type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_LINE) return NO;
  return !GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(nil_chk(self->matrix_), 5)) && GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(self->matrix_, 3)) && GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(self->matrix_, 1));
}

jboolean GeogebraCommonKernelKernelNDGeoConicND_checkDefined(GeogebraCommonKernelKernelNDGeoConicND *self) {
  jboolean allZero = YES;
  jdouble maxCoeffAbs = 0;
  for (jint i = 0; i < 6; i++) {
    if (JavaLangDouble_isNaNWithDouble_(IOSDoubleArray_Get(nil_chk(self->matrix_), i)) || JavaLangDouble_isInfiniteWithDouble_(IOSDoubleArray_Get(self->matrix_, i))) {
      return NO;
    }
    jdouble abs = JavaLangMath_absWithDouble_(IOSDoubleArray_Get(self->matrix_, i));
    if (abs > GeogebraCommonKernelKernel_STANDARD_PRECISION) allZero = NO;
    if ((i == 0 || i == 1 || i == 3) && maxCoeffAbs < abs) {
      maxCoeffAbs = abs;
    }
  }
  if (allZero) {
    return NO;
  }
  if (maxCoeffAbs == 0) {
    return YES;
  }
  jdouble factor = 1.0;
  if (maxCoeffAbs < GeogebraCommonKernelKernelNDGeoConicND_MIN_COEFFICIENT_SIZE) {
    factor = 2;
    while (maxCoeffAbs * factor < GeogebraCommonKernelKernelNDGeoConicND_MIN_COEFFICIENT_SIZE) factor *= 2;
  }
  else if (maxCoeffAbs > GeogebraCommonKernelKernelNDGeoConicND_MAX_COEFFICIENT_SIZE) {
    factor = 0.5;
    while (maxCoeffAbs * factor > GeogebraCommonKernelKernelNDGeoConicND_MAX_COEFFICIENT_SIZE) factor *= 0.5;
  }
  if (factor != 1.0 && !JavaLangDouble_isInfiniteWithDouble_(factor) && !JavaLangDouble_isNaNWithDouble_(factor)) {
    maxCoeffAbs *= factor;
    for (jint i = 0; i < 6; i++) {
      *IOSDoubleArray_GetRef(nil_chk(self->matrix_), i) *= factor;
    }
  }
  return YES;
}

void GeogebraCommonKernelKernelNDGeoConicND_setCoeffsWithDouble_withDouble_withDouble_withDouble_withDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble a, jdouble b, jdouble c, jdouble d, jdouble e, jdouble f) {
  *IOSDoubleArray_GetRef(nil_chk(self->matrix_), 0) = a;
  *IOSDoubleArray_GetRef(self->matrix_, 1) = c;
  *IOSDoubleArray_GetRef(self->matrix_, 2) = f;
  *IOSDoubleArray_GetRef(self->matrix_, 3) = b / 2.0;
  *IOSDoubleArray_GetRef(self->matrix_, 4) = d / 2.0;
  *IOSDoubleArray_GetRef(self->matrix_, 5) = e / 2.0;
  [self classifyConic];
}

IOSObjectArray *GeogebraCommonKernelKernelNDGeoConicND_getLines(GeogebraCommonKernelKernelNDGeoConicND *self) {
  if (self->lines_ == nil) {
    GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_lines_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoLine_class_()]);
    IOSObjectArray_SetAndConsume(self->lines_, 0, new_GeogebraCommonKernelGeosGeoLine_initWithGeogebraCommonKernelConstruction_(self->cons_));
    IOSObjectArray_SetAndConsume(self->lines_, 1, new_GeogebraCommonKernelGeosGeoLine_initWithGeogebraCommonKernelConstruction_(self->cons_));
  }
  return self->lines_;
}

id<GeogebraCommonAwtGAffineTransform> GeogebraCommonKernelKernelNDGeoConicND_getAffineTransform(GeogebraCommonKernelKernelNDGeoConicND *self) {
  if (self->transform_ == nil) GeogebraCommonKernelKernelNDGeoConicND_set_transform_(self, [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newAffineTransform]);
  return self->transform_;
}

void GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(GeogebraCommonKernelKernelNDGeoConicND *self) {
  id<GeogebraCommonAwtGAffineTransform> at = GeogebraCommonKernelKernelNDGeoConicND_getAffineTransform(self);
  [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(at)) setTransformWithDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) getX] withDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) getY] withDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getX] withDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getY] withDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->b_)) getX] withDouble:[self->b_ getY]];
}

void GeogebraCommonKernelKernelNDGeoConicND_setCircleWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoSegment_(GeogebraCommonKernelKernelNDGeoConicND *self, GeogebraCommonKernelGeosGeoPoint *M, GeogebraCommonKernelGeosGeoSegment *geoSegment) {
  self->defined_ = ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(M)) isDefined] && ![M isInfinite] && [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(geoSegment)) isDefined]);
  jdouble r = [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(geoSegment)) getLength];
  if (GeogebraCommonKernelKernel_isZeroWithDouble_(r)) {
    r = 0;
  }
  else if (r < 0) {
    self->defined_ = NO;
  }
  if (self->defined_) {
    [self setCircleMatrixWithGeogebraCommonKernelGeosGeoPoint:M withDouble:r];
    GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
  }
}

void GeogebraCommonKernelKernelNDGeoConicND_doTranslateWithDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble vx, jdouble vy) {
  [self translateMatrixWithDoubleArray:self->matrix_ withDouble:vx withDouble:vy];
  [self setMidpointWithDoubleArray:[((GeogebraCommonKernelMatrixCoords *) nil_chk([((GeogebraCommonKernelMatrixCoords *) nil_chk([self getMidpoint])) addWithGeogebraCommonKernelMatrixCoords:[new_GeogebraCommonKernelMatrixCoords_initWithDoubleArray_([IOSDoubleArray arrayWithDoubles:(jdouble[]){ vx, vy, 0 } count:3]) autorelease]])) get]];
}

void GeogebraCommonKernelKernelNDGeoConicND_rotateWithDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble phi) {
  GeogebraCommonKernelKernelNDGeoConicND_rotateMatrixWithDoubleArray_withDouble_(self->matrix_, phi);
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) rotateWithDouble:phi];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) rotateWithDouble:phi];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->b_)) rotateWithDouble:phi];
  [self setMidpointWithDoubleArray:[IOSDoubleArray arrayWithDoubles:(jdouble[]){ [self->b_ getX], [self->b_ getY] } count:2]];
}

void GeogebraCommonKernelKernelNDGeoConicND_rotateMatrixWithDoubleArray_withDouble_(IOSDoubleArray *matrix, jdouble phi) {
  GeogebraCommonKernelKernelNDGeoConicND_initialize();
  jdouble sum = IOSDoubleArray_Get(nil_chk(matrix), 0) + IOSDoubleArray_Get(matrix, 1);
  jdouble diff = IOSDoubleArray_Get(matrix, 0) - IOSDoubleArray_Get(matrix, 1);
  jdouble cos = JavaLangMath_cosWithDouble_(phi);
  jdouble sin = JavaLangMath_sinWithDouble_(phi);
  jdouble cos2 = (cos + sin) * (cos - sin);
  jdouble sin2 = 2.0 * cos * sin;
  jdouble temp = diff * cos2 - 2.0 * IOSDoubleArray_Get(matrix, 3) * sin2;
  jdouble A0 = (sum + temp) / 2.0;
  jdouble A1 = (sum - temp) / 2.0;
  jdouble A3 = IOSDoubleArray_Get(matrix, 3) * cos2 + diff * cos * sin;
  jdouble A4 = IOSDoubleArray_Get(matrix, 4) * cos - IOSDoubleArray_Get(matrix, 5) * sin;
  *IOSDoubleArray_GetRef(matrix, 5) = IOSDoubleArray_Get(matrix, 5) * cos + IOSDoubleArray_Get(matrix, 4) * sin;
  *IOSDoubleArray_GetRef(matrix, 0) = A0;
  *IOSDoubleArray_GetRef(matrix, 1) = A1;
  *IOSDoubleArray_GetRef(matrix, 3) = A3;
  *IOSDoubleArray_GetRef(matrix, 4) = A4;
}

void GeogebraCommonKernelKernelNDGeoConicND_doDilateWithDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble factor) {
  jdouble r = 1.0 / factor;
  jdouble r2 = r * r;
  *IOSDoubleArray_GetRef(nil_chk(self->matrix_), 0) *= r2;
  *IOSDoubleArray_GetRef(self->matrix_, 1) *= r2;
  *IOSDoubleArray_GetRef(self->matrix_, 3) *= r2;
  *IOSDoubleArray_GetRef(self->matrix_, 4) *= r;
  *IOSDoubleArray_GetRef(self->matrix_, 5) *= r;
}

void GeogebraCommonKernelKernelNDGeoConicND_updateDegenerates(GeogebraCommonKernelKernelNDGeoConicND *self) {
  switch (self->type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
    GeogebraCommonKernelKernelNDGeoConicND_singlePoint(self);
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    GeogebraCommonKernelKernelNDGeoConicND_intersectingLinesWithDoubleArray_(self, self->mu_);
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
    GeogebraCommonKernelKernelNDGeoConicND_doubleLine(self);
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
    GeogebraCommonKernelKernelNDGeoConicND_parallelLinesWithDoubleArray_(self, self->mu_);
    break;
  }
}

void GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(GeogebraCommonKernelKernelNDGeoConicND *self) {
  self->length_ = GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_(self->eigenvecX_, self->eigenvecY_);
  if (self->length_ != 1.0) {
    self->eigenvecX_ = self->eigenvecX_ / self->length_;
    self->eigenvecY_ = self->eigenvecY_ / self->length_;
  }
  if ([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) isContinuous]) {
    if ([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) getX] * self->eigenvecX_ < -[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) getY] * self->eigenvecY_) {
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) setXWithDouble:-self->eigenvecX_];
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) setYWithDouble:-self->eigenvecY_];
    }
    else {
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) setXWithDouble:self->eigenvecX_];
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) setYWithDouble:self->eigenvecY_];
    }
    if ([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getY] * self->eigenvecX_ < [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getX] * self->eigenvecY_) {
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setXWithDouble:self->eigenvecY_];
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setYWithDouble:-self->eigenvecX_];
    }
    else {
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setXWithDouble:-self->eigenvecY_];
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setYWithDouble:self->eigenvecX_];
    }
  }
  else if (!self->eigenvectorsSetOnLoad_) {
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) setXWithDouble:self->eigenvecX_];
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) setYWithDouble:self->eigenvecY_];
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setXWithDouble:-self->eigenvecY_];
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setYWithDouble:self->eigenvecX_];
  }
  self->eigenvectorsSetOnLoad_ = NO;
}

void GeogebraCommonKernelKernelNDGeoConicND_setParabolicEigenvectors(GeogebraCommonKernelKernelNDGeoConicND *self) {
  self->length_ = GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_(self->eigenvecX_, self->eigenvecY_);
  if (self->length_ != 1.0) {
    self->eigenvecX_ = self->eigenvecX_ / self->length_;
    self->eigenvecY_ = self->eigenvecY_ / self->length_;
  }
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) setXWithDouble:self->eigenvecX_];
  [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) setYWithDouble:self->eigenvecY_];
  if ([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) isContinuous]) {
    if ([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getY] * self->eigenvecX_ < [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getX] * self->eigenvecY_) {
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setXWithDouble:self->eigenvecY_];
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setYWithDouble:-self->eigenvecX_];
    }
    else {
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setXWithDouble:-self->eigenvecY_];
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setYWithDouble:self->eigenvecX_];
    }
  }
  else if (!self->eigenvectorsSetOnLoad_) {
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setXWithDouble:-self->eigenvecY_];
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setYWithDouble:self->eigenvecX_];
  }
  self->eigenvectorsSetOnLoad_ = NO;
}

void GeogebraCommonKernelKernelNDGeoConicND_makePathParametersInvalid(GeogebraCommonKernelKernelNDGeoConicND *self) {
  if (self->pointsOnConic_ == nil) return;
  GeogebraCommonKernelKernelNDGeoConicND_getAffineTransform(self);
  if (self->oldTransform_ == nil) GeogebraCommonKernelKernelNDGeoConicND_set_oldTransform_(self, [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newAffineTransform]);
  jboolean eigenVectorsSame = GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_([((id<GeogebraCommonAwtGAffineTransform>) nil_chk(self->transform_)) getScaleX], [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(self->oldTransform_)) getScaleX], GeogebraCommonKernelKernel_MIN_PRECISION) || GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_([self->transform_ getScaleY], [self->oldTransform_ getScaleY], GeogebraCommonKernelKernel_MIN_PRECISION) || GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_([self->transform_ getShearX], [self->oldTransform_ getShearX], GeogebraCommonKernelKernel_MIN_PRECISION) || GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_([self->transform_ getShearY], [self->oldTransform_ getShearY], GeogebraCommonKernelKernel_MIN_PRECISION);
  if (!eigenVectorsSame) {
    [self->oldTransform_ setTransformWithGeogebraCommonAwtGAffineTransform:self->transform_];
    jint size = [((JavaUtilArrayList *) nil_chk(self->pointsOnConic_)) size];
    for (jint i = 0; i < size; i++) {
      id<GeogebraCommonKernelKernelNDGeoPointND> point = [self->pointsOnConic_ getWithInt:i];
      if ([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(point)) getPath] == self) {
        [((GeogebraCommonKernelPathParameter *) nil_chk([point getPathParameter])) setTWithDouble:JavaLangDouble_NaN];
      }
    }
  }
}

jboolean GeogebraCommonKernelKernelNDGeoConicND_isDetSzero(GeogebraCommonKernelKernelNDGeoConicND *self) {
  jdouble maxAbs = JavaLangMath_absWithDouble_(IOSDoubleArray_Get(nil_chk(self->matrix_), 0));
  jdouble abs = JavaLangMath_absWithDouble_(IOSDoubleArray_Get(self->matrix_, 1));
  if (abs > maxAbs) maxAbs = abs;
  abs = JavaLangMath_absWithDouble_(IOSDoubleArray_Get(self->matrix_, 3));
  return GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_(IOSDoubleArray_Get(self->matrix_, 0) * IOSDoubleArray_Get(self->matrix_, 1), IOSDoubleArray_Get(self->matrix_, 3) * IOSDoubleArray_Get(self->matrix_, 3), self->errDetS_);
}

void GeogebraCommonKernelKernelNDGeoConicND_classifyMidpointConicWithBoolean_(GeogebraCommonKernelKernelNDGeoConicND *self, jboolean degenerate) {
  if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(nil_chk(self->matrix_), 3))) {
    *IOSDoubleArray_GetRef(nil_chk(self->eigenval_), 0) = IOSDoubleArray_Get(self->matrix_, 0);
    *IOSDoubleArray_GetRef(self->eigenval_, 1) = IOSDoubleArray_Get(self->matrix_, 1);
    self->eigenvecX_ = 1.0;
    self->eigenvecY_ = 0.0;
  }
  else {
    *IOSDoubleArray_GetRef(nil_chk(self->eigenval_), 0) = self->detS_;
    *IOSDoubleArray_GetRef(self->eigenval_, 1) = -(IOSDoubleArray_Get(self->matrix_, 0) + IOSDoubleArray_Get(self->matrix_, 1));
    *IOSDoubleArray_GetRef(self->eigenval_, 2) = 1.0;
    jint nRoots = [((GeogebraCommonKernelEquationSolver *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) getKernel])) getEquationSolver])) solveQuadraticWithDoubleArray:self->eigenval_ withDoubleArray:self->eigenval_ withDouble:GeogebraCommonKernelKernel_STANDARD_PRECISION];
    if (nRoots == 1) {
      *IOSDoubleArray_GetRef(self->eigenval_, 1) = IOSDoubleArray_Get(self->eigenval_, 0);
    }
    self->eigenvecX_ = -IOSDoubleArray_Get(self->matrix_, 3);
    self->eigenvecY_ = -IOSDoubleArray_Get(self->eigenval_, 0) + IOSDoubleArray_Get(self->matrix_, 0);
  }
  [self setMidpointWithDoubleArray:[IOSDoubleArray arrayWithDoubles:(jdouble[]){ (IOSDoubleArray_Get(self->matrix_, 3) * IOSDoubleArray_Get(self->matrix_, 5) - IOSDoubleArray_Get(self->matrix_, 1) * IOSDoubleArray_Get(self->matrix_, 4)) / self->detS_, (IOSDoubleArray_Get(self->matrix_, 3) * IOSDoubleArray_Get(self->matrix_, 4) - IOSDoubleArray_Get(self->matrix_, 0) * IOSDoubleArray_Get(self->matrix_, 5)) / self->detS_ } count:2]];
  jdouble beta = IOSDoubleArray_Get(self->matrix_, 4) * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->b_)) getX] + IOSDoubleArray_Get(self->matrix_, 5) * [self->b_ getY] + IOSDoubleArray_Get(self->matrix_, 2);
  if (degenerate || GeogebraCommonKernelKernel_isZeroWithDouble_(beta)) {
    GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(self);
    *IOSDoubleArray_GetRef(nil_chk(self->mu_), 0) = IOSDoubleArray_Get(nil_chk(self->eigenval_), 0) / IOSDoubleArray_Get(self->eigenval_, 1);
    if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(self->mu_, 0))) {
      *IOSDoubleArray_GetRef(self->mu_, 0) = 0.0;
      GeogebraCommonKernelKernelNDGeoConicND_intersectingLinesWithDoubleArray_(self, self->mu_);
    }
    else if (IOSDoubleArray_Get(self->mu_, 0) < 0.0) {
      *IOSDoubleArray_GetRef(self->mu_, 0) = JavaLangMath_sqrtWithDouble_(-IOSDoubleArray_Get(self->mu_, 0));
      GeogebraCommonKernelKernelNDGeoConicND_intersectingLinesWithDoubleArray_(self, self->mu_);
    }
    else {
      GeogebraCommonKernelKernelNDGeoConicND_singlePoint(self);
    }
  }
  else {
    *IOSDoubleArray_GetRef(nil_chk(self->mu_), 0) = -IOSDoubleArray_Get(nil_chk(self->eigenval_), 0) / beta;
    *IOSDoubleArray_GetRef(self->mu_, 1) = -IOSDoubleArray_Get(self->eigenval_, 1) / beta;
    if (self->detS_ < 0) {
      GeogebraCommonKernelKernelNDGeoConicND_hyperbolaWithDoubleArray_(self, self->mu_);
    }
    else {
      if (IOSDoubleArray_Get(self->mu_, 0) > 0 && IOSDoubleArray_Get(self->mu_, 1) > 0) {
        GeogebraCommonKernelKernelNDGeoConicND_ellipseWithDoubleArray_(self, self->mu_);
      }
      else {
        [self empty];
      }
    }
  }
}

void GeogebraCommonKernelKernelNDGeoConicND_singlePoint(GeogebraCommonKernelKernelNDGeoConicND *self) {
  self->type_ = GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT;
  if (self->singlePoint__ == nil) GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_singlePoint__(self, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(self->cons_));
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(self->singlePoint__)) setCoordsWithDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->b_)) getX] withDouble:[self->b_ getY] withDouble:1.0];
}

void GeogebraCommonKernelKernelNDGeoConicND_intersectingLinesWithDoubleArray_(GeogebraCommonKernelKernelNDGeoConicND *self, IOSDoubleArray *mu1) {
  self->type_ = GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES;
  GeogebraCommonKernelKernelNDGeoConicND_getLines(self);
  self->temp1_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) getX] * IOSDoubleArray_Get(nil_chk(mu1), 0);
  self->temp2_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) getY] * IOSDoubleArray_Get(mu1, 0);
  self->nx_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getX] - self->temp1_;
  self->ny_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getY] - self->temp2_;
  if (JavaLangMath_absWithDouble_(self->nx_ * ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(self->lines_), 0)))->x_ + self->ny_ * ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->y_) < JavaLangMath_absWithDouble_(self->nx_ * ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->x_ + self->ny_ * ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->y_)) self->index_ = 1;
  else self->index_ = 0;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, self->index_)))->x_ = self->nx_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, self->index_)))->y_ = self->ny_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, self->index_)))->z_ = -(self->nx_ * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->b_)) getX] + self->ny_ * [self->b_ getY]);
  self->nx_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getX] + self->temp1_;
  self->ny_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getY] + self->temp2_;
  self->index_ = 1 - self->index_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, self->index_)))->x_ = self->nx_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, self->index_)))->y_ = self->ny_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, self->index_)))->z_ = -(self->nx_ * [self->b_ getX] + self->ny_ * [self->b_ getY]);
  GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForLines(self);
}

void GeogebraCommonKernelKernelNDGeoConicND_ellipseWithDoubleArray_(GeogebraCommonKernelKernelNDGeoConicND *self, IOSDoubleArray *mu1) {
  if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(IOSDoubleArray_Get(nil_chk(mu1), 0) / IOSDoubleArray_Get(mu1, 1), 1.0)) {
    self->eigenvecX_ = 1;
    self->eigenvecY_ = 0;
    GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(self);
    self->type_ = GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE;
    *IOSDoubleArray_GetRef(nil_chk(self->halfAxes_), 0) = JavaLangMath_sqrtWithDouble_(1.0 / IOSDoubleArray_Get(mu1, 0));
    *IOSDoubleArray_GetRef(self->halfAxes_, 1) = IOSDoubleArray_Get(self->halfAxes_, 0);
    self->linearEccentricity_ = 0.0;
    self->eccentricity_ = 0.0;
  }
  else {
    if (IOSDoubleArray_Get(mu1, 0) > IOSDoubleArray_Get(mu1, 1)) {
      self->temp_ = IOSDoubleArray_Get(mu1, 0);
      *IOSDoubleArray_GetRef(mu1, 0) = IOSDoubleArray_Get(mu1, 1);
      *IOSDoubleArray_GetRef(mu1, 1) = self->temp_;
      self->temp_ = self->eigenvecX_;
      self->eigenvecX_ = -self->eigenvecY_;
      self->eigenvecY_ = self->temp_;
    }
    GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(self);
    self->type_ = GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE;
    *IOSDoubleArray_GetRef(mu1, 0) = 1.0 / IOSDoubleArray_Get(mu1, 0);
    *IOSDoubleArray_GetRef(mu1, 1) = 1.0 / IOSDoubleArray_Get(mu1, 1);
    *IOSDoubleArray_GetRef(nil_chk(self->halfAxes_), 0) = JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(mu1, 0));
    *IOSDoubleArray_GetRef(self->halfAxes_, 1) = JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(mu1, 1));
    self->linearEccentricity_ = JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(mu1, 0) - IOSDoubleArray_Get(mu1, 1));
    self->eccentricity_ = self->linearEccentricity_ / JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(mu1, 0));
  }
}

void GeogebraCommonKernelKernelNDGeoConicND_hyperbolaWithDoubleArray_(GeogebraCommonKernelKernelNDGeoConicND *self, IOSDoubleArray *mu1) {
  self->type_ = GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA;
  if (IOSDoubleArray_Get(nil_chk(mu1), 0) < 0) {
    self->temp_ = IOSDoubleArray_Get(mu1, 0);
    *IOSDoubleArray_GetRef(mu1, 0) = IOSDoubleArray_Get(mu1, 1);
    *IOSDoubleArray_GetRef(mu1, 1) = self->temp_;
    self->temp_ = self->eigenvecX_;
    self->eigenvecX_ = -self->eigenvecY_;
    self->eigenvecY_ = self->temp_;
  }
  GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(self);
  *IOSDoubleArray_GetRef(mu1, 0) = 1.0 / IOSDoubleArray_Get(mu1, 0);
  *IOSDoubleArray_GetRef(mu1, 1) = -1.0 / IOSDoubleArray_Get(mu1, 1);
  *IOSDoubleArray_GetRef(nil_chk(self->halfAxes_), 0) = JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(mu1, 0));
  *IOSDoubleArray_GetRef(self->halfAxes_, 1) = JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(mu1, 1));
  self->linearEccentricity_ = JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(mu1, 0) + IOSDoubleArray_Get(mu1, 1));
  self->eccentricity_ = self->linearEccentricity_ / JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(mu1, 0));
}

void GeogebraCommonKernelKernelNDGeoConicND_classifyParabolicConicWithBoolean_(GeogebraCommonKernelKernelNDGeoConicND *self, jboolean degenerate) {
  if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(nil_chk(self->matrix_), 3))) {
    if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(self->matrix_, 0))) {
      if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(self->matrix_, 1))) {
        GeogebraCommonKernelKernelNDGeoConicND_handleSzero(self);
        return;
      }
      self->lambda_ = IOSDoubleArray_Get(self->matrix_, 1);
      self->eigenvecX_ = 1.0;
      self->eigenvecY_ = 0.0;
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->c_)) setXWithDouble:IOSDoubleArray_Get(self->matrix_, 4)];
      [self->c_ setYWithDouble:IOSDoubleArray_Get(self->matrix_, 5)];
    }
    else {
      self->lambda_ = IOSDoubleArray_Get(self->matrix_, 0);
      self->eigenvecX_ = 0.0;
      self->eigenvecY_ = 1.0;
      [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->c_)) setXWithDouble:IOSDoubleArray_Get(self->matrix_, 5)];
      [self->c_ setYWithDouble:-IOSDoubleArray_Get(self->matrix_, 4)];
    }
  }
  else {
    self->lambda_ = IOSDoubleArray_Get(self->matrix_, 0) + IOSDoubleArray_Get(self->matrix_, 1);
    self->length_ = GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_(IOSDoubleArray_Get(self->matrix_, 3), IOSDoubleArray_Get(self->matrix_, 0));
    self->eigenvecX_ = IOSDoubleArray_Get(self->matrix_, 3) / self->length_;
    self->eigenvecY_ = -IOSDoubleArray_Get(self->matrix_, 0) / self->length_;
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->c_)) setXWithDouble:IOSDoubleArray_Get(self->matrix_, 4) * self->eigenvecX_ + IOSDoubleArray_Get(self->matrix_, 5) * self->eigenvecY_];
    [self->c_ setYWithDouble:IOSDoubleArray_Get(self->matrix_, 5) * self->eigenvecX_ - IOSDoubleArray_Get(self->matrix_, 4) * self->eigenvecY_];
  }
  if (degenerate || GeogebraCommonKernelKernel_isZeroWithDouble_([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->c_)) getX])) {
    GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(self);
    self->temp_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->c_)) getY] / self->lambda_;
    [self setMidpointWithDoubleArray:[IOSDoubleArray arrayWithDoubles:(jdouble[]){ self->temp_ * self->eigenvecY_, -self->temp_ * self->eigenvecX_ } count:2]];
    *IOSDoubleArray_GetRef(nil_chk(self->mu_), 0) = -self->temp_ * self->temp_ + IOSDoubleArray_Get(self->matrix_, 2) / self->lambda_;
    if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(self->mu_, 0))) {
      GeogebraCommonKernelKernelNDGeoConicND_doubleLine(self);
    }
    else if (IOSDoubleArray_Get(self->mu_, 0) < 0) {
      *IOSDoubleArray_GetRef(self->mu_, 0) = JavaLangMath_sqrtWithDouble_(-IOSDoubleArray_Get(self->mu_, 0));
      GeogebraCommonKernelKernelNDGeoConicND_parallelLinesWithDoubleArray_(self, self->mu_);
    }
    else {
      [self empty];
    }
  }
  else {
    GeogebraCommonKernelKernelNDGeoConicND_parabola(self);
  }
}

void GeogebraCommonKernelKernelNDGeoConicND_doubleLine(GeogebraCommonKernelKernelNDGeoConicND *self) {
  self->type_ = GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE;
  GeogebraCommonKernelKernelNDGeoConicND_getLines(self);
  self->nx_ = -[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) getY];
  self->ny_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) getX];
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(self->lines_), 0)))->x_ = self->nx_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->y_ = self->ny_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->z_ = -([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->b_)) getX] * self->nx_ + [self->b_ getY] * self->ny_);
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->x_ = ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->x_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->y_ = ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->y_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->z_ = ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->z_;
  GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForDoubleLine(self);
}

void GeogebraCommonKernelKernelNDGeoConicND_handleSzero(GeogebraCommonKernelKernelNDGeoConicND *self) {
  if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(nil_chk(self->matrix_), 4))) {
    if (GeogebraCommonKernelKernel_isZeroWithDouble_(IOSDoubleArray_Get(self->matrix_, 5))) {
      [self empty];
      return;
    }
    [self setMidpointWithDoubleArray:[IOSDoubleArray arrayWithDoubles:(jdouble[]){ 0, -IOSDoubleArray_Get(self->matrix_, 2) / (2 * IOSDoubleArray_Get(self->matrix_, 5)) } count:2]];
  }
  else {
    [self setMidpointWithDoubleArray:[IOSDoubleArray arrayWithDoubles:(jdouble[]){ -IOSDoubleArray_Get(self->matrix_, 2) / (2 * IOSDoubleArray_Get(self->matrix_, 4)), 0 } count:2]];
  }
  self->eigenvecX_ = IOSDoubleArray_Get(self->matrix_, 5);
  self->eigenvecY_ = -IOSDoubleArray_Get(self->matrix_, 4);
  GeogebraCommonKernelKernelNDGeoConicND_setEigenvectors(self);
  GeogebraCommonKernelKernelNDGeoConicND_doubleLine(self);
}

void GeogebraCommonKernelKernelNDGeoConicND_parallelLinesWithDoubleArray_(GeogebraCommonKernelKernelNDGeoConicND *self, IOSDoubleArray *mu1) {
  self->type_ = GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES;
  GeogebraCommonKernelKernelNDGeoConicND_getLines(self);
  self->nx_ = -[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) getY];
  self->ny_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) getX];
  self->temp1_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->b_)) getX] * self->nx_ + [self->b_ getY] * self->ny_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(self->lines_), 0)))->x_ = self->nx_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->y_ = self->ny_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->x_ = self->nx_;
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->y_ = self->ny_;
  self->temp2_ = IOSDoubleArray_Get(nil_chk(mu1), 0) - self->temp1_;
  if (JavaLangMath_absWithDouble_(((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->z_ - self->temp2_) < JavaLangMath_absWithDouble_(((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->z_ - self->temp2_)) {
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->z_ = self->temp2_;
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->z_ = -self->temp1_ - IOSDoubleArray_Get(mu1, 0);
  }
  else {
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0)))->z_ = -self->temp1_ - IOSDoubleArray_Get(mu1, 0);
    ((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1)))->z_ = self->temp2_;
  }
  GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForLines(self);
}

void GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForLines(GeogebraCommonKernelKernelNDGeoConicND *self) {
  if (self->startPoints_ == nil) {
    GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_startPoints_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
    for (jint i = 0; i < 2; i++) {
      IOSObjectArray_SetAndConsume(self->startPoints_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(self->cons_));
    }
  }
  for (jint i = 0; i < 2; i++) {
    [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(self->lines_), i))) setStartPointWithGeogebraCommonKernelGeosGeoPoint:nil];
    [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, i))) getPointOnLineWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(nil_chk(self->startPoints_), i)];
    [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, i))) setStartPointWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(self->startPoints_, i)];
  }
}

void GeogebraCommonKernelKernelNDGeoConicND_setStartPointsForDoubleLine(GeogebraCommonKernelKernelNDGeoConicND *self) {
  if (self->startPoints_ == nil) {
    GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_startPoints_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
    for (jint i = 0; i < 2; i++) {
      IOSObjectArray_SetAndConsume(self->startPoints_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(self->cons_));
    }
  }
  [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(self->lines_), 0))) setStartPointWithGeogebraCommonKernelGeosGeoPoint:nil];
  [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0))) getPointOnLineWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(nil_chk(self->startPoints_), 0)];
  [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 0))) setStartPointWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(self->startPoints_, 0)];
  [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(self->lines_, 1))) setStartPointWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(self->startPoints_, 0)];
}

void GeogebraCommonKernelKernelNDGeoConicND_parabola(GeogebraCommonKernelKernelNDGeoConicND *self) {
  self->type_ = GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA;
  self->temp2_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(self->c_)) getY] / self->lambda_;
  self->temp1_ = ([self->c_ getY] * self->temp2_ - IOSDoubleArray_Get(nil_chk(self->matrix_), 2)) / (2 * [self->c_ getX]);
  [self setMidpointWithDoubleArray:[IOSDoubleArray arrayWithDoubles:(jdouble[]){ self->eigenvecY_ * self->temp2_ + self->eigenvecX_ * self->temp1_, self->eigenvecY_ * self->temp1_ - self->eigenvecX_ * self->temp2_ } count:2]];
  GeogebraCommonKernelKernelNDGeoConicND_setParabolicEigenvectors(self);
  self->p_ = -[self->c_ getX] / self->lambda_;
  if (self->p_ < 0) {
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) setXWithDouble:-[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) getX]];
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) setYWithDouble:-[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) getY]];
    self->p_ = -self->p_;
  }
  self->linearEccentricity_ = self->p_ / 2;
  self->eccentricity_ = 1;
}

jdouble GeogebraCommonKernelKernelNDGeoConicND_detWithDoubleArray_(IOSDoubleArray *matrix) {
  GeogebraCommonKernelKernelNDGeoConicND_initialize();
  return IOSDoubleArray_Get(nil_chk(matrix), 0) * (IOSDoubleArray_Get(matrix, 1) * IOSDoubleArray_Get(matrix, 2) - IOSDoubleArray_Get(matrix, 5) * IOSDoubleArray_Get(matrix, 5)) - IOSDoubleArray_Get(matrix, 2) * IOSDoubleArray_Get(matrix, 3) * IOSDoubleArray_Get(matrix, 3) - IOSDoubleArray_Get(matrix, 1) * IOSDoubleArray_Get(matrix, 4) * IOSDoubleArray_Get(matrix, 4) + 2 * IOSDoubleArray_Get(matrix, 3) * IOSDoubleArray_Get(matrix, 4) * IOSDoubleArray_Get(matrix, 5);
}

jboolean GeogebraCommonKernelKernelNDGeoConicND_hasPositiveEigenvectorOrientation(GeogebraCommonKernelKernelNDGeoConicND *self) {
  return [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 0))) getX] * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getY] > [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 0))) getY] * [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getX];
}

void GeogebraCommonKernelKernelNDGeoConicND_setPositiveEigenvectorOrientationWithBoolean_(GeogebraCommonKernelKernelNDGeoConicND *self, jboolean flag) {
  if (flag != GeogebraCommonKernelKernelNDGeoConicND_hasPositiveEigenvectorOrientation(self)) {
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(nil_chk(self->eigenvec_), 1))) setXWithDouble:-[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getX]];
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) setYWithDouble:-[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(IOSObjectArray_Get(self->eigenvec_, 1))) getY]];
    GeogebraCommonKernelKernelNDGeoConicND_setAffineTransform(self);
  }
}

jdouble GeogebraCommonKernelKernelNDGeoConicND_evaluateWithDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble x, jdouble y) {
  return IOSDoubleArray_Get(nil_chk(self->matrix_), 2) + IOSDoubleArray_Get(self->matrix_, 4) * x + IOSDoubleArray_Get(self->matrix_, 5) * y + y * (IOSDoubleArray_Get(self->matrix_, 5) + IOSDoubleArray_Get(self->matrix_, 3) * x + IOSDoubleArray_Get(self->matrix_, 1) * y) + x * (IOSDoubleArray_Get(self->matrix_, 4) + IOSDoubleArray_Get(self->matrix_, 0) * x + IOSDoubleArray_Get(self->matrix_, 3) * y);
}

void GeogebraCommonKernelKernelNDGeoConicND_polarPointWithDouble_withDouble_withDouble_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble x, jdouble y, jdouble z, GeogebraCommonKernelGeosGeoPoint *polar) {
  if (![self isDefined]) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(polar)) setUndefined];
    return;
  }
  if (self->polarMatrix_ == nil) {
    GeogebraCommonKernelKernelNDGeoConicND_setAndConsume_polarMatrix_(self, new_GeogebraCommonUtilGgbMat_initWithInt_withInt_(3, 3));
  }
  [((GeogebraCommonUtilGgbMat *) nil_chk(self->polarMatrix_)) set3x3fromConicWithDoubleArray:self->matrix_];
  [self->polarMatrix_ inverseImmediate];
  if ([self->polarMatrix_ isUndefined]) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(polar)) setUndefined];
    return;
  }
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(polar)) setCoordsWithDouble:[self->polarMatrix_ getEntryWithInt:0 withInt:0] * x + [self->polarMatrix_ getEntryWithInt:0 withInt:1] * y + [self->polarMatrix_ getEntryWithInt:0 withInt:2] * z withDouble:[self->polarMatrix_ getEntryWithInt:1 withInt:0] * x + [self->polarMatrix_ getEntryWithInt:1 withInt:1] * y + [self->polarMatrix_ getEntryWithInt:1 withInt:2] * z withDouble:[self->polarMatrix_ getEntryWithInt:2 withInt:0] * x + [self->polarMatrix_ getEntryWithInt:2 withInt:1] * y + [self->polarMatrix_ getEntryWithInt:2 withInt:2] * z];
}

void GeogebraCommonKernelKernelNDGeoConicND_diameterLineWithDouble_withDouble_withGeogebraCommonKernelGeosGeoLine_(GeogebraCommonKernelKernelNDGeoConicND *self, jdouble vx, jdouble vy, GeogebraCommonKernelGeosGeoLine *diameter) {
  ((GeogebraCommonKernelGeosGeoLine *) nil_chk(diameter))->x_ = IOSDoubleArray_Get(nil_chk(self->matrix_), 0) * vx + IOSDoubleArray_Get(self->matrix_, 3) * vy;
  diameter->y_ = IOSDoubleArray_Get(self->matrix_, 3) * vx + IOSDoubleArray_Get(self->matrix_, 1) * vy;
  diameter->z_ = IOSDoubleArray_Get(self->matrix_, 4) * vx + IOSDoubleArray_Get(self->matrix_, 5) * vy;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelKernelNDGeoConicND)
