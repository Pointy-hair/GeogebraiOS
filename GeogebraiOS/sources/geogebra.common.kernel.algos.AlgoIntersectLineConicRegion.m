//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/algos/AlgoIntersectLineConicRegion.java
//


#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/euclidian/EuclidianConstants.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/PathParameter.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoIntersectLineConic.h"
#include "geogebra/common/kernel/algos/AlgoIntersectLineConicRegion.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoConic.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoRay.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "java/lang/Double.h"

@interface GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion () {
 @public
  IOSObjectArray *lines_;
  jint numberOfLineParts_;
  jint numberOfOutputLines_;
  JavaLangDouble *tMin_, *tMax_;
  jboolean currentPartIsInRegion_;
}

+ (jboolean)inOpenIntervalWithDouble:(jdouble)t
                          withDouble:(jdouble)a
                          withDouble:(jdouble)b;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion, lines_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion, tMin_, JavaLangDouble *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion, tMax_, JavaLangDouble *)

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(jdouble t, jdouble a, jdouble b);

@implementation GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion

- (GeogebraCommonKernelCommandsCommandsEnum *)getClassName {
  return GeogebraCommonKernelCommandsCommandsEnum_get_IntersectPath();
}

- (jint)getRelatedModeID {
  return GeogebraCommonEuclidianEuclidianConstants_MODE_INTERSECTION_CURVE;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                                       withNSStringArray:(IOSObjectArray *)labels
                     withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)g
                    withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c {
  GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_initWithGeogebraCommonKernelConstruction_withNSStringArray_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(self, cons, labels, g, c);
  return self;
}

- (void)initElements {
  [super initElements];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(P_))->size_; i++) {
    [self setOutputDependenciesWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(P_, i)];
  }
  GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_set_tMin_(self, JavaLangDouble_valueOfWithDouble_([((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_)) getMinParameter]));
  GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_set_tMax_(self, JavaLangDouble_valueOfWithDouble_([g_ getMaxParameter]));
  GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_setAndConsume_lines_(self, [IOSObjectArray newArrayWithLength:4 type:GeogebraCommonKernelGeosGeoLine_class_()]);
  IOSObjectArray_Set(lines_, 0, (GeogebraCommonKernelGeosGeoLine *) check_class_cast([g_ copyInternalWithGeogebraCommonKernelConstruction:cons_], [GeogebraCommonKernelGeosGeoLine class]));
  if (JavaLangDouble_isInfiniteWithDouble_([tMin_ doubleValue])) IOSObjectArray_SetAndConsume(lines_, 1, new_GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_(cons_));
  else IOSObjectArray_SetAndConsume(lines_, 1, new_GeogebraCommonKernelGeosGeoSegment_initWithGeogebraCommonKernelConstruction_(cons_));
  IOSObjectArray_SetAndConsume(lines_, 2, new_GeogebraCommonKernelGeosGeoSegment_initWithGeogebraCommonKernelConstruction_(cons_));
  if (JavaLangDouble_isInfiniteWithDouble_([tMax_ doubleValue])) IOSObjectArray_SetAndConsume(lines_, 3, new_GeogebraCommonKernelGeosGeoRay_initWithGeogebraCommonKernelConstruction_(cons_));
  else IOSObjectArray_SetAndConsume(lines_, 3, new_GeogebraCommonKernelGeosGeoSegment_initWithGeogebraCommonKernelConstruction_(cons_));
  for (jint i = 0; i < 4; i++) {
    [self setOutputDependenciesWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(lines_, i)];
  }
}

- (IOSObjectArray *)getIntersectionLines {
  IOSObjectArray *ret = [IOSObjectArray arrayWithLength:numberOfOutputLines_ type:GeogebraCommonKernelGeosGeoLine_class_()];
  for (jint i = 0; i < numberOfOutputLines_; i++) {
    IOSObjectArray_Set(ret, i, (GeogebraCommonKernelGeosGeoLine *) check_class_cast([super getOutputWithInt:i], [GeogebraCommonKernelGeosGeoLine class]));
  }
  return ret;
}

- (jint)getNumOfLineParts {
  return numberOfLineParts_;
}

- (jint)getOutputSize {
  return numberOfOutputLines_;
}

- (void)compute {
  [super compute];
  numberOfOutputLines_ = 0;
  [self initCurrentPartIsInRegion];
  {
    jdouble t1;
    jdouble t2;
    jint j0;
    jint j1;
    switch (intersectionType_) {
      case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PRODUCING_LINE:
      case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_ASYMPTOTIC_LINE:
      case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PASSING_LINE:
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 1))) setUndefined];
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 2))) setUndefined];
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 3))) setUndefined];
      if (!currentPartIsInRegion_) [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 0))) setUndefined];
      else {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 0))) setWithGeogebraCommonKernelGeosGeoElement:g_];
        numberOfOutputLines_++;
      }
      break;
      case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_MEETING_LINE:
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) setUndefined];
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 2))) setUndefined];
      if (currentPartIsInRegion_) {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 3))) setUndefined];
        jdouble t = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_)) getPossibleParameterWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(Q_), 0))) getCoords]];
        if ([((JavaLangDouble *) nil_chk(tMin_)) isInfinite]) {
          [((GeogebraCommonKernelGeosGeoRay *) nil_chk(((GeogebraCommonKernelGeosGeoRay *) check_class_cast(IOSObjectArray_Get(lines_, 1), [GeogebraCommonKernelGeosGeoRay class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, 0) withGeogebraCommonKernelGeosGeoVec3D:g_];
          [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) changeSign];
          numberOfOutputLines_++;
        }
        else {
          if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([tMin_ doubleValue], t)) [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) setUndefined];
          else {
            [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(((GeogebraCommonKernelGeosGeoSegment *) check_class_cast(IOSObjectArray_Get(lines_, 3), [GeogebraCommonKernelGeosGeoSegment class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, 0) withGeogebraCommonKernelGeosGeoPoint:g_->endPoint_ withGeogebraCommonKernelGeosGeoVec3D:g_];
            numberOfOutputLines_++;
          }
        }
      }
      else {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) setUndefined];
        jdouble t = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_)) getPossibleParameterWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(Q_), 0))) getCoords]];
        if ([((JavaLangDouble *) nil_chk(tMax_)) isInfinite]) {
          [((GeogebraCommonKernelGeosGeoRay *) nil_chk(((GeogebraCommonKernelGeosGeoRay *) check_class_cast(IOSObjectArray_Get(lines_, 3), [GeogebraCommonKernelGeosGeoRay class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, 0) withGeogebraCommonKernelGeosGeoVec3D:g_];
          numberOfOutputLines_++;
        }
        else {
          if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([((JavaLangDouble *) nil_chk(tMin_)) doubleValue], t)) [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) setUndefined];
          else {
            [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(((GeogebraCommonKernelGeosGeoSegment *) check_class_cast(IOSObjectArray_Get(lines_, 3), [GeogebraCommonKernelGeosGeoSegment class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, 0) withGeogebraCommonKernelGeosGeoPoint:g_->endPoint_ withGeogebraCommonKernelGeosGeoVec3D:g_];
            numberOfOutputLines_++;
          }
        }
      }
      break;
      case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_TANGENT_LINE:
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) setUndefined];
      if (currentPartIsInRegion_) {
        jdouble t = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_)) getPossibleParameterWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(Q_), 0))) getCoords]];
        if ([((JavaLangDouble *) nil_chk(tMin_)) isInfinite]) {
          [((GeogebraCommonKernelGeosGeoRay *) nil_chk(((GeogebraCommonKernelGeosGeoRay *) check_class_cast(IOSObjectArray_Get(lines_, 1), [GeogebraCommonKernelGeosGeoRay class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, 0) withGeogebraCommonKernelGeosGeoVec3D:g_];
          [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) changeSign];
          numberOfOutputLines_++;
        }
        else {
          if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([tMin_ doubleValue], t)) [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) setUndefined];
          else {
            [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(((GeogebraCommonKernelGeosGeoSegment *) check_class_cast(IOSObjectArray_Get(lines_, 3), [GeogebraCommonKernelGeosGeoSegment class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, 0) withGeogebraCommonKernelGeosGeoPoint:g_->endPoint_ withGeogebraCommonKernelGeosGeoVec3D:g_];
            numberOfOutputLines_++;
          }
        }
        if ([((JavaLangDouble *) nil_chk(tMax_)) isInfinite]) {
          [((GeogebraCommonKernelGeosGeoRay *) nil_chk(((GeogebraCommonKernelGeosGeoRay *) check_class_cast(IOSObjectArray_Get(lines_, 3), [GeogebraCommonKernelGeosGeoRay class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, 0) withGeogebraCommonKernelGeosGeoVec3D:g_];
          numberOfOutputLines_++;
        }
        else {
          if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([tMin_ doubleValue], t)) [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) setUndefined];
          else {
            [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(((GeogebraCommonKernelGeosGeoSegment *) check_class_cast(IOSObjectArray_Get(lines_, 3), [GeogebraCommonKernelGeosGeoSegment class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, 0) withGeogebraCommonKernelGeosGeoPoint:g_->endPoint_ withGeogebraCommonKernelGeosGeoVec3D:g_];
            numberOfOutputLines_++;
          }
        }
      }
      else {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) setUndefined];
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 3))) setUndefined];
      }
      break;
      case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_SECANT_LINE:
      t1 = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_)) getPossibleParameterWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(Q_), 0))) getCoords]];
      t2 = [g_ getPossibleParameterWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(Q_, 1))) getCoords]];
      j0 = 0;
      j1 = 1;
      if (t1 > t2) {
        jdouble temp = t1;
        t1 = t2;
        t2 = temp;
        j1 = 0;
        j0 = 1;
      }
      [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(lines_), 0))) setUndefined];
      if (currentPartIsInRegion_) {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 2))) setUndefined];
        if ([((JavaLangDouble *) nil_chk(tMin_)) isInfinite]) {
          [((GeogebraCommonKernelGeosGeoRay *) nil_chk(((GeogebraCommonKernelGeosGeoRay *) check_class_cast(IOSObjectArray_Get(lines_, 1), [GeogebraCommonKernelGeosGeoRay class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, j0) withGeogebraCommonKernelGeosGeoVec3D:g_];
          [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) changeSign];
          numberOfOutputLines_++;
        }
        else {
          if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([tMin_ doubleValue], t1)) [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) setUndefined];
          else {
            [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(((GeogebraCommonKernelGeosGeoSegment *) check_class_cast(IOSObjectArray_Get(lines_, 1), [GeogebraCommonKernelGeosGeoSegment class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, j0) withGeogebraCommonKernelGeosGeoPoint:g_->endPoint_ withGeogebraCommonKernelGeosGeoVec3D:g_];
            numberOfOutputLines_++;
          }
        }
        if ([((JavaLangDouble *) nil_chk(tMax_)) isInfinite]) {
          [((GeogebraCommonKernelGeosGeoRay *) nil_chk(((GeogebraCommonKernelGeosGeoRay *) check_class_cast(IOSObjectArray_Get(lines_, 3), [GeogebraCommonKernelGeosGeoRay class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, j1) withGeogebraCommonKernelGeosGeoVec3D:g_];
          numberOfOutputLines_++;
        }
        else {
          if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(t2, [tMax_ doubleValue])) [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 3))) setUndefined];
          else {
            [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(((GeogebraCommonKernelGeosGeoSegment *) check_class_cast(IOSObjectArray_Get(lines_, 3), [GeogebraCommonKernelGeosGeoSegment class])))) setWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q_, j1) withGeogebraCommonKernelGeosGeoPoint:g_->endPoint_ withGeogebraCommonKernelGeosGeoVec3D:g_];
            numberOfOutputLines_++;
          }
        }
      }
      else {
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 1))) setUndefined];
        [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 3))) setUndefined];
        if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(t1, [((JavaLangDouble *) nil_chk(tMax_)) doubleValue]) || GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([((JavaLangDouble *) nil_chk(tMin_)) doubleValue], t2)) [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, 2))) setUndefined];
        else {
          [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(((GeogebraCommonKernelGeosGeoSegment *) check_class_cast(IOSObjectArray_Get(lines_, 2), [GeogebraCommonKernelGeosGeoSegment class])))) setWithGeogebraCommonKernelGeosGeoPoint:GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([tMin_ doubleValue], t1) ? g_->startPoint_ : IOSObjectArray_Get(Q_, j0) withGeogebraCommonKernelGeosGeoPoint:GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(t2, [tMax_ doubleValue]) ? g_->endPoint_ : IOSObjectArray_Get(Q_, j1) withGeogebraCommonKernelGeosGeoVec3D:g_];
          numberOfOutputLines_++;
        }
      }
      break;
    }
  }
  [self refreshOutput];
}

- (void)refreshOutput {
  [super setOutputLengthWithInt:numberOfOutputLines_];
  jint index = 0;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(lines_))->size_; i++) {
    if ([((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(lines_, i))) isDefined]) {
      [super setOutputWithInt:index withGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(lines_, i)];
      index++;
    }
  }
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_setAndConsume_input_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoElement_class_()]);
  IOSObjectArray_Set(input_, 0, c_);
  IOSObjectArray_Set(input_, 1, g_);
  [self setDependencies];
}

+ (jboolean)inOpenIntervalWithDouble:(jdouble)t
                          withDouble:(jdouble)a
                          withDouble:(jdouble)b {
  return GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t, a, b);
}

- (void)initCurrentPartIsInRegion {
  switch (intersectionType_) {
    case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PRODUCING_LINE:
    case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_ASYMPTOTIC_LINE:
    case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_PASSING_LINE:
    numberOfLineParts_ = 1;
    break;
    case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_MEETING_LINE:
    numberOfLineParts_ = 2;
    break;
    case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_TANGENT_LINE:
    case GeogebraCommonKernelAlgosAlgoIntersectLineConic_INTERSECTION_SECANT_LINE:
    numberOfLineParts_ = 3;
    break;
    default:
    numberOfLineParts_ = -1;
  }
  currentPartIsInRegion_ = NO;
  GeogebraCommonKernelMatrixCoords *ex = nil;
  jdouble t0, t1 = 0;
  switch (((GeogebraCommonKernelGeosGeoConic *) nil_chk(c_))->type_) {
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
    ex = [c_ getEigenvecWithInt:0];
    if (numberOfLineParts_ == 2) {
      currentPartIsInRegion_ = GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(0, [((GeogebraCommonKernelMatrixCoords *) nil_chk([((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_)) getCoords])) dotproductWithGeogebraCommonKernelMatrixCoords:ex]);
    }
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
    ex = [c_ getEigenvecWithInt:0];
    if (numberOfLineParts_ == 2) {
      [c_ pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(nil_chk(Q_), 0)];
      t0 = [((GeogebraCommonKernelPathParameter *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(Q_, 0))) getPathParameter])) getT];
      currentPartIsInRegion_ = (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(1, t0) ^ GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([((GeogebraCommonKernelMatrixCoords *) nil_chk([((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_)) getCoords])) dotproductWithGeogebraCommonKernelMatrixCoords:ex], 0));
    }
    else if (numberOfLineParts_ == 3) {
      [c_ pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(nil_chk(Q_), 0)];
      [c_ pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(Q_, 1)];
      t0 = [((GeogebraCommonKernelPathParameter *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(Q_, 0))) getPathParameter])) getT];
      t1 = [((GeogebraCommonKernelPathParameter *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(Q_, 1))) getPathParameter])) getT];
      currentPartIsInRegion_ = (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(1, t0) ^ GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(1, t1));
    }
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
    if (numberOfLineParts_ == 1) {
      currentPartIsInRegion_ = YES;
    }
    else if (numberOfLineParts_ == 2) {
      [c_ pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(nil_chk(Q_), 0)];
      t0 = [((GeogebraCommonKernelPathParameter *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(Q_, 0))) getPathParameter])) getT];
      currentPartIsInRegion_ = ((GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t0, 1, 2) || GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t0, -1, 0)) ^ GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_([((GeogebraCommonKernelMatrixCoords *) nil_chk([((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_)) getCoords])) dotproductWithGeogebraCommonKernelMatrixCoords:ex], 0));
    }
    else if (numberOfLineParts_ == 3) {
      [c_ pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(nil_chk(Q_), 0)];
      [c_ pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(Q_, 1)];
      t0 = [((GeogebraCommonKernelPathParameter *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(Q_, 0))) getPathParameter])) getT];
      t1 = [((GeogebraCommonKernelPathParameter *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(Q_, 1))) getPathParameter])) getT];
      currentPartIsInRegion_ = ((GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t0, -1, 0) && GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t1, 1, 2)) || (GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t1, -1, 0) && GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t0, 1, 2)) || (GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t0, 0, 1) && GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t1, 2, 3)) || (GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t1, 0, 1) && GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(t0, 2, 3)));
    }
    break;
    case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
    if (numberOfLineParts_ == 1) {
      if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(-((GeogebraCommonKernelGeosGeoLine *) nil_chk(g_))->z_ / ((g_->x_) * (g_->x_) + (g_->y_) * (g_->y_)), 0)) currentPartIsInRegion_ = YES;
    }
    break;
    default:
    break;
  }
  currentPartIsInRegion_ ^= [c_ isInverseFill];
}

- (void)dealloc {
  RELEASE_(lines_);
  RELEASE_(labelPrefixForLines_);
  RELEASE_(tMin_);
  RELEASE_(tMax_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getClassName", NULL, "Lgeogebra.common.kernel.commands.Commands;", 0x1, NULL, NULL },
    { "getRelatedModeID", NULL, "I", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withNSStringArray:withGeogebraCommonKernelGeosGeoLine:withGeogebraCommonKernelGeosGeoConic:", "AlgoIntersectLineConicRegion", NULL, 0x1, NULL, NULL },
    { "initElements", NULL, "V", 0x4, NULL, NULL },
    { "getIntersectionLines", NULL, "[Lgeogebra.common.kernel.geos.GeoLine;", 0x1, NULL, NULL },
    { "getNumOfLineParts", NULL, "I", 0x1, NULL, NULL },
    { "getOutputSize", NULL, "I", 0x1, NULL, NULL },
    { "compute", NULL, "V", 0x1, NULL, NULL },
    { "refreshOutput", NULL, "V", 0x4, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x1, NULL, NULL },
    { "inOpenIntervalWithDouble:withDouble:withDouble:", "inOpenInterval", "Z", 0xa, NULL, NULL },
    { "initCurrentPartIsInRegion", NULL, "V", 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "lines_", NULL, 0x2, "[Lgeogebra.common.kernel.geos.GeoLine;", NULL, NULL,  },
    { "numberOfLineParts_", NULL, 0x2, "I", NULL, NULL,  },
    { "numberOfOutputLines_", NULL, 0x2, "I", NULL, NULL,  },
    { "labelPrefixForLines_", NULL, 0x0, "Ljava.lang.String;", NULL, NULL,  },
    { "tMin_", NULL, 0x2, "Ljava.lang.Double;", NULL, NULL,  },
    { "tMax_", NULL, 0x2, "Ljava.lang.Double;", NULL, NULL,  },
    { "currentPartIsInRegion_", NULL, 0x2, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion = { 2, "AlgoIntersectLineConicRegion", "geogebra.common.kernel.algos", NULL, 0x1, 12, methods, 7, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion;
}

@end

void GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_initWithGeogebraCommonKernelConstruction_withNSStringArray_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion *self, GeogebraCommonKernelConstruction *cons, IOSObjectArray *labels, GeogebraCommonKernelGeosGeoLine *g, GeogebraCommonKernelGeosGeoConic *c) {
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(self, cons, g, c);
  GeogebraCommonKernelGeosGeoElement_setLabelsWithNSStringArray_withGeogebraCommonKernelGeosGeoElementArray_(labels, [self getIntersectionLines]);
}

GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion *new_GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_initWithGeogebraCommonKernelConstruction_withNSStringArray_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(GeogebraCommonKernelConstruction *cons, IOSObjectArray *labels, GeogebraCommonKernelGeosGeoLine *g, GeogebraCommonKernelGeosGeoConic *c) {
  GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion *self = [GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion alloc];
  GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_initWithGeogebraCommonKernelConstruction_withNSStringArray_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoConic_(self, cons, labels, g, c);
  return self;
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_inOpenIntervalWithDouble_withDouble_withDouble_(jdouble t, jdouble a, jdouble b) {
  GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion_initialize();
  return GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(b, t) && GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(t, a);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelAlgosAlgoIntersectLineConicRegion)
