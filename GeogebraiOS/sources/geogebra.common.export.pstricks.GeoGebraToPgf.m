//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/export/pstricks/GeoGebraToPgf.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GAffineTransform.h"
#include "geogebra/common/awt/GColor.h"
#include "geogebra/common/awt/GFont.h"
#include "geogebra/common/awt/GRectangle.h"
#include "geogebra/common/euclidian/DrawableND.h"
#include "geogebra/common/euclidian/EuclidianView.h"
#include "geogebra/common/euclidian/draw/DrawPoint.h"
#include "geogebra/common/export/pstricks/ExportSettings.h"
#include "geogebra/common/export/pstricks/GeoGebraExport.h"
#include "geogebra/common/export/pstricks/GeoGebraToPgf.h"
#include "geogebra/common/export/pstricks/UnicodeTeX.h"
#include "geogebra/common/factories/AwtFactory.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/MyPoint.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoAngleLines.h"
#include "geogebra/common/kernel/algos/AlgoAnglePoints.h"
#include "geogebra/common/kernel/algos/AlgoAngleVector.h"
#include "geogebra/common/kernel/algos/AlgoAngleVectors.h"
#include "geogebra/common/kernel/algos/AlgoBoxPlot.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoFunctionAreaSums.h"
#include "geogebra/common/kernel/algos/AlgoIntegralFunctions.h"
#include "geogebra/common/kernel/algos/AlgoIntersectAbstract.h"
#include "geogebra/common/kernel/algos/AlgoSlope.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/cas/AlgoIntegralDefinite.h"
#include "geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "geogebra/common/kernel/geos/GeoAngle.h"
#include "geogebra/common/kernel/geos/GeoConic.h"
#include "geogebra/common/kernel/geos/GeoConicPart.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoLocus.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoPolyLine.h"
#include "geogebra/common/kernel/geos/GeoPolygon.h"
#include "geogebra/common/kernel/geos/GeoRay.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/geos/GeoText.h"
#include "geogebra/common/kernel/geos/GeoTransferFunction.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/kernel/geos/GeoVec3D.h"
#include "geogebra/common/kernel/geos/GeoVector.h"
#include "geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/kernelND/GeoVectorND.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/plugin/EuclidianStyleConstants.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/util/GStringTokenizer.h"
#include "geogebra/common/util/StringUtil.h"
#include "geogebra/common/util/Unicode.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/Iterator.h"
#include "org/apache/commons/math/fraction/Fraction.h"

#define GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX 0
#define GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX 1
#define GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT 2
#define GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_BEAMER 3

@interface GeogebraCommonExportPstricksGeoGebraToPgf () {
 @public
  jint functionIdentifier_;
  jboolean forceGnuplot_;
  jboolean gnuplotWarning_;
  jboolean hatchWarning_;
}

- (void)addTextWithNSString:(NSString *)st
                withBoolean:(jboolean)isLatex
                    withInt:(jint)style;

- (void)drawFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                  withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                                withBoolean:(jboolean)integral
                     withGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo1;

- (jboolean)isTrigInvWithNSString:(NSString *)s;

- (IOSBooleanArray *)hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)en;

- (void)drawPgfStandardWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                     withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                                  withNSString:(NSString *)value
                                                    withDouble:(jdouble)xrangemax
                                                    withDouble:(jdouble)xrangemin;

- (void)drawGnuPlotWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                 withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                              withNSString:(NSString *)value
                                                withDouble:(jdouble)xrangemax
                                                withDouble:(jdouble)xrangemin;

- (void)drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                         withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                                        withDouble:(jdouble)xrangemax
                                                        withDouble:(jdouble)xrangemin
                                                       withBoolean:(jboolean)integral
                            withGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo1;

- (void)drawSingleCurveWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)geo
                                           withJavaLangStringBuilder:(JavaLangStringBuilder *)sb;

+ (NSString *)replaceXWithNSString:(NSString *)name
                      withNSString:(NSString *)substitute;

+ (NSString *)killSpaceWithNSString:(NSString *)name;

- (jboolean)warningFuncWithNSString:(NSString *)sb
                       withNSString:(NSString *)nameFunc;

- (void)addWarningGnuplot;

- (void)addWarningHatch;

+ (void)renameFuncWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                               withNSString:(NSString *)nameFunc
                               withNSString:(NSString *)nameNew;

- (jdouble)maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                       withDouble:(jdouble)a
                                                       withDouble:(jdouble)b;

- (jdouble)firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                         withDouble:(jdouble)a
                                                         withDouble:(jdouble)b;

- (void)drawCircleWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)geo;

- (void)drawGrid;

- (void)drawAxis;

- (NSString *)getUnitWithNSStringArray:(IOSObjectArray *)units
                            withDouble:(jdouble)spaceTick
                               withInt:(jint)xy;

- (jboolean)hasMeasureUnitWithNSStringArray:(IOSObjectArray *)units
                                 withDouble:(jdouble)spaceTick
                                    withInt:(jint)xy;

- (NSString *)footnotesizeWithNSString:(NSString *)s;

- (void)writePointWithDouble:(jdouble)x
                  withDouble:(jdouble)y
   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb;

- (void)LinestyleCodeWithInt:(jint)linestyle
   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb;

- (NSString *)handleAxesStyle;

@end

J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonExportPstricksGeoGebraToPgf, FORMAT_LATEX, jint)

J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonExportPstricksGeoGebraToPgf, FORMAT_PLAIN_TEX, jint)

J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonExportPstricksGeoGebraToPgf, FORMAT_CONTEXT, jint)

J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonExportPstricksGeoGebraToPgf, FORMAT_BEAMER, jint)

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_addTextWithNSString_withBoolean_withInt_(GeogebraCommonExportPstricksGeoGebraToPgf *self, NSString *st, jboolean isLatex, jint style);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_drawFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *geo, JavaLangStringBuilder *sb, jboolean integral, GeogebraCommonKernelGeosGeoNumeric *geo1);

__attribute__((unused)) static jboolean GeogebraCommonExportPstricksGeoGebraToPgf_isTrigInvWithNSString_(GeogebraCommonExportPstricksGeoGebraToPgf *self, NSString *s);

__attribute__((unused)) static IOSBooleanArray *GeogebraCommonExportPstricksGeoGebraToPgf_hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelArithmeticExpressionNode *en);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_drawPgfStandardWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withNSString_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *geo, JavaLangStringBuilder *sb, NSString *value, jdouble xrangemax, jdouble xrangemin);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_drawGnuPlotWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withNSString_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *geo, JavaLangStringBuilder *sb, NSString *value, jdouble xrangemax, jdouble xrangemin);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withDouble_withDouble_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *geo, JavaLangStringBuilder *sb, jdouble xrangemax, jdouble xrangemin, jboolean integral, GeogebraCommonKernelGeosGeoNumeric *geo1);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_drawSingleCurveWithGeogebraCommonKernelGeosGeoCurveCartesian_withJavaLangStringBuilder_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoCurveCartesian *geo, JavaLangStringBuilder *sb);

__attribute__((unused)) static NSString *GeogebraCommonExportPstricksGeoGebraToPgf_replaceXWithNSString_withNSString_(NSString *name, NSString *substitute);

__attribute__((unused)) static NSString *GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(NSString *name);

__attribute__((unused)) static jboolean GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(GeogebraCommonExportPstricksGeoGebraToPgf *self, NSString *sb, NSString *nameFunc);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_addWarningGnuplot(GeogebraCommonExportPstricksGeoGebraToPgf *self);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_addWarningHatch(GeogebraCommonExportPstricksGeoGebraToPgf *self);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(JavaLangStringBuilder *sb, NSString *nameFunc, NSString *nameNew);

__attribute__((unused)) static jdouble GeogebraCommonExportPstricksGeoGebraToPgf_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b);

__attribute__((unused)) static jdouble GeogebraCommonExportPstricksGeoGebraToPgf_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_drawCircleWithGeogebraCommonKernelGeosGeoConic_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoConic *geo);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_drawGrid(GeogebraCommonExportPstricksGeoGebraToPgf *self);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_drawAxis(GeogebraCommonExportPstricksGeoGebraToPgf *self);

__attribute__((unused)) static NSString *GeogebraCommonExportPstricksGeoGebraToPgf_getUnitWithNSStringArray_withDouble_withInt_(GeogebraCommonExportPstricksGeoGebraToPgf *self, IOSObjectArray *units, jdouble spaceTick, jint xy);

__attribute__((unused)) static jboolean GeogebraCommonExportPstricksGeoGebraToPgf_hasMeasureUnitWithNSStringArray_withDouble_withInt_(GeogebraCommonExportPstricksGeoGebraToPgf *self, IOSObjectArray *units, jdouble spaceTick, jint xy);

__attribute__((unused)) static NSString *GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(GeogebraCommonExportPstricksGeoGebraToPgf *self, NSString *s);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(GeogebraCommonExportPstricksGeoGebraToPgf *self, jdouble x, jdouble y, JavaLangStringBuilder *sb);

__attribute__((unused)) static void GeogebraCommonExportPstricksGeoGebraToPgf_LinestyleCodeWithInt_withJavaLangStringBuilder_(GeogebraCommonExportPstricksGeoGebraToPgf *self, jint linestyle, JavaLangStringBuilder *sb);

__attribute__((unused)) static NSString *GeogebraCommonExportPstricksGeoGebraToPgf_handleAxesStyle(GeogebraCommonExportPstricksGeoGebraToPgf *self);

@implementation GeogebraCommonExportPstricksGeoGebraToPgf

- (instancetype)initWithGeogebraCommonMainApp:(GeogebraCommonMainApp *)app {
  GeogebraCommonExportPstricksGeoGebraToPgf_initWithGeogebraCommonMainApp_(self, app);
  return self;
}

- (void)generateAllCode {
  format__ = [((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) getFormat];
  forceGnuplot_ = [frame_ getGnuplot];
  @try {
    xunit_ = [frame_ getXUnit];
    yunit_ = [frame_ getYUnit];
  }
  @catch (JavaLangNullPointerException *e2) {
    xunit_ = 1;
    yunit_ = 1;
  }
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_code_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_codePoint_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_codePreamble_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_codeFilledObject_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_codeBeginDoc_(self, new_JavaLangStringBuilder_init());
  GeogebraCommonExportPstricksGeoGebraExport_setAndConsume_CustomColor_(self, new_JavaUtilHashMap_init());
  if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX) {
    [codePreamble_ appendWithNSString:JreStrcat("$I$", @"\\documentclass[", [frame_ getFontSize], @"pt]{article}\n\\usepackage{pgf,tikz}\n\\usepackage{mathrsfs}\n\\usetikzlibrary{arrows}\n\\pagestyle{empty}\n")];
    [codeBeginDoc_ appendWithNSString:@"\\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x="];
    [codeBeginDoc_ appendWithDouble:xunit_];
    [codeBeginDoc_ appendWithNSString:@"cm,y="];
    [codeBeginDoc_ appendWithDouble:yunit_];
    [codeBeginDoc_ appendWithNSString:@"cm]\n"];
  }
  else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) {
    [codePreamble_ appendWithNSString:@"%Uncomment next line if XeTeX is used\n%\\def\\pgfsysdriver{pgfsys-xetex.def}\n\n"];
    [codePreamble_ appendWithNSString:@"\\input pgf.tex\n\\input tikz.tex\n"];
    [codePreamble_ appendWithNSString:@"\\usetikzlibrary{arrows}\n"];
    [codePreamble_ appendWithNSString:@"\\baselineskip="];
    [codePreamble_ appendWithInt:[frame_ getFontSize]];
    [codePreamble_ appendWithNSString:@"pt\n\\hsize=6.3truein\n\\vsize=8.7truein\n"];
    [codeBeginDoc_ appendWithNSString:@"\\tikzpicture[line cap=round,line join=round,>=triangle 45,x="];
    [codeBeginDoc_ appendWithDouble:xunit_];
    [codeBeginDoc_ appendWithNSString:@"cm,y="];
    [codeBeginDoc_ appendWithDouble:yunit_];
    [codeBeginDoc_ appendWithNSString:@"cm]\n"];
  }
  else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) {
    [codePreamble_ appendWithNSString:JreStrcat("$I$", @"\\setupbodyfont[", [frame_ getFontSize], @"pt]\n")];
    [codePreamble_ appendWithNSString:@"\\usemodule[tikz]\n\\usemodule[pgf]\n"];
    [codePreamble_ appendWithNSString:@"\\usetikzlibrary[arrows]\n\\setuppagenumbering[location=]\n"];
    [codeBeginDoc_ appendWithNSString:@"\\startTEXpage\n\\starttikzpicture[line cap=round,line join=round,>=triangle 45,x="];
    [codeBeginDoc_ appendWithDouble:xunit_];
    [codeBeginDoc_ appendWithNSString:@"cm,y="];
    [codeBeginDoc_ appendWithDouble:yunit_];
    [codeBeginDoc_ appendWithNSString:@"cm]\n"];
  }
  else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_BEAMER) {
    [codePreamble_ appendWithNSString:JreStrcat("$I$", @"\\documentclass[", [frame_ getFontSize], @"pt]{beamer}\n\\usepackage{pgf,tikz}\n\\usetikzlibrary{arrows}\n\\pagestyle{empty}\n")];
    [codeBeginDoc_ appendWithNSString:@"\\begin{frame}\n"];
    [codeBeginDoc_ appendWithNSString:@"\\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x="];
    [codeBeginDoc_ appendWithDouble:xunit_];
    [codeBeginDoc_ appendWithNSString:@"cm,y="];
    [codeBeginDoc_ appendWithDouble:yunit_];
    [codeBeginDoc_ appendWithNSString:@"cm]\n"];
  }
  if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_BEAMER) format__ = GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX;
  if ([((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getShowGrid]) {
    GeogebraCommonExportPstricksGeoGebraToPgf_drawGrid(self);
  }
  if ([euclidianView_ getShowXaxis] || [euclidianView_ getShowYaxis]) {
    GeogebraCommonExportPstricksGeoGebraToPgf_drawAxis(self);
  }
  [codeFilledObject_ appendWithNSString:@"\\clip"];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, xmin_, ymin_, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" rectangle "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, xmax_, ymax_, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@";\n"];
  [self drawAllElements];
  if ([codePoint_ length] != 0 && format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX) {
    [codePoint_ insertWithInt:0 withNSString:@"\\begin{scriptsize}\n"];
    [codePoint_ appendWithNSString:@"\\end{scriptsize}\n"];
  }
  [code_ appendWithJavaLangCharSequence:codePoint_];
  if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX) {
    [code_ appendWithNSString:@"\\end{tikzpicture}\n"];
    if (isBeamer_) [code_ appendWithNSString:@"\\end{frame}\n"];
    [code_ appendWithNSString:@"\\end{document}"];
    [codeBeginDoc_ insertWithInt:0 withNSString:@"\\begin{document}\n"];
  }
  else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) {
    [code_ appendWithNSString:@"\\endtikzpicture\n\\bye\n"];
  }
  else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) {
    [code_ appendWithNSString:@"\\stoptikzpicture\n\\stopTEXpage\n\\stoptext"];
    [codeBeginDoc_ insertWithInt:0 withNSString:@"\\starttext\n"];
  }
  [code_ insertWithInt:0 withNSString:JreStrcat("@", codeFilledObject_)];
  [code_ insertWithInt:0 withNSString:JreStrcat("@", codeBeginDoc_)];
  [code_ insertWithInt:0 withNSString:JreStrcat("@", codePreamble_)];
  [frame_ writeWithJavaLangStringBuilder:code_];
}

- (void)drawLocusWithGeogebraCommonKernelGeosGeoLocus:(GeogebraCommonKernelGeosGeoLocus *)g {
  JavaUtilArrayList *ll = [((GeogebraCommonKernelGeosGeoLocus *) nil_chk(g)) getPoints];
  id<JavaUtilIterator> it = [((JavaUtilArrayList *) nil_chk(ll)) iterator];
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:g withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("C$$", '[', s, @"] ");
  [code_ appendWithNSString:s];
  jboolean first = YES;
  jboolean out = NO;
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    GeogebraCommonKernelMyPoint *mp = [it next];
    jdouble x = ((GeogebraCommonKernelMyPoint *) nil_chk(mp))->x_;
    jdouble y = mp->y_;
    jboolean b = mp->lineTo_;
    if (x > xmin_ && x < xmax_ && y > ymin_ && y < ymax_) {
      if (b && !first) [code_ appendWithNSString:@" -- "];
      else if (first) first = NO;
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, code_);
      out = NO;
    }
    else if (!first && mp->lineTo_ && !out) {
      out = YES;
      [code_ appendWithNSString:@" -- "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, code_);
    }
    else {
      first = YES;
      out = NO;
    }
  }
  [code_ appendWithNSString:@";\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawBoxPlotWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelAlgosAlgoBoxPlot *algo = ((GeogebraCommonKernelAlgosAlgoBoxPlot *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoBoxPlot class]));
  jdouble y = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([((GeogebraCommonKernelAlgosAlgoBoxPlot *) nil_chk(algo)) getA])) getDouble];
  jdouble height = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble];
  IOSDoubleArray *lf = [algo getLeftBorders];
  jdouble min = IOSDoubleArray_Get(nil_chk(lf), 0);
  jdouble q1 = IOSDoubleArray_Get(lf, 1);
  jdouble med = IOSDoubleArray_Get(lf, 2);
  jdouble q3 = IOSDoubleArray_Get(lf, 3);
  jdouble max = IOSDoubleArray_Get(lf, 4);
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw "];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("C$$", '[', s, @"] ");
  [codeFilledObject_ appendWithNSString:s];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, min, y - height, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@"-- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, min, y + height, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, max, y - height, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@"-- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, max, y + height, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, med, y - height, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@"-- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, med, y + height, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, min, y, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@"-- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, q1, y, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, q3, y, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@"-- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, max, y, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@";\n"];
  if (isBeamer_) [codeFilledObject_ appendWithNSString:@"  "];
  [codeFilledObject_ appendWithNSString:@"\\draw"];
  if (((jint) [s length]) != 0) [codeFilledObject_ appendWithNSString:s];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, q1, y - height, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" rectangle "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, q3, y + height, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@";\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawSumTrapezoidalWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelAlgosAlgoFunctionAreaSums *algo = (GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoFunctionAreaSums class]);
  jint n = [((GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) nil_chk(algo)) getIntervals];
  IOSDoubleArray *y = [algo getValues];
  IOSDoubleArray *x = [algo getLeftBorder];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  for (jint i = 0; i < n; i++) {
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw"];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) [codeFilledObject_ appendWithNSString:JreStrcat("C$$", '[', s, @"] ")];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(nil_chk(x), i), 0, codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(x, i + 1), 0, codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(x, i + 1), IOSDoubleArray_Get(nil_chk(y), i + 1), codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(x, i), IOSDoubleArray_Get(y, i), codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" -- cycle;\n"];
    if (i != n - 1 && isBeamer_) [codeFilledObject_ appendWithNSString:@"  "];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawSumUpperLowerWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelAlgosAlgoFunctionAreaSums *algo = (GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoFunctionAreaSums class]);
  jint n = [((GeogebraCommonKernelAlgosAlgoFunctionAreaSums *) nil_chk(algo)) getIntervals];
  jdouble step = [algo getStep];
  IOSDoubleArray *y = [algo getValues];
  IOSDoubleArray *x = [algo getLeftBorder];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  for (jint i = 0; i < n; i++) {
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw"];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) [codeFilledObject_ appendWithNSString:JreStrcat("C$$", '[', s, @"] ")];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(nil_chk(x), i), 0, codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" rectangle "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(x, i) + step, IOSDoubleArray_Get(nil_chk(y), i), codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@";\n"];
    if (i != -1 && isBeamer_) [codeFilledObject_ appendWithNSString:@"  "];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawIntegralFunctionsWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelAlgosAlgoIntegralFunctions *algo = (GeogebraCommonKernelAlgosAlgoIntegralFunctions *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoIntegralFunctions class]);
  GeogebraCommonKernelGeosGeoFunction *f = [((GeogebraCommonKernelAlgosAlgoIntegralFunctions *) nil_chk(algo)) getF];
  GeogebraCommonKernelGeosGeoFunction *g = [algo getG];
  jdouble a = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getA])) getDouble];
  jdouble b = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble];
  jdouble fa = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) evaluateWithDouble:a];
  jdouble gb = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(g)) evaluateWithDouble:b];
  NSString *value = [f toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  value = GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(value, YES));
  jboolean plotWithGnuplot = GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"tan(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"cosh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"acosh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"asinh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"atanh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"sinh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"tanh(");
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [codeFilledObject_ appendWithNSString:JreStrcat("C$$", '[', s, @"] ")];
  }
  [codeFilledObject_ appendWithNSString:@"{"];
  if (plotWithGnuplot) {
    [codeFilledObject_ appendWithNSString:@" plot[raw gnuplot, id=func"];
    [codeFilledObject_ appendWithInt:functionIdentifier_];
    functionIdentifier_++;
    [codeFilledObject_ appendWithNSString:@"] function{set samples 100; set xrange ["];
    [codeFilledObject_ appendWithDouble:a];
    [codeFilledObject_ appendWithNSString:@":"];
    [codeFilledObject_ appendWithDouble:b];
    [codeFilledObject_ appendWithNSString:@"]; plot "];
    value = [((NSString *) nil_chk(value)) replaceAll:@"\\^" withReplacement:@"**"];
    [codeFilledObject_ appendWithNSString:value];
    [codeFilledObject_ appendWithNSString:@"}"];
  }
  else {
    [codeFilledObject_ appendWithNSString:@"["];
    [codeFilledObject_ appendWithNSString:@"smooth,samples=50,domain="];
    [codeFilledObject_ appendWithDouble:a];
    [codeFilledObject_ appendWithNSString:@":"];
    [codeFilledObject_ appendWithDouble:b];
    [codeFilledObject_ appendWithNSString:@"] plot"];
    [codeFilledObject_ appendWithNSString:@"(\\x,{"];
    value = GeogebraCommonExportPstricksGeoGebraToPgf_replaceXWithNSString_withNSString_(value, @"\\x");
    [codeFilledObject_ appendWithNSString:value];
    [codeFilledObject_ appendWithNSString:@"})"];
  }
  [codeFilledObject_ appendWithNSString:@"} -- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, b, gb, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" {"];
  value = [g toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  value = GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(value, YES));
  plotWithGnuplot = (GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"tan(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"cosh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"acosh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"asinh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"atanh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"sinh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"tanh("));
  if (plotWithGnuplot) {
    [codeFilledObject_ appendWithNSString:@"-- plot[raw gnuplot, id=func"];
    [codeFilledObject_ appendWithInt:functionIdentifier_];
    functionIdentifier_++;
    [codeFilledObject_ appendWithNSString:@"] function{set parametric ; set samples 100; set trange ["];
    [codeFilledObject_ appendWithDouble:a];
    [codeFilledObject_ appendWithNSString:@":"];
    [codeFilledObject_ appendWithDouble:b];
    [codeFilledObject_ appendWithNSString:@"]; plot "];
    NSString *variable = JreStrcat("$$", [self formatWithDouble:b + a], @"-t");
    [codeFilledObject_ appendWithNSString:variable];
    [codeFilledObject_ appendWithNSString:@","];
    value = GeogebraCommonExportPstricksGeoGebraToPgf_replaceXWithNSString_withNSString_(value, variable);
    value = [((NSString *) nil_chk(value)) replaceAll:@"\\^" withReplacement:@"**"];
    [codeFilledObject_ appendWithNSString:value];
    [codeFilledObject_ appendWithNSString:@"}"];
  }
  else {
    [codeFilledObject_ appendWithNSString:@"["];
    [codeFilledObject_ appendWithNSString:@"smooth,samples=50,domain="];
    [codeFilledObject_ appendWithDouble:b];
    [codeFilledObject_ appendWithNSString:@":"];
    [codeFilledObject_ appendWithDouble:a];
    [codeFilledObject_ appendWithNSString:@"] -- plot"];
    [codeFilledObject_ appendWithNSString:@"(\\x,{"];
    value = GeogebraCommonExportPstricksGeoGebraToPgf_replaceXWithNSString_withNSString_(value, @"\\x");
    [codeFilledObject_ appendWithNSString:value];
    [codeFilledObject_ appendWithNSString:@"})"];
  }
  [codeFilledObject_ appendWithNSString:@"} -- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, a, fa, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" -- cycle;\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawIntegralWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  GeogebraCommonKernelCasAlgoIntegralDefinite *algo = (GeogebraCommonKernelCasAlgoIntegralDefinite *) check_class_cast([((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [GeogebraCommonKernelCasAlgoIntegralDefinite class]);
  GeogebraCommonKernelGeosGeoFunction *f = [((GeogebraCommonKernelCasAlgoIntegralDefinite *) nil_chk(algo)) getFunction];
  jdouble a = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getA])) getDouble];
  jdouble b = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble];
  if (a == JavaLangDouble_NEGATIVE_INFINITY) {
    a = xmin_;
  }
  if (b == JavaLangDouble_POSITIVE_INFINITY) {
    b = xmax_;
  }
  NSString *value = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  value = GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(value, YES));
  jboolean plotWithGnuplot = GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"tan(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"cosh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"acosh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"asinh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"atanh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"sinh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"tanh(");
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  if (![self isLatexFunctionWithNSString:[f toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()]]) {
    jdouble af = xmin_;
    jdouble bf = xmax_;
    if ([f hasInterval]) {
      af = [f getIntervalMin];
      bf = [f getIntervalMax];
    }
    [f setIntervalWithDouble:a withDouble:b];
    GeogebraCommonExportPstricksGeoGebraToPgf_drawFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(self, f, code_, YES, geo);
    [f setIntervalWithDouble:af withDouble:bf];
    if ([f isEuclidianVisible]) {
      GeogebraCommonExportPstricksGeoGebraToPgf_drawFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(self, f, code_, NO, geo);
    }
  }
  else {
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw"];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
      [codeFilledObject_ appendWithNSString:@"["];
      [codeFilledObject_ appendWithNSString:s];
    }
    if (plotWithGnuplot) {
      if (((jint) [s length]) != 0) {
        [codeFilledObject_ appendWithNSString:@"]"];
      }
      [codeFilledObject_ appendWithNSString:@" plot[raw gnuplot, id=func"];
      [codeFilledObject_ appendWithInt:functionIdentifier_];
      functionIdentifier_++;
      [codeFilledObject_ appendWithNSString:@"] function{set samples 100; set xrange ["];
      [codeFilledObject_ appendWithDouble:a];
      [codeFilledObject_ appendWithNSString:@":"];
      [codeFilledObject_ appendWithDouble:b];
      [codeFilledObject_ appendWithNSString:@"]; plot "];
      value = [((NSString *) nil_chk(value)) replaceAll:@"\\^" withReplacement:@"**"];
      [codeFilledObject_ appendWithNSString:value];
      [codeFilledObject_ appendWithNSString:@"}"];
    }
    else {
      if (((jint) [s length]) != 0) [codeFilledObject_ appendWithNSString:@", "];
      else [codeFilledObject_ appendWithNSString:@"["];
      [codeFilledObject_ appendWithNSString:@"smooth,samples=50,domain="];
      [codeFilledObject_ appendWithDouble:a];
      [codeFilledObject_ appendWithNSString:@":"];
      [codeFilledObject_ appendWithDouble:b];
      [codeFilledObject_ appendWithNSString:@"] plot"];
      [codeFilledObject_ appendWithNSString:@"(\\x,{"];
      value = GeogebraCommonExportPstricksGeoGebraToPgf_replaceXWithNSString_withNSString_(value, @"\\x");
      [codeFilledObject_ appendWithNSString:value];
      [codeFilledObject_ appendWithNSString:@"})"];
    }
    [codeFilledObject_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, b, 0, codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, a, 0, codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" -- cycle;\n"];
    [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
  }
}

- (void)drawSlopeWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  jint slopeTriangleSize = [((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getSlopeTriangleSize];
  jdouble rwHeight = [geo getValue] * slopeTriangleSize;
  jdouble height = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getYscale] * rwHeight;
  IOSDoubleArray *coords = [IOSDoubleArray arrayWithLength:2];
  if (JavaLangMath_absWithDouble_(height) > JavaLangFloat_MAX_VALUE) {
    return;
  }
  GeogebraCommonKernelGeosGeoLine *g = [((GeogebraCommonKernelAlgosAlgoSlope *) nil_chk(((GeogebraCommonKernelAlgosAlgoSlope *) check_class_cast([geo getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoSlope class])))) getg];
  [((GeogebraCommonKernelGeosGeoLine *) nil_chk(g)) getInhomPointOnLineWithDoubleArray:coords];
  jfloat x = (jfloat) IOSDoubleArray_Get(coords, 0);
  jfloat y = (jfloat) IOSDoubleArray_Get(coords, 1);
  jfloat xright = x + slopeTriangleSize;
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [codeFilledObject_ appendWithNSString:JreStrcat("C$$", '[', s, @"] ")];
  }
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" -- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, xright, y, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@" -- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, xright, y + rwHeight, codeFilledObject_);
  [codeFilledObject_ appendWithNSString:@";\n"];
  jfloat xLabelHor = (x + xright) / 2;
  jfloat yLabelHor = y - (jfloat) (([((GeogebraCommonAwtGFont *) nil_chk([euclidianView_ getFont])) getSize] + 2) / [euclidianView_ getYscale]);
  GeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
  [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw[color="];
  [self ColorCodeWithGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:codePoint_];
  [codePoint_ appendWithNSString:@"] "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, xLabelHor, yLabelHor, codePoint_);
  [codePoint_ appendWithNSString:@" node[anchor=south west] {"];
  [codePoint_ appendWithInt:slopeTriangleSize];
  [codePoint_ appendWithNSString:@"};\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawAngleWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo {
  jint arcSize = [((GeogebraCommonKernelGeosGeoAngle *) nil_chk(geo)) getArcSize];
  GeogebraCommonKernelAlgosAlgoElement *algo = [geo getParentAlgorithm];
  id<GeogebraCommonKernelKernelNDGeoPointND> vertex, point;
  id<GeogebraCommonKernelKernelNDGeoVectorND> v;
  GeogebraCommonKernelGeosGeoLine *line, *line2;
  GeogebraCommonKernelGeosGeoPoint *tempPoint = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(construction_) autorelease];
  [tempPoint setCoordsWithDouble:0.0 withDouble:0.0 withDouble:1.0];
  IOSDoubleArray *firstVec = [IOSDoubleArray arrayWithLength:2];
  IOSDoubleArray *m = [IOSDoubleArray arrayWithLength:2];
  if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoAnglePoints class]]) {
    GeogebraCommonKernelAlgosAlgoAnglePoints *pa = (GeogebraCommonKernelAlgosAlgoAnglePoints *) check_class_cast(algo, [GeogebraCommonKernelAlgosAlgoAnglePoints class]);
    vertex = [((GeogebraCommonKernelAlgosAlgoAnglePoints *) nil_chk(pa)) getB];
    point = [pa getA];
    [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(point)) getInhomCoordsInD3];
    *IOSDoubleArray_GetRef(firstVec, 0) = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] - IOSDoubleArray_Get(m, 0);
    *IOSDoubleArray_GetRef(firstVec, 1) = [coords getY] - IOSDoubleArray_Get(m, 1);
  }
  else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoAngleVectors class]]) {
    GeogebraCommonKernelAlgosAlgoAngleVectors *va = (GeogebraCommonKernelAlgosAlgoAngleVectors *) check_class_cast(algo, [GeogebraCommonKernelAlgosAlgoAngleVectors class]);
    v = [((GeogebraCommonKernelAlgosAlgoAngleVectors *) nil_chk(va)) getv];
    vertex = [((id<GeogebraCommonKernelKernelNDGeoVectorND>) nil_chk(v)) getStartPoint];
    if (vertex == nil) vertex = tempPoint;
    [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    [v getInhomCoordsWithDoubleArray:firstVec];
  }
  else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoAngleLines class]]) {
    GeogebraCommonKernelAlgosAlgoAngleLines *la = (GeogebraCommonKernelAlgosAlgoAngleLines *) check_class_cast(algo, [GeogebraCommonKernelAlgosAlgoAngleLines class]);
    vertex = tempPoint;
    [((GeogebraCommonKernelAlgosAlgoAngleLines *) nil_chk(la)) updateDrawInfoWithDoubleArray:m withDoubleArray:firstVec withGeogebraCommonEuclidianDrawDrawAngle:nil];
  }
  else if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoAngleVector class]]) {
    GeogebraCommonKernelAlgosAlgoAngleVector *va = (GeogebraCommonKernelAlgosAlgoAngleVector *) check_class_cast(algo, [GeogebraCommonKernelAlgosAlgoAngleVector class]);
    GeogebraCommonKernelGeosGeoVec3D *vec = [((GeogebraCommonKernelAlgosAlgoAngleVector *) nil_chk(va)) getVec3D];
    if ([vec isKindOfClass:[GeogebraCommonKernelGeosGeoVector class]]) {
      v = (GeogebraCommonKernelGeosGeoVector *) check_class_cast(vec, [GeogebraCommonKernelGeosGeoVector class]);
      vertex = [((id<GeogebraCommonKernelKernelNDGeoVectorND>) nil_chk(v)) getStartPoint];
      if (vertex == nil) vertex = tempPoint;
      [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    }
    else if ([vec isKindOfClass:[GeogebraCommonKernelGeosGeoPoint class]]) {
      point = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(vec, [GeogebraCommonKernelGeosGeoPoint class]);
      vertex = tempPoint;
      [vertex getInhomCoordsWithDoubleArray:m];
    }
    *IOSDoubleArray_GetRef(firstVec, 0) = 1;
    *IOSDoubleArray_GetRef(firstVec, 1) = 0;
  }
  [tempPoint remove];
  jdouble angSt = JavaLangMath_atan2WithDouble_withDouble_(IOSDoubleArray_Get(firstVec, 1), IOSDoubleArray_Get(firstVec, 0));
  jdouble angExt = [geo getRawAngle];
  if (angExt > JavaLangMath_PI * 2) angExt -= JavaLangMath_PI * 2;
  if ([geo getAngleStyle] == GeogebraCommonKernelGeosGeoAngle_AngleStyleEnum_get_NOTREFLEX()) {
    if (angExt > JavaLangMath_PI) {
      angSt += angExt;
      angExt = 2.0 * JavaLangMath_PI - angExt;
    }
  }
  if ([geo getAngleStyle] == GeogebraCommonKernelGeosGeoAngle_AngleStyleEnum_get_ISREFLEX()) {
    if (angExt < JavaLangMath_PI) {
      angSt += angExt;
      angExt = 2.0 * JavaLangMath_PI - angExt;
    }
  }
  angExt += angSt;
  jdouble r = arcSize / [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXscale];
  if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([geo getValue], GeogebraCommonKernelKernel_PI_HALF) && [geo isEmphasizeRightAngle] && [euclidianView_ getRightAngleStyle] == GeogebraCommonPluginEuclidianStyleConstants_RIGHT_ANGLE_STYLE_SQUARE) {
    r = r / JavaLangMath_sqrtWithDouble_(2);
    IOSDoubleArray *x = [IOSDoubleArray arrayWithLength:8];
    *IOSDoubleArray_GetRef(x, 0) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_cosWithDouble_(angSt);
    *IOSDoubleArray_GetRef(x, 1) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sinWithDouble_(angSt);
    *IOSDoubleArray_GetRef(x, 2) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_sqrtWithDouble_(2) * JavaLangMath_cosWithDouble_(angSt + GeogebraCommonKernelKernel_PI_HALF / 2);
    *IOSDoubleArray_GetRef(x, 3) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sqrtWithDouble_(2) * JavaLangMath_sinWithDouble_(angSt + GeogebraCommonKernelKernel_PI_HALF / 2);
    *IOSDoubleArray_GetRef(x, 4) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_cosWithDouble_(angSt + GeogebraCommonKernelKernel_PI_HALF);
    *IOSDoubleArray_GetRef(x, 5) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sinWithDouble_(angSt + GeogebraCommonKernelKernel_PI_HALF);
    *IOSDoubleArray_GetRef(x, 6) = IOSDoubleArray_Get(m, 0);
    *IOSDoubleArray_GetRef(x, 7) = IOSDoubleArray_Get(m, 1);
    [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw"];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
      [codeFilledObject_ appendWithNSString:JreStrcat("C$$", '[', s, @"] ")];
    }
    for (jint i = 0; i < 4; i++) {
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(x, 2 * i), IOSDoubleArray_Get(x, 2 * i + 1), codeFilledObject_);
      [codeFilledObject_ appendWithNSString:@" -- "];
    }
    [codeFilledObject_ appendWithNSString:@"cycle; \n"];
    [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
  }
  else {
    jdouble angStDeg = fmod(JavaLangMath_toDegreesWithDouble_(angSt), 360);
    jdouble angEndDeg = fmod(JavaLangMath_toDegreesWithDouble_(angExt), 360);
    if (angStDeg > angEndDeg) angStDeg = angStDeg - 360;
    [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw [shift={"];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(m, 0), IOSDoubleArray_Get(m, 1), codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@"}"];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
      [codeFilledObject_ appendWithNSString:JreStrcat("C$$", ',', s, @"] ")];
    }
    else {
      [codeFilledObject_ appendWithNSString:@"] "];
    }
    [codeFilledObject_ appendWithNSString:@"(0,0) -- ("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:angStDeg]];
    [codeFilledObject_ appendWithNSString:@":"];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:r]];
    [codeFilledObject_ appendWithNSString:@") arc ("];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:angStDeg]];
    [codeFilledObject_ appendWithNSString:@":"];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:angEndDeg]];
    [codeFilledObject_ appendWithNSString:@":"];
    [codeFilledObject_ appendWithNSString:[self formatWithDouble:r]];
    [codeFilledObject_ appendWithNSString:@") -- cycle;\n"];
    [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
    if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([geo getValue], GeogebraCommonKernelKernel_PI_HALF) && [geo isEmphasizeRightAngle] && [euclidianView_ getRightAngleStyle] == GeogebraCommonPluginEuclidianStyleConstants_RIGHT_ANGLE_STYLE_DOT) {
      jdouble diameter = geo->lineThickness_ / [euclidianView_ getXscale];
      jdouble radius = arcSize / [euclidianView_ getXscale] / 1.7;
      jdouble labelAngle = (angSt + angExt) / 2.0;
      jdouble x1 = IOSDoubleArray_Get(m, 0) + radius * JavaLangMath_cosWithDouble_(labelAngle);
      jdouble x2 = IOSDoubleArray_Get(m, 1) + radius * JavaLangMath_sinWithDouble_(labelAngle);
      [self startBeamerWithJavaLangStringBuilder:code_];
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\fill"];
      s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
      if (((jint) [((NSString *) nil_chk(s)) length]) != 0) [code_ appendWithNSString:JreStrcat("C$$", '[', s, @"] ")];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, x2, code_);
      [code_ appendWithNSString:@" circle ("];
      [code_ appendWithNSString:[self formatWithDouble:diameter / 2]];
      [code_ appendWithNSString:@");\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
    }
  }
  jint deco = geo->decorationType_;
  if (deco != GeogebraCommonKernelGeosGeoElement_DECORATION_NONE) {
    [self startBeamerWithJavaLangStringBuilder:code_];
    [self markAngleWithGeogebraCommonKernelGeosGeoAngle:geo withDouble:r withDoubleArray:m withDouble:angSt withDouble:angExt];
    [self endBeamerWithJavaLangStringBuilder:code_];
  }
}

- (void)drawArrowArcWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                         withDoubleArray:(IOSDoubleArray *)vertex
                                              withDouble:(jdouble)angSt
                                              withDouble:(jdouble)angEnd
                                              withDouble:(jdouble)r
                                             withBoolean:(jboolean)anticlockwise {
  jdouble angStDeg = fmod(JavaLangMath_toDegreesWithDouble_(angSt), 360);
  jdouble angEndDeg = fmod(JavaLangMath_toDegreesWithDouble_(angEnd), 360);
  if (angStDeg > angEndDeg) angStDeg -= 360;
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw [shift={"];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(nil_chk(vertex), 0), IOSDoubleArray_Get(vertex, 1), code_);
  [code_ appendWithNSString:@"},-"];
  if (anticlockwise) [code_ appendWithNSString:@">"];
  else [code_ appendWithNSString:@"<"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [code_ appendWithNSString:JreStrcat("C$$", ',', s, @"] ")];
  }
  else {
    [code_ appendWithNSString:@"] "];
  }
  [code_ appendWithNSString:@"("];
  [code_ appendWithNSString:[self formatWithDouble:angStDeg]];
  [code_ appendWithNSString:@":"];
  [code_ appendWithNSString:[self formatWithDouble:r]];
  [code_ appendWithNSString:@") arc ("];
  [code_ appendWithNSString:[self formatWithDouble:angStDeg]];
  [code_ appendWithNSString:@":"];
  [code_ appendWithNSString:[self formatWithDouble:angEndDeg]];
  [code_ appendWithNSString:@":"];
  [code_ appendWithNSString:[self formatWithDouble:r]];
  [code_ appendWithNSString:@");\n"];
}

- (void)drawArcWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                    withDoubleArray:(IOSDoubleArray *)vertex
                                         withDouble:(jdouble)angSt
                                         withDouble:(jdouble)angEnd
                                         withDouble:(jdouble)r {
  jdouble angStDeg = fmod(JavaLangMath_toDegreesWithDouble_(angSt), 360);
  jdouble angEndDeg = fmod(JavaLangMath_toDegreesWithDouble_(angEnd), 360);
  if (angStDeg > angEndDeg) angStDeg -= 360;
  if (isBeamer_) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw [shift={"];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(nil_chk(vertex), 0), IOSDoubleArray_Get(vertex, 1), code_);
  [code_ appendWithNSString:@"}"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [code_ appendWithNSString:JreStrcat("C$$", ',', s, @"] ")];
  }
  else {
    [code_ appendWithNSString:@"] "];
  }
  [code_ appendWithNSString:@"("];
  [code_ appendWithNSString:[self formatWithDouble:angStDeg]];
  [code_ appendWithNSString:@":"];
  [code_ appendWithNSString:[self formatWithDouble:r]];
  [code_ appendWithNSString:@") arc ("];
  [code_ appendWithNSString:[self formatWithDouble:angStDeg]];
  [code_ appendWithNSString:@":"];
  [code_ appendWithNSString:[self formatWithDouble:angEndDeg]];
  [code_ appendWithNSString:@":"];
  [code_ appendWithNSString:[self formatWithDouble:r]];
  [code_ appendWithNSString:@");\n"];
}

- (void)drawTickWithGeogebraCommonKernelGeosGeoAngle:(GeogebraCommonKernelGeosGeoAngle *)geo
                                     withDoubleArray:(IOSDoubleArray *)vertex
                                          withDouble:(jdouble)angle {
  angle = -angle;
  jdouble radius = [((GeogebraCommonKernelGeosGeoAngle *) nil_chk(geo)) getArcSize];
  jdouble diff = 2.5 + geo->lineThickness_ / 4.0;
  jdouble x1 = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:IOSDoubleArray_Get(nil_chk(vertex), 0) + (radius - diff) * JavaLangMath_cosWithDouble_(angle)];
  jdouble x2 = [euclidianView_ toRealWorldCoordXWithDouble:IOSDoubleArray_Get(vertex, 0) + (radius + diff) * JavaLangMath_cosWithDouble_(angle)];
  jdouble y1 = [euclidianView_ toRealWorldCoordYWithDouble:IOSDoubleArray_Get(vertex, 1) + (radius - diff) * JavaLangMath_sinWithDouble_(angle) * [euclidianView_ getScaleRatio]];
  jdouble y2 = [euclidianView_ toRealWorldCoordYWithDouble:IOSDoubleArray_Get(vertex, 1) + (radius + diff) * JavaLangMath_sinWithDouble_(angle) * [euclidianView_ getScaleRatio]];
  if (isBeamer_) {
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  }
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [code_ appendWithNSString:JreStrcat("C$$", '[', s, @"] ")];
  }
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
  [code_ appendWithNSString:@" -- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x2, y2, code_);
  [code_ appendWithNSString:@";\n"];
}

- (void)drawSliderWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo {
  jboolean horizontal = [((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) isSliderHorizontal];
  jdouble max = [geo getIntervalMax];
  jdouble min = [geo getIntervalMin];
  jdouble value = [geo getValue];
  jdouble width = [geo getSliderWidth];
  jdouble x = [geo getSliderX];
  jdouble y = [geo getSliderY];
  if ([geo isAbsoluteScreenLocActive]) {
    x = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:x];
    y = [euclidianView_ toRealWorldCoordYWithDouble:y];
    width = horizontal ? width / [euclidianView_ getXscale] : width / [euclidianView_ getYscale];
  }
  GeogebraCommonKernelGeosGeoPoint *geoPoint = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(construction_) autorelease];
  [geoPoint setObjColorWithGeogebraCommonAwtGColor:[geo getObjectColor]];
  NSString *label = GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_([geo getLabelDescription], YES);
  [geoPoint setLabelWithNSString:label];
  jdouble param = (value - min) / (max - min);
  [geoPoint setPointSizeWithInt:2 + (geo->lineThickness_ + 1) / 3];
  [geoPoint setLabelVisibleWithBoolean:[geo isLabelVisible]];
  if (horizontal) [geoPoint setCoordsWithDouble:x + width * param withDouble:y withDouble:1.0];
  else [geoPoint setCoordsWithDouble:x withDouble:y + width * param withDouble:1.0];
  GeogebraCommonEuclidianDrawDrawPoint *drawPoint = [new_GeogebraCommonEuclidianDrawDrawPoint_initWithGeogebraCommonEuclidianEuclidianView_withGeogebraCommonKernelKernelNDGeoPointND_(euclidianView_, geoPoint) autorelease];
  [drawPoint setGeoElementWithGeogebraCommonKernelGeosGeoElement:geo];
  if ([geo isLabelVisible]) {
    if (horizontal) {
      drawPoint->xLabel_ -= 15;
      drawPoint->yLabel_ -= 5;
    }
    else {
      drawPoint->xLabel_ += 5;
      drawPoint->yLabel_ += 2 * [geoPoint getPointSize] + 4;
    }
  }
  [self drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:geoPoint];
  [self drawLabelWithGeogebraCommonKernelGeosGeoElement:geoPoint withGeogebraCommonEuclidianDrawableND:drawPoint];
  [geoPoint remove];
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    s = JreStrcat("C$$", '[', s, @"] ");
    [code_ appendWithNSString:s];
  }
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, code_);
  [code_ appendWithNSString:@" -- "];
  if (horizontal) {
    x += width;
  }
  else {
    y += width;
  }
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, code_);
  [code_ appendWithNSString:@";\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawPolygonWithGeogebraCommonKernelGeosGeoPolygon:(GeogebraCommonKernelGeosGeoPolygon *)geo {
  jfloat alpha = [((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(geo)) getAlphaValue];
  if (alpha == 0.0f && [geo getFillType] == GeogebraCommonKernelGeosGeoElement_FillTypeEnum_get_IMAGE()) return;
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\fill"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    s = JreStrcat("C$$", '[', s, @"] ");
    [codeFilledObject_ appendWithNSString:s];
  }
  IOSObjectArray *points = [geo getPoints];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(points))->size_; i++) {
    GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(points, i))) getCoordsInD2];
    jdouble x = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX], y = [coords getY], z = [coords getZ];
    x = x / z;
    y = y / z;
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" -- "];
  }
  [codeFilledObject_ appendWithNSString:@"cycle;\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawTextWithGeogebraCommonKernelGeosGeoText:(GeogebraCommonKernelGeosGeoText *)geo {
  jboolean isLatex = [((GeogebraCommonKernelGeosGeoText *) nil_chk(geo)) isLaTeX];
  NSString *st = [geo getTextString];
  jint style = [geo getFontStyle];
  jint size = J2ObjCFpToInt(([geo getFontSizeMultiplier] * [((GeogebraCommonMainApp *) nil_chk([self getApp])) getFontSize]));
  GeogebraCommonKernelGeosGeoPoint *gp;
  jdouble x, y;
  if ([geo isAbsoluteScreenLocActive]) {
    x = [geo getAbsoluteScreenLocX];
    y = [geo getAbsoluteScreenLocY];
  }
  else {
    gp = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([geo getStartPoint], [GeogebraCommonKernelGeosGeoPoint class]);
    if (gp == nil) {
      x = J2ObjCFpToInt([((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXZero]);
      y = J2ObjCFpToInt([euclidianView_ getYZero]);
    }
    else {
      if (![gp isDefined]) {
        return;
      }
      x = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordXWithDouble:gp->inhomX_];
      y = [euclidianView_ toScreenCoordYWithDouble:gp->inhomY_];
    }
    x += geo->labelOffsetX_;
    y += geo->labelOffsetY_;
  }
  x = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:x];
  y = [euclidianView_ toRealWorldCoordYWithDouble:y - [((GeogebraCommonAwtGFont *) nil_chk([euclidianView_ getFont])) getSize]];
  jint id_ = [((NSString *) nil_chk(st)) indexOfString:@"\n"];
  if (id_ == -1) {
    [self startBeamerWithJavaLangStringBuilder:code_];
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw "];
    GeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
    if (![((GeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
      [code_ appendWithNSString:@"[color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:code_];
      [code_ appendWithNSString:@"]"];
    }
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, code_);
    [code_ appendWithNSString:@" node[anchor=north west] {"];
    GeogebraCommonExportPstricksGeoGebraToPgf_addTextWithNSString_withBoolean_withInt_(self, st, isLatex, style);
    [code_ appendWithNSString:@"};\n"];
    [self endBeamerWithJavaLangStringBuilder:code_];
  }
  else {
    JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
    GeogebraCommonUtilGStringTokenizer *stk = [new_GeogebraCommonUtilGStringTokenizer_initWithNSString_withChar_(st, 0x000a) autorelease];
    jint width = 0;
    GeogebraCommonAwtGFont *font = [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newFontWithNSString:[geo isSerifFont] ? @"Serif" : @"SansSerif" withInt:style withInt:size];
    while ([stk hasMoreTokens]) {
      NSString *line = [stk nextToken];
      width = JavaLangMath_maxWithInt_withInt_(width, J2ObjCFpToInt(JavaLangMath_ceilWithDouble_(GeogebraCommonUtilStringUtil_estimateLengthWithNSString_withGeogebraCommonAwtGFont_(line, font))));
      [sb appendWithNSString:line];
      if ([stk hasMoreTokens]) [sb appendWithNSString:@" \\\\ "];
    }
    [self startBeamerWithJavaLangStringBuilder:code_];
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw "];
    GeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
    if (![((GeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
      [code_ appendWithNSString:@"[color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:code_];
      [code_ appendWithNSString:@"]"];
    }
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, code_);
    [code_ appendWithNSString:@" node[anchor=north west] {"];
    [code_ appendWithNSString:@"\\parbox{"];
    [code_ appendWithNSString:[self formatWithDouble:width * (xmax_ - xmin_) * xunit_ / [euclidianView_ getWidth] + 1]];
    [code_ appendWithNSString:@" cm}{"];
    GeogebraCommonExportPstricksGeoGebraToPgf_addTextWithNSString_withBoolean_withInt_(self, [NSString stringWithJavaLangStringBuilder:sb], isLatex, style);
    [code_ appendWithNSString:@"}};\n"];
    [self endBeamerWithJavaLangStringBuilder:code_];
  }
}

- (void)addTextWithNSString:(NSString *)st
                withBoolean:(jboolean)isLatex
                    withInt:(jint)style {
  GeogebraCommonExportPstricksGeoGebraToPgf_addTextWithNSString_withBoolean_withInt_(self, st, isLatex, style);
}

- (void)drawGeoConicPartWithGeogebraCommonKernelGeosGeoConicPart:(GeogebraCommonKernelGeosGeoConicPart *)geo {
  jdouble r1 = IOSDoubleArray_Get(nil_chk([((GeogebraCommonKernelGeosGeoConicPart *) nil_chk(geo)) getHalfAxes]), 0);
  jdouble r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
  jdouble startAngle = [geo getParameterStart];
  jdouble endAngle = [geo getParameterEnd];
  id<GeogebraCommonAwtGAffineTransform> af = [geo getAffineTransform];
  jdouble m11 = [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(af)) getScaleX];
  jdouble m22 = [af getScaleY];
  jdouble m12 = [af getShearX];
  jdouble m21 = [af getShearY];
  jdouble tx = [af getTranslateX];
  jdouble ty = [af getTranslateY];
  if (startAngle > endAngle) {
    startAngle = startAngle - JavaLangMath_PI * 2;
  }
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw [shift={"];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, tx, ty, code_);
  [code_ appendWithNSString:@"}"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    s = JreStrcat("C$$", ',', s, @"] ");
    [code_ appendWithNSString:s];
  }
  else {
    [code_ appendWithNSString:@"]"];
  }
  if ([geo getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR) {
    [code_ appendWithNSString:@" (0,0) -- "];
    JavaLangStringBuilder *sb1 = [new_JavaLangStringBuilder_init() autorelease];
    [sb1 appendWithNSString:[self formatWithDouble:r1]];
    [sb1 appendWithNSString:@"*cos(\\t r)"];
    JavaLangStringBuilder *sb2 = [new_JavaLangStringBuilder_init() autorelease];
    [sb2 appendWithNSString:[self formatWithDouble:r2]];
    [sb2 appendWithNSString:@"*sin(\\t r)"];
    [code_ appendWithNSString:@" plot[domain="];
    [code_ appendWithNSString:[self formatWithDouble:startAngle]];
    [code_ appendWithNSString:@":"];
    [code_ appendWithNSString:[self formatWithDouble:endAngle]];
    [code_ appendWithNSString:@",variable=\\t]({"];
    [code_ appendWithNSString:[self formatWithDouble:m11]];
    [code_ appendWithNSString:@"*"];
    [code_ appendWithJavaLangCharSequence:sb1];
    [code_ appendWithNSString:@"+"];
    [code_ appendWithNSString:[self formatWithDouble:m12]];
    [code_ appendWithNSString:@"*"];
    [code_ appendWithJavaLangCharSequence:sb2];
    [code_ appendWithNSString:@"},{"];
    [code_ appendWithNSString:[self formatWithDouble:m21]];
    [code_ appendWithNSString:@"*"];
    [code_ appendWithJavaLangCharSequence:sb1];
    [code_ appendWithNSString:@"+"];
    [code_ appendWithNSString:[self formatWithDouble:m22]];
    [code_ appendWithNSString:@"*"];
    [code_ appendWithJavaLangCharSequence:sb2];
    [code_ appendWithNSString:@"})"];
    [code_ appendWithNSString:@" -- cycle ;\n"];
  }
  else if ([geo getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC) {
    JavaLangStringBuilder *sb1 = [new_JavaLangStringBuilder_init() autorelease];
    [sb1 appendWithNSString:[self formatWithDouble:r1]];
    [sb1 appendWithNSString:@"*cos(\\t r)"];
    JavaLangStringBuilder *sb2 = [new_JavaLangStringBuilder_init() autorelease];
    [sb2 appendWithNSString:[self formatWithDouble:r2]];
    [sb2 appendWithNSString:@"*sin(\\t r)"];
    [code_ appendWithNSString:@" plot[domain="];
    [code_ appendWithNSString:[self formatWithDouble:startAngle]];
    [code_ appendWithNSString:@":"];
    [code_ appendWithNSString:[self formatWithDouble:endAngle]];
    [code_ appendWithNSString:@",variable=\\t]({"];
    [code_ appendWithNSString:[self formatWithDouble:m11]];
    [code_ appendWithNSString:@"*"];
    [code_ appendWithJavaLangCharSequence:sb1];
    [code_ appendWithNSString:@"+"];
    [code_ appendWithNSString:[self formatWithDouble:m12]];
    [code_ appendWithNSString:@"*"];
    [code_ appendWithJavaLangCharSequence:sb2];
    [code_ appendWithNSString:@"},{"];
    [code_ appendWithNSString:[self formatWithDouble:m21]];
    [code_ appendWithNSString:@"*"];
    [code_ appendWithJavaLangCharSequence:sb1];
    [code_ appendWithNSString:@"+"];
    [code_ appendWithNSString:[self formatWithDouble:m22]];
    [code_ appendWithNSString:@"*"];
    [code_ appendWithJavaLangCharSequence:sb2];
    [code_ appendWithNSString:@"});\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                  withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                                withBoolean:(jboolean)integral
                     withGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo1 {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(self, geo, sb, integral, geo1);
}

- (jboolean)isTrigInvWithNSString:(NSString *)s {
  return GeogebraCommonExportPstricksGeoGebraToPgf_isTrigInvWithNSString_(self, s);
}

- (IOSBooleanArray *)hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)en {
  return GeogebraCommonExportPstricksGeoGebraToPgf_hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode_(self, en);
}

- (void)drawPgfStandardWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                     withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                                  withNSString:(NSString *)value
                                                    withDouble:(jdouble)xrangemax
                                                    withDouble:(jdouble)xrangemin {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawPgfStandardWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withNSString_withDouble_withDouble_(self, geo, sb, value, xrangemax, xrangemin);
}

- (void)drawGnuPlotWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                 withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                              withNSString:(NSString *)value
                                                withDouble:(jdouble)xrangemax
                                                withDouble:(jdouble)xrangemin {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawGnuPlotWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withNSString_withDouble_withDouble_(self, geo, sb, value, xrangemax, xrangemin);
}

- (void)drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo
                                         withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                                        withDouble:(jdouble)xrangemax
                                                        withDouble:(jdouble)xrangemin
                                                       withBoolean:(jboolean)integral
                            withGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)geo1 {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withDouble_withDouble_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(self, geo, sb, xrangemax, xrangemin, integral, geo1);
}

- (void)drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)geo
                                                                  withBoolean:(jboolean)trasparency {
  GeogebraCommonExportPstricksGeoGebraToPgf_addWarningGnuplot(self);
  GeogebraCommonExportPstricksGeoGebraToPgf_drawSingleCurveWithGeogebraCommonKernelGeosGeoCurveCartesian_withJavaLangStringBuilder_(self, geo, code_);
}

- (void)drawSingleCurveWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)geo
                                           withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawSingleCurveWithGeogebraCommonKernelGeosGeoCurveCartesian_withJavaLangStringBuilder_(self, geo, sb);
}

- (void)drawFunctionWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)geo {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(self, geo, code_, NO, nil);
}

+ (NSString *)replaceXWithNSString:(NSString *)name
                      withNSString:(NSString *)substitute {
  return GeogebraCommonExportPstricksGeoGebraToPgf_replaceXWithNSString_withNSString_(name, substitute);
}

+ (NSString *)killSpaceWithNSString:(NSString *)name {
  return GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(name);
}

- (jboolean)warningFuncWithNSString:(NSString *)sb
                       withNSString:(NSString *)nameFunc {
  return GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, sb, nameFunc);
}

- (void)addWarningGnuplot {
  GeogebraCommonExportPstricksGeoGebraToPgf_addWarningGnuplot(self);
}

- (void)addWarningHatch {
  GeogebraCommonExportPstricksGeoGebraToPgf_addWarningHatch(self);
}

+ (void)renameFuncWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                               withNSString:(NSString *)nameFunc
                               withNSString:(NSString *)nameNew {
  GeogebraCommonExportPstricksGeoGebraToPgf_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, nameFunc, nameNew);
}

- (jdouble)maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                       withDouble:(jdouble)a
                                                       withDouble:(jdouble)b {
  return GeogebraCommonExportPstricksGeoGebraToPgf_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, a, b);
}

- (jdouble)firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                         withDouble:(jdouble)a
                                                         withDouble:(jdouble)b {
  return GeogebraCommonExportPstricksGeoGebraToPgf_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, a, b);
}

- (void)drawGeoVectorWithGeogebraCommonKernelGeosGeoVector:(GeogebraCommonKernelGeosGeoVector *)geo {
  id<GeogebraCommonKernelKernelNDGeoPointND> pointStart = [((GeogebraCommonKernelGeosGeoVector *) nil_chk(geo)) getStartPoint];
  jdouble x1, y1;
  if (nil == pointStart) {
    x1 = 0;
    y1 = 0;
  }
  else {
    GeogebraCommonKernelMatrixCoords *c = [pointStart getCoords];
    x1 = [((GeogebraCommonKernelMatrixCoords *) nil_chk(c)) getX] / [c getZ];
    y1 = [c getY] / [c getZ];
  }
  IOSDoubleArray *coord = [IOSDoubleArray arrayWithLength:3];
  [geo getCoordsWithDoubleArray:coord];
  jdouble x2 = IOSDoubleArray_Get(coord, 0) + x1;
  jdouble y2 = IOSDoubleArray_Get(coord, 1) + y1;
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw [->"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [code_ appendWithNSString:@","];
    [code_ appendWithNSString:s];
  }
  [code_ appendWithNSString:@"] "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
  [code_ appendWithNSString:@" -- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x2, y2, code_);
  [code_ appendWithNSString:@";\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawCircleWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)geo {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawCircleWithGeogebraCommonKernelGeosGeoConic_(self, geo);
}

- (void)drawGeoConicWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)geo {
  {
    id<GeogebraCommonAwtGAffineTransform> at;
    jdouble eigenvecX;
    jdouble eigenvecY;
    jdouble x1;
    jdouble y1;
    jdouble r1;
    jdouble r2;
    jdouble angle;
    NSString *s;
    jdouble p;
    jdouble x0;
    jint i;
    jint k2;
    switch ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getType]) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
      GeogebraCommonExportPstricksGeoGebraToPgf_drawCircleWithGeogebraCommonKernelGeosGeoConic_(self, geo);
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
      at = [geo getAffineTransform];
      eigenvecX = [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
      r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX));
      [self startBeamerWithJavaLangStringBuilder:code_];
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw [rotate around={"];
      [code_ appendWithNSString:[self formatWithDouble:angle]];
      [code_ appendWithNSString:@":"];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
      [code_ appendWithNSString:@"}"];
      s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
      if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
        [code_ appendWithNSString:@","];
        [code_ appendWithNSString:s];
      }
      [code_ appendWithNSString:@"] "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
      [code_ appendWithNSString:@" ellipse ("];
      [code_ appendWithNSString:[self formatWithDouble:r1 * xunit_]];
      [code_ appendWithNSString:@"cm and "];
      [code_ appendWithNSString:[self formatWithDouble:r2 * yunit_]];
      [code_ appendWithNSString:@"cm);\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
      p = geo->p_;
      at = [geo getAffineTransform];
      eigenvecX = [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      x0 = JavaLangMath_maxWithDouble_withDouble_(JavaLangMath_absWithDouble_(x1 - xmin_), JavaLangMath_absWithDouble_(x1 - xmax_));
      x0 = JavaLangMath_maxWithDouble_withDouble_(x0, JavaLangMath_absWithDouble_(y1 - ymin_));
      x0 = JavaLangMath_maxWithDouble_withDouble_(x0, JavaLangMath_absWithDouble_(y1 - ymax_));
      x0 = 4 * x0 / p;
      i = 4;
      k2 = 16;
      while (k2 < x0) {
        i += 2;
        k2 = i * i;
      }
      x0 = i * p;
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX)) - 90;
      [self startBeamerWithJavaLangStringBuilder:code_];
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw [samples=50,rotate around={"];
      [code_ appendWithNSString:[self formatWithDouble:angle]];
      [code_ appendWithNSString:@":"];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
      [code_ appendWithNSString:@"},xshift="];
      [code_ appendWithNSString:[self formatWithDouble:x1 * xunit_]];
      [code_ appendWithNSString:@"cm,yshift="];
      [code_ appendWithNSString:[self formatWithDouble:y1 * yunit_]];
      [code_ appendWithNSString:@"cm"];
      s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
      if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
        [code_ appendWithNSString:@","];
        [code_ appendWithNSString:s];
      }
      [code_ appendWithNSString:@",domain="];
      [code_ appendWithDouble:-x0];
      [code_ appendWithNSString:@":"];
      [code_ appendWithDouble:x0];
      [code_ appendWithNSString:@")] plot (\\x,{(\\x)^2/2/"];
      [code_ appendWithDouble:p];
      [code_ appendWithNSString:@"});\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
      at = [geo getAffineTransform];
      eigenvecX = [((id<GeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
      r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX));
      [self startBeamerWithJavaLangStringBuilder:code_];
      [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw [samples=50,domain=-0.99:0.99,rotate around={"];
      [code_ appendWithNSString:[self formatWithDouble:angle]];
      [code_ appendWithNSString:@":"];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
      [code_ appendWithNSString:@"},xshift="];
      [code_ appendWithNSString:[self formatWithDouble:x1 * xunit_]];
      [code_ appendWithNSString:@"cm,yshift="];
      [code_ appendWithNSString:[self formatWithDouble:y1 * yunit_]];
      [code_ appendWithNSString:@"cm"];
      s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
      if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
        [code_ appendWithNSString:@","];
        [code_ appendWithNSString:s];
      }
      [code_ appendWithNSString:@"] plot ({"];
      [code_ appendWithNSString:[self formatWithDouble:r1]];
      [code_ appendWithNSString:@"*(1+(\\x)^2)/(1-(\\x)^2)},{"];
      [code_ appendWithNSString:[self formatWithDouble:r2]];
      [code_ appendWithNSString:@"*2*(\\x)/(1-(\\x)^2)});\n"];
      if (isBeamer_) [code_ appendWithNSString:@"  "];
      [code_ appendWithNSString:@"\\draw [samples=50,domain=-0.99:0.99,rotate around={"];
      [code_ appendWithNSString:[self formatWithDouble:angle]];
      [code_ appendWithNSString:@":"];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
      [code_ appendWithNSString:@"},xshift="];
      [code_ appendWithNSString:[self formatWithDouble:x1 * xunit_]];
      [code_ appendWithNSString:@"cm,yshift="];
      [code_ appendWithNSString:[self formatWithDouble:y1 * yunit_]];
      [code_ appendWithNSString:@"cm"];
      s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
      if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
        [code_ appendWithNSString:@","];
        [code_ appendWithNSString:s];
      }
      [code_ appendWithNSString:@"] plot ({"];
      [code_ appendWithNSString:[self formatWithDouble:r1]];
      [code_ appendWithNSString:@"*(-1-(\\x)^2)/(1-(\\x)^2)},{"];
      [code_ appendWithNSString:[self formatWithDouble:r2]];
      [code_ appendWithNSString:@"*(-2)*(\\x)/(1-(\\x)^2)});\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
    }
  }
}

- (void)drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)gp {
  if ([((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) getExportPointSymbol]) {
    jdouble x = [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:JreStrcat("D", [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(gp)) getX])];
    jdouble y = [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) evaluateToDoubleWithNSString:JreStrcat("D", [gp getY])];
    jdouble z = [gp getZ];
    x = x / z;
    y = y / z;
    GeogebraCommonAwtGColor *dotcolor = [gp getObjectColor];
    jdouble dotsize = [gp getPointSize];
    jint dotstyle = [gp getPointStyle];
    if (dotstyle == -1) {
      dotstyle = GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_DOT;
    }
    [self startBeamerWithJavaLangStringBuilder:codePoint_];
    if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_CIRCLE) {
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@"] "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@" circle ("];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_CROSS) {
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@"] "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@"-- ++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt) -- ++("];
      [codePoint_ appendWithDouble:dotsize];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:dotsize];
      [codePoint_ appendWithNSString:@"pt) ++(-"];
      [codePoint_ appendWithDouble:dotsize];
      [codePoint_ appendWithNSString:@"pt,0) -- ++("];
      [codePoint_ appendWithDouble:dotsize];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:dotsize];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_EMPTY_DIAMOND) {
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@"] "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@" ++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,0 pt) -- ++("];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt)--++("];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt)--++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt)--++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_FILLED_DIAMOND) {
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [fill="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@"] "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@" ++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,0 pt) -- ++("];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt)--++("];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt)--++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt)--++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_PLUS) {
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@"] "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@"-- ++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,0 pt) -- ++("];
      [codePoint_ appendWithDouble:dotsize];
      [codePoint_ appendWithNSString:@"pt,0 pt) ++(-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt) -- ++(0 pt,"];
      [codePoint_ appendWithDouble:dotsize];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_EAST) {
      jdouble radius = 3 * dotsize / 4;
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [fill="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@",shift={"];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@"},rotate=270] (0,0)"];
      [codePoint_ appendWithNSString:@" ++(0 pt,"];
      [codePoint_ appendWithDouble:radius];
      [codePoint_ appendWithNSString:@"pt) -- ++("];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius / 2 * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:radius / 2 * 3];
      [codePoint_ appendWithNSString:@"pt)--++(-"];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,0 pt) -- ++("];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius / 2 * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:3 * radius / 2];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_NORTH) {
      jdouble radius = 3 * dotsize / 4;
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [fill="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@",shift={"];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@"}] (0,0)"];
      [codePoint_ appendWithNSString:@" ++(0 pt,"];
      [codePoint_ appendWithDouble:radius];
      [codePoint_ appendWithNSString:@"pt) -- ++("];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius / 2 * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:radius / 2 * 3];
      [codePoint_ appendWithNSString:@"pt)--++(-"];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,0 pt) -- ++("];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius / 2 * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:3 * radius / 2];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_SOUTH) {
      jdouble radius = 3 * dotsize / 4;
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [fill="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@",shift={"];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@"},rotate=180] (0,0)"];
      [codePoint_ appendWithNSString:@" ++(0 pt,"];
      [codePoint_ appendWithDouble:radius];
      [codePoint_ appendWithNSString:@"pt) -- ++("];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius / 2 * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:radius / 2 * 3];
      [codePoint_ appendWithNSString:@"pt)--++(-"];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,0 pt) -- ++("];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius / 2 * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:3 * radius / 2];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else if (dotstyle == GeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_WEST) {
      jdouble radius = 3 * dotsize / 4;
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [fill="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@",shift={"];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@"},rotate=90] (0,0)"];
      [codePoint_ appendWithNSString:@" ++(0 pt,"];
      [codePoint_ appendWithDouble:radius];
      [codePoint_ appendWithNSString:@"pt) -- ++("];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius / 2 * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,-"];
      [codePoint_ appendWithDouble:radius / 2 * 3];
      [codePoint_ appendWithNSString:@"pt)--++(-"];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,0 pt) -- ++("];
      [codePoint_ appendWithNSString:[self formatWithDouble:radius / 2 * JavaLangMath_sqrtWithDouble_(3)]];
      [codePoint_ appendWithNSString:@"pt,"];
      [codePoint_ appendWithDouble:3 * radius / 2];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    else {
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw [fill="];
      [self ColorCodeWithGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@"] "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, codePoint_);
      [codePoint_ appendWithNSString:@" circle ("];
      [codePoint_ appendWithDouble:dotsize / 2];
      [codePoint_ appendWithNSString:@"pt);\n"];
    }
    [self endBeamerWithJavaLangStringBuilder:codePoint_];
  }
  if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(gp)) getShowTrimmedIntersectionLines]) {
    GeogebraCommonKernelAlgosAlgoElement *algo = [gp getParentAlgorithm];
    if ([algo isKindOfClass:[GeogebraCommonKernelAlgosAlgoIntersectAbstract class]]) {
      IOSObjectArray *geos = [((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(algo)) getInput];
      jdouble x1 = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordXdWithDouble:[gp getInhomX]];
      jdouble y1 = [euclidianView_ toScreenCoordYdWithDouble:[gp getInhomY]];
      jdouble x2 = [euclidianView_ toScreenCoordXdWithDouble:[gp getInhomX]] + 30;
      jdouble y2 = [euclidianView_ toScreenCoordYdWithDouble:[gp getInhomY]] + 30;
      x1 = [euclidianView_ toRealWorldCoordXWithDouble:x1];
      x2 = [euclidianView_ toRealWorldCoordXWithDouble:x2];
      y1 = [euclidianView_ toRealWorldCoordYWithDouble:y1];
      y2 = [euclidianView_ toRealWorldCoordYWithDouble:y2];
      jdouble r1 = JavaLangMath_absWithDouble_(x2 - x1);
      jdouble r2 = JavaLangMath_absWithDouble_(y2 - y1);
      JavaLangStringBuilder *s = [new_JavaLangStringBuilder_init() autorelease];
      if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX) [s appendWithNSString:@"\\begin{scope}\n"];
      else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) [s appendWithNSString:@"\\startscope\n"];
      else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) [s appendWithNSString:@"\\scope\n"];
      [s appendWithNSString:@"\\clip ("];
      [s appendWithNSString:[self formatWithDouble:x1]];
      [s appendWithNSString:@","];
      [s appendWithNSString:[self formatWithDouble:y1]];
      [s appendWithNSString:@") ellipse ("];
      [s appendWithNSString:[self formatWithDouble:r1]];
      [s appendWithNSString:@"cm and "];
      [s appendWithNSString:[self formatWithDouble:r2]];
      [s appendWithNSString:@"cm);\n"];
      NSString *end = @"\\end{scope}\n";
      if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) end = @"\\stopscope\n";
      else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) end = @"\\endscope\n";
      jboolean fill1 = NO;
      jboolean draw = ![((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(nil_chk(geos), 0))) isEuclidianVisible];
      if (draw) {
        fill1 = ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 0))) isFillable] && [((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 0))) getAlphaValue] > 0.0f);
        if (fill1) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
        else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
        [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 0) withBoolean:NO withBoolean:YES];
      }
      if (geos->size_ > 1 && ![((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) isEuclidianVisible]) {
        jboolean fill2 = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) isFillable] && ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) getAlphaValue] > 0.0f);
        if (draw) {
          if (fill1 == fill2) {
            [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
            if (fill1) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
          }
          else {
            if (fill1) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
            if (fill2) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
            else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
            [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
            if (fill2) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
          }
        }
        else {
          if (fill2) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
          else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
          [self drawGeoElementWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
          if (fill2) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
          else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
        }
      }
      else if (draw) {
        if (fill1) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
        else [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
      }
    }
  }
}

- (void)drawGeoLineWithGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)geo {
  jdouble a = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(geo)) getX];
  jdouble b = [geo getY];
  jdouble c = [geo getZ];
  [self startBeamerWithJavaLangStringBuilder:code_];
  jdouble heightScreen = [((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) textYmaxValue] - [frame_ textYminValue];
  if (JavaLangMath_absWithDouble_(a / b / heightScreen) > 40) {
    b = 0;
  }
  if (b != 0) {
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw ["];
    NSString *option = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(option)) length]) != 0) {
      [code_ appendWithNSString:option];
      [code_ appendWithNSString:@","];
    }
    [code_ appendWithNSString:@"domain="];
    [code_ appendWithNSString:[self formatWithDouble:xmin_]];
    [code_ appendWithNSString:@":"];
    [code_ appendWithNSString:[self formatWithDouble:xmax_]];
    [code_ appendWithNSString:@"] plot(\\x,{(-"];
    [code_ appendWithNSString:[self formatWithDouble:c]];
    [code_ appendWithNSString:@"-"];
    [code_ appendWithNSString:[self formatWithDouble:a]];
    [code_ appendWithNSString:@"*\\x)/"];
    NSString *tmpy = [self formatWithDouble:b];
    if ([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpy] != 0) [code_ appendWithNSString:tmpy];
    else [code_ appendWithDouble:b];
    [code_ appendWithNSString:@"});\n"];
  }
  else if (b == 0) {
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw "];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("C$$", '[', s, @"] ");
    [code_ appendWithNSString:s];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, -c / a, ymin_, code_);
    [code_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, -c / a, ymax_, code_);
    [code_ appendWithNSString:@";\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawGeoSegmentWithGeogebraCommonKernelGeosGeoSegment:(GeogebraCommonKernelGeosGeoSegment *)geo {
  IOSDoubleArray *A = [IOSDoubleArray arrayWithLength:2];
  IOSDoubleArray *B = [IOSDoubleArray arrayWithLength:2];
  GeogebraCommonKernelGeosGeoPoint *pointStart = ((GeogebraCommonKernelGeosGeoPoint *) [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(geo)) getStartPoint]);
  GeogebraCommonKernelGeosGeoPoint *pointEnd = ((GeogebraCommonKernelGeosGeoPoint *) [geo getEndPoint]);
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(pointStart)) getInhomCoordsWithDoubleArray:A];
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(pointEnd)) getInhomCoordsWithDoubleArray:B];
  [self startBeamerWithJavaLangStringBuilder:code_];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw "];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("C$$", '[', s, @"] ");
  [code_ appendWithNSString:s];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(A, 0), IOSDoubleArray_Get(A, 1), code_);
  [code_ appendWithNSString:@"-- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(B, 0), IOSDoubleArray_Get(B, 1), code_);
  [code_ appendWithNSString:@";\n"];
  jint deco = geo->decorationType_;
  if (deco != GeogebraCommonKernelGeosGeoElement_DECORATION_NONE) [self markWithDoubleArray:A withDoubleArray:B withInt:deco withGeogebraCommonKernelGeosGeoElement:geo];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawLineWithDouble:(jdouble)x1
                withDouble:(jdouble)y1
                withDouble:(jdouble)x2
                withDouble:(jdouble)y2
withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (isBeamer_) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw "];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("C$$", '[', s, @"] ");
  [code_ appendWithNSString:s];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
  [code_ appendWithNSString:@" -- "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x2, y2, code_);
  [code_ appendWithNSString:@";\n"];
}

- (void)drawGeoRayWithGeogebraCommonKernelGeosGeoRay:(GeogebraCommonKernelGeosGeoRay *)geo {
  GeogebraCommonKernelGeosGeoPoint *pointStart = ((GeogebraCommonKernelGeosGeoPoint *) [((GeogebraCommonKernelGeosGeoRay *) nil_chk(geo)) getStartPoint]);
  jdouble x1 = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(pointStart)) getX];
  jdouble z1 = [pointStart getZ];
  x1 = x1 / z1;
  jdouble y1 = [pointStart getY] / z1;
  jdouble a = [geo getX];
  jdouble b = [geo getY];
  jdouble c = [geo getZ];
  jdouble inf = xmin_, sup = xmax_;
  if (b > 0) {
    inf = x1;
  }
  else {
    sup = x1;
  }
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (b != 0) {
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw ["];
    NSString *option = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(option)) length]) != 0) {
      [code_ appendWithNSString:option];
      [code_ appendWithNSString:@","];
    }
    [code_ appendWithNSString:@"domain="];
    [code_ appendWithDouble:inf];
    [code_ appendWithNSString:@":"];
    [code_ appendWithDouble:sup];
    [code_ appendWithNSString:@"] plot(\\x,{(-"];
    [code_ appendWithNSString:[self formatWithDouble:c]];
    [code_ appendWithNSString:@"-"];
    [code_ appendWithNSString:[self formatWithDouble:a]];
    [code_ appendWithNSString:@"*\\x)/"];
    NSString *tmpy = [self formatWithDouble:b];
    if ([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpy] != 0) [code_ appendWithNSString:tmpy];
    else [code_ appendWithDouble:b];
    [code_ appendWithNSString:@"});\n"];
  }
  else if (b == 0) {
    if (a < 0) sup = ymax_;
    else sup = ymin_;
    [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\draw "];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("C$$", '[', s, @"] ");
    [code_ appendWithNSString:s];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, code_);
    [code_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, sup, code_);
    [code_ appendWithNSString:@";\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawLabelWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo
                  withGeogebraCommonEuclidianDrawableND:(GeogebraCommonEuclidianDrawableND *)drawGeo {
  @try {
    if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isLabelVisible]) {
      NSString *name = [geo getLabelDescription];
      if ([geo getLabelMode] == GeogebraCommonKernelGeosGeoElement_LABEL_CAPTION) {
        NSString *nameSym = name;
        for (jint i = 0; i < ((jint) [((NSString *) nil_chk(name)) length]); i++) {
          NSString *uCode = JreStrcat("C", [name charAtWithInt:i]);
          if ([((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
            nameSym = [((NSString *) nil_chk(nameSym)) replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$$", @"\\$\\\\", [((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode], @"\\$")];
          }
        }
        nameSym = [((NSString *) nil_chk(nameSym)) replace:@"$\\euro$" withSequence:@"euro"];
        name = nameSym;
        if ([((NSString *) nil_chk(name)) contains:@"_"]) {
          name = JreStrcat("C$C", '$', name, '$');
        }
      }
      else {
        name = JreStrcat("C$C", '$', GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_([geo getLabelDescription], YES), '$');
      }
      if ([((NSString *) nil_chk(name)) indexOfString:@"\u00b0"] != -1) {
        if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX) {
          name = [name replaceAll:@"\u00b0" withReplacement:@"\\\\textrm{\\\\degre}"];
          if ([((JavaLangStringBuilder *) nil_chk(codePreamble_)) indexOfWithNSString:@"\\degre"] == -1) [codePreamble_ appendWithNSString:@"\\newcommand{\\degre}{\\ensuremath{^\\circ}}\n"];
        }
        else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT || format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) {
          name = [name replaceAll:@"\u00b0" withReplacement:@"{}^{\\\\circ}"];
        }
      }
      if (nil == drawGeo) drawGeo = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getDrawableForWithGeogebraCommonKernelGeosGeoElement:geo];
      jdouble xLabel = [((GeogebraCommonEuclidianDrawableND *) nil_chk(drawGeo)) getxLabel];
      jdouble yLabel = [drawGeo getyLabel];
      xLabel = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:JavaLangMath_roundWithDouble_(xLabel)];
      yLabel = [euclidianView_ toRealWorldCoordYWithDouble:JavaLangMath_roundWithDouble_(yLabel)];
      GeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
      [self startBeamerWithJavaLangStringBuilder:codePoint_];
      jint width = J2ObjCFpToInt(JavaLangMath_ceilWithDouble_(GeogebraCommonUtilStringUtil_estimateLengthWithNSString_withGeogebraCommonAwtGFont_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_([geo getLabelDescription], YES), [euclidianView_ getFont])));
      jint height = J2ObjCFpToInt(JavaLangMath_ceilWithDouble_(GeogebraCommonUtilStringUtil_estimateHeightWithNSString_withGeogebraCommonAwtGFont_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_([geo getLabelDescription], YES), [euclidianView_ getFont])));
      IOSDoubleArray *translation = [IOSDoubleArray arrayWithLength:2];
      *IOSDoubleArray_GetRef(translation, 0) = [euclidianView_ getXZero] + width / 2;
      *IOSDoubleArray_GetRef(translation, 1) = [euclidianView_ getYZero] - height / 2;
      *IOSDoubleArray_GetRef(translation, 0) = [euclidianView_ toRealWorldCoordXWithDouble:IOSDoubleArray_Get(translation, 0)];
      *IOSDoubleArray_GetRef(translation, 1) = [euclidianView_ toRealWorldCoordYWithDouble:IOSDoubleArray_Get(translation, 1)];
      [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\draw[color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:codePoint_];
      [codePoint_ appendWithNSString:@"] "];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, xLabel + IOSDoubleArray_Get(translation, 0), yLabel + IOSDoubleArray_Get(translation, 1), codePoint_);
      [codePoint_ appendWithNSString:@" node {"];
      [codePoint_ appendWithNSString:name];
      [codePoint_ appendWithNSString:@"};\n"];
      [self endBeamerWithJavaLangStringBuilder:codePoint_];
    }
  }
  @catch (JavaLangNullPointerException *e) {
  }
}

- (void)drawGrid {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawGrid(self);
}

- (void)drawAxis {
  GeogebraCommonExportPstricksGeoGebraToPgf_drawAxis(self);
}

- (NSString *)getUnitWithNSStringArray:(IOSObjectArray *)units
                            withDouble:(jdouble)spaceTick
                               withInt:(jint)xy {
  return GeogebraCommonExportPstricksGeoGebraToPgf_getUnitWithNSStringArray_withDouble_withInt_(self, units, spaceTick, xy);
}

- (jboolean)hasMeasureUnitWithNSStringArray:(IOSObjectArray *)units
                                 withDouble:(jdouble)spaceTick
                                    withInt:(jint)xy {
  return GeogebraCommonExportPstricksGeoGebraToPgf_hasMeasureUnitWithNSStringArray_withDouble_withInt_(self, units, spaceTick, xy);
}

- (NSString *)footnotesizeWithNSString:(NSString *)s {
  return GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, s);
}

- (void)writePointWithDouble:(jdouble)x
                  withDouble:(jdouble)y
   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, sb);
}

- (NSString *)LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo
                                                       withBoolean:(jboolean)transparency {
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  jint linethickness = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getLineThickness];
  jint linestyle = [geo getLineType];
  GeogebraCommonExportPstricksGeoGebraExport_Info *info = [new_GeogebraCommonExportPstricksGeoGebraExport_Info_initWithGeogebraCommonExportPstricksGeoGebraExport_withGeogebraCommonKernelGeosGeoElement_(self, geo) autorelease];
  jboolean coma = NO;
  if (linethickness != GeogebraCommonPluginEuclidianStyleConstants_DEFAULT_LINE_THICKNESS) {
    coma = YES;
    [sb appendWithNSString:@"line width="];
    [sb appendWithNSString:[self formatWithDouble:linethickness / 2.0 * 0.8]];
    [sb appendWithNSString:@"pt"];
  }
  if (linestyle != GeogebraCommonPluginEuclidianStyleConstants_DEFAULT_LINE_TYPE) {
    if (coma) [sb appendWithNSString:@","];
    else coma = YES;
    GeogebraCommonExportPstricksGeoGebraToPgf_LinestyleCodeWithInt_withJavaLangStringBuilder_(self, linestyle, sb);
  }
  if (![((GeogebraCommonAwtGColor *) nil_chk([info getLinecolor])) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
    if (coma) [sb appendWithNSString:@","];
    else coma = YES;
    if (transparency && [geo isFillable] && [info getFillType] == GeogebraCommonKernelGeosGeoElement_FillTypeEnum_get_IMAGE()) [sb appendWithNSString:@"pattern "];
    [sb appendWithNSString:@"color="];
    [self ColorCodeWithGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
  }
  if (transparency && [geo isFillable]) {
    {
      jdouble angle;
      switch ([[info getFillType] ordinal]) {
        case GeogebraCommonKernelGeosGeoElement_FillType_STANDARD:
        if ([info getAlpha] > 0.0f) {
          if (coma) [sb appendWithNSString:@","];
          else coma = YES;
          [sb appendWithNSString:@"fill="];
          [self ColorCodeWithGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
          [sb appendWithNSString:@",fill opacity="];
          [sb appendWithFloat:[info getAlpha]];
        }
        break;
        case GeogebraCommonKernelGeosGeoElement_FillType_SYMBOLS:
        case GeogebraCommonKernelGeosGeoElement_FillType_CROSSHATCHED:
        case GeogebraCommonKernelGeosGeoElement_FillType_CHESSBOARD:
        case GeogebraCommonKernelGeosGeoElement_FillType_HONEYCOMB:
        case GeogebraCommonKernelGeosGeoElement_FillType_DOTTED:
        case GeogebraCommonKernelGeosGeoElement_FillType_BRICK:
        case GeogebraCommonKernelGeosGeoElement_FillType_HATCH:
        GeogebraCommonExportPstricksGeoGebraToPgf_addWarningHatch(self);
        if (coma) [sb appendWithNSString:@","];
        else coma = YES;
        [sb appendWithNSString:@"fill="];
        [self ColorCodeWithGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
        [sb appendWithNSString:@",pattern="];
        if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) {
          if ([((JavaLangStringBuilder *) nil_chk(codePreamble_)) indexOfWithNSString:@"usetikzlibrary{patterns}"] == -1) [codePreamble_ appendWithNSString:@"\\usetikzlibrary{patterns}\n"];
        }
        else {
          if ([((JavaLangStringBuilder *) nil_chk(codePreamble_)) indexOfWithNSString:@"usetikzlibrary[patterns]"] == -1) [codePreamble_ appendWithNSString:@"\\usetikzlibrary[patterns]\n"];
        }
        angle = [info getAngle];
        if ([info getFillType] == GeogebraCommonKernelGeosGeoElement_FillTypeEnum_get_DOTTED()) {
          [sb appendWithNSString:@"dots"];
        }
        else {
          if (angle < 20) [sb appendWithNSString:@"horizontal lines"];
          else if (angle < 70) [sb appendWithNSString:@"north east lines"];
          else if (angle < 110) [sb appendWithNSString:@"vertical lines"];
          else if (angle < 160) [sb appendWithNSString:@"north west lines"];
          else [sb appendWithNSString:@"horizontal lines"];
        }
        [sb appendWithNSString:@",pattern color="];
        [self ColorCodeWithGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
        break;
      }
    }
  }
  return [NSString stringWithJavaLangStringBuilder:sb];
}

- (void)LinestyleCodeWithInt:(jint)linestyle
   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  GeogebraCommonExportPstricksGeoGebraToPgf_LinestyleCodeWithInt_withJavaLangStringBuilder_(self, linestyle, sb);
}

- (void)ColorCodeWithGeogebraCommonAwtGColor:(GeogebraCommonAwtGColor *)c
                   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  if ([((id<GeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) isGrayscale]) {
    if ([((GeogebraCommonAwtGColor *) nil_chk(c)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"black"];
      return;
    }
    NSString *colorname = @"";
    jint red = [c getRed];
    jint green = [c getGreen];
    jint blue = [c getBlue];
    jint grayscale = (red + green + blue) / 3;
    c = [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newColorWithInt:grayscale withInt:grayscale withInt:grayscale];
    if ([((JavaUtilHashMap *) nil_chk(CustomColor_)) containsKeyWithId:c]) {
      colorname = [((NSString *) nil_chk([CustomColor_ getWithId:c])) description];
    }
    else {
      if ([((GeogebraCommonAwtGColor *) nil_chk(c)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"black"];
        return;
      }
      else if ([c isEqual:GeogebraCommonAwtGColor_get_RED_()]) {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"red"];
        return;
      }
      else if ([c isEqual:GeogebraCommonAwtGColor_get_BLUE_()]) {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"blue"];
        return;
      }
      else if ([c isEqual:GeogebraCommonAwtGColor_get_GREEN_()]) {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"green"];
        return;
      }
      colorname = [self createCustomColorWithInt:red withInt:green withInt:blue];
      if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX || format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) {
        [((JavaLangStringBuilder *) nil_chk(codeBeginDoc_)) insertWithInt:0 withNSString:JreStrcat("$$$$C$C$$", @"\\definecolor{", colorname, @"}{rgb}{", [self formatWithDouble:grayscale / 255.0], ',', [self formatWithDouble:grayscale / 255.0], ',', [self formatWithDouble:grayscale / 255.0], @"}\n")];
        [CustomColor_ putWithId:c withId:colorname];
      }
      else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) {
        [((JavaLangStringBuilder *) nil_chk(codeBeginDoc_)) insertWithInt:0 withNSString:JreStrcat("$$$$$$$$$", @"\\definecolor[", colorname, @"][r=", [self formatWithDouble:grayscale / 255.0], @",g=", [self formatWithDouble:grayscale / 255.0], @",b=", [self formatWithDouble:grayscale / 255.0], @"]\n")];
        [CustomColor_ putWithId:c withId:colorname];
      }
    }
    if ([((GeogebraCommonAwtGColor *) nil_chk(c)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"black"];
      return;
    }
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:colorname];
  }
  else {
    if ([((GeogebraCommonAwtGColor *) nil_chk(c)) isEqual:GeogebraCommonAwtGColor_get_BLACK_()]) {
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"black"];
      return;
    }
    NSString *colorname = @"";
    if ([((JavaUtilHashMap *) nil_chk(CustomColor_)) containsKeyWithId:c]) {
      colorname = [((NSString *) nil_chk([CustomColor_ getWithId:c])) description];
    }
    else {
      jint red = [c getRed];
      jint green = [c getGreen];
      jint blue = [c getBlue];
      colorname = [self createCustomColorWithInt:red withInt:green withInt:blue];
      if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX || format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) {
        [((JavaLangStringBuilder *) nil_chk(codeBeginDoc_)) insertWithInt:0 withNSString:JreStrcat("$$$$C$C$$", @"\\definecolor{", colorname, @"}{rgb}{", [self formatWithDouble:red / 255.0], ',', [self formatWithDouble:green / 255.0], ',', [self formatWithDouble:blue / 255.0], @"}\n")];
        [CustomColor_ putWithId:c withId:colorname];
      }
      else if (format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) {
        [((JavaLangStringBuilder *) nil_chk(codeBeginDoc_)) insertWithInt:0 withNSString:JreStrcat("$$$$$$$$$", @"\\definecolor[", colorname, @"][r=", [self formatWithDouble:red / 255.0], @",g=", [self formatWithDouble:green / 255.0], @",b=", [self formatWithDouble:blue / 255.0], @"]\n")];
        [CustomColor_ putWithId:c withId:colorname];
      }
    }
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:colorname];
  }
}

- (void)drawImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:(GeogebraCommonKernelImplicitGeoImplicitPoly *)geo {
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\n%WARNING: PGF/Tikz and Gnuplot don't support implicit curves\n"];
  [code_ appendWithNSString:@"%Rather try PSTricks export\n"];
  [code_ appendWithNSString:@"%Cannot draw "];
  [code_ appendWithNSString:[self getImplicitExprWithGeogebraCommonKernelImplicitGeoImplicitPoly:geo]];
  [code_ appendWithNSString:@"\n\n"];
}

- (void)drawPolyLineWithGeogebraCommonKernelGeosGeoPolyLine:(GeogebraCommonKernelGeosGeoPolyLine *)geo {
  IOSObjectArray *path = [((GeogebraCommonKernelGeosGeoPolyLine *) nil_chk(geo)) getPoints];
  if (((IOSObjectArray *) nil_chk(path))->size_ < 2) return;
  [self startBeamerWithJavaLangStringBuilder:code_];
  JavaLangStringBuilder *str = [new_JavaLangStringBuilder_init() autorelease];
  [str appendWithNSString:@"\\draw "];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("C$$", '[', s, @"] ");
  [str appendWithNSString:s];
  for (jint i = 0; i < path->size_; i++) {
    GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(path, i))) getInhomCoords];
    jdouble x1 = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX];
    jdouble y1 = [coords getY];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, str);
    if (i != path->size_ - 1) [str appendWithNSString:@"-- "];
  }
  [str appendWithNSString:@";\n"];
  NSString *s1 = [str description];
  s1 = [((NSString *) nil_chk(s1)) replaceAll:@"-- \\(\\?,\\?\\)--" withReplacement:JreStrcat("$$", @";\n \\\\draw ", s)];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:s1];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (GeogebraCommonKernelStringTemplate *)getStringTemplate {
  return GeogebraCommonKernelStringTemplate_getWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_(GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_PGF());
}

- (NSString *)handleAxesStyle {
  return GeogebraCommonExportPstricksGeoGebraToPgf_handleAxesStyle(self);
}

- (void)drawHistogramOrBarChartBoxWithDoubleArray:(IOSDoubleArray *)y
                                  withDoubleArray:(IOSDoubleArray *)x
                                          withInt:(jint)length
                                       withDouble:(jdouble)width
           withGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)g {
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  for (jint i = 0; i < length; i++) {
    barNumber_ = i + 1;
    [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\draw"];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:g withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) [codeFilledObject_ appendWithNSString:JreStrcat("C$$", '[', s, @"] ")];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(nil_chk(x), i), 0, codeFilledObject_);
    [codeFilledObject_ appendWithNSString:@" rectangle "];
    if (x->size_ == length) {
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(x, i) + width, IOSDoubleArray_Get(nil_chk(y), i), codeFilledObject_);
    }
    else {
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, IOSDoubleArray_Get(x, i + 1), IOSDoubleArray_Get(nil_chk(y), i), codeFilledObject_);
    }
    [codeFilledObject_ appendWithNSString:@";\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawNyquistWithGeogebraCommonKernelGeosGeoTransferFunction:(GeogebraCommonKernelGeosGeoTransferFunction *)g {
  NSString *la = @"<-";
  NSString *ra = @"->";
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:g withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    la = @",<-";
    ra = @",->";
  }
  NSString *template_ = JreStrcat("$$$", @"\\draw[", s, @"\u00a7arrows\u00a7] (%0,%1) -- (%2,%3);\n");
  JavaLangStringBuilder *lineBuilder = [self drawNyquistDiagramWithGeogebraCommonKernelGeosGeoTransferFunction:g withNSString:template_ withNSString:@"\u00a7arrows\u00a7" withNSString:la withNSString:ra];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:JreStrcat("$$", [((JavaLangStringBuilder *) nil_chk(lineBuilder)) description], @";\n")];
}

- (jboolean)fillSplineWithGeogebraCommonKernelGeosGeoCurveCartesianArray:(IOSObjectArray *)curves {
  NSString *liopco = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(nil_chk(curves), 0) withBoolean:YES];
  if (![((NSString *) nil_chk(liopco)) contains:@"fill"]) {
    return NO;
  }
  JavaLangStringBuilder *fill = [new_JavaLangStringBuilder_init() autorelease];
  liopco = JreStrcat("C$C", '[', liopco, ']');
  NSString *template_ = @"\\pgflineto{\\pgfxy(%0,%1)}\n";
  jdouble p = [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, 0))) getMinParameter];
  jdouble y = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, 0))) getFunY])) evaluateWithDouble:[((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, 0))) getMinParameter]];
  jdouble yprec = y;
  if (JavaLangMath_absWithDouble_(y) < 0.001) y = yprec = 0;
  jdouble xprec = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, 0))) getFunX])) evaluateWithDouble:[((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, 0))) getMinParameter]];
  jdouble x = xprec;
  [fill appendWithNSString:JreStrcat("$DCD$", @"\\pgfmoveto{\\pgfxy(", x, ',', y, @")}")];
  for (jint i = 0; i < curves->size_; i++) {
    p = [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getMinParameter];
    y = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getFunY])) evaluateWithDouble:[((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getMinParameter]];
    yprec = y;
    if (JavaLangMath_absWithDouble_(y) < 0.001) y = yprec = 0;
    jdouble step = ([((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getMaxParameter] - [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getMinParameter]) / 200;
    xprec = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getFunX])) evaluateWithDouble:[((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getMinParameter]];
    x = xprec;
    for (; p <= [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getMaxParameter]; p += step) {
      y = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getFunY])) evaluateWithDouble:p];
      x = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(IOSObjectArray_Get(curves, i))) getFunX])) evaluateWithDouble:p];
      if (JavaLangMath_absWithDouble_(y) < 0.001) y = 0;
      if (JavaLangMath_absWithDouble_(x) < 0.001) x = 0;
      [fill appendWithId:GeogebraCommonUtilStringUtil_formatWithNSString_withDouble_withDouble_withDouble_withDouble_(template_, xprec, yprec, x, y)];
      yprec = y;
      xprec = x;
    }
  }
  [fill appendWithNSString:JreStrcat("$$CDCD$", @"\\draw", liopco, '(', x, ',', y, @") circle(0pt);\n")];
  [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:fill];
  return YES;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonMainApp:", "GeoGebraToPgf", NULL, 0x1, NULL, NULL },
    { "generateAllCode", NULL, "V", 0x1, NULL, NULL },
    { "drawLocusWithGeogebraCommonKernelGeosGeoLocus:", "drawLocus", "V", 0x4, NULL, NULL },
    { "drawBoxPlotWithGeogebraCommonKernelGeosGeoNumeric:", "drawBoxPlot", "V", 0x4, NULL, NULL },
    { "drawSumTrapezoidalWithGeogebraCommonKernelGeosGeoNumeric:", "drawSumTrapezoidal", "V", 0x4, NULL, NULL },
    { "drawSumUpperLowerWithGeogebraCommonKernelGeosGeoNumeric:", "drawSumUpperLower", "V", 0x4, NULL, NULL },
    { "drawIntegralFunctionsWithGeogebraCommonKernelGeosGeoNumeric:", "drawIntegralFunctions", "V", 0x4, NULL, NULL },
    { "drawIntegralWithGeogebraCommonKernelGeosGeoNumeric:", "drawIntegral", "V", 0x4, NULL, NULL },
    { "drawSlopeWithGeogebraCommonKernelGeosGeoNumeric:", "drawSlope", "V", 0x4, NULL, NULL },
    { "drawAngleWithGeogebraCommonKernelGeosGeoAngle:", "drawAngle", "V", 0x4, NULL, NULL },
    { "drawArrowArcWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:withDouble:withDouble:withBoolean:", "drawArrowArc", "V", 0x4, NULL, NULL },
    { "drawArcWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:withDouble:withDouble:", "drawArc", "V", 0x4, NULL, NULL },
    { "drawTickWithGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:", "drawTick", "V", 0x4, NULL, NULL },
    { "drawSliderWithGeogebraCommonKernelGeosGeoNumeric:", "drawSlider", "V", 0x4, NULL, NULL },
    { "drawPolygonWithGeogebraCommonKernelGeosGeoPolygon:", "drawPolygon", "V", 0x4, NULL, NULL },
    { "drawTextWithGeogebraCommonKernelGeosGeoText:", "drawText", "V", 0x4, NULL, NULL },
    { "addTextWithNSString:withBoolean:withInt:", "addText", "V", 0x2, NULL, NULL },
    { "drawGeoConicPartWithGeogebraCommonKernelGeosGeoConicPart:", "drawGeoConicPart", "V", 0x4, NULL, NULL },
    { "drawFunctionWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:withBoolean:withGeogebraCommonKernelGeosGeoNumeric:", "drawFunction", "V", 0x2, NULL, NULL },
    { "isTrigInvWithNSString:", "isTrigInv", "Z", 0x2, NULL, NULL },
    { "hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode:", "hasFractionalOrTrigoExponent", "[Z", 0x2, NULL, NULL },
    { "drawPgfStandardWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:withNSString:withDouble:withDouble:", "drawPgfStandard", "V", 0x2, NULL, NULL },
    { "drawGnuPlotWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:withNSString:withDouble:withDouble:", "drawGnuPlot", "V", 0x2, NULL, NULL },
    { "drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:withDouble:withDouble:withBoolean:withGeogebraCommonKernelGeosGeoNumeric:", "drawNoLatexFunction", "V", 0x2, NULL, NULL },
    { "drawSingleCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:withBoolean:", "drawSingleCurveCartesian", "V", 0x4, NULL, NULL },
    { "drawSingleCurveWithGeogebraCommonKernelGeosGeoCurveCartesian:withJavaLangStringBuilder:", "drawSingleCurve", "V", 0x2, NULL, NULL },
    { "drawFunctionWithGeogebraCommonKernelGeosGeoFunction:", "drawFunction", "V", 0x4, NULL, NULL },
    { "replaceXWithNSString:withNSString:", "replaceX", "Ljava.lang.String;", 0xa, NULL, NULL },
    { "killSpaceWithNSString:", "killSpace", "Ljava.lang.String;", 0xa, NULL, NULL },
    { "warningFuncWithNSString:withNSString:", "warningFunc", "Z", 0x2, NULL, NULL },
    { "addWarningGnuplot", NULL, "V", 0x2, NULL, NULL },
    { "addWarningHatch", NULL, "V", 0x2, NULL, NULL },
    { "renameFuncWithJavaLangStringBuilder:withNSString:withNSString:", "renameFunc", "V", 0xa, NULL, NULL },
    { "maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction:withDouble:withDouble:", "maxDefinedValue", "D", 0x2, NULL, NULL },
    { "firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction:withDouble:withDouble:", "firstDefinedValue", "D", 0x2, NULL, NULL },
    { "drawGeoVectorWithGeogebraCommonKernelGeosGeoVector:", "drawGeoVector", "V", 0x4, NULL, NULL },
    { "drawCircleWithGeogebraCommonKernelGeosGeoConic:", "drawCircle", "V", 0x2, NULL, NULL },
    { "drawGeoConicWithGeogebraCommonKernelGeosGeoConic:", "drawGeoConic", "V", 0x4, NULL, NULL },
    { "drawGeoPointWithGeogebraCommonKernelGeosGeoPoint:", "drawGeoPoint", "V", 0x4, NULL, NULL },
    { "drawGeoLineWithGeogebraCommonKernelGeosGeoLine:", "drawGeoLine", "V", 0x4, NULL, NULL },
    { "drawGeoSegmentWithGeogebraCommonKernelGeosGeoSegment:", "drawGeoSegment", "V", 0x4, NULL, NULL },
    { "drawLineWithDouble:withDouble:withDouble:withDouble:withGeogebraCommonKernelGeosGeoElement:", "drawLine", "V", 0x4, NULL, NULL },
    { "drawGeoRayWithGeogebraCommonKernelGeosGeoRay:", "drawGeoRay", "V", 0x4, NULL, NULL },
    { "drawLabelWithGeogebraCommonKernelGeosGeoElement:withGeogebraCommonEuclidianDrawableND:", "drawLabel", "V", 0x4, NULL, NULL },
    { "drawGrid", NULL, "V", 0x2, NULL, NULL },
    { "drawAxis", NULL, "V", 0x2, NULL, NULL },
    { "getUnitWithNSStringArray:withDouble:withInt:", "getUnit", "Ljava.lang.String;", 0x2, NULL, NULL },
    { "hasMeasureUnitWithNSStringArray:withDouble:withInt:", "hasMeasureUnit", "Z", 0x2, NULL, NULL },
    { "footnotesizeWithNSString:", "footnotesize", "Ljava.lang.String;", 0x2, NULL, NULL },
    { "writePointWithDouble:withDouble:withJavaLangStringBuilder:", "writePoint", "V", 0x2, NULL, NULL },
    { "LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:withBoolean:", "LineOptionCode", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "LinestyleCodeWithInt:withJavaLangStringBuilder:", "LinestyleCode", "V", 0x2, NULL, NULL },
    { "ColorCodeWithGeogebraCommonAwtGColor:withJavaLangStringBuilder:", "ColorCode", "V", 0x4, NULL, NULL },
    { "drawImplicitPolyWithGeogebraCommonKernelImplicitGeoImplicitPoly:", "drawImplicitPoly", "V", 0x4, NULL, NULL },
    { "drawPolyLineWithGeogebraCommonKernelGeosGeoPolyLine:", "drawPolyLine", "V", 0x4, NULL, NULL },
    { "getStringTemplate", NULL, "Lgeogebra.common.kernel.StringTemplate;", 0x4, NULL, NULL },
    { "handleAxesStyle", NULL, "Ljava.lang.String;", 0x2, NULL, NULL },
    { "drawHistogramOrBarChartBoxWithDoubleArray:withDoubleArray:withInt:withDouble:withGeogebraCommonKernelGeosGeoNumeric:", "drawHistogramOrBarChartBox", "V", 0x4, NULL, NULL },
    { "drawNyquistWithGeogebraCommonKernelGeosGeoTransferFunction:", "drawNyquist", "V", 0x4, NULL, NULL },
    { "fillSplineWithGeogebraCommonKernelGeosGeoCurveCartesianArray:", "fillSpline", "Z", 0x4, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "FORMAT_LATEX_", NULL, 0x1a, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX },
    { "FORMAT_PLAIN_TEX_", NULL, 0x1a, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX },
    { "FORMAT_CONTEXT_", NULL, 0x1a, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT },
    { "FORMAT_BEAMER_", NULL, 0x1a, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_BEAMER },
    { "functionIdentifier_", NULL, 0x2, "I", NULL, NULL,  },
    { "forceGnuplot_", NULL, 0x2, "Z", NULL, NULL,  },
    { "gnuplotWarning_", NULL, 0x2, "Z", NULL, NULL,  },
    { "hatchWarning_", NULL, 0x2, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonExportPstricksGeoGebraToPgf = { 2, "GeoGebraToPgf", "geogebra.common.export.pstricks", NULL, 0x401, 60, methods, 8, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonExportPstricksGeoGebraToPgf;
}

@end

void GeogebraCommonExportPstricksGeoGebraToPgf_initWithGeogebraCommonMainApp_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonMainApp *app) {
  GeogebraCommonExportPstricksGeoGebraExport_initWithGeogebraCommonMainApp_(self, app);
  self->functionIdentifier_ = 0;
  self->forceGnuplot_ = NO;
  self->gnuplotWarning_ = NO;
  self->hatchWarning_ = NO;
}

void GeogebraCommonExportPstricksGeoGebraToPgf_addTextWithNSString_withBoolean_withInt_(GeogebraCommonExportPstricksGeoGebraToPgf *self, NSString *st, jboolean isLatex, jint style) {
  if (self->format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX) {
    if (isLatex) {
      if (![((NSString *) nil_chk(st)) hasPrefix:@"$"]) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"$"];
      for (jint i = 0; i < ((jint) [st length]); i++) {
        NSString *uCode = JreStrcat("C", [st charAtWithInt:i]);
        if ([((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
          [self addTextPackage];
          st = [st replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$", @"\\\\", [((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode])];
        }
      }
    }
    else {
      st = [((NSString *) nil_chk(st)) replaceAll:@"\\\\" withReplacement:@"\\\\textbackslash "];
      for (jint i = 0; i < ((jint) [((NSString *) nil_chk(st)) length]); i++) {
        NSString *uCode = JreStrcat("C", [st charAtWithInt:i]);
        if ([((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
          [self addTextPackage];
          st = [st replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$$", @"\\$\\\\", [((JavaUtilHashMap *) nil_chk(GeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode], @"\\$")];
        }
      }
      st = [((NSString *) nil_chk(st)) replace:@"$\\euro$" withSequence:@"euro"];
    }
    switch (style) {
      case 1:
      if (isLatex) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathbf{"];
      else [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textbf{"];
      break;
      case 2:
      if (isLatex) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathit{"];
      else [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textit{"];
      break;
      case 3:
      if (isLatex) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathit{\\mathbf{"];
      else [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textit{\\textbf{"];
      break;
    }
    [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:st];
    switch (style) {
      case 1:
      case 2:
      [self->code_ appendWithNSString:@"}"];
      break;
      case 3:
      [self->code_ appendWithNSString:@"}}"];
      break;
    }
    if (isLatex && ![((NSString *) nil_chk(st)) hasSuffix:@"$"]) [self->code_ appendWithNSString:@"$"];
  }
  else if (self->format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) {
    if (isLatex) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"$"];
    switch (style) {
      case 1:
      [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"{\\bf "];
      break;
      case 2:
      [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"{\\em "];
      break;
      case 3:
      [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"{\\em \\bf"];
      break;
    }
    [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:st];
    switch (style) {
      case 1:
      case 2:
      case 3:
      [self->code_ appendWithNSString:@"}"];
      break;
    }
    if (isLatex && ![((NSString *) nil_chk(st)) hasSuffix:@"$"]) [self->code_ appendWithNSString:@"$"];
  }
  else if (self->format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) {
    if (isLatex && ![((NSString *) nil_chk(st)) hasSuffix:@"$"]) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"$"];
    switch (style) {
      case 1:
      [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\bf{"];
      break;
      case 2:
      [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\it{ "];
      break;
      case 3:
      [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\it{\\bf{"];
      break;
    }
    [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:st];
    switch (style) {
      case 1:
      case 2:
      [self->code_ appendWithNSString:@"}"];
      case 3:
      [self->code_ appendWithNSString:@"}}"];
      break;
    }
    if (isLatex && ![((NSString *) nil_chk(st)) hasSuffix:@"$"]) [self->code_ appendWithNSString:@"$"];
  }
}

void GeogebraCommonExportPstricksGeoGebraToPgf_drawFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *geo, JavaLangStringBuilder *sb, jboolean integral, GeogebraCommonKernelGeosGeoNumeric *geo1) {
  GeogebraCommonKernelArithmeticFunction *f = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(geo)) getFunction];
  if (nil == f) return;
  NSString *value = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f)) toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  value = GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(value, YES));
  jboolean plotWithGnuplot = GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"cosh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"acosh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"asinh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"atanh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"sinh(") || GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(self, value, @"tanh(");
  IOSBooleanArray *v = GeogebraCommonExportPstricksGeoGebraToPgf_hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode_(self, [f getExpression]);
  if (IOSBooleanArray_Get(nil_chk(v), 0)) {
    if (!plotWithGnuplot) {
      GeogebraCommonExportPstricksGeoGebraToPgf_addWarningGnuplot(self);
    }
    if (IOSBooleanArray_Get(v, 1)) {
      value = [((NSString *) nil_chk(value)) replaceAll:@"\\*180/pi" withReplacement:@""];
    }
  }
  jdouble a = self->xmin_;
  jdouble b = self->xmax_;
  if ([geo hasInterval]) {
    a = JavaLangMath_maxWithDouble_withDouble_(a, [geo getIntervalMin]);
    b = JavaLangMath_minWithDouble_withDouble_(b, [geo getIntervalMax]);
  }
  jdouble xrangemax = a, xrangemin = a;
  while (xrangemax < b) {
    xrangemin = GeogebraCommonExportPstricksGeoGebraToPgf_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, geo, a, b);
    if (xrangemin == b) break;
    xrangemax = GeogebraCommonExportPstricksGeoGebraToPgf_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, geo, xrangemin, b);
    [self startBeamerWithJavaLangStringBuilder:sb];
    if (self->forceGnuplot_) {
      if (![self isLatexFunctionWithNSString:[f toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()]]) {
        GeogebraCommonExportPstricksGeoGebraToPgf_drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withDouble_withDouble_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(self, geo, sb, xrangemax, xrangemin, integral, geo1);
      }
      else {
        value = [((NSString *) nil_chk(value)) replaceAll:@"\\*180/pi" withReplacement:@""];
        GeogebraCommonExportPstricksGeoGebraToPgf_drawGnuPlotWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withNSString_withDouble_withDouble_(self, geo, sb, value, xrangemax, xrangemin);
      }
    }
    else {
      if (![self isLatexFunctionWithNSString:[f toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()]] || GeogebraCommonExportPstricksGeoGebraToPgf_isTrigInvWithNSString_(self, [f toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_noLocalDefault_()])) {
        GeogebraCommonExportPstricksGeoGebraToPgf_drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withDouble_withDouble_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(self, geo, sb, xrangemax, xrangemin, integral, geo1);
      }
      else {
        GeogebraCommonExportPstricksGeoGebraToPgf_drawPgfStandardWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withNSString_withDouble_withDouble_(self, geo, sb, value, xrangemax, xrangemin);
      }
    }
    [self endBeamerWithJavaLangStringBuilder:sb];
    xrangemax += self->PRECISION_XRANGE_FUNCTION_;
    a = xrangemax;
  }
}

jboolean GeogebraCommonExportPstricksGeoGebraToPgf_isTrigInvWithNSString_(GeogebraCommonExportPstricksGeoGebraToPgf *self, NSString *s) {
  return [((NSString *) nil_chk([((NSString *) nil_chk(s)) lowercaseString])) contains:@"atan("] || [((NSString *) nil_chk([s lowercaseString])) contains:@"acos("] || [((NSString *) nil_chk([s lowercaseString])) contains:@"asin("];
}

IOSBooleanArray *GeogebraCommonExportPstricksGeoGebraToPgf_hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelArithmeticExpressionNode *en) {
  IOSBooleanArray *v = [IOSBooleanArray arrayWithBooleans:(jboolean[]){ NO, NO } count:2];
  if (en == nil || [en getOperation] == GeogebraCommonPluginOperationEnum_get_NO_OPERATION()) {
    return v;
  }
  GeogebraCommonPluginOperationEnum *op = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en)) getOperation];
  if (op == GeogebraCommonPluginOperationEnum_get_POWER()) {
    GeogebraCommonKernelArithmeticExpressionNode *le = [en getRightTree];
    if ([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(le)) isNumberValue]) {
      if ([((NSString *) nil_chk([le toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]])) contains:@"sin"] || [((NSString *) nil_chk([le toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]])) contains:@"cos"] || [((NSString *) nil_chk([le toValueStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]])) contains:@"tan"]) {
        *IOSBooleanArray_GetRef(v, 1) = YES;
      }
      jdouble val = [le evaluateDouble];
      *IOSBooleanArray_GetRef(v, 0) = !((J2ObjCFpToInt((val))) == val);
      return v;
    }
    op = [le getOperation];
    *IOSBooleanArray_GetRef(v, 0) = (op == GeogebraCommonPluginOperationEnum_get_DIVIDE());
    return v;
  }
  if (!IOSBooleanArray_Get(nil_chk(GeogebraCommonExportPstricksGeoGebraToPgf_hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode_(self, [en getRightTree])), 0)) {
    return GeogebraCommonExportPstricksGeoGebraToPgf_hasFractionalOrTrigoExponentWithGeogebraCommonKernelArithmeticExpressionNode_(self, [en getLeftTree]);
  }
  *IOSBooleanArray_GetRef(v, 0) = YES;
  return v;
}

void GeogebraCommonExportPstricksGeoGebraToPgf_drawPgfStandardWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withNSString_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *geo, JavaLangStringBuilder *sb, NSString *value, jdouble xrangemax, jdouble xrangemin) {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\draw"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [sb appendWithNSString:@"["];
    [sb appendWithNSString:s];
    [sb appendWithNSString:@","];
  }
  else [sb appendWithNSString:@"["];
  [sb appendWithNSString:@"smooth,samples=100,domain="];
  [sb appendWithDouble:xrangemin];
  [sb appendWithNSString:@":"];
  [sb appendWithDouble:xrangemax];
  [sb appendWithNSString:@"] plot"];
  [sb appendWithNSString:@"(\\x,{"];
  value = GeogebraCommonExportPstricksGeoGebraToPgf_replaceXWithNSString_withNSString_(value, @"(\\x)");
  [sb appendWithNSString:value];
  [sb appendWithNSString:@"});\n"];
}

void GeogebraCommonExportPstricksGeoGebraToPgf_drawGnuPlotWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withNSString_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *geo, JavaLangStringBuilder *sb, NSString *value, jdouble xrangemax, jdouble xrangemin) {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\draw"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [sb appendWithNSString:@"["];
    [sb appendWithNSString:s];
    [sb appendWithNSString:@"]"];
  }
  [sb appendWithNSString:@" plot[raw gnuplot, id=func"];
  [sb appendWithInt:self->functionIdentifier_];
  self->functionIdentifier_++;
  [sb appendWithNSString:@"] function{set samples 100; set xrange ["];
  [sb appendWithDouble:xrangemin + 0.1];
  [sb appendWithNSString:@":"];
  [sb appendWithDouble:xrangemax - 0.1];
  [sb appendWithNSString:@"]; plot "];
  NSString *valueGnu = [((NSString *) nil_chk(value)) replaceAll:@"\\^" withReplacement:@"**"];
  [sb appendWithNSString:valueGnu];
  [sb appendWithNSString:@"};\n"];
}

void GeogebraCommonExportPstricksGeoGebraToPgf_drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction_withJavaLangStringBuilder_withDouble_withDouble_withBoolean_withGeogebraCommonKernelGeosGeoNumeric_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *geo, JavaLangStringBuilder *sb, jdouble xrangemax, jdouble xrangemin, jboolean integral, GeogebraCommonKernelGeosGeoNumeric *geo1) {
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    s = JreStrcat("C$C", '[', s, ']');
  }
  NSString *template_ = JreStrcat("$$$", @"\\draw", s, @" (%0,%1) -- (%2,%3);\n");
  NSString *cycle = @"";
  NSString *close = @"";
  if (integral) {
    close = JreStrcat("C$$$$", '(', [self formatWithDouble:[((GeogebraCommonKernelGeosGeoFunction *) nil_chk(geo)) getIntervalMax]], @",0) -- (", [self formatWithDouble:[geo getIntervalMin]], @",0) -- ");
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:JreStrcat("$$C", @"\\draw[", [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo1 withBoolean:YES], ']')];
    template_ = @" (%0,%1) -- (%2,%3) --";
    cycle = @"cycle;\n";
  }
  JavaLangStringBuilder *lineBuilder = [self drawNoLatexFunctionWithGeogebraCommonKernelGeosGeoFunction:geo withDouble:xrangemax withDouble:xrangemin withInt:400 withNSString:template_];
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:JreStrcat("$$$", [((JavaLangStringBuilder *) nil_chk(lineBuilder)) description], close, cycle)];
}

void GeogebraCommonExportPstricksGeoGebraToPgf_drawSingleCurveWithGeogebraCommonKernelGeosGeoCurveCartesian_withJavaLangStringBuilder_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoCurveCartesian *geo, JavaLangStringBuilder *sb) {
  jdouble start = [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(geo)) getMinParameter];
  jdouble end = [geo getMaxParameter];
  NSString *fx = [geo getFunXWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  fx = GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(fx, YES));
  fx = [((NSString *) nil_chk(fx)) replaceAll:@"\\^" withReplacement:@"**"];
  NSString *fy = [geo getFunYWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  fy = GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(GeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(fy, YES));
  fy = [((NSString *) nil_chk(fy)) replaceAll:@"\\^" withReplacement:@"**"];
  fx = [((NSString *) nil_chk(fx)) replaceAll:@"\\*180/pi" withReplacement:@""];
  fy = [((NSString *) nil_chk(fy)) replaceAll:@"\\*180/pi" withReplacement:@""];
  NSString *variable = [geo getVarStringWithGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  jboolean warning = !([((NSString *) nil_chk(variable)) isEqual:@"t"]);
  if (warning) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"% WARNING: You have to use the special variable t in parametric plot"];
  [self startBeamerWithJavaLangStringBuilder:sb];
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\draw"];
  NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
  if (((jint) [((NSString *) nil_chk(s)) length]) != 0) {
    [sb appendWithNSString:@"["];
    [sb appendWithNSString:s];
  }
  if (((jint) [s length]) != 0) {
    [sb appendWithNSString:@", "];
  }
  else {
    [sb appendWithNSString:@"["];
  }
  [sb appendWithNSString:@"smooth,samples=100,domain="];
  [sb appendWithDouble:start];
  [sb appendWithNSString:@":"];
  [sb appendWithDouble:end];
  [sb appendWithNSString:@"] plot[parametric] function{"];
  [sb appendWithNSString:fx];
  [sb appendWithNSString:@","];
  [sb appendWithNSString:fy];
  [sb appendWithNSString:@"};\n"];
  [self endBeamerWithJavaLangStringBuilder:sb];
}

NSString *GeogebraCommonExportPstricksGeoGebraToPgf_replaceXWithNSString_withNSString_(NSString *name, NSString *substitute) {
  GeogebraCommonExportPstricksGeoGebraToPgf_initialize();
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_initWithNSString_(name) autorelease];
  if (((jint) [((NSString *) nil_chk(name)) length]) > 0 && [name charAtWithInt:0] == '-') [sb insertWithInt:0 withNSString:@"0"];
  jint i = 0;
  while (i < [sb length]) {
    jchar before = '1';
    jchar after = '1';
    jchar character = [sb charAtWithInt:i];
    if (character == 'x') {
      if (i > 0) {
        before = [sb charAtWithInt:i - 1];
      }
      if (i < [sb length] - 1) {
        after = [sb charAtWithInt:i + 1];
      }
      jint id1 = [@"1234567890^ +-*/%()\t" indexOf:after];
      jint id2 = [@"1234567890^ +-*/%()\t" indexOf:before];
      if (id1 != -1 && id2 != -1) {
        [sb deleteCharAtWithInt:i];
        [sb insertWithInt:i withNSString:substitute];
        i += ((jint) [((NSString *) nil_chk(substitute)) length]) - 1;
      }
    }
    i++;
  }
  return [NSString stringWithJavaLangStringBuilder:sb];
}

NSString *GeogebraCommonExportPstricksGeoGebraToPgf_killSpaceWithNSString_(NSString *name) {
  GeogebraCommonExportPstricksGeoGebraToPgf_initialize();
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  jboolean operand = NO;
  jboolean space = NO;
  for (jint i = 0; i < ((jint) [((NSString *) nil_chk(name)) length]); i++) {
    jchar c = [name charAtWithInt:i];
    if ([@"*/+-" indexOf:c] != -1) {
      [sb appendWithChar:c];
      operand = YES;
      space = NO;
    }
    else if (c == ' ') {
      if (!operand) space = YES;
      else {
        space = NO;
        operand = NO;
      }
    }
    else {
      if (space && ![name contains:@"If"]) [sb appendWithNSString:@"*"];
      [sb appendWithChar:c];
      space = NO;
      operand = NO;
    }
  }
  GeogebraCommonExportPstricksGeoGebraToPgf_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, GeogebraCommonUtilUnicode_get_EULER_STRING_(), @"2.718281828");
  GeogebraCommonExportPstricksGeoGebraToPgf_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, @"\\pi", @"3.1415926535");
  return [NSString stringWithJavaLangStringBuilder:sb];
}

jboolean GeogebraCommonExportPstricksGeoGebraToPgf_warningFuncWithNSString_withNSString_(GeogebraCommonExportPstricksGeoGebraToPgf *self, NSString *sb, NSString *nameFunc) {
  if (self->forceGnuplot_) return YES;
  jint ind = [((NSString *) nil_chk(sb)) indexOfString:nameFunc];
  if (ind != -1) {
    GeogebraCommonExportPstricksGeoGebraToPgf_addWarningGnuplot(self);
    return YES;
  }
  return NO;
}

void GeogebraCommonExportPstricksGeoGebraToPgf_addWarningGnuplot(GeogebraCommonExportPstricksGeoGebraToPgf *self) {
  if (self->gnuplotWarning_) return;
  self->gnuplotWarning_ = YES;
  [((JavaLangStringBuilder *) nil_chk(self->codePreamble_)) appendWithNSString:@" \n%<<<<<<<WARNING>>>>>>>\n"];
  [self->codePreamble_ appendWithNSString:@"% PGF/Tikz doesn't support the following mathematical functions:\n"];
  [self->codePreamble_ appendWithNSString:@"% cosh, acosh, sinh, asinh, tanh, atanh,\n"];
  [self->codePreamble_ appendWithNSString:@"% x^r with r not integer\n\n"];
  [self->codePreamble_ appendWithNSString:@"% Plotting will be done using GNUPLOT\n"];
  [self->codePreamble_ appendWithNSString:@"% GNUPLOT must be installed and you must allow Latex to call external programs by\n"];
  [self->codePreamble_ appendWithNSString:@"% Adding the following option to your compiler\n"];
  [self->codePreamble_ appendWithNSString:@"% shell-escape    OR    enable-write18 \n"];
  [self->codePreamble_ appendWithNSString:@"% Example: pdflatex --shell-escape file.tex \n\n"];
}

void GeogebraCommonExportPstricksGeoGebraToPgf_addWarningHatch(GeogebraCommonExportPstricksGeoGebraToPgf *self) {
  if (self->hatchWarning_) return;
  self->hatchWarning_ = YES;
  [((JavaLangStringBuilder *) nil_chk(self->codePreamble_)) appendWithNSString:@" \n\n%<<<<<<<WARNING>>>>>>>\n"];
  [self->codePreamble_ appendWithNSString:@"% PGF/Tikz doesn't support hatch filling very well\n"];
  [self->codePreamble_ appendWithNSString:@"% Use PStricks for a perfect hatching export\n\n"];
}

void GeogebraCommonExportPstricksGeoGebraToPgf_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(JavaLangStringBuilder *sb, NSString *nameFunc, NSString *nameNew) {
  GeogebraCommonExportPstricksGeoGebraToPgf_initialize();
  jint ind = [((JavaLangStringBuilder *) nil_chk(sb)) indexOfWithNSString:nameFunc];
  while (ind > -1) {
    [sb replaceWithInt:ind withInt:ind + ((jint) [((NSString *) nil_chk(nameFunc)) length]) withNSString:nameNew];
    ind = [sb indexOfWithNSString:nameFunc];
  }
}

jdouble GeogebraCommonExportPstricksGeoGebraToPgf_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b) {
  jdouble x = a;
  jdouble step = (b - a) / 100;
  while (x <= b) {
    jdouble y = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) evaluateWithDouble:x];
    if (JavaLangDouble_isNaNWithDouble_(y)) {
      if (step < self->PRECISION_XRANGE_FUNCTION_) return x - step;
      return GeogebraCommonExportPstricksGeoGebraToPgf_maxDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, x - step, x);
    }
    x += step;
  }
  return b;
}

jdouble GeogebraCommonExportPstricksGeoGebraToPgf_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b) {
  jdouble x = a;
  jdouble step = (b - a) / 100;
  while (x <= b) {
    jdouble y = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) evaluateWithDouble:x];
    if (!JavaLangDouble_isNaNWithDouble_(y)) {
      if (x == a) return a;
      else if (step < self->PRECISION_XRANGE_FUNCTION_) return x;
      else return GeogebraCommonExportPstricksGeoGebraToPgf_firstDefinedValueWithGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, x - step, x);
    }
    x += step;
  }
  return b;
}

void GeogebraCommonExportPstricksGeoGebraToPgf_drawCircleWithGeogebraCommonKernelGeosGeoConic_(GeogebraCommonExportPstricksGeoGebraToPgf *self, GeogebraCommonKernelGeosGeoConic *geo) {
  JavaLangStringBuilder *build = [new_JavaLangStringBuilder_init() autorelease];
  if (self->xunit_ == self->yunit_) {
    jdouble x = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((GeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getTranslationVector])) getX];
    jdouble y = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
    jdouble r = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
    [self startBeamerWithJavaLangStringBuilder:build];
    [build appendWithNSString:@"\\draw"];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("$$$", @" [", s, @"] ");
    [build appendWithNSString:s];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, build);
    [build appendWithNSString:@" circle ("];
    NSString *tmpr = [self formatWithDouble:r * self->xunit_];
    if ([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpr] != 0) [build appendWithNSString:tmpr];
    else [build appendWithDouble:r];
    [build appendWithNSString:@"cm);\n"];
    [self endBeamerWithJavaLangStringBuilder:build];
  }
  else {
    jdouble x1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((GeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getTranslationVector])) getX];
    jdouble y1 = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
    jdouble r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
    jdouble r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
    [self startBeamerWithJavaLangStringBuilder:build];
    [build appendWithNSString:@"\\draw"];
    NSString *s = [self LineOptionCodeWithGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    if (((jint) [((NSString *) nil_chk(s)) length]) != 0) s = JreStrcat("$$$", @" [", s, @"] ");
    [build appendWithNSString:s];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x1, y1, build);
    [build appendWithNSString:@" ellipse ("];
    [build appendWithNSString:[self formatWithDouble:r1 * self->xunit_]];
    [build appendWithNSString:@"cm and "];
    [build appendWithNSString:[self formatWithDouble:r2 * self->yunit_]];
    [build appendWithNSString:@"cm);\n"];
    [self endBeamerWithJavaLangStringBuilder:build];
  }
  if ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getAlphaValue] > 0.0f) {
    [((JavaLangStringBuilder *) nil_chk(self->codeFilledObject_)) appendWithJavaLangCharSequence:build];
  }
  else {
    [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithJavaLangCharSequence:build];
  }
}

void GeogebraCommonExportPstricksGeoGebraToPgf_drawGrid(GeogebraCommonExportPstricksGeoGebraToPgf *self) {
  GeogebraCommonAwtGColor *gridCol = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->euclidianView_)) getGridColor];
  IOSDoubleArray *GridDist = [self->euclidianView_ getGridDistances];
  jint gridLine = [self->euclidianView_ getGridLineStyle];
  [((JavaLangStringBuilder *) nil_chk(self->codeBeginDoc_)) appendWithNSString:@"\\draw [color="];
  [self ColorCodeWithGeogebraCommonAwtGColor:gridCol withJavaLangStringBuilder:self->codeBeginDoc_];
  [self->codeBeginDoc_ appendWithNSString:@","];
  GeogebraCommonExportPstricksGeoGebraToPgf_LinestyleCodeWithInt_withJavaLangStringBuilder_(self, gridLine, self->codeBeginDoc_);
  [self->codeBeginDoc_ appendWithNSString:@", xstep="];
  [self->codeBeginDoc_ appendWithNSString:[self sci2decWithDouble:IOSDoubleArray_Get(nil_chk(GridDist), 0) * self->xunit_]];
  [self->codeBeginDoc_ appendWithNSString:@"cm,ystep="];
  [self->codeBeginDoc_ appendWithNSString:[self sci2decWithDouble:IOSDoubleArray_Get(GridDist, 1) * self->yunit_]];
  [self->codeBeginDoc_ appendWithNSString:@"cm] "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, self->xmin_, self->ymin_, self->codeBeginDoc_);
  [self->codeBeginDoc_ appendWithNSString:@" grid "];
  GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, self->xmax_, self->ymax_, self->codeBeginDoc_);
  [self->codeBeginDoc_ appendWithNSString:@";\n"];
}

void GeogebraCommonExportPstricksGeoGebraToPgf_drawAxis(GeogebraCommonExportPstricksGeoGebraToPgf *self) {
  GeogebraCommonAwtGColor *color = [((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->euclidianView_)) getAxesColor];
  jboolean showAxis = [self->euclidianView_ getShowXaxis];
  IOSObjectArray *label = [self->euclidianView_ getAxesLabelsWithBoolean:NO];
  if (self->ymin_ > 0 || self->ymax_ < 0) showAxis = NO;
  jdouble spaceTick = IOSDoubleArray_Get(nil_chk([self->euclidianView_ getAxesNumberingDistances]), 0);
  jboolean showNumbers = IOSBooleanArray_Get(nil_chk([self->euclidianView_ getShowAxesNumbers]), 0);
  jint tickStyle = IOSIntArray_Get(nil_chk([self->euclidianView_ getAxesTickStyles]), 0);
  if (showAxis) {
    [((JavaLangStringBuilder *) nil_chk(self->codeBeginDoc_)) appendWithNSString:JreStrcat("$$$", @"\\draw[", GeogebraCommonExportPstricksGeoGebraToPgf_handleAxesStyle(self), @"color=")];
    [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
    [self->codeBeginDoc_ appendWithNSString:@"] "];
    IOSBooleanArray *positiveOnly = [self->euclidianView_ getPositiveAxes];
    jdouble assignMax = self->xmin_;
    if (IOSBooleanArray_Get(nil_chk(positiveOnly), 0)) {
      assignMax = 0;
    }
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, assignMax, 0, self->codeBeginDoc_);
    [self->codeBeginDoc_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, self->xmax_, 0, self->codeBeginDoc_);
    [self->codeBeginDoc_ appendWithNSString:@";\n"];
    jint x1 = J2ObjCFpToInt((assignMax / spaceTick));
    jint xstartInt = x1;
    jdouble xstart = x1 * spaceTick;
    JavaLangStringBuilder *tmp = [new_JavaLangStringBuilder_init() autorelease];
    while (xstart < self->xmax_) {
      if (JavaLangMath_absWithDouble_(xstart) > 0.1) [tmp appendWithNSString:[self formatWithDouble:xstart]];
      xstart += spaceTick;
      x1++;
      if (xstart < self->xmax_ && JavaLangMath_absWithDouble_(xstart) > 0.1) [tmp appendWithNSString:@","];
    }
    JavaLangStringBuilder *buffer = [new_JavaLangStringBuilder_init() autorelease];
    [buffer appendWithNSString:@"\\foreach \\x in {"];
    [buffer appendWithJavaLangCharSequence:tmp];
    [buffer appendWithNSString:@"}\n"];
    [buffer appendWithNSString:@"\\draw[shift={(\\x,0)},color="];
    [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:buffer];
    JavaLangStringBuilder *ticks = [new_JavaLangStringBuilder_init() autorelease];
    if (tickStyle != GeogebraCommonPluginEuclidianStyleConstants_AXES_TICK_STYLE_NONE) [ticks appendWithNSString:@"] (0pt,2pt) -- (0pt,-2pt)"];
    else [ticks appendWithNSString:@"] (0pt,-2pt)"];
    if (showNumbers) {
      IOSObjectArray *units = [self->euclidianView_ getAxesUnitLabels];
      if (GeogebraCommonExportPstricksGeoGebraToPgf_hasMeasureUnitWithNSStringArray_withDouble_withInt_(self, units, spaceTick, 0)) {
        NSString *unit = GeogebraCommonExportPstricksGeoGebraToPgf_getUnitWithNSStringArray_withDouble_withInt_(self, units, spaceTick, 0);
        if (![((NSString *) nil_chk(unit)) contains:@"p"]) {
          [self->codeBeginDoc_ appendWithJavaLangCharSequence:buffer];
          [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
          [self->codeBeginDoc_ appendWithNSString:@" node[below] {"];
          if ([unit contains:@"c"]) {
            [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, JreStrcat("$$", @"\\x", unit))];
          }
          else {
            [self->codeBeginDoc_ appendWithNSString:JreStrcat("$$", GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"\\x"), unit)];
          }
          [self->codeBeginDoc_ appendWithNSString:@"};\n"];
        }
        else {
          if (![unit contains:@"2"]) {
            for (jint i = xstartInt; i < x1; i++) {
              if (i != 0) {
                [self->codeBeginDoc_ appendWithNSString:JreStrcat("$D$", @"\\draw[shift={(", (i * JavaLangMath_PI), @",0)},color=")];
                [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
                [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
                [self->codeBeginDoc_ appendWithNSString:@" node[below] {"];
                if (i == -1) {
                  [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, JreStrcat("C$", '-', unit))];
                }
                else {
                  if (i == 1) {
                    [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, unit)];
                  }
                  else {
                    [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, JreStrcat("I$", i, unit))];
                  }
                }
                [self->codeBeginDoc_ appendWithNSString:@"};\n"];
              }
            }
          }
          else {
            for (jint i = xstartInt; i < x1; i++) {
              if (i != 0) {
                [self->codeBeginDoc_ appendWithNSString:JreStrcat("$D$", @"\\draw[shift={(", (i * JavaLangMath_PI / 2), @",0)},color=")];
                [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
                [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
                [self->codeBeginDoc_ appendWithNSString:@" node[below] {"];
                if (i == -1) {
                  [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, JreStrcat("C$", '-', unit))];
                }
                else {
                  if (i == 1) {
                    [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, unit)];
                  }
                  else {
                    OrgApacheCommonsMathFractionFraction *f = [new_OrgApacheCommonsMathFractionFraction_initWithInt_withInt_(i, 2) autorelease];
                    if ([f doubleValue] == -1) {
                      [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"-\\pi")];
                    }
                    else {
                      if ([f doubleValue] == 1) {
                        [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"\\pi")];
                      }
                      else {
                        NSString *foot = JreStrcat("I$", [f getNumerator], @"\\pi");
                        if ([f getDenominator] != 1) {
                          foot = JreStrcat("$$", foot, JreStrcat("CI", '/', [f getDenominator]));
                        }
                        [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, foot)];
                      }
                    }
                  }
                }
                [self->codeBeginDoc_ appendWithNSString:@"};\n"];
              }
            }
          }
        }
      }
      else {
        [self->codeBeginDoc_ appendWithJavaLangCharSequence:buffer];
        [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
        [self->codeBeginDoc_ appendWithNSString:@" node[below] {"];
        [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"\\x")];
        [self->codeBeginDoc_ appendWithNSString:@"};\n"];
      }
    }
    else {
      [self->codeBeginDoc_ appendWithJavaLangCharSequence:buffer];
      [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
      [self->codeBeginDoc_ appendWithNSString:@";\n"];
    }
    if (nil != IOSObjectArray_Get(nil_chk(label), 0)) {
      [self->codeBeginDoc_ appendWithNSString:@"\\draw[color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
      [self->codeBeginDoc_ appendWithNSString:@"] "];
      jint width = J2ObjCFpToInt(JavaLangMath_ceilWithDouble_(GeogebraCommonUtilStringUtil_estimateLengthWithNSString_withGeogebraCommonAwtGFont_(IOSObjectArray_Get(label, 0), [self->euclidianView_ getFont])));
      id<GeogebraCommonAwtGRectangle> rect = [self->euclidianView_ getSelectionRectangle];
      jdouble x = [self->euclidianView_ toRealWorldCoordXWithDouble:[self->euclidianView_ getWidth] - 10 - width];
      if (rect != nil) {
        x = [self->euclidianView_ toRealWorldCoordXWithDouble:[rect getMaxX] - 10 - width];
      }
      jdouble y = [self->euclidianView_ toRealWorldCoordYWithDouble:[self->euclidianView_ getYZero] - 4];
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, self->codeBeginDoc_);
      [self->codeBeginDoc_ appendWithNSString:@" node [anchor=south west] { "];
      [self->codeBeginDoc_ appendWithNSString:IOSObjectArray_Get(label, 0)];
      [self->codeBeginDoc_ appendWithNSString:@"};\n"];
    }
  }
  showAxis = [self->euclidianView_ getShowYaxis];
  if (self->xmin_ > 0 || self->xmax_ < 0) showAxis = NO;
  spaceTick = IOSDoubleArray_Get(nil_chk([self->euclidianView_ getAxesNumberingDistances]), 1);
  showNumbers = IOSBooleanArray_Get(nil_chk([self->euclidianView_ getShowAxesNumbers]), 1);
  tickStyle = [self resizePtWithInt:IOSIntArray_Get(nil_chk([self->euclidianView_ getAxesTickStyles]), 1)];
  if (showAxis) {
    [((JavaLangStringBuilder *) nil_chk(self->codeBeginDoc_)) appendWithNSString:JreStrcat("$$$", @"\\draw[", GeogebraCommonExportPstricksGeoGebraToPgf_handleAxesStyle(self), @"color=")];
    [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
    [self->codeBeginDoc_ appendWithNSString:@"] "];
    IOSBooleanArray *positiveOnly = [self->euclidianView_ getPositiveAxes];
    jdouble assignMax = self->ymin_;
    if (IOSBooleanArray_Get(nil_chk(positiveOnly), 0)) {
      assignMax = 0;
    }
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, 0, assignMax, self->codeBeginDoc_);
    [self->codeBeginDoc_ appendWithNSString:@" -- "];
    GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, 0, self->ymax_, self->codeBeginDoc_);
    [self->codeBeginDoc_ appendWithNSString:@";\n"];
    jint y1 = J2ObjCFpToInt((assignMax / spaceTick));
    jint ystartInt = y1;
    jdouble ystart = y1 * spaceTick;
    JavaLangStringBuilder *tmp = [new_JavaLangStringBuilder_init() autorelease];
    while (ystart < self->ymax_) {
      if (JavaLangMath_absWithDouble_(ystart) > 0.1) [tmp appendWithNSString:[self formatWithDouble:ystart]];
      ystart += spaceTick;
      y1++;
      if (ystart < self->ymax_ && JavaLangMath_absWithDouble_(ystart) > 0.1) [tmp appendWithNSString:@","];
    }
    JavaLangStringBuilder *buffer = [new_JavaLangStringBuilder_init() autorelease];
    [buffer appendWithNSString:@"\\foreach \\y in {"];
    [buffer appendWithJavaLangCharSequence:tmp];
    [buffer appendWithNSString:@"}\n"];
    [buffer appendWithNSString:@"\\draw[shift={(0,\\y)},color="];
    [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:buffer];
    JavaLangStringBuilder *ticks = [new_JavaLangStringBuilder_init() autorelease];
    if (tickStyle != GeogebraCommonPluginEuclidianStyleConstants_AXES_TICK_STYLE_NONE) [ticks appendWithNSString:@"] (2pt,0pt) -- (-2pt,0pt)"];
    else [ticks appendWithNSString:@"] (-2pt,0pt)"];
    if (showNumbers) {
      IOSObjectArray *units = [self->euclidianView_ getAxesUnitLabels];
      if (GeogebraCommonExportPstricksGeoGebraToPgf_hasMeasureUnitWithNSStringArray_withDouble_withInt_(self, units, spaceTick, 1)) {
        NSString *unit = GeogebraCommonExportPstricksGeoGebraToPgf_getUnitWithNSStringArray_withDouble_withInt_(self, units, spaceTick, 1);
        if (![((NSString *) nil_chk(unit)) contains:@"p"]) {
          [self->codeBeginDoc_ appendWithJavaLangCharSequence:buffer];
          [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
          [self->codeBeginDoc_ appendWithNSString:@" node[left] {"];
          if ([unit contains:@"c"]) {
            [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, JreStrcat("$$", @"\\y", unit))];
          }
          else {
            [self->codeBeginDoc_ appendWithNSString:JreStrcat("$$", GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"\\y"), unit)];
          }
          [self->codeBeginDoc_ appendWithNSString:@"};\n"];
        }
        else {
          if (![unit contains:@"2"]) {
            for (jint i = ystartInt; i < y1; i++) {
              if (i != 0) {
                [self->codeBeginDoc_ appendWithNSString:JreStrcat("$D$", @"\\draw[shift={(0,", (i * JavaLangMath_PI), @")},color=")];
                [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
                [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
                [self->codeBeginDoc_ appendWithNSString:@" node[left] {"];
                if (i == -1) {
                  [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, JreStrcat("C$", '-', unit))];
                }
                else {
                  if (i == 1) {
                    [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, unit)];
                  }
                  else {
                    [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, JreStrcat("I$", i, unit))];
                  }
                }
                [self->codeBeginDoc_ appendWithNSString:@"};\n"];
              }
            }
          }
          else {
            for (jint i = ystartInt; i < y1; i++) {
              if (i != 0) {
                [self->codeBeginDoc_ appendWithNSString:JreStrcat("$D$", @"\\draw[shift={(0,", (i * JavaLangMath_PI / 2), @")},color=")];
                [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
                [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
                [self->codeBeginDoc_ appendWithNSString:@" node[left] {"];
                if (i == -1) {
                  [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, JreStrcat("C$", '-', unit))];
                }
                else {
                  if (i == 1) {
                    [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, unit)];
                  }
                  else {
                    OrgApacheCommonsMathFractionFraction *f = [new_OrgApacheCommonsMathFractionFraction_initWithInt_withInt_(i, 2) autorelease];
                    if ([f doubleValue] == -1) {
                      [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"-\\pi")];
                    }
                    else {
                      if ([f doubleValue] == 1) {
                        [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"\\pi")];
                      }
                      else {
                        NSString *foot = JreStrcat("I$", [f getNumerator], @"\\pi");
                        if ([f getDenominator] != 1) {
                          foot = JreStrcat("$$", foot, JreStrcat("CI", '/', [f getDenominator]));
                        }
                        [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, foot)];
                      }
                    }
                  }
                }
                [self->codeBeginDoc_ appendWithNSString:@"};\n"];
              }
            }
          }
        }
      }
      else {
        [self->codeBeginDoc_ appendWithJavaLangCharSequence:buffer];
        [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
        [self->codeBeginDoc_ appendWithNSString:@" node[left] {"];
        [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"\\y")];
        [self->codeBeginDoc_ appendWithNSString:@"};\n"];
      }
    }
    else {
      [self->codeBeginDoc_ appendWithJavaLangCharSequence:buffer];
      [self->codeBeginDoc_ appendWithJavaLangCharSequence:ticks];
      [self->codeBeginDoc_ appendWithNSString:@";\n"];
    }
    if (nil != IOSObjectArray_Get(nil_chk(label), 1)) {
      [self->codeBeginDoc_ appendWithNSString:@"\\draw[color="];
      [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
      [self->codeBeginDoc_ appendWithNSString:@"] "];
      jint height = J2ObjCFpToInt(JavaLangMath_ceilWithDouble_(GeogebraCommonUtilStringUtil_estimateHeightWithNSString_withGeogebraCommonAwtGFont_(IOSObjectArray_Get(label, 1), [self->euclidianView_ getFont])));
      id<GeogebraCommonAwtGRectangle> rect = [self->euclidianView_ getSelectionRectangle];
      jdouble x = [self->euclidianView_ toRealWorldCoordXWithDouble:[self->euclidianView_ getXZero] + 5];
      jdouble y = [self->euclidianView_ toRealWorldCoordYWithDouble:5 + height];
      if (rect != nil) {
        y = [self->euclidianView_ toRealWorldCoordYWithDouble:[rect getMinY] + 5 + height];
      }
      GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(self, x, y, self->codeBeginDoc_);
      [self->codeBeginDoc_ appendWithNSString:@" node [anchor=west] { "];
      [self->codeBeginDoc_ appendWithNSString:IOSObjectArray_Get(label, 1)];
      [self->codeBeginDoc_ appendWithNSString:@"};\n"];
    }
  }
  jboolean notOrigin = ((self->xmax_ < 0 || self->xmin_ > 0) || (self->ymax_ < 0 || self->ymin_ > 0));
  if (!notOrigin && (IOSBooleanArray_Get(nil_chk([self->euclidianView_ getShowAxesNumbers]), 0) || IOSBooleanArray_Get(nil_chk([self->euclidianView_ getShowAxesNumbers]), 1))) {
    [((JavaLangStringBuilder *) nil_chk(self->codeBeginDoc_)) appendWithNSString:@"\\draw[color="];
    [self ColorCodeWithGeogebraCommonAwtGColor:color withJavaLangStringBuilder:self->codeBeginDoc_];
    [self->codeBeginDoc_ appendWithNSString:@"] (0pt,-10pt) node[right] {"];
    [self->codeBeginDoc_ appendWithNSString:GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(self, @"0")];
    [self->codeBeginDoc_ appendWithNSString:@"};\n"];
  }
}

NSString *GeogebraCommonExportPstricksGeoGebraToPgf_getUnitWithNSStringArray_withDouble_withInt_(GeogebraCommonExportPstricksGeoGebraToPgf *self, IOSObjectArray *units, jdouble spaceTick, jint xy) {
  if (spaceTick == JavaLangMath_PI / 2) {
    return @"\\pi/2";
  }
  if (spaceTick == JavaLangMath_PI || [((NSString *) nil_chk(IOSObjectArray_Get(nil_chk(units), xy))) charAtWithInt:0] == (jint) 0x03c0) {
    return @"\\pi";
  }
  if ([((NSString *) nil_chk(IOSObjectArray_Get(nil_chk(units), xy))) charAtWithInt:0] == (jint) 0x00b0) {
    return @"^\\circ";
  }
  return IOSObjectArray_Get(units, xy);
}

jboolean GeogebraCommonExportPstricksGeoGebraToPgf_hasMeasureUnitWithNSStringArray_withDouble_withInt_(GeogebraCommonExportPstricksGeoGebraToPgf *self, IOSObjectArray *units, jdouble spaceTick, jint xy) {
  return (units != nil && IOSObjectArray_Get(units, xy) != nil && ((jint) [((NSString *) nil_chk(IOSObjectArray_Get(units, xy))) length]) != 0) || spaceTick == JavaLangMath_PI || spaceTick == JavaLangMath_PI / 2;
}

NSString *GeogebraCommonExportPstricksGeoGebraToPgf_footnotesizeWithNSString_(GeogebraCommonExportPstricksGeoGebraToPgf *self, NSString *s) {
  if (self->format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_LATEX) return JreStrcat("$$C", @"\\footnotesize $", s, '$');
  else if (self->format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_CONTEXT) return JreStrcat("$$C", @"\\tfx $", s, '$');
  else if (self->format__ == GeogebraCommonExportPstricksGeoGebraToPgf_FORMAT_PLAIN_TEX) return JreStrcat("C$C", '$', s, '$');
  return s;
}

void GeogebraCommonExportPstricksGeoGebraToPgf_writePointWithDouble_withDouble_withJavaLangStringBuilder_(GeogebraCommonExportPstricksGeoGebraToPgf *self, jdouble x, jdouble y, JavaLangStringBuilder *sb) {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"("];
  [sb appendWithNSString:[self formatWithDouble:x]];
  [sb appendWithNSString:@","];
  [sb appendWithNSString:[self formatWithDouble:y]];
  [sb appendWithNSString:@")"];
}

void GeogebraCommonExportPstricksGeoGebraToPgf_LinestyleCodeWithInt_withJavaLangStringBuilder_(GeogebraCommonExportPstricksGeoGebraToPgf *self, jint linestyle, JavaLangStringBuilder *sb) {
  {
    jint size;
    jint size8;
    jint size1;
    jint size4;
    switch (linestyle) {
      case GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DOTTED:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"dotted"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_SHORT:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"dash pattern=on "];
      size = [self resizePtWithInt:4];
      [sb appendWithInt:size];
      [sb appendWithNSString:@"pt off "];
      [sb appendWithInt:size];
      [sb appendWithNSString:@"pt"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_LONG:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"dash pattern=on "];
      size8 = [self resizePtWithInt:8];
      [sb appendWithInt:size8];
      [sb appendWithNSString:@"pt off "];
      [sb appendWithInt:size8];
      [sb appendWithNSString:@"pt"];
      break;
      case GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_DOTTED:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"dash pattern=on "];
      size1 = [self resizePtWithInt:1];
      size4 = [self resizePtWithInt:4];
      size8 = [self resizePtWithInt:8];
      [sb appendWithInt:size1];
      [sb appendWithNSString:@"pt off "];
      [sb appendWithInt:size4];
      [sb appendWithNSString:@"pt on "];
      [sb appendWithInt:size8];
      [sb appendWithNSString:@"pt off "];
      [sb appendWithInt:4];
      [sb appendWithNSString:@"pt"];
      break;
    }
  }
}

NSString *GeogebraCommonExportPstricksGeoGebraToPgf_handleAxesStyle(GeogebraCommonExportPstricksGeoGebraToPgf *self) {
  NSString *styleAx = @"";
  if (([((GeogebraCommonEuclidianEuclidianView *) nil_chk(self->euclidianView_)) getAxesLineStyle] & GeogebraCommonPluginEuclidianStyleConstants_AXES_RIGHT_ARROW) == GeogebraCommonPluginEuclidianStyleConstants_AXES_RIGHT_ARROW) {
    styleAx = @"->,";
  }
  if (([self->euclidianView_ getAxesLineStyle] & GeogebraCommonPluginEuclidianStyleConstants_AXES_LEFT_ARROW) == GeogebraCommonPluginEuclidianStyleConstants_AXES_LEFT_ARROW) {
    styleAx = JreStrcat("C$", '<', styleAx);
  }
  if (([self->euclidianView_ getAxesLineStyle] & GeogebraCommonPluginEuclidianStyleConstants_AXES_BOLD) == GeogebraCommonPluginEuclidianStyleConstants_AXES_BOLD) {
    styleAx = JreStrcat("$$", styleAx, @"ultra thick,");
  }
  return styleAx;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonExportPstricksGeoGebraToPgf)
