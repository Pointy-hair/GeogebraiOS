//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/geos/GeoImage.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GBufferedImage.h"
#include "geogebra/common/awt/MyImage.h"
#include "geogebra/common/euclidian/EuclidianConstants.h"
#include "geogebra/common/euclidian/EuclidianViewInterfaceSlim.h"
#include "geogebra/common/factories/AwtFactory.h"
#include "geogebra/common/kernel/CircularDefinitionException.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/LocateableList.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoElementGraphicsAdapter.h"
#include "geogebra/common/kernel/geos/GeoImage.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/kernel/kernelND/GeoLineND.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "geogebra/common/util/StringUtil.h"
#include "java/lang/Double.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/Vector.h"

@interface GeogebraCommonKernelGeosGeoImage () {
 @public
  IOSObjectArray *corners_;
  jboolean inBackground_, defined_;
  jboolean hasAbsoluteLocation__;
  jboolean interpolate_;
  jint screenX_, screenY_;
  jboolean hasAbsoluteScreenLocation_;
  IOSObjectArray *tempPoints_;
  IOSDoubleArray *tempCoords_;
  JavaUtilArrayList *al_;
}

- (void)initTempPoints OBJC_METHOD_FAMILY_NONE;

- (void)updateHasAbsoluteLocation;

- (NSString *)getXMLabsScreenLoc;

- (NSString *)getCornerPointXMLWithInt:(jint)number;

- (void)getInternalCornerPointCoordsWithDoubleArray:(IOSDoubleArray *)coords
                                            withInt:(jint)n;

- (jboolean)initTransformPoints OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoImage, corners_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoImage, tempPoints_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoImage, tempCoords_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoImage, al_, JavaUtilArrayList *)

static JavaUtilVector *GeogebraCommonKernelGeosGeoImage_instances_;
J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelGeosGeoImage, instances_, JavaUtilVector *)
J2OBJC_STATIC_FIELD_SETTER(GeogebraCommonKernelGeosGeoImage, instances_, JavaUtilVector *)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoImage_initTempPoints(GeogebraCommonKernelGeosGeoImage *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoImage_updateHasAbsoluteLocation(GeogebraCommonKernelGeosGeoImage *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoImage_hasAbsoluteLocation(GeogebraCommonKernelGeosGeoImage *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoImage_isInterpolate(GeogebraCommonKernelGeosGeoImage *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoImage_isDefined(GeogebraCommonKernelGeosGeoImage *self);

__attribute__((unused)) static NSString *GeogebraCommonKernelGeosGeoImage_getXMLabsScreenLoc(GeogebraCommonKernelGeosGeoImage *self);

__attribute__((unused)) static NSString *GeogebraCommonKernelGeosGeoImage_getCornerPointXMLWithInt_(GeogebraCommonKernelGeosGeoImage *self, jint number);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoImage_getInternalCornerPointCoordsWithDoubleArray_withInt_(GeogebraCommonKernelGeosGeoImage *self, IOSDoubleArray *coords, jint n);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoImage_initTransformPoints(GeogebraCommonKernelGeosGeoImage *self);

J2OBJC_INITIALIZED_DEFN(GeogebraCommonKernelGeosGeoImage)

@implementation GeogebraCommonKernelGeosGeoImage

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c {
  GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                                            withNSString:(NSString *)label
                                            withNSString:(NSString *)fileName {
  GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_withNSString_withNSString_(self, c, label, fileName);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoImage:(GeogebraCommonKernelGeosGeoImage *)img {
  GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelGeosGeoImage_(self, img);
  return self;
}

- (GeogebraCommonKernelGeosGeoElement *)copy__ {
  return [new_GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelGeosGeoImage_(self) autorelease];
}

- (jint)getRelatedModeID {
  return GeogebraCommonEuclidianEuclidianConstants_MODE_IMAGE;
}

- (void)initTempPoints {
  GeogebraCommonKernelGeosGeoImage_initTempPoints(self);
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  GeogebraCommonKernelGeosGeoImage *img = (GeogebraCommonKernelGeosGeoImage *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoImage class]);
  [self setImageFileNameWithNSString:[((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([((GeogebraCommonKernelGeosGeoImage *) nil_chk(img)) getGraphicsAdapter])) getImageFileName]];
  if (cons_ != ((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo))->cons_ && [self isAlgoMacroOutput]) return;
  hasAbsoluteScreenLocation_ = img->hasAbsoluteScreenLocation_;
  if (hasAbsoluteScreenLocation_) {
    screenX_ = img->screenX_;
    screenY_ = img->screenY_;
  }
  else {
    hasAbsoluteLocation__ = YES;
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
      if (IOSObjectArray_Get(img->corners_, i) == nil) {
        IOSObjectArray_Set(corners_, i, nil);
      }
      else {
        GeogebraCommonKernelGeosGeoImage_initTempPoints(self);
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(img->corners_, i)];
        IOSObjectArray_Set(corners_, i, IOSObjectArray_Get(tempPoints_, i));
      }
    }
  }
  interpolate_ = img->interpolate_;
  defined_ = img->defined_;
}

- (void)setVisualStyleWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  [super setVisualStyleWithGeogebraCommonKernelGeosGeoElement:geo];
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoImage]) {
    inBackground_ = ((GeogebraCommonKernelGeosGeoImage *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoImage class]))->inBackground_;
  }
}

+ (void)updateInstances {
  GeogebraCommonKernelGeosGeoImage_updateInstances();
}

- (jboolean)showToolTipText {
  return !inBackground_ && [super showToolTipText];
}

- (jboolean)isInBackground {
  return inBackground_;
}

- (void)setInBackgroundWithBoolean:(jboolean)flag {
  inBackground_ = flag;
}

- (void)setImageFileNameWithNSString:(NSString *)fileName
                             withInt:(jint)width
                             withInt:(jint)height {
  if (fileName == nil) return;
  if ([((NSString *) nil_chk(fileName)) isEqual:[((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) getImageFileName]]) return;
  [((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) setImageFileNameOnlyWithNSString:fileName];
  [((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) setImageOnlyWithGeogebraCommonAwtMyImage:[((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getApplication])) getExternalImageAdapterWithNSString:fileName withInt:width withInt:height]];
  if ([((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) getImageOnly] != nil) {
    pixelWidth_ = [((id<GeogebraCommonAwtMyImage>) nil_chk([((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) getImageOnly])) getWidth];
    pixelHeight_ = [((id<GeogebraCommonAwtMyImage>) nil_chk([((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) getImageOnly])) getHeight];
  }
  else {
    pixelWidth_ = 0;
    pixelHeight_ = 0;
  }
}

- (void)setImageFileNameWithNSString:(NSString *)fileName {
  [self setImageFileNameWithNSString:fileName withInt:0 withInt:0];
}

- (void)setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p {
  [self setCornerWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(p, [GeogebraCommonKernelGeosGeoPoint class]) withInt:0];
}

- (void)removeStartPointWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p {
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    if (IOSObjectArray_Get(corners_, i) == p) [self setCornerWithGeogebraCommonKernelGeosGeoPoint:nil withInt:i];
  }
}

- (void)setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p
                                                        withInt:(jint)number {
  [self setCornerWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(p, [GeogebraCommonKernelGeosGeoPoint class]) withInt:number];
}

- (void)initStartPointWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p
                                                         withInt:(jint)number {
  IOSObjectArray_Set(nil_chk(corners_), number, (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(p, [GeogebraCommonKernelGeosGeoPoint class]));
}

- (void)setCornerWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)p
                                              withInt:(jint)number {
  if ([self isAlgoMacroOutput]) return;
  if (IOSObjectArray_Get(nil_chk(corners_), 0) == nil && number > 0) return;
  if ([self isParentOfWithGeogebraCommonKernelKernelNDGeoElementND:p]) return;
  if (p == nil) {
    if (IOSObjectArray_Get(corners_, number) != nil) [((GeogebraCommonKernelLocateableList *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, number))) getLocateableList])) unregisterLocateableWithGeogebraCommonKernelLocateable:self];
    if (number == 0 && IOSObjectArray_Get(corners_, 0) != nil) {
      GeogebraCommonKernelGeosGeoPoint *temp = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_) autorelease];
      [temp setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(corners_, 0)];
      IOSObjectArray_Set(corners_, 0, temp);
    }
    else IOSObjectArray_Set(corners_, number, nil);
  }
  else {
    for (jint i = 0; i < corners_->size_; i++) {
      if (p == IOSObjectArray_Get(corners_, i)) return;
    }
    if (IOSObjectArray_Get(corners_, number) != nil) [((GeogebraCommonKernelLocateableList *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, number))) getLocateableList])) unregisterLocateableWithGeogebraCommonKernelLocateable:self];
    IOSObjectArray_Set(corners_, number, p);
    [((GeogebraCommonKernelLocateableList *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, number))) getLocateableList])) registerLocateableWithGeogebraCommonKernelLocateable:self];
  }
  [self setAbsoluteScreenLocActiveWithBoolean:NO];
  GeogebraCommonKernelGeosGeoImage_updateHasAbsoluteLocation(self);
}

- (void)updateHasAbsoluteLocation {
  GeogebraCommonKernelGeosGeoImage_updateHasAbsoluteLocation(self);
}

- (void)doRemove {
  [((JavaUtilVector *) nil_chk(GeogebraCommonKernelGeosGeoImage_instances_)) removeWithId:self];
  if (inBackground_) {
    inBackground_ = NO;
    [self notifyUpdate];
  }
  [super doRemove];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    if (IOSObjectArray_Get(corners_, i) != nil) [((GeogebraCommonKernelLocateableList *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, i))) getLocateableList])) unregisterLocateableWithGeogebraCommonKernelLocateable:self];
  }
}

- (GeogebraCommonKernelGeosGeoPoint *)getStartPoint {
  return IOSObjectArray_Get(nil_chk(corners_), 0);
}

- (IOSObjectArray *)getStartPoints {
  return corners_;
}

- (GeogebraCommonKernelGeosGeoPoint *)getCornerWithInt:(jint)number {
  return IOSObjectArray_Get(nil_chk(corners_), number);
}

- (jboolean)hasAbsoluteLocation {
  return GeogebraCommonKernelGeosGeoImage_hasAbsoluteLocation(self);
}

- (jboolean)isInterpolate {
  return GeogebraCommonKernelGeosGeoImage_isInterpolate(self);
}

- (void)setInterpolateWithBoolean:(jboolean)flag {
  interpolate_ = flag;
}

- (void)setWaitForStartPoint {
}

- (jboolean)isDefined {
  return GeogebraCommonKernelGeosGeoImage_isDefined(self);
}

- (void)setUndefined {
  defined_ = NO;
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [self toStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return label_ == nil ? [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Image"] : label_;
}

- (jboolean)showInAlgebraView {
  return YES;
}

- (jboolean)showInEuclidianView {
  return [((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) getImageOnly] != nil && GeogebraCommonKernelGeosGeoImage_isDefined(self);
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_IMAGE();
}

- (jboolean)isMoveable {
  return (hasAbsoluteScreenLocation_ || hasAbsoluteLocation__) && [self isChangeable];
}

- (jboolean)isRotateMoveable {
  return !hasAbsoluteScreenLocation_ && hasAbsoluteLocation__ && [self isChangeable];
}

- (jboolean)isFillable {
  return YES;
}

- (jboolean)isNumberValue {
  return NO;
}

- (jboolean)isGeoImage {
  return YES;
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\t<file name=\""];
  [sb appendWithNSString:GeogebraCommonUtilStringUtil_encodeXMLWithNSString_([((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) getImageFileName])];
  [sb appendWithNSString:@"\"/>\n"];
  [sb appendWithNSString:@"\t<inBackground val=\""];
  [sb appendWithBoolean:inBackground_];
  [sb appendWithNSString:@"\"/>\n"];
  if (!GeogebraCommonKernelGeosGeoImage_isInterpolate(self)) [sb appendWithNSString:@"\t<interpolate val=\"false\"/>\n"];
  if (hasAbsoluteScreenLocation_) {
    [sb appendWithNSString:GeogebraCommonKernelGeosGeoImage_getXMLabsScreenLoc(self)];
  }
  else {
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
      if (IOSObjectArray_Get(corners_, i) != nil) {
        [sb appendWithNSString:GeogebraCommonKernelGeosGeoImage_getCornerPointXMLWithInt_(self, i)];
      }
    }
  }
  [self getAuxiliaryXMLWithJavaLangStringBuilder:sb];
  [super getXMLtagsWithJavaLangStringBuilder:sb];
}

- (NSString *)getXMLabsScreenLoc {
  return GeogebraCommonKernelGeosGeoImage_getXMLabsScreenLoc(self);
}

- (NSString *)getCornerPointXMLWithInt:(jint)number {
  return GeogebraCommonKernelGeosGeoImage_getCornerPointXMLWithInt_(self, number);
}

- (void)setAbsoluteScreenLocWithInt:(jint)x
                            withInt:(jint)y {
  screenX_ = x;
  screenY_ = y;
}

- (jint)getAbsoluteScreenLocX {
  return screenX_;
}

- (jint)getAbsoluteScreenLocY {
  return screenY_;
}

- (void)setRealWorldLocWithDouble:(jdouble)x
                       withDouble:(jdouble)y {
  GeogebraCommonKernelGeosGeoPoint *locPoint = [self getStartPoint];
  if (locPoint == nil) {
    locPoint = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_) autorelease];
    [self setCornerWithGeogebraCommonKernelGeosGeoPoint:locPoint withInt:0];
  }
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(locPoint)) setCoordsWithDouble:x withDouble:y withDouble:1.0];
}

- (jdouble)getRealWorldLocX {
  if (IOSObjectArray_Get(nil_chk(corners_), 0) == nil) {
    return 0;
  }
  return ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, 0)))->inhomX_;
}

- (jdouble)getRealWorldLocY {
  if (IOSObjectArray_Get(nil_chk(corners_), 0) == nil) {
    return 0;
  }
  return ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, 0)))->inhomY_;
}

- (void)setAbsoluteScreenLocActiveWithBoolean:(jboolean)flag {
  hasAbsoluteScreenLocation_ = flag;
  if (flag) {
    for (jint i = 0; i < 3; i++) {
      if (IOSObjectArray_Get(nil_chk(corners_), i) != nil) {
        [((GeogebraCommonKernelLocateableList *) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, i))) getLocateableList])) unregisterLocateableWithGeogebraCommonKernelLocateable:self];
      }
    }
    IOSObjectArray_Set(nil_chk(corners_), 1, nil);
    IOSObjectArray_Set(corners_, 2, nil);
  }
}

- (jboolean)isAbsoluteScreenLocActive {
  return hasAbsoluteScreenLocation_;
}

- (jboolean)isAbsoluteScreenLocateable {
  return [self isIndependent];
}

- (void)calculateCornerPointWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)result
                                                         withInt:(jint)n {
  if (hasAbsoluteScreenLocation_) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(result)) setUndefined];
    return;
  }
  if (IOSObjectArray_Get(nil_chk(corners_), 0) == nil) GeogebraCommonKernelGeosGeoImage_initTempPoints(self);
  {
    IOSDoubleArray *b;
    IOSDoubleArray *d;
    switch (n) {
      case 1:
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(result)) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(corners_, 0)];
      break;
      case 2:
      GeogebraCommonKernelGeosGeoImage_getInternalCornerPointCoordsWithDoubleArray_withInt_(self, tempCoords_, 1);
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(result)) setCoordsWithDouble:IOSDoubleArray_Get(nil_chk(tempCoords_), 0) withDouble:IOSDoubleArray_Get(tempCoords_, 1) withDouble:1.0];
      break;
      case 3:
      b = [IOSDoubleArray arrayWithLength:2];
      d = [IOSDoubleArray arrayWithLength:2];
      GeogebraCommonKernelGeosGeoImage_getInternalCornerPointCoordsWithDoubleArray_withInt_(self, b, 1);
      GeogebraCommonKernelGeosGeoImage_getInternalCornerPointCoordsWithDoubleArray_withInt_(self, d, 2);
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(result)) setCoordsWithDouble:IOSDoubleArray_Get(d, 0) + IOSDoubleArray_Get(b, 0) - ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, 0)))->inhomX_ withDouble:IOSDoubleArray_Get(d, 1) + IOSDoubleArray_Get(b, 1) - ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, 0)))->inhomY_ withDouble:1.0];
      break;
      case 4:
      GeogebraCommonKernelGeosGeoImage_getInternalCornerPointCoordsWithDoubleArray_withInt_(self, tempCoords_, 2);
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(result)) setCoordsWithDouble:IOSDoubleArray_Get(nil_chk(tempCoords_), 0) withDouble:IOSDoubleArray_Get(tempCoords_, 1) withDouble:1.0];
      break;
      default:
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(result)) setUndefined];
    }
  }
}

- (void)getInternalCornerPointCoordsWithDoubleArray:(IOSDoubleArray *)coords
                                            withInt:(jint)n {
  GeogebraCommonKernelGeosGeoImage_getInternalCornerPointCoordsWithDoubleArray_withInt_(self, coords, n);
}

- (jboolean)initTransformPoints {
  return GeogebraCommonKernelGeosGeoImage_initTransformPoints(self);
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phiValue {
  if (!GeogebraCommonKernelGeosGeoImage_initTransformPoints(self)) return;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) rotateWithGeogebraCommonKernelArithmeticNumberValue:phiValue];
    IOSObjectArray_Set(corners_, i, IOSObjectArray_Get(tempPoints_, i));
  }
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phiValue
                 withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)Q {
  if (!GeogebraCommonKernelGeosGeoImage_initTransformPoints(self)) return;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) rotateWithGeogebraCommonKernelArithmeticNumberValue:phiValue withGeogebraCommonKernelKernelNDGeoPointND:Q];
    IOSObjectArray_Set(corners_, i, IOSObjectArray_Get(tempPoints_, i));
  }
}

- (void)mirrorWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)Q {
  if (!GeogebraCommonKernelGeosGeoImage_initTransformPoints(self)) return;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) mirrorWithGeogebraCommonKernelMatrixCoords:Q];
    IOSObjectArray_Set(corners_, i, IOSObjectArray_Get(tempPoints_, i));
  }
}

- (void)matrixTransformWithDouble:(jdouble)a
                       withDouble:(jdouble)b
                       withDouble:(jdouble)c
                       withDouble:(jdouble)d {
  if (!GeogebraCommonKernelGeosGeoImage_initTransformPoints(self)) return;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    GeogebraCommonKernelGeosGeoVec2D *vec = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) getVector];
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(vec)) matrixTransformWithDouble:a withDouble:b withDouble:c withDouble:d];
    if (IOSObjectArray_Get(corners_, i) == nil) IOSObjectArray_SetAndConsume(corners_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_));
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, i))) setCoordsWithGeogebraCommonKernelGeosGeoVec2D:vec];
  }
}

- (jboolean)isMatrixTransformable {
  return YES;
}

- (void)mirrorWithGeogebraCommonKernelKernelNDGeoLineND:(id<GeogebraCommonKernelKernelNDGeoLineND>)g {
  if (!GeogebraCommonKernelGeosGeoImage_initTransformPoints(self)) return;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) mirrorWithGeogebraCommonKernelKernelNDGeoLineND:g];
    IOSObjectArray_Set(corners_, i, IOSObjectArray_Get(tempPoints_, i));
  }
}

- (void)translateWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)v {
  if (!GeogebraCommonKernelGeosGeoImage_initTransformPoints(self)) return;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) translateWithGeogebraCommonKernelMatrixCoords:v];
    IOSObjectArray_Set(corners_, i, IOSObjectArray_Get(tempPoints_, i));
  }
}

- (jboolean)isTranslateable {
  return YES;
}

- (void)dilateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)r
                       withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)S {
  if (!GeogebraCommonKernelGeosGeoImage_initTransformPoints(self)) return;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) dilateWithGeogebraCommonKernelArithmeticNumberValue:r withGeogebraCommonKernelMatrixCoords:S];
    IOSObjectArray_Set(corners_, i, IOSObjectArray_Get(tempPoints_, i));
  }
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoImage]) return NO;
  if (((GeogebraCommonKernelGeosGeoImage *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoImage class]))->pixelWidth_ != self->pixelWidth_) return NO;
  if (((GeogebraCommonKernelGeosGeoImage *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoImage class]))->pixelHeight_ != self->pixelHeight_) return NO;
  NSString *imageFileName = [((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) getImageFileName];
  NSString *md5A = [((NSString *) nil_chk(imageFileName)) substring:0 endIndex:[((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getApplication])) getMD5folderLengthWithNSString:imageFileName]];
  NSString *imageFileName2 = [((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([((GeogebraCommonKernelGeosGeoImage *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoImage class])) getGraphicsAdapter])) getImageFileName];
  NSString *md5B = [((NSString *) nil_chk(imageFileName2)) substring:0 endIndex:[((GeogebraCommonMainApp *) nil_chk([kernel_ getApplication])) getMD5folderLengthWithNSString:imageFileName]];
  if ([((NSString *) nil_chk(md5A)) isEqual:md5B]) return YES;
  return NO;
}

- (jboolean)isAlwaysFixed {
  return NO;
}

- (jboolean)hasMoveableInputPointsWithGeogebraCommonEuclidianEuclidianViewInterfaceSlim:(id<GeogebraCommonEuclidianEuclidianViewInterfaceSlim>)view {
  if (GeogebraCommonKernelGeosGeoImage_hasAbsoluteLocation(self)) return NO;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    if (IOSObjectArray_Get(corners_, i) != nil && ![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, i))) isMoveableWithGeogebraCommonEuclidianEuclidianViewInterfaceSlim:view]) return NO;
  }
  return YES;
}

- (JavaUtilArrayList *)getFreeInputPointsWithGeogebraCommonEuclidianEuclidianViewInterfaceSlim:(id<GeogebraCommonEuclidianEuclidianViewInterfaceSlim>)view {
  if (GeogebraCommonKernelGeosGeoImage_hasAbsoluteLocation(self)) return nil;
  if (al_ == nil) GeogebraCommonKernelGeosGeoImage_setAndConsume_al_(self, new_JavaUtilArrayList_init());
  else [al_ clear];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    if (IOSObjectArray_Get(corners_, i) != nil) [((JavaUtilArrayList *) nil_chk(al_)) addWithId:IOSObjectArray_Get(corners_, i)];
  }
  return al_;
}

- (jboolean)isAuxiliaryObjectByDefault {
  return YES;
}

- (jboolean)isAlgebraViewEditable {
  return NO;
}

- (void)matrixTransformWithDouble:(jdouble)a00
                       withDouble:(jdouble)a01
                       withDouble:(jdouble)a02
                       withDouble:(jdouble)a10
                       withDouble:(jdouble)a11
                       withDouble:(jdouble)a12
                       withDouble:(jdouble)a20
                       withDouble:(jdouble)a21
                       withDouble:(jdouble)a22 {
  GeogebraCommonKernelGeosGeoImage_initTempPoints(self);
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(corners_))->size_; i++) {
    GeogebraCommonKernelGeosGeoVec2D *vec = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(tempPoints_), i))) getVector];
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(vec)) matrixTransformWithDouble:a00 withDouble:a01 withDouble:a02 withDouble:a10 withDouble:a11 withDouble:a12 withDouble:a20 withDouble:a21 withDouble:a22];
    if (IOSObjectArray_Get(corners_, i) == nil) IOSObjectArray_SetAndConsume(corners_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_));
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(corners_, i))) setCoordsWithGeogebraCommonKernelGeosGeoVec2D:vec];
  }
}

- (void)clearFillImage {
  [((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([self getGraphicsAdapter])) setImageOnlyWithGeogebraCommonAwtMyImage:[((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newMyImageWithInt:pixelWidth_ withInt:pixelHeight_ withInt:GeogebraCommonAwtGBufferedImage_TYPE_INT_ARGB]];
  [self updateRepaint];
}

- (jboolean)isPinnable {
  return YES;
}

- (void)updateLocation {
  [self updateGeo];
  [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) notifyUpdateLocationWithGeogebraCommonKernelGeosGeoElement:self];
}

- (GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)getLastHitType {
  return GeogebraCommonKernelGeosGeoElement_HitTypeEnum_get_ON_FILLING();
}

- (void)dealloc {
  RELEASE_(corners_);
  RELEASE_(tempPoints_);
  RELEASE_(tempCoords_);
  RELEASE_(al_);
  [super dealloc];
}

+ (void)initialize {
  if (self == [GeogebraCommonKernelGeosGeoImage class]) {
    JreStrongAssignAndConsume(&GeogebraCommonKernelGeosGeoImage_instances_, nil, new_JavaUtilVector_init());
    J2OBJC_SET_INITIALIZED(GeogebraCommonKernelGeosGeoImage)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:", "GeoImage", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withNSString:withNSString:", "GeoImage", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoImage:", "GeoImage", NULL, 0x1, NULL, NULL },
    { "copy__", "copy", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "getRelatedModeID", NULL, "I", 0x1, NULL, NULL },
    { "initTempPoints", NULL, "V", 0x2, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "setVisualStyleWithGeogebraCommonKernelGeosGeoElement:", "setVisualStyle", "V", 0x1, NULL, NULL },
    { "updateInstances", NULL, "V", 0x9, NULL, NULL },
    { "showToolTipText", NULL, "Z", 0x1, NULL, NULL },
    { "isInBackground", NULL, "Z", 0x11, NULL, NULL },
    { "setInBackgroundWithBoolean:", "setInBackground", "V", 0x1, NULL, NULL },
    { "setImageFileNameWithNSString:withInt:withInt:", "setImageFileName", "V", 0x1, NULL, NULL },
    { "setImageFileNameWithNSString:", "setImageFileName", "V", 0x1, NULL, NULL },
    { "setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:", "setStartPoint", "V", 0x1, "Lgeogebra.common.kernel.CircularDefinitionException;", NULL },
    { "removeStartPointWithGeogebraCommonKernelKernelNDGeoPointND:", "removeStartPoint", "V", 0x1, NULL, NULL },
    { "setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:withInt:", "setStartPoint", "V", 0x1, "Lgeogebra.common.kernel.CircularDefinitionException;", NULL },
    { "initStartPointWithGeogebraCommonKernelKernelNDGeoPointND:withInt:", "initStartPoint", "V", 0x1, NULL, NULL },
    { "setCornerWithGeogebraCommonKernelGeosGeoPoint:withInt:", "setCorner", "V", 0x1, NULL, NULL },
    { "updateHasAbsoluteLocation", NULL, "V", 0x2, NULL, NULL },
    { "doRemove", NULL, "V", 0x1, NULL, NULL },
    { "getStartPoint", NULL, "Lgeogebra.common.kernel.geos.GeoPoint;", 0x1, NULL, NULL },
    { "getStartPoints", NULL, "[Lgeogebra.common.kernel.geos.GeoPoint;", 0x1, NULL, NULL },
    { "getCornerWithInt:", "getCorner", "Lgeogebra.common.kernel.geos.GeoPoint;", 0x11, NULL, NULL },
    { "hasAbsoluteLocation", NULL, "Z", 0x11, NULL, NULL },
    { "isInterpolate", NULL, "Z", 0x11, NULL, NULL },
    { "setInterpolateWithBoolean:", "setInterpolate", "V", 0x11, NULL, NULL },
    { "setWaitForStartPoint", NULL, "V", 0x1, NULL, NULL },
    { "isDefined", NULL, "Z", 0x11, NULL, NULL },
    { "setUndefined", NULL, "V", 0x1, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "showInAlgebraView", NULL, "Z", 0x1, NULL, NULL },
    { "showInEuclidianView", NULL, "Z", 0x4, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "isMoveable", NULL, "Z", 0x11, NULL, NULL },
    { "isRotateMoveable", NULL, "Z", 0x11, NULL, NULL },
    { "isFillable", NULL, "Z", 0x1, NULL, NULL },
    { "isNumberValue", NULL, "Z", 0x1, NULL, NULL },
    { "isGeoImage", NULL, "Z", 0x1, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "getXMLabsScreenLoc", NULL, "Ljava.lang.String;", 0x2, NULL, NULL },
    { "getCornerPointXMLWithInt:", "getCornerPointXML", "Ljava.lang.String;", 0x2, NULL, NULL },
    { "setAbsoluteScreenLocWithInt:withInt:", "setAbsoluteScreenLoc", "V", 0x1, NULL, NULL },
    { "getAbsoluteScreenLocX", NULL, "I", 0x1, NULL, NULL },
    { "getAbsoluteScreenLocY", NULL, "I", 0x1, NULL, NULL },
    { "setRealWorldLocWithDouble:withDouble:", "setRealWorldLoc", "V", 0x1, NULL, NULL },
    { "getRealWorldLocX", NULL, "D", 0x1, NULL, NULL },
    { "getRealWorldLocY", NULL, "D", 0x1, NULL, NULL },
    { "setAbsoluteScreenLocActiveWithBoolean:", "setAbsoluteScreenLocActive", "V", 0x1, NULL, NULL },
    { "isAbsoluteScreenLocActive", NULL, "Z", 0x1, NULL, NULL },
    { "isAbsoluteScreenLocateable", NULL, "Z", 0x1, NULL, NULL },
    { "calculateCornerPointWithGeogebraCommonKernelGeosGeoPoint:withInt:", "calculateCornerPoint", "V", 0x1, NULL, NULL },
    { "getInternalCornerPointCoordsWithDoubleArray:withInt:", "getInternalCornerPointCoords", "V", 0x2, NULL, NULL },
    { "initTransformPoints", NULL, "Z", 0x2, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:", "rotate", "V", 0x11, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelKernelNDGeoPointND:", "rotate", "V", 0x11, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelMatrixCoords:", "mirror", "V", 0x1, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "isMatrixTransformable", NULL, "Z", 0x1, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelKernelNDGeoLineND:", "mirror", "V", 0x1, NULL, NULL },
    { "translateWithGeogebraCommonKernelMatrixCoords:", "translate", "V", 0x1, NULL, NULL },
    { "isTranslateable", NULL, "Z", 0x11, NULL, NULL },
    { "dilateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelMatrixCoords:", "dilate", "V", 0x1, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x11, NULL, NULL },
    { "isAlwaysFixed", NULL, "Z", 0x1, NULL, NULL },
    { "hasMoveableInputPointsWithGeogebraCommonEuclidianEuclidianViewInterfaceSlim:", "hasMoveableInputPoints", "Z", 0x1, NULL, NULL },
    { "getFreeInputPointsWithGeogebraCommonEuclidianEuclidianViewInterfaceSlim:", "getFreeInputPoints", "Ljava.util.ArrayList;", 0x1, NULL, NULL },
    { "isAuxiliaryObjectByDefault", NULL, "Z", 0x11, NULL, NULL },
    { "isAlgebraViewEditable", NULL, "Z", 0x11, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "clearFillImage", NULL, "V", 0x1, NULL, NULL },
    { "isPinnable", NULL, "Z", 0x1, NULL, NULL },
    { "updateLocation", NULL, "V", 0x1, NULL, NULL },
    { "getLastHitType", NULL, "Lgeogebra.common.kernel.geos.GeoElement$HitType;", 0x11, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "corners_", NULL, 0x2, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "pixelWidth_", NULL, 0x4, "I", NULL, NULL,  },
    { "pixelHeight_", NULL, 0x4, "I", NULL, NULL,  },
    { "inBackground_", NULL, 0x2, "Z", NULL, NULL,  },
    { "defined_", NULL, 0x2, "Z", NULL, NULL,  },
    { "hasAbsoluteLocation__", "hasAbsoluteLocation", 0x2, "Z", NULL, NULL,  },
    { "interpolate_", NULL, 0x2, "Z", NULL, NULL,  },
    { "screenX_", NULL, 0x2, "I", NULL, NULL,  },
    { "screenY_", NULL, 0x2, "I", NULL, NULL,  },
    { "hasAbsoluteScreenLocation_", NULL, 0x2, "Z", NULL, NULL,  },
    { "tempPoints_", NULL, 0x2, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "instances_", NULL, 0xa, "Ljava.util.Vector;", &GeogebraCommonKernelGeosGeoImage_instances_, "Ljava/util/Vector<Lgeogebra/common/kernel/geos/GeoImage;>;",  },
    { "tempCoords_", NULL, 0x2, "[D", NULL, NULL,  },
    { "al_", NULL, 0x2, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/kernelND/GeoPointND;>;",  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoImage = { 2, "GeoImage", "geogebra.common.kernel.geos", NULL, 0x1, 75, methods, 14, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoImage;
}

@end

void GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelGeosGeoImage *self, GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoElement_initWithGeogebraCommonKernelConstruction_(self, c);
  self->interpolate_ = YES;
  self->hasAbsoluteScreenLocation_ = NO;
  GeogebraCommonKernelGeosGeoImage_setAndConsume_tempCoords_(self, [IOSDoubleArray newArrayWithLength:2]);
  GeogebraCommonKernelGeosGeoImage_set_al_(self, nil);
  [self setConstructionDefaults];
  [self setAlphaValueWithFloat:1.0f];
  [self setAuxiliaryObjectWithBoolean:YES];
  GeogebraCommonKernelGeosGeoImage_setAndConsume_corners_(self, [IOSObjectArray newArrayWithLength:3 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
  [((JavaUtilVector *) nil_chk(GeogebraCommonKernelGeosGeoImage_instances_)) addWithId:self];
  self->defined_ = YES;
}

GeogebraCommonKernelGeosGeoImage *new_GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoImage *self = [GeogebraCommonKernelGeosGeoImage alloc];
  GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

void GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_withNSString_withNSString_(GeogebraCommonKernelGeosGeoImage *self, GeogebraCommonKernelConstruction *c, NSString *label, NSString *fileName) {
  GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_(self, c);
  [self setImageFileNameWithNSString:fileName];
  [self setLabelWithNSString:label];
}

GeogebraCommonKernelGeosGeoImage *new_GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_withNSString_withNSString_(GeogebraCommonKernelConstruction *c, NSString *label, NSString *fileName) {
  GeogebraCommonKernelGeosGeoImage *self = [GeogebraCommonKernelGeosGeoImage alloc];
  GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_withNSString_withNSString_(self, c, label, fileName);
  return self;
}

void GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelGeosGeoImage_(GeogebraCommonKernelGeosGeoImage *self, GeogebraCommonKernelGeosGeoImage *img) {
  GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelConstruction_(self, ((GeogebraCommonKernelGeosGeoImage *) nil_chk(img))->cons_);
  [self setWithGeogebraCommonKernelGeosGeoElement:img];
}

GeogebraCommonKernelGeosGeoImage *new_GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelGeosGeoImage_(GeogebraCommonKernelGeosGeoImage *img) {
  GeogebraCommonKernelGeosGeoImage *self = [GeogebraCommonKernelGeosGeoImage alloc];
  GeogebraCommonKernelGeosGeoImage_initWithGeogebraCommonKernelGeosGeoImage_(self, img);
  return self;
}

void GeogebraCommonKernelGeosGeoImage_initTempPoints(GeogebraCommonKernelGeosGeoImage *self) {
  if (self->tempPoints_ == nil) {
    GeogebraCommonKernelGeosGeoImage_setAndConsume_tempPoints_(self, [IOSObjectArray newArrayWithLength:3 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
    for (jint i = 0; i < self->tempPoints_->size_; i++) {
      IOSObjectArray_SetAndConsume(self->tempPoints_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(self->cons_));
    }
  }
  if (IOSObjectArray_Get(nil_chk(self->corners_), 0) == nil) IOSObjectArray_Set(self->corners_, 0, IOSObjectArray_Get(nil_chk(self->tempPoints_), 0));
}

void GeogebraCommonKernelGeosGeoImage_updateInstances() {
  GeogebraCommonKernelGeosGeoImage_initialize();
  for (jint i = [((JavaUtilVector *) nil_chk(GeogebraCommonKernelGeosGeoImage_instances_)) size] - 1; i >= 0; i--) {
    GeogebraCommonKernelGeosGeoImage *geo = [GeogebraCommonKernelGeosGeoImage_instances_ getWithInt:i];
    [geo setImageFileNameWithNSString:[((GeogebraCommonKernelGeosGeoElementGraphicsAdapter *) nil_chk([((GeogebraCommonKernelGeosGeoImage *) nil_chk(geo)) getGraphicsAdapter])) getImageFileName]];
    [geo updateCascade];
  }
}

void GeogebraCommonKernelGeosGeoImage_updateHasAbsoluteLocation(GeogebraCommonKernelGeosGeoImage *self) {
  self->hasAbsoluteLocation__ = YES;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->corners_))->size_; i++) {
    if (!(IOSObjectArray_Get(self->corners_, i) == nil || [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->corners_, i))) isAbsoluteStartPoint])) {
      self->hasAbsoluteLocation__ = NO;
      return;
    }
  }
}

jboolean GeogebraCommonKernelGeosGeoImage_hasAbsoluteLocation(GeogebraCommonKernelGeosGeoImage *self) {
  return self->hasAbsoluteLocation__;
}

jboolean GeogebraCommonKernelGeosGeoImage_isInterpolate(GeogebraCommonKernelGeosGeoImage *self) {
  return self->interpolate_;
}

jboolean GeogebraCommonKernelGeosGeoImage_isDefined(GeogebraCommonKernelGeosGeoImage *self) {
  if (!self->defined_) return NO;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->corners_))->size_; i++) {
    if (IOSObjectArray_Get(self->corners_, i) != nil && ![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->corners_, i))) isDefined]) return NO;
  }
  return YES;
}

NSString *GeogebraCommonKernelGeosGeoImage_getXMLabsScreenLoc(GeogebraCommonKernelGeosGeoImage *self) {
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  [sb appendWithNSString:@"\t<absoluteScreenLocation x=\""];
  [sb appendWithInt:self->screenX_];
  [sb appendWithNSString:@"\" y=\""];
  [sb appendWithInt:self->screenY_];
  [sb appendWithNSString:@"\"/>"];
  return [sb description];
}

NSString *GeogebraCommonKernelGeosGeoImage_getCornerPointXMLWithInt_(GeogebraCommonKernelGeosGeoImage *self, jint number) {
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  [sb appendWithNSString:@"\t<startPoint number=\""];
  [sb appendWithInt:number];
  [sb appendWithNSString:@"\""];
  if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->corners_), number))) isAbsoluteStartPoint]) {
    [sb appendWithNSString:JreStrcat("$DC", @" x=\"", ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->corners_, number)))->x_, '"')];
    [sb appendWithNSString:JreStrcat("$DC", @" y=\"", ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->corners_, number)))->y_, '"')];
    [sb appendWithNSString:JreStrcat("$DC", @" z=\"", ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->corners_, number)))->z_, '"')];
  }
  else {
    [sb appendWithNSString:@" exp=\""];
    GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sb, [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->corners_, number))) getLabelWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_xmlTemplate_()]);
    [sb appendWithNSString:@"\""];
  }
  [sb appendWithNSString:@"/>\n"];
  return [sb description];
}

void GeogebraCommonKernelGeosGeoImage_getInternalCornerPointCoordsWithDoubleArray_withInt_(GeogebraCommonKernelGeosGeoImage *self, IOSDoubleArray *coords, jint n) {
  GeogebraCommonKernelGeosGeoPoint *A = IOSObjectArray_Get(nil_chk(self->corners_), 0);
  GeogebraCommonKernelGeosGeoPoint *B = IOSObjectArray_Get(self->corners_, 1);
  GeogebraCommonKernelGeosGeoPoint *D = IOSObjectArray_Get(self->corners_, 2);
  jdouble xscale = [((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getXscale];
  jdouble yscale = [self->kernel_ getYscale];
  jdouble width = self->pixelWidth_;
  jdouble height = self->pixelHeight_;
  if (xscale != yscale) {
    height = height * yscale / xscale;
  }
  switch (n) {
    case 0:
    *IOSDoubleArray_GetRef(nil_chk(coords), 0) = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(A))->inhomX_;
    *IOSDoubleArray_GetRef(coords, 1) = A->inhomY_;
    break;
    case 1:
    if (B != nil) {
      *IOSDoubleArray_GetRef(nil_chk(coords), 0) = B->inhomX_;
      *IOSDoubleArray_GetRef(coords, 1) = B->inhomY_;
    }
    else {
      if (D == nil) {
        *IOSDoubleArray_GetRef(nil_chk(coords), 0) = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(A))->inhomX_ + width / xscale;
        *IOSDoubleArray_GetRef(coords, 1) = A->inhomY_;
      }
      else {
        jdouble nx = D->inhomY_ - ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(A))->inhomY_;
        jdouble ny = A->inhomX_ - D->inhomX_;
        jdouble factor = width / height;
        *IOSDoubleArray_GetRef(nil_chk(coords), 0) = A->inhomX_ + factor * nx;
        *IOSDoubleArray_GetRef(coords, 1) = A->inhomY_ + factor * ny;
      }
    }
    break;
    case 2:
    if (D != nil) {
      *IOSDoubleArray_GetRef(nil_chk(coords), 0) = D->inhomX_;
      *IOSDoubleArray_GetRef(coords, 1) = D->inhomY_;
    }
    else {
      if (B == nil) {
        *IOSDoubleArray_GetRef(nil_chk(coords), 0) = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(A))->inhomX_;
        *IOSDoubleArray_GetRef(coords, 1) = A->inhomY_ + height / yscale;
      }
      else {
        jdouble nx = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(A))->inhomY_ - B->inhomY_;
        jdouble ny = B->inhomX_ - A->inhomX_;
        jdouble factor = height / width;
        *IOSDoubleArray_GetRef(nil_chk(coords), 0) = A->inhomX_ + factor * nx;
        *IOSDoubleArray_GetRef(coords, 1) = A->inhomY_ + factor * ny;
      }
    }
    break;
    default:
    *IOSDoubleArray_GetRef(nil_chk(coords), 0) = JavaLangDouble_NaN;
    *IOSDoubleArray_GetRef(coords, 1) = JavaLangDouble_NaN;
  }
}

jboolean GeogebraCommonKernelGeosGeoImage_initTransformPoints(GeogebraCommonKernelGeosGeoImage *self) {
  if (self->hasAbsoluteScreenLocation_ || !self->hasAbsoluteLocation__) return NO;
  GeogebraCommonKernelGeosGeoImage_initTempPoints(self);
  [self calculateCornerPointWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(nil_chk(self->tempPoints_), 0) withInt:1];
  [self calculateCornerPointWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(self->tempPoints_, 1) withInt:2];
  [self calculateCornerPointWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(self->tempPoints_, 2) withInt:4];
  return YES;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoImage)
