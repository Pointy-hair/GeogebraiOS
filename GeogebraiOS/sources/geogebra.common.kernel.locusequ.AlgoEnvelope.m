//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/locusequ/AlgoEnvelope.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/cas/GeoGebraCAS.h"
#include "geogebra/common/cas/giac/CASgiac.h"
#include "geogebra/common/cas/singularws/SingularWebService.h"
#include "geogebra/common/kernel/CASGenericInterface.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/GeoGebraCasInterface.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Path.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoPointOnPath.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "geogebra/common/kernel/locusequ/AlgoEnvelope.h"
#include "geogebra/common/kernel/locusequ/CASTranslator.h"
#include "geogebra/common/kernel/locusequ/EquationAuxiliarSymbolicPoint.h"
#include "geogebra/common/kernel/locusequ/EquationHelpers.h"
#include "geogebra/common/kernel/locusequ/EquationList.h"
#include "geogebra/common/kernel/locusequ/EquationPoint.h"
#include "geogebra/common/kernel/locusequ/EquationScope.h"
#include "geogebra/common/kernel/locusequ/EquationSystem.h"
#include "geogebra/common/kernel/locusequ/arith/Equation.h"
#include "geogebra/common/kernel/locusequ/arith/EquationSymbolicValue.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/util/debug/Log.h"
#include "java/lang/Exception.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/Throwable.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/Collection.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/Set.h"
#include "java/util/TreeSet.h"

@interface GeogebraCommonKernelLocusequAlgoEnvelope () {
 @public
  GeogebraCommonKernelGeosGeoPoint *movingPoint_;
  GeogebraCommonKernelGeosGeoElement *path_;
  GeogebraCommonKernelImplicitGeoImplicitPoly *geoPoly_;
  IOSObjectArray *efficientInput_AlgoEnvelope_, *standardInput_;
}

- (NSString *)getImplicitPoly;

+ (void)addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList:(GeogebraCommonKernelLocusequEquationList *)restrictions
                               withGeogebraCommonKernelAlgosAlgoElement:(GeogebraCommonKernelAlgosAlgoElement *)algo
                          withGeogebraCommonKernelLocusequEquationScope:(GeogebraCommonKernelLocusequEquationScope *)scope
                                                        withJavaUtilSet:(id<JavaUtilSet>)visitedAlgos;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelLocusequAlgoEnvelope, movingPoint_, GeogebraCommonKernelGeosGeoPoint *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelLocusequAlgoEnvelope, path_, GeogebraCommonKernelGeosGeoElement *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelLocusequAlgoEnvelope, geoPoly_, GeogebraCommonKernelImplicitGeoImplicitPoly *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelLocusequAlgoEnvelope, efficientInput_AlgoEnvelope_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelLocusequAlgoEnvelope, standardInput_, IOSObjectArray *)

__attribute__((unused)) static NSString *GeogebraCommonKernelLocusequAlgoEnvelope_getImplicitPoly(GeogebraCommonKernelLocusequAlgoEnvelope *self);

__attribute__((unused)) static void GeogebraCommonKernelLocusequAlgoEnvelope_addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList_withGeogebraCommonKernelAlgosAlgoElement_withGeogebraCommonKernelLocusequEquationScope_withJavaUtilSet_(GeogebraCommonKernelLocusequEquationList *restrictions, GeogebraCommonKernelAlgosAlgoElement *algo, GeogebraCommonKernelLocusequEquationScope *scope, id<JavaUtilSet> visitedAlgos);

NSString *GeogebraCommonKernelLocusequAlgoEnvelope_CLASS_NAME_ = @"AlgoEnvelope";

@implementation GeogebraCommonKernelLocusequAlgoEnvelope

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                                            withNSString:(NSString *)label
                  withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)path
                    withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)movingPoint {
  GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(self, cons, label, path, movingPoint);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                  withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)path
                    withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)movingPoint {
  GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(self, cons, path, movingPoint);
  return self;
}

- (void)setInputOutput {
  JavaUtilTreeSet *inSet = [new_JavaUtilTreeSet_init() autorelease];
  [inSet addWithId:[((id<GeogebraCommonKernelPath>) nil_chk([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(self->movingPoint_)) getPath])) toGeoElement]];
  id<JavaUtilIterator> it = [((JavaUtilTreeSet *) nil_chk([((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->path_)) getAllPredecessors])) iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    GeogebraCommonKernelGeosGeoElement *geo = [it next];
    if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isIndependent] || [geo isPointOnPath]) {
      [inSet addWithId:geo];
    }
  }
  [inSet removeWithId:movingPoint_];
  GeogebraCommonKernelLocusequAlgoEnvelope_setAndConsume_efficientInput_AlgoEnvelope_(self, [IOSObjectArray newArrayWithLength:[inSet size] type:GeogebraCommonKernelGeosGeoElement_class_()]);
  GeogebraCommonKernelLocusequAlgoEnvelope_set_efficientInput_AlgoEnvelope_(self, [inSet toArrayWithNSObjectArray:efficientInput_AlgoEnvelope_]);
  GeogebraCommonKernelLocusequAlgoEnvelope_setAndConsume_standardInput_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoElement_class_()]);
  IOSObjectArray_Set(standardInput_, 0, self->path_);
  IOSObjectArray_Set(standardInput_, 1, self->movingPoint_);
  [self setOutputLengthWithInt:1];
  [self setOutputWithInt:0 withGeogebraCommonKernelGeosGeoElement:self->geoPoly_];
  [self setEfficientDependenciesWithGeogebraCommonKernelGeosGeoElementArray:standardInput_ withGeogebraCommonKernelGeosGeoElementArray:efficientInput_AlgoEnvelope_];
}

- (GeogebraCommonKernelImplicitGeoImplicitPoly *)getPoly {
  return self->geoPoly_;
}

- (void)compute {
  NSString *result = nil;
  @try {
    result = GeogebraCommonKernelLocusequAlgoEnvelope_getImplicitPoly(self);
  }
  @catch (JavaLangThrowable *ex) {
    GeogebraCommonUtilDebugLog_warnWithNSString_(@"Error computing implicit curve");
  }
  if (result != nil) {
    @try {
      [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(self->geoPoly_)) setCoeffWithDoubleArray2:GeogebraCommonKernelLocusequCASTranslator_getBivarPolyCoefficientsSingularWithNSString_(result)];
      [self->geoPoly_ setDefined];
    }
    @catch (JavaLangException *e) {
      [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(self->geoPoly_)) setUndefined];
    }
  }
  else {
    [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(self->geoPoly_)) setUndefined];
  }
}

- (NSString *)getImplicitPoly {
  return GeogebraCommonKernelLocusequAlgoEnvelope_getImplicitPoly(self);
}

+ (void)addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList:(GeogebraCommonKernelLocusequEquationList *)restrictions
                               withGeogebraCommonKernelAlgosAlgoElement:(GeogebraCommonKernelAlgosAlgoElement *)algo
                          withGeogebraCommonKernelLocusequEquationScope:(GeogebraCommonKernelLocusequEquationScope *)scope
                                                        withJavaUtilSet:(id<JavaUtilSet>)visitedAlgos {
  GeogebraCommonKernelLocusequAlgoEnvelope_addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList_withGeogebraCommonKernelAlgosAlgoElement_withGeogebraCommonKernelLocusequEquationScope_withJavaUtilSet_(restrictions, algo, scope, visitedAlgos);
}

- (GeogebraCommonKernelCommandsCommandsEnum *)getClassName {
  return GeogebraCommonKernelCommandsCommandsEnum_get_Envelope();
}

- (void)dealloc {
  RELEASE_(movingPoint_);
  RELEASE_(path_);
  RELEASE_(geoPoly_);
  RELEASE_(efficientInput_AlgoEnvelope_);
  RELEASE_(standardInput_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withNSString:withGeogebraCommonKernelGeosGeoElement:withGeogebraCommonKernelGeosGeoPoint:", "AlgoEnvelope", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelGeosGeoElement:withGeogebraCommonKernelGeosGeoPoint:", "AlgoEnvelope", NULL, 0x1, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x4, NULL, NULL },
    { "getPoly", NULL, "Lgeogebra.common.kernel.implicit.GeoImplicitPoly;", 0x1, NULL, NULL },
    { "compute", NULL, "V", 0x1, NULL, NULL },
    { "getImplicitPoly", NULL, "Ljava.lang.String;", 0x2, "Ljava.lang.Throwable;", NULL },
    { "addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList:withGeogebraCommonKernelAlgosAlgoElement:withGeogebraCommonKernelLocusequEquationScope:withJavaUtilSet:", "addAlgoIfNotVisited", "V", 0xa, NULL, NULL },
    { "getClassName", NULL, "Lgeogebra.common.kernel.commands.Commands;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "movingPoint_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "path_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoElement;", NULL, NULL,  },
    { "CLASS_NAME_", NULL, 0x19, "Ljava.lang.String;", &GeogebraCommonKernelLocusequAlgoEnvelope_CLASS_NAME_, NULL,  },
    { "geoPoly_", NULL, 0x2, "Lgeogebra.common.kernel.implicit.GeoImplicitPoly;", NULL, NULL,  },
    { "efficientInput_AlgoEnvelope_", "efficientInput", 0x2, "[Lgeogebra.common.kernel.geos.GeoElement;", NULL, NULL,  },
    { "standardInput_", NULL, 0x2, "[Lgeogebra.common.kernel.geos.GeoElement;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelLocusequAlgoEnvelope = { 2, "AlgoEnvelope", "geogebra.common.kernel.locusequ", NULL, 0x1, 8, methods, 6, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelLocusequAlgoEnvelope;
}

@end

void GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelLocusequAlgoEnvelope *self, GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelGeosGeoElement *path, GeogebraCommonKernelGeosGeoPoint *movingPoint) {
  GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(self, cons, path, movingPoint);
  [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(self->geoPoly_)) setLabelWithNSString:label];
}

GeogebraCommonKernelLocusequAlgoEnvelope *new_GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelGeosGeoElement *path, GeogebraCommonKernelGeosGeoPoint *movingPoint) {
  GeogebraCommonKernelLocusequAlgoEnvelope *self = [GeogebraCommonKernelLocusequAlgoEnvelope alloc];
  GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(self, cons, label, path, movingPoint);
  return self;
}

void GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelLocusequAlgoEnvelope *self, GeogebraCommonKernelConstruction *cons, GeogebraCommonKernelGeosGeoElement *path, GeogebraCommonKernelGeosGeoPoint *movingPoint) {
  GeogebraCommonKernelAlgosAlgoElement_initWithGeogebraCommonKernelConstruction_(self, cons);
  GeogebraCommonKernelLocusequAlgoEnvelope_set_movingPoint_(self, movingPoint);
  GeogebraCommonKernelLocusequAlgoEnvelope_set_path_(self, path);
  GeogebraCommonKernelLocusequAlgoEnvelope_setAndConsume_geoPoly_(self, new_GeogebraCommonKernelImplicitGeoImplicitPoly_initWithGeogebraCommonKernelConstruction_(cons));
  [self setInputOutput];
  [self compute];
}

GeogebraCommonKernelLocusequAlgoEnvelope *new_GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelConstruction *cons, GeogebraCommonKernelGeosGeoElement *path, GeogebraCommonKernelGeosGeoPoint *movingPoint) {
  GeogebraCommonKernelLocusequAlgoEnvelope *self = [GeogebraCommonKernelLocusequAlgoEnvelope alloc];
  GeogebraCommonKernelLocusequAlgoEnvelope_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(self, cons, path, movingPoint);
  return self;
}

NSString *GeogebraCommonKernelLocusequAlgoEnvelope_getImplicitPoly(GeogebraCommonKernelLocusequAlgoEnvelope *self) {
  NSString *locusLib = GeogebraCommonCasSingularwsSingularWebService_getLocusLib();
  GeogebraCommonKernelLocusequEquationScope *scope = [new_GeogebraCommonKernelLocusequEquationScope_initWithGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoPoint_(self->path_, self->movingPoint_) autorelease];
  IOSObjectArray *points = GeogebraCommonKernelLocusequEquationHelpers_getDependentPredecessorPointsForElementWithGeogebraCommonKernelGeosGeoElement_(self->path_);
  GeogebraCommonKernelLocusequEquationPoint *pequ;
  GeogebraCommonKernelLocusequEquationList *restrictions = [new_GeogebraCommonKernelLocusequEquationList_init() autorelease];
  GeogebraCommonKernelAlgosAlgoElement *algo;
  id<JavaUtilSet> visitedAlgos = [new_JavaUtilHashSet_init() autorelease];
  jboolean constructionIsFeasible = YES;
  {
    IOSObjectArray *a__ = points;
    GeogebraCommonKernelGeosGeoPoint * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    GeogebraCommonKernelGeosGeoPoint * const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      GeogebraCommonKernelGeosGeoPoint *p = *b__++;
      pequ = [scope getPointWithGeogebraCommonKernelGeosGeoPoint:p];
      if (![((GeogebraCommonKernelLocusequEquationPoint *) nil_chk(pequ)) isIndependent]) {
        GeogebraCommonKernelLocusequAlgoEnvelope_addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList_withGeogebraCommonKernelAlgosAlgoElement_withGeogebraCommonKernelLocusequEquationScope_withJavaUtilSet_(restrictions, [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p)) getParentAlgorithm], scope, visitedAlgos);
        if ([p getParentAlgorithm] != nil && ![((GeogebraCommonKernelAlgosAlgoElement *) nil_chk([p getParentAlgorithm])) isLocusEquable]) {
          constructionIsFeasible = NO;
          break;
        }
        for (id __strong algoObj in nil_chk([p getAlgorithmList])) {
          algo = (GeogebraCommonKernelAlgosAlgoElement *) check_class_cast(algoObj, [GeogebraCommonKernelAlgosAlgoElement class]);
          GeogebraCommonKernelLocusequAlgoEnvelope_addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList_withGeogebraCommonKernelAlgosAlgoElement_withGeogebraCommonKernelLocusequEquationScope_withJavaUtilSet_(restrictions, algo, scope, visitedAlgos);
        }
      }
    }
  }
  for (GeogebraCommonKernelLocusequEquationAuxiliarSymbolicPoint * __strong p in nil_chk([scope getAuxiliarSymbolicPoints])) {
    [restrictions addAllWithJavaUtilCollection:[((GeogebraCommonKernelLocusequEquationAuxiliarSymbolicPoint *) nil_chk(p)) getRestrictions]];
  }
  GeogebraCommonKernelGeosGeoPoint *locusPoint = [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(self->cons_) autorelease];
  GeogebraCommonKernelAlgosAlgoPointOnPath *apop = [new_GeogebraCommonKernelAlgosAlgoPointOnPath_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelPath_withDouble_withDouble_(self->cons_, (id<GeogebraCommonKernelPath>) check_protocol_cast(self->path_, @protocol(GeogebraCommonKernelPath)), 1, 1) autorelease];
  [locusPoint setParentAlgorithmWithGeogebraCommonKernelAlgosAlgoElement:apop];
  GeogebraCommonKernelLocusequEquationList *last = [new_GeogebraCommonKernelLocusequEquationList_init() autorelease];
  GeogebraCommonKernelLocusequAlgoEnvelope_addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList_withGeogebraCommonKernelAlgosAlgoElement_withGeogebraCommonKernelLocusequEquationScope_withJavaUtilSet_(last, apop, scope, visitedAlgos);
  [locusPoint remove];
  if (!constructionIsFeasible) {
    return nil;
  }
  GeogebraCommonKernelLocusequCASTranslator *ct = [new_GeogebraCommonKernelLocusequCASTranslator_initWithGeogebraCommonKernelKernel_(self->kernel_) autorelease];
  GeogebraCommonKernelLocusequEquationSystem *es = [new_GeogebraCommonKernelLocusequEquationSystem_initWithGeogebraCommonKernelLocusequEquationList_withGeogebraCommonKernelLocusequEquationScope_(restrictions, scope) autorelease];
  id<JavaUtilCollection> restrictionsT = [ct translateWithGeogebraCommonKernelLocusequEquationSystem:es];
  es = [new_GeogebraCommonKernelLocusequEquationSystem_initWithGeogebraCommonKernelLocusequEquationList_withGeogebraCommonKernelLocusequEquationScope_(last, scope) autorelease];
  id<JavaUtilCollection> lastT = [ct translateWithGeogebraCommonKernelLocusequEquationSystem:es];
  id<JavaUtilCollection> scopeVars = [scope getAllVariables];
  jint varsN = [((id<JavaUtilCollection>) nil_chk(scopeVars)) size];
  IOSIntArray *scopeVarsI = [IOSIntArray arrayWithLength:varsN];
  id<JavaUtilIterator> it = [scopeVars iterator];
  jint i = 0;
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    *IOSIntArray_GetRef(scopeVarsI, i++) = [((GeogebraCommonKernelLocusequArithEquationSymbolicValue *) nil_chk(((GeogebraCommonKernelLocusequArithEquationSymbolicValue *) check_class_cast([it next], [GeogebraCommonKernelLocusequArithEquationSymbolicValue class])))) getId];
  }
  JavaUtilArrays_sortWithIntArray_(scopeVarsI);
  NSString *varx = JreStrcat("CI", 'x', IOSIntArray_Get(scopeVarsI, varsN - 2));
  NSString *vary = JreStrcat("CI", 'x', IOSIntArray_Get(scopeVarsI, varsN - 1));
  IOSObjectArray *lastS = [IOSObjectArray arrayWithLength:[((id<JavaUtilCollection>) nil_chk(lastT)) size] type:NSString_class_()];
  it = [lastT iterator];
  i = 0;
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    NSString *eq = [nil_chk([it next]) description];
    eq = [((NSString *) nil_chk(eq)) replaceAll:varx withReplacement:@"x"];
    eq = [((NSString *) nil_chk(eq)) replaceAll:vary withReplacement:@"y"];
    eq = GeogebraCommonKernelLocusequCASTranslator_convertFloatsToRationalsWithNSString_(eq);
    IOSObjectArray_Set(lastS, i++, eq);
  }
  NSString *vars = @"";
  for (i = 0; i < varsN - 2; ++i) {
    vars = JreStrcat("$$", vars, JreStrcat("CI", 'x', IOSIntArray_Get(scopeVarsI, i)));
    if (i < varsN - 3) {
      vars = JreStrcat("$C", vars, ',');
    }
  }
  NSString *polys = @"";
  it = [((id<JavaUtilCollection>) nil_chk(restrictionsT)) iterator];
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    polys = JreStrcat("$$", polys, JreStrcat("$C", GeogebraCommonKernelLocusequCASTranslator_convertFloatsToRationalsWithNSString_([nil_chk([it next]) description]), ','));
  }
  it = [lastT iterator];
  for (i = 0; i < lastS->size_; ++i) {
    polys = JreStrcat("$$", polys, GeogebraCommonKernelLocusequCASTranslator_convertFloatsToRationalsWithNSString_(IOSObjectArray_Get(lastS, i)));
    if (i < lastS->size_ - 1) {
      polys = JreStrcat("$C", polys, ',');
    }
  }
  JavaLangStringBuilder *script = [new_JavaLangStringBuilder_init() autorelease];
  if (((jint) [((NSString *) nil_chk(locusLib)) length]) == 0) {
    [script appendWithNSString:@"[["];
    [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([script appendWithNSString:@"m:=["])) appendWithNSString:polys])) appendWithNSString:@"]],[J:=det("];
    for (i = 0; i < varsN - 2; ++i) {
      [script appendWithNSString:@"["];
      for (jint j = 0; j < varsN - 2; ++j) {
        [script appendWithNSString:JreStrcat("$I$IC", @"diff(m[", i, @"],x", IOSIntArray_Get(scopeVarsI, j), ')')];
        if (j != varsN - 3) {
          [script appendWithNSString:@","];
        }
      }
      [script appendWithNSString:@"]"];
      if (i != varsN - 3) {
        [script appendWithNSString:@","];
      }
    }
    [script appendWithNSString:@")]][1][0]"];
    GeogebraCommonUtilDebugLog_infoWithNSString_(JreStrcat("$@", @"[Envelope] input to giac (compute det of Jacobi matrix): ", script));
    GeogebraCommonCasGeoGebraCAS *cas = (GeogebraCommonCasGeoGebraCAS *) check_class_cast([((GeogebraCommonKernelKernel *) nil_chk([locusPoint getKernel])) getGeoGebraCAS], [GeogebraCommonCasGeoGebraCAS class]);
    @try {
      NSString *det = [((id<GeogebraCommonKernelCASGenericInterface>) nil_chk([((GeogebraCommonCasGeoGebraCAS *) nil_chk(cas)) getCurrentCAS])) evaluateRawWithNSString:[script description]];
      GeogebraCommonUtilDebugLog_infoWithNSString_(JreStrcat("$$", @"[Envelope] output from giac (compute det of Jacobi matrix): ", det));
      NSString *script2 = [((id<GeogebraCommonKernelCASGenericInterface>) nil_chk([cas getCurrentCAS])) createLocusEquationScriptWithNSString:JreStrcat("$C$", polys, ',', det) withNSString:JreStrcat("$$", vars, @",x,y") withNSString:vars];
      GeogebraCommonUtilDebugLog_infoWithNSString_(JreStrcat("$$", @"[Envelope] input to giac: ", script2));
      @try {
        [cas evaluateRawWithNSString:GeogebraCommonCasGiacCASgiac_get_closeString_()];
      }
      @catch (JavaLangThrowable *e) {
        [((JavaLangThrowable *) nil_chk(e)) printStackTrace];
      }
      NSString *result = [((id<GeogebraCommonKernelCASGenericInterface>) nil_chk([cas getCurrentCAS])) evaluateRawWithNSString:script2];
      @try {
        [cas evaluateRawWithNSString:GeogebraCommonCasGiacCASgiac_get_initString_()];
      }
      @catch (JavaLangThrowable *e) {
        [((JavaLangThrowable *) nil_chk(e)) printStackTrace];
      }
      result = [result substring:1 endIndex:((jint) [((NSString *) nil_chk(result)) length]) - 1];
      return result;
    }
    @catch (JavaLangException *ex) {
      GeogebraCommonUtilDebugLog_warnWithNSString_(@"Error computing envelope");
      return nil;
    }
  }
  [script appendWithNSString:@"proc mylocusdgto(list L) {poly p=1;int i; int j; int k;for(i=1;i<=size(L);i++) { if(L[i][3]<>\"Degenerate\") { if(size(L[i][1])>1) {p=p*((L[i][1][1])^2+(L[i][1][2])^2);}else {p=p*L[i][1][1];}} } return(p); }"];
  [script appendWithNSString:@"proc myenvelopeto (list GG) {list GGG;if (GG[1][2][1]<>1) { GGG=delete(GG,1); }else { GGG=GG; };string SLo=locusto(locus(GGG));if (find(SLo,\"Normal\") == 0 and find(SLo,\"Accumulation\") == 0 and find(SLo,\"Special\") == 0){ return(1); }else { return(mylocusdgto(locus(GGG))); } }"];
  [((JavaLangStringBuilder *) nil_chk([script appendWithNSString:JreStrcat("$$$$", @"LIB \"", locusLib, @".lib\";ring r=(0,x,y),(", vars)])) appendWithNSString:@"),dp;short=0;ideal m="];
  [script appendWithNSString:polys];
  [script appendWithNSString:JreStrcat("$$$", @";poly D=det(jacob(m));ideal S=", polys, @",D;list e=myenvelopeto(grobcov(S));")];
  [script appendWithNSString:@"string ex=\"poly p=\" + string(e[1]);"];
  [script appendWithNSString:@"ring rr=0,(x,y),dp;"];
  [script appendWithNSString:@"execute(ex);"];
  [((JavaLangStringBuilder *) nil_chk([script appendWithNSString:@"printf(\"%s,%s,%s\",size(coeffs(p,x)),size(coeffs(p,y)),"])) appendWithNSString:@"coeffs(coeffs(p,x),y));"];
  GeogebraCommonUtilDebugLog_infoWithNSString_(JreStrcat("$@", @"[Envelope] input to singular: ", script));
  NSString *result = [((GeogebraCommonCasSingularwsSingularWebService *) nil_chk(GeogebraCommonMainApp_get_singularWS_())) directCommandWithNSString:[script description]];
  GeogebraCommonUtilDebugLog_infoWithNSString_(JreStrcat("$$", @"[Envelope] output from singular: ", result));
  return result;
}

void GeogebraCommonKernelLocusequAlgoEnvelope_addAlgoIfNotVisitedWithGeogebraCommonKernelLocusequEquationList_withGeogebraCommonKernelAlgosAlgoElement_withGeogebraCommonKernelLocusequEquationScope_withJavaUtilSet_(GeogebraCommonKernelLocusequEquationList *restrictions, GeogebraCommonKernelAlgosAlgoElement *algo, GeogebraCommonKernelLocusequEquationScope *scope, id<JavaUtilSet> visitedAlgos) {
  GeogebraCommonKernelLocusequAlgoEnvelope_initialize();
  if (![((id<JavaUtilSet>) nil_chk(visitedAlgos)) containsWithId:algo]) {
    [visitedAlgos addWithId:algo];
    GeogebraCommonKernelLocusequEquationList *eqs = [((GeogebraCommonKernelLocusequEquationScope *) nil_chk(scope)) getRestrictionsFromAlgoWithGeogebraCommonKernelAlgosAlgoElement:algo];
    GeogebraCommonMainApp_debugWithNSString_(@"[Envelope] Restrictions init");
    GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$", @"[Envelope] Construction ", [((GeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(nil_chk([((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(algo)) getOutput]), 0))) description]));
    for (GeogebraCommonKernelLocusequArithEquation * __strong eq in nil_chk(eqs)) {
      GeogebraCommonMainApp_debugWithNSString_([((GeogebraCommonKernelLocusequArithEquation *) nil_chk(eq)) description]);
    }
    GeogebraCommonMainApp_debugWithNSString_(@"[Envelope] Restrictions end");
    [((GeogebraCommonKernelLocusequEquationList *) nil_chk(restrictions)) addAllWithJavaUtilCollection:eqs];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelLocusequAlgoEnvelope)
