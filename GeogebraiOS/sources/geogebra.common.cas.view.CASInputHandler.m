//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/cas/view/CASInputHandler.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/cas/view/CASInputHandler.h"
#include "geogebra/common/cas/view/CASTable.h"
#include "geogebra/common/cas/view/CASTableCellEditor.h"
#include "geogebra/common/cas/view/CASView.h"
#include "geogebra/common/cas/view/MarbleRenderer.h"
#include "geogebra/common/kernel/CASException.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/GeoGebraCasInterface.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/arithmetic/AssignmentType.h"
#include "geogebra/common/kernel/arithmetic/Command.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/FunctionNVar.h"
#include "geogebra/common/kernel/arithmetic/Inspecting.h"
#include "geogebra/common/kernel/arithmetic/MyList.h"
#include "geogebra/common/kernel/arithmetic/MySpecialDouble.h"
#include "geogebra/common/kernel/arithmetic/ValidExpression.h"
#include "geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "geogebra/common/kernel/geos/GeoCasCell.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/parser/ParseException.h"
#include "geogebra/common/kernel/parser/Parser.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/util/StringUtil.h"
#include "java/lang/ArrayIndexOutOfBoundsException.h"
#include "java/lang/Character.h"
#include "java/lang/Double.h"
#include "java/lang/Integer.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/Throwable.h"
#include "java/util/ArrayList.h"

@interface GeogebraCommonCasViewCASInputHandler () {
 @public
  GeogebraCommonCasViewCASView *casView_;
  GeogebraCommonKernelKernel *kernel_;
  id<GeogebraCommonCasViewCASTable> consoleTable_;
}

+ (jboolean)meaningfulSelectionWithNSString:(NSString *)text;

- (void)processMultipleRowsWithNSString:(NSString *)ggbcmd;

- (void)handleReferenceWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                         withInt:(jint)selectedRow
                                         withInt:(jint)referenceNumber
                                     withBoolean:(jboolean)addParentheses
                                     withBoolean:(jboolean)noParentheses
                                     withBoolean:(jboolean)needOutput;

- (void)appendReferenceWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                    withNSString:(NSString *)reference
                                     withBoolean:(jboolean)addParentheses
                                     withBoolean:(jboolean)noParentheses;

+ (jboolean)isPositiveNumberWithNSString:(NSString *)s;

- (NSString *)fixInputErrorsWithNSString:(NSString *)input;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonCasViewCASInputHandler, casView_, GeogebraCommonCasViewCASView *)
J2OBJC_FIELD_SETTER(GeogebraCommonCasViewCASInputHandler, kernel_, GeogebraCommonKernelKernel *)
J2OBJC_FIELD_SETTER(GeogebraCommonCasViewCASInputHandler, consoleTable_, id<GeogebraCommonCasViewCASTable>)

__attribute__((unused)) static jboolean GeogebraCommonCasViewCASInputHandler_meaningfulSelectionWithNSString_(NSString *text);

__attribute__((unused)) static void GeogebraCommonCasViewCASInputHandler_processMultipleRowsWithNSString_(GeogebraCommonCasViewCASInputHandler *self, NSString *ggbcmd);

__attribute__((unused)) static void GeogebraCommonCasViewCASInputHandler_handleReferenceWithJavaLangStringBuilder_withInt_withInt_withBoolean_withBoolean_withBoolean_(GeogebraCommonCasViewCASInputHandler *self, JavaLangStringBuilder *sb, jint selectedRow, jint referenceNumber, jboolean addParentheses, jboolean noParentheses, jboolean needOutput);

__attribute__((unused)) static void GeogebraCommonCasViewCASInputHandler_appendReferenceWithJavaLangStringBuilder_withNSString_withBoolean_withBoolean_(GeogebraCommonCasViewCASInputHandler *self, JavaLangStringBuilder *sb, NSString *reference, jboolean addParentheses, jboolean noParentheses);

__attribute__((unused)) static jboolean GeogebraCommonCasViewCASInputHandler_isPositiveNumberWithNSString_(NSString *s);

__attribute__((unused)) static NSString *GeogebraCommonCasViewCASInputHandler_fixInputErrorsWithNSString_(GeogebraCommonCasViewCASInputHandler *self, NSString *input);

@implementation GeogebraCommonCasViewCASInputHandler

- (instancetype)initWithGeogebraCommonCasViewCASView:(GeogebraCommonCasViewCASView *)view {
  GeogebraCommonCasViewCASInputHandler_initWithGeogebraCommonCasViewCASView_(self, view);
  return self;
}

- (void)processCurrentRowWithNSString:(NSString *)ggbcmd {
  jint selRow = [((id<GeogebraCommonCasViewCASTable>) nil_chk(consoleTable_)) getSelectedRow];
  if (selRow < 0) return;
  GeogebraCommonKernelGeosGeoCasCell *cellValue = [consoleTable_ getGeoCasCellWithInt:selRow];
  if ([((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(cellValue)) isUseAsText]) {
    [self processRowThenEditWithInt:selRow withBoolean:YES];
    return;
  }
  if (([((NSString *) nil_chk(ggbcmd)) equalsIgnoreCase:@"Solve"] || [ggbcmd equalsIgnoreCase:@"NSolve"]) && (((IOSIntArray *) nil_chk([consoleTable_ getSelectedRows]))->size_ > 1)) {
    GeogebraCommonCasViewCASInputHandler_processMultipleRowsWithNSString_(self, ggbcmd);
    return;
  }
  [cellValue setErrorWithNSString:nil];
  id<GeogebraCommonCasViewCASTableCellEditor> cellEditor = [consoleTable_ getEditor];
  NSString *selectedText = [((id<GeogebraCommonCasViewCASTableCellEditor>) nil_chk(cellEditor)) getInputSelectedText];
  jint selStart = [cellEditor getInputSelectionStart];
  jint selEnd = [cellEditor getInputSelectionEnd];
  NSString *selRowInput = [cellEditor getInput];
  if (selRowInput != nil && [selRowInput hasPrefix:@"@"]) {
    @try {
      NSString *s = [((id<GeogebraCommonKernelGeoGebraCasInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getGeoGebraCAS])) evaluateRawWithNSString:[selRowInput substring:1]];
      [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) processAlgebraCommandNoExceptionHandlingWithNSString:JreStrcat("$$C", @"casOutput=\"", s, '"') withBoolean:NO withBoolean:NO withBoolean:NO withBoolean:NO];
    }
    @catch (JavaLangThrowable *e) {
      [((JavaLangThrowable *) nil_chk(e)) printStackTrace];
    }
    return;
  }
  if (selRowInput == nil || ((jint) [selRowInput length]) == 0) {
    if ([consoleTable_ getSelectedRow] != -1) {
      [consoleTable_ startEditingRowWithInt:[consoleTable_ getSelectedRow]];
      GeogebraCommonKernelGeosGeoCasCell *cell = [consoleTable_ getGeoCasCellWithInt:[consoleTable_ getSelectedRow]];
      if ([((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(cell)) getInputVE] != nil) selRowInput = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([cell getInputVE])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericDefault_()];
    }
    if (((jint) [((NSString *) nil_chk(selRowInput)) length]) == 0) return;
  }
  [consoleTable_ stopEditing];
  NSString *prefix, *evalText, *postfix;
  jboolean hasSelectedText = GeogebraCommonCasViewCASInputHandler_meaningfulSelectionWithNSString_(selectedText);
  if (hasSelectedText) {
    prefix = JreStrcat("$C", [((NSString *) nil_chk([((NSString *) nil_chk(selRowInput)) substring:0 endIndex:selStart])) trim], ' ');
    if (selStart > 0 || selEnd < ((jint) [selRowInput length])) {
      evalText = JreStrcat("C$C", '(', selectedText, ')');
      jchar firstEvalChar = [((NSString *) nil_chk([((NSString *) nil_chk(selectedText)) trim])) charAtWithInt:0];
      if (firstEvalChar == '+' || firstEvalChar == '-') {
        prefix = JreStrcat("$C", prefix, '+');
      }
    }
    else {
      evalText = selectedText;
    }
    postfix = [((NSString *) nil_chk([selRowInput substring:selEnd])) trim];
  }
  else {
    prefix = @"";
    evalText = selRowInput;
    postfix = @"";
  }
  @try {
    jboolean staticReferenceFound = NO;
    NSString *newPrefix = [self resolveCASrowReferencesWithNSString:prefix withInt:selRow withChar:GeogebraCommonKernelGeosGeoCasCell_ROW_REFERENCE_STATIC withBoolean:NO];
    if (![((NSString *) nil_chk(newPrefix)) isEqual:prefix]) {
      staticReferenceFound = YES;
      prefix = newPrefix;
    }
    NSString *newEvalText = [self resolveCASrowReferencesWithNSString:evalText withInt:selRow withChar:GeogebraCommonKernelGeosGeoCasCell_ROW_REFERENCE_STATIC withBoolean:hasSelectedText];
    if (![((NSString *) nil_chk(newEvalText)) isEqual:evalText]) {
      staticReferenceFound = YES;
      evalText = newEvalText;
    }
    NSString *newPostfix = [self resolveCASrowReferencesWithNSString:postfix withInt:selRow withChar:GeogebraCommonKernelGeosGeoCasCell_ROW_REFERENCE_STATIC withBoolean:NO];
    if (![((NSString *) nil_chk(newPostfix)) isEqual:postfix]) {
      staticReferenceFound = YES;
      postfix = newPostfix;
    }
    if (staticReferenceFound) {
      [cellValue setInputWithNSString:JreStrcat("$$$", newPrefix, newEvalText, newPostfix)];
    }
    if (!hasSelectedText && ([ggbcmd isEqual:@"Evaluate"] || [ggbcmd isEqual:@"KeepInput"])) {
      NSString *fixedInput = GeogebraCommonCasViewCASInputHandler_fixInputErrorsWithNSString_(self, selRowInput);
      if (![((NSString *) nil_chk(fixedInput)) isEqual:selRowInput]) {
        [cellValue setInputWithNSString:fixedInput];
        evalText = fixedInput;
      }
    }
    jboolean structureOK = [cellValue isStructurallyEqualToLocalizedInputWithNSString:JreStrcat("$$$", prefix, evalText, postfix)];
    if (!structureOK) {
      [consoleTable_ startEditingRowWithInt:selRow];
      cellEditor = [consoleTable_ getEditor];
      [((id<GeogebraCommonCasViewCASTableCellEditor>) nil_chk(cellEditor)) setInputSelectionStartWithInt:selStart];
      [cellEditor setInputSelectionEndWithInt:selEnd];
      return;
    }
    jboolean isAssignment = [cellValue getAssignmentVariable] != nil;
    jboolean isEvaluate = [ggbcmd isEqual:@"Evaluate"];
    jboolean isNumeric = [ggbcmd isEqual:@"Numeric"];
    jboolean isKeepInput = [ggbcmd isEqual:@"KeepInput"];
    if ([ggbcmd isEqual:@"Substitute"]) {
      if (isAssignment && !hasSelectedText) {
        evalText = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([cellValue getInputVE])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
      }
      [((GeogebraCommonCasViewCASView *) nil_chk(casView_)) showSubstituteDialogWithNSString:prefix withNSString:evalText withNSString:postfix withInt:selRow];
      return;
    }
    if (isAssignment) {
      GeogebraCommonKernelArithmeticValidExpression *inVE = [cellValue getInputVE];
      if (isNumeric && inVE != nil) {
        if ([inVE getTopLevelCommand] == nil || ![((NSString *) nil_chk([((GeogebraCommonKernelArithmeticCommand *) nil_chk([inVE getTopLevelCommand])) getName])) isEqual:@"Numeric"]) {
          [cellValue setProcessingInformationWithNSString:prefix withNSString:JreStrcat("$C$C", ggbcmd, '[', [inVE toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericDefault_()], ']') withNSString:postfix];
        }
      }
      else {
        [cellValue setProcessingInformationWithNSString:prefix withNSString:[cellValue getInputWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()] withNSString:postfix];
      }
      if (isKeepInput || isEvaluate || isNumeric) {
        [cellValue setEvalCommandWithNSString:ggbcmd];
      }
      jboolean needInsertRow = !isEvaluate && !isKeepInput && !isNumeric;
      jboolean success = [self processRowThenEditWithInt:selRow withBoolean:!needInsertRow];
      if (success && needInsertRow) {
        NSString *ggbcmd1 = ggbcmd;
        GeogebraCommonKernelArithmeticValidExpression *outputVE = [cellValue getOutputValidExpression];
        NSString *assignmentLabel = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk(outputVE)) getLabelForAssignment];
        NSString *label = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([cellValue getEvalVE])) getLabelForAssignment];
        GeogebraCommonKernelGeosGeoCasCell *newRowValue = [new_GeogebraCommonKernelGeosGeoCasCell_initWithGeogebraCommonKernelConstruction_([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getConstruction]) autorelease];
        JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_initWithNSString_(label) autorelease];
        jboolean isDerivative = [ggbcmd isEqual:@"Derivative"];
        jboolean isIntegral = !isDerivative && [ggbcmd isEqual:@"Integral"];
        if ((isDerivative || isIntegral) && [[outputVE unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]]) {
          if (isDerivative) {
            [sb appendWithChar:'\''];
          }
          [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([sb appendWithChar:'('])) appendWithNSString:[((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast([outputVE unwrap], [GeogebraCommonKernelArithmeticFunctionNVar class])))) getVarStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]])) appendWithChar:')'];
          [sb appendWithNSString:[outputVE getAssignmentOperator]];
          [((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([((JavaLangStringBuilder *) nil_chk([sb appendWithNSString:ggbcmd])) appendWithChar:'['])) appendWithNSString:assignmentLabel])) appendWithChar:']'];
          ggbcmd1 = @"Evaluate";
        }
        [newRowValue setInputWithNSString:[sb description]];
        [((GeogebraCommonCasViewCASView *) nil_chk(casView_)) insertRowWithGeogebraCommonKernelGeosGeoCasCell:newRowValue withBoolean:YES];
        [self processCurrentRowWithNSString:ggbcmd1];
      }
      return;
    }
    jboolean wrapEvalText = !isEvaluate && !isKeepInput && !(isNumeric && ([((NSString *) nil_chk(evalText)) hasPrefix:@"N["] || [evalText hasPrefix:@"N("] || [evalText hasPrefix:@"Numeric["] || [evalText hasPrefix:@"Numeric("]));
    if (wrapEvalText) {
      JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
      [sb appendWithNSString:ggbcmd];
      [sb appendWithNSString:@"["];
      [sb appendWithNSString:evalText];
      [sb appendWithNSString:@"]"];
      evalText = [sb description];
    }
    [cellValue setProcessingInformationWithNSString:prefix withNSString:evalText withNSString:postfix];
    [cellValue setEvalCommandWithNSString:ggbcmd];
  }
  @catch (GeogebraCommonKernelCASException *ex) {
    [cellValue setErrorWithNSString:[((GeogebraCommonKernelCASException *) nil_chk(ex)) getKey]];
  }
  [self processRowThenEditWithInt:selRow withBoolean:YES];
}

+ (jboolean)meaningfulSelectionWithNSString:(NSString *)text {
  return GeogebraCommonCasViewCASInputHandler_meaningfulSelectionWithNSString_(text);
}

- (void)deleteCurrentRow {
  IOSIntArray *selected = [((id<GeogebraCommonCasViewCASTable>) nil_chk(consoleTable_)) getSelectedRows];
  {
    IOSIntArray *a__ = selected;
    jint const *b__ = ((IOSIntArray *) nil_chk(a__))->buffer_;
    jint const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      jint current = *b__++;
      GeogebraCommonKernelGeosGeoCasCell *cell = [consoleTable_ getGeoCasCellWithInt:current];
      if (cell != nil) {
        [cell remove];
        [((GeogebraCommonMainApp *) nil_chk([consoleTable_ getApplication])) storeUndoInfo];
      }
    }
  }
}

- (void)processMultipleRowsWithNSString:(NSString *)ggbcmd {
  GeogebraCommonCasViewCASInputHandler_processMultipleRowsWithNSString_(self, ggbcmd);
}

- (jboolean)processRowThenEditWithInt:(jint)selRow
                          withBoolean:(jboolean)startEditing {
  GeogebraCommonKernelGeosGeoCasCell *cellValue = [((id<GeogebraCommonCasViewCASTable>) nil_chk(consoleTable_)) getGeoCasCellWithInt:selRow];
  jboolean success;
  jboolean isLastRow = [consoleTable_ getRowCount] <= selRow + 1;
  if (![((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(cellValue)) isError] && ![cellValue isUseAsText]) {
    [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) processCasCellWithGeogebraCommonKernelGeosGeoCasCell:cellValue withBoolean:isLastRow];
  }
  else if ([cellValue isIndependent] && ![cellValue isUseAsText]) {
    [((GeogebraCommonKernelConstruction *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getConstruction])) addToConstructionListWithGeogebraCommonKernelAlgosConstructionElement:cellValue withBoolean:YES];
  }
  else if ([cellValue isUseAsText]) {
    [((GeogebraCommonKernelConstruction *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getConstruction])) addToConstructionListWithGeogebraCommonKernelAlgosConstructionElement:cellValue withBoolean:YES];
    [kernel_ notifyAddWithGeogebraCommonKernelGeosGeoElement:cellValue];
  }
  [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) notifyRepaint];
  jint rowNum = [cellValue getRowNumber];
  isLastRow = ([consoleTable_ getRowCount] <= rowNum + 1);
  success = ![cellValue isError];
  if (startEditing || !success) {
    jboolean goDown = success && (isLastRow || [((GeogebraCommonCasViewCASView *) nil_chk(casView_)) isRowOutputEmptyWithInt:rowNum + 1]);
    [consoleTable_ startEditingRowWithInt:goDown ? rowNum + 1 : rowNum];
  }
  return success;
}

- (NSString *)resolveCASrowReferencesWithNSString:(NSString *)str
                                          withInt:(jint)selectedRow
                                         withChar:(jchar)delimiter
                                      withBoolean:(jboolean)noParentheses {
  jboolean newNoParentheses = noParentheses;
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  {
    jboolean foundReference;
    jboolean addParentheses;
    jboolean startOfReferenceNumber;
    jboolean needOutput;
    jint referenceNumber;
    switch (delimiter) {
      case GeogebraCommonKernelGeosGeoCasCell_ROW_REFERENCE_DYNAMIC:
      case GeogebraCommonKernelGeosGeoCasCell_ROW_REFERENCE_STATIC:
      GeogebraCommonMainApp_debugWithNSString_(JreStrcat("I$$", selectedRow, @": ", str));
      foundReference = NO;
      addParentheses = NO;
      startOfReferenceNumber = NO;
      needOutput = YES;
      referenceNumber = -1;
      for (jint i = 0; i < ((jint) [((NSString *) nil_chk(str)) length]); i++) {
        jchar c = [str charAtWithInt:i];
        if (foundReference) {
          if (GeogebraCommonUtilStringUtil_isDigitWithChar_(c)) {
            if (startOfReferenceNumber) {
              startOfReferenceNumber = NO;
              referenceNumber = 0;
            }
            referenceNumber = referenceNumber * 10 + JavaLangCharacter_digitWithChar_withInt_(c, 10);
            continue;
          }
          else if (c == delimiter) {
            needOutput = NO;
            continue;
          }
          foundReference = NO;
          if (c != ')') {
            addParentheses = YES;
            newNoParentheses = NO;
          }
          GeogebraCommonCasViewCASInputHandler_handleReferenceWithJavaLangStringBuilder_withInt_withInt_withBoolean_withBoolean_withBoolean_(self, sb, selectedRow, referenceNumber, addParentheses, newNoParentheses, needOutput);
        }
        if (c != delimiter) {
          [sb appendWithChar:c];
          addParentheses = YES;
          if ((i == 0 && c != '(') || (i > 0 && c != ')')) {
            newNoParentheses = NO;
          }
        }
        else {
          foundReference = YES;
          startOfReferenceNumber = YES;
        }
      }
      if (foundReference) {
        GeogebraCommonCasViewCASInputHandler_handleReferenceWithJavaLangStringBuilder_withInt_withInt_withBoolean_withBoolean_withBoolean_(self, sb, selectedRow, referenceNumber, addParentheses, newNoParentheses, needOutput);
      }
      break;
    }
  }
  return [sb description];
}

- (void)handleReferenceWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                         withInt:(jint)selectedRow
                                         withInt:(jint)referenceNumber
                                     withBoolean:(jboolean)addParentheses
                                     withBoolean:(jboolean)noParentheses
                                     withBoolean:(jboolean)needOutput {
  GeogebraCommonCasViewCASInputHandler_handleReferenceWithJavaLangStringBuilder_withInt_withInt_withBoolean_withBoolean_withBoolean_(self, sb, selectedRow, referenceNumber, addParentheses, noParentheses, needOutput);
}

- (void)appendReferenceWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                    withNSString:(NSString *)reference
                                     withBoolean:(jboolean)addParentheses
                                     withBoolean:(jboolean)noParentheses {
  GeogebraCommonCasViewCASInputHandler_appendReferenceWithJavaLangStringBuilder_withNSString_withBoolean_withBoolean_(self, sb, reference, addParentheses, noParentheses);
}

+ (jboolean)isPositiveNumberWithNSString:(NSString *)s {
  return GeogebraCommonCasViewCASInputHandler_isPositiveNumberWithNSString_(s);
}

- (NSString *)fixInputErrorsWithNSString:(NSString *)input {
  return GeogebraCommonCasViewCASInputHandler_fixInputErrorsWithNSString_(self, input);
}

+ (void)handleMarbleWithGeogebraCommonKernelGeosGeoCasCell:(GeogebraCommonKernelGeosGeoCasCell *)cell
                   withGeogebraCommonCasViewMarbleRenderer:(id<GeogebraCommonCasViewMarbleRenderer>)renderer {
  GeogebraCommonCasViewCASInputHandler_handleMarbleWithGeogebraCommonKernelGeosGeoCasCell_withGeogebraCommonCasViewMarbleRenderer_(cell, renderer);
}

- (void)dealloc {
  RELEASE_(casView_);
  RELEASE_(kernel_);
  RELEASE_(consoleTable_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonCasViewCASView:", "CASInputHandler", NULL, 0x1, NULL, NULL },
    { "processCurrentRowWithNSString:", "processCurrentRow", "V", 0x1, NULL, NULL },
    { "meaningfulSelectionWithNSString:", "meaningfulSelection", "Z", 0xa, NULL, NULL },
    { "deleteCurrentRow", NULL, "V", 0x1, NULL, NULL },
    { "processMultipleRowsWithNSString:", "processMultipleRows", "V", 0x2, NULL, NULL },
    { "processRowThenEditWithInt:withBoolean:", "processRowThenEdit", "Z", 0x1, NULL, NULL },
    { "resolveCASrowReferencesWithNSString:withInt:withChar:withBoolean:", "resolveCASrowReferences", "Ljava.lang.String;", 0x1, "Lgeogebra.common.kernel.CASException;", NULL },
    { "handleReferenceWithJavaLangStringBuilder:withInt:withInt:withBoolean:withBoolean:withBoolean:", "handleReference", "V", 0x2, "Lgeogebra.common.kernel.CASException;", NULL },
    { "appendReferenceWithJavaLangStringBuilder:withNSString:withBoolean:withBoolean:", "appendReference", "V", 0x2, NULL, NULL },
    { "isPositiveNumberWithNSString:", "isPositiveNumber", "Z", 0xa, NULL, NULL },
    { "fixInputErrorsWithNSString:", "fixInputErrors", "Ljava.lang.String;", 0x2, NULL, NULL },
    { "handleMarbleWithGeogebraCommonKernelGeosGeoCasCell:withGeogebraCommonCasViewMarbleRenderer:", "handleMarble", "V", 0x9, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "casView_", NULL, 0x2, "Lgeogebra.common.cas.view.CASView;", NULL, NULL,  },
    { "kernel_", NULL, 0x2, "Lgeogebra.common.kernel.Kernel;", NULL, NULL,  },
    { "consoleTable_", NULL, 0x2, "Lgeogebra.common.cas.view.CASTable;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonCasViewCASInputHandler = { 2, "CASInputHandler", "geogebra.common.cas.view", NULL, 0x1, 12, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonCasViewCASInputHandler;
}

@end

void GeogebraCommonCasViewCASInputHandler_initWithGeogebraCommonCasViewCASView_(GeogebraCommonCasViewCASInputHandler *self, GeogebraCommonCasViewCASView *view) {
  NSObject_init(self);
  GeogebraCommonCasViewCASInputHandler_set_casView_(self, view);
  GeogebraCommonCasViewCASInputHandler_set_kernel_(self, [((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonCasViewCASView *) nil_chk(view)) getApp])) getKernel]);
  GeogebraCommonCasViewCASInputHandler_set_consoleTable_(self, [view getConsoleTable]);
}

GeogebraCommonCasViewCASInputHandler *new_GeogebraCommonCasViewCASInputHandler_initWithGeogebraCommonCasViewCASView_(GeogebraCommonCasViewCASView *view) {
  GeogebraCommonCasViewCASInputHandler *self = [GeogebraCommonCasViewCASInputHandler alloc];
  GeogebraCommonCasViewCASInputHandler_initWithGeogebraCommonCasViewCASView_(self, view);
  return self;
}

jboolean GeogebraCommonCasViewCASInputHandler_meaningfulSelectionWithNSString_(NSString *text) {
  GeogebraCommonCasViewCASInputHandler_initialize();
  if (text == nil) return NO;
  NSString *trimmed = [((NSString *) nil_chk(text)) trim];
  if (((jint) [((NSString *) nil_chk(trimmed)) length]) == 0) return NO;
  if (((jint) [trimmed length]) == 1 && [@"]})" indexOfString:trimmed] > -1) return NO;
  return YES;
}

void GeogebraCommonCasViewCASInputHandler_processMultipleRowsWithNSString_(GeogebraCommonCasViewCASInputHandler *self, NSString *ggbcmd) {
  GeogebraCommonKernelStringTemplate *tpl = GeogebraCommonKernelStringTemplate_get_defaultTemplate_();
  [((id<GeogebraCommonCasViewCASTable>) nil_chk(self->consoleTable_)) stopEditing];
  jint selRow = [self->consoleTable_ getSelectedRow];
  if (selRow < 0) selRow = [self->consoleTable_ getRowCount] - 1;
  jint currentRow = selRow;
  IOSIntArray *selectedIndices = [self->consoleTable_ getSelectedRows];
  jint nrEquations;
  JavaUtilArrayList *l = [new_JavaUtilArrayList_init() autorelease];
  for (jint i = 0; i < ((IOSIntArray *) nil_chk(selectedIndices))->size_; i++) {
    if (![((GeogebraCommonCasViewCASView *) nil_chk(self->casView_)) isRowEmptyWithInt:IOSIntArray_Get(selectedIndices, i)]) [l addWithId:JavaLangInteger_valueOfWithInt_(IOSIntArray_Get(selectedIndices, i))];
  }
  selectedIndices = [IOSIntArray arrayWithLength:[l size]];
  for (jint i = 0; i < [l size]; i++) {
    *IOSIntArray_GetRef(selectedIndices, i) = [((JavaLangInteger *) nil_chk([l getWithInt:i])) intValue];
  }
  jboolean oneRowOnly = NO;
  if (selectedIndices->size_ == 1) {
    oneRowOnly = YES;
    nrEquations = 1;
  }
  else {
    nrEquations = selectedIndices->size_;
  }
  GeogebraCommonKernelGeosGeoCasCell *cellValue;
  @try {
    cellValue = [self->consoleTable_ getGeoCasCellWithInt:currentRow];
  }
  @catch (JavaLangArrayIndexOutOfBoundsException *e) {
    cellValue = nil;
  }
  if (cellValue == nil || (![cellValue isEmpty] && !oneRowOnly)) {
    cellValue = [new_GeogebraCommonKernelGeosGeoCasCell_initWithGeogebraCommonKernelConstruction_([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getConstruction]) autorelease];
    currentRow = [self->consoleTable_ getRowCount] - 1;
    [((GeogebraCommonCasViewCASView *) nil_chk(self->casView_)) insertRowWithGeogebraCommonKernelGeosGeoCasCell:cellValue withBoolean:NO];
  }
  jint counter = 0;
  IOSObjectArray *references = [IOSObjectArray arrayWithLength:nrEquations type:NSString_class_()];
  for (jint i = 0; i < selectedIndices->size_; i++) {
    GeogebraCommonKernelGeosGeoCasCell *selCellValue = [self->consoleTable_ getGeoCasCellWithInt:IOSIntArray_Get(selectedIndices, i)];
    NSString *cellText;
    NSString *assignedVariable = [((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(selCellValue)) getAssignmentVariable];
    jboolean inTheSelectedRow = currentRow == IOSIntArray_Get(selectedIndices, i);
    if (assignedVariable != nil) {
      IOSObjectArray_Set(references, i, assignedVariable);
    }
    else {
      cellText = [((GeogebraCommonKernelArithmeticValidExpression *) nil_chk([selCellValue getInputVE])) toStringWithGeogebraCommonKernelStringTemplate:tpl];
      cellText = [self resolveCASrowReferencesWithNSString:cellText withInt:IOSIntArray_Get(selectedIndices, i) withChar:GeogebraCommonKernelGeosGeoCasCell_ROW_REFERENCE_STATIC withBoolean:NO];
      if (!inTheSelectedRow) IOSObjectArray_Set(references, i, JreStrcat("CI", '$', (IOSIntArray_Get(selectedIndices, i) + 1)));
      else {
        NSCAssert(NO, @"this should not be possible");
        IOSObjectArray_Set(references, counter, cellText);
      }
    }
  }
  NSString *evalText;
  JavaLangStringBuilder *cellText = [new_JavaLangStringBuilder_initWithNSString_(@"{") autorelease];
  for (jint i = 0; i < nrEquations; i++) {
    if (i != 0) [cellText appendWithNSString:@", "];
    [cellText appendWithNSString:IOSObjectArray_Get(references, i)];
  }
  [cellText appendWithNSString:@"}"];
  if (([((NSString *) nil_chk(ggbcmd)) isEqual:@"Evaluate"] || [ggbcmd isEqual:@"KeepInput"])) {
    NSString *fixedInput = GeogebraCommonCasViewCASInputHandler_fixInputErrorsWithNSString_(self, [cellText description]);
    if (![((NSString *) nil_chk(fixedInput)) isEqual:[cellText description]]) {
      evalText = fixedInput;
    }
  }
  [((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(cellValue)) setInputWithNSString:[cellText description]];
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  [sb appendWithNSString:ggbcmd];
  [sb appendWithNSString:@"["];
  [sb appendWithJavaLangCharSequence:cellText];
  [sb appendWithNSString:@"]"];
  evalText = [sb description];
  [cellValue setProcessingInformationWithNSString:@"" withNSString:evalText withNSString:@""];
  [self processRowThenEditWithInt:currentRow withBoolean:YES];
}

void GeogebraCommonCasViewCASInputHandler_handleReferenceWithJavaLangStringBuilder_withInt_withInt_withBoolean_withBoolean_withBoolean_(GeogebraCommonCasViewCASInputHandler *self, JavaLangStringBuilder *sb, jint selectedRow, jint referenceNumber, jboolean addParentheses, jboolean noParentheses, jboolean needOutput) {
  if (referenceNumber > 0 && referenceNumber != selectedRow + 1 && referenceNumber <= [((GeogebraCommonCasViewCASView *) nil_chk(self->casView_)) getRowCount]) {
    NSString *reference;
    if (needOutput) {
      reference = [self->casView_ getRowOutputValueWithInt:referenceNumber - 1];
    }
    else {
      reference = [self->casView_ getRowInputValueWithInt:referenceNumber - 1];
    }
    GeogebraCommonCasViewCASInputHandler_appendReferenceWithJavaLangStringBuilder_withNSString_withBoolean_withBoolean_(self, sb, reference, addParentheses, noParentheses);
  }
  else if (referenceNumber == -1 && selectedRow > 0) {
    NSString *reference;
    if (needOutput) {
      reference = [((GeogebraCommonCasViewCASView *) nil_chk(self->casView_)) getRowOutputValueWithInt:selectedRow - 1];
    }
    else {
      reference = [((GeogebraCommonCasViewCASView *) nil_chk(self->casView_)) getRowInputValueWithInt:selectedRow - 1];
    }
    GeogebraCommonCasViewCASInputHandler_appendReferenceWithJavaLangStringBuilder_withNSString_withBoolean_withBoolean_(self, sb, reference, addParentheses, noParentheses);
  }
  else {
    GeogebraCommonKernelCASException *ex = [new_GeogebraCommonKernelCASException_initWithNSString_(@"CAS.InvalidReferenceError") autorelease];
    [ex setKeyWithNSString:@"CAS.InvalidReferenceError"];
    @throw ex;
  }
}

void GeogebraCommonCasViewCASInputHandler_appendReferenceWithJavaLangStringBuilder_withNSString_withBoolean_withBoolean_(GeogebraCommonCasViewCASInputHandler *self, JavaLangStringBuilder *sb, NSString *reference, jboolean addParentheses, jboolean noParentheses) {
  jboolean parantheses = addParentheses;
  if (GeogebraCommonCasViewCASInputHandler_isPositiveNumberWithNSString_(reference)) {
    parantheses = NO;
  }
  else {
    @try {
      NSString *parsed = [((GeogebraCommonKernelParserParser *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getParser])) parseLabelWithNSString:reference];
      if ([((NSString *) nil_chk(parsed)) isEqual:reference]) {
        parantheses = NO;
      }
    }
    @catch (GeogebraCommonKernelParserParseException *e) {
    }
  }
  if (parantheses && !noParentheses) {
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:JreStrcat("C$C", '(', reference, ')')];
  }
  else {
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:reference];
  }
}

jboolean GeogebraCommonCasViewCASInputHandler_isPositiveNumberWithNSString_(NSString *s) {
  GeogebraCommonCasViewCASInputHandler_initialize();
  @try {
    jdouble d = JavaLangDouble_parseDoubleWithNSString_(s);
    return d >= 0;
  }
  @catch (JavaLangNumberFormatException *ex) {
    return NO;
  }
}

NSString *GeogebraCommonCasViewCASInputHandler_fixInputErrorsWithNSString_(GeogebraCommonCasViewCASInputHandler *self, NSString *input) {
  NSString *inputTrim = [((NSString *) nil_chk(input)) trim];
  if ([((NSString *) nil_chk(inputTrim)) hasSuffix:@":="]) {
    inputTrim = JreStrcat("$C$$", [((GeogebraCommonMainLocalization *) nil_chk([((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonCasViewCASView *) nil_chk(self->casView_)) getApp])) getLocalization])) getCommandWithNSString:@"Delete"], '[', [((NSString *) nil_chk([inputTrim substring:0 endIndex:((jint) [inputTrim length]) - 2])) trim], @"];");
  }
  else if ([inputTrim hasSuffix:@"="]) {
    inputTrim = [inputTrim substring:0 endIndex:((jint) [inputTrim length]) - 1];
  }
  return inputTrim;
}

void GeogebraCommonCasViewCASInputHandler_handleMarbleWithGeogebraCommonKernelGeosGeoCasCell_withGeogebraCommonCasViewMarbleRenderer_(GeogebraCommonKernelGeosGeoCasCell *cell, id<GeogebraCommonCasViewMarbleRenderer> renderer) {
  GeogebraCommonCasViewCASInputHandler_initialize();
  jboolean marbleShown = [((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(cell)) hasTwinGeo] && [((GeogebraCommonKernelGeosGeoElement *) nil_chk([cell getTwinGeo])) isEuclidianVisible] && [((GeogebraCommonKernelGeosGeoElement *) nil_chk([cell getTwinGeo])) isEuclidianShowable];
  GeogebraCommonKernelArithmeticValidExpression *ve = [cell getOutputValidExpression];
  jboolean isPlottable = YES;
  jint dim = [((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk([cell getKernel])) getApplication])) is3D] ? 3 : 2;
  if (ve != nil) {
    if ([[ve unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticMyList class]]) {
      GeogebraCommonKernelArithmeticMyList *ml = (GeogebraCommonKernelArithmeticMyList *) check_class_cast([ve unwrap], [GeogebraCommonKernelArithmeticMyList class]);
      jint i = 0;
      while (i < [((GeogebraCommonKernelArithmeticMyList *) nil_chk(ml)) size] && isPlottable) {
        isPlottable &= (!([[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([ml getItemWithInt:i])) unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticMySpecialDouble class]]) && ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([ml getItemWithInt:i++])) unwrap])) inspectWithGeogebraCommonKernelArithmeticInspecting:GeogebraCommonKernelArithmeticInspecting_UnplottableChecker_getCheckerWithInt_(dim)]);
      }
    }
    else if ([[ve unwrap] isKindOfClass:[GeogebraCommonKernelArithmeticCommand class]]) {
      isPlottable &= [((NSString *) nil_chk([((GeogebraCommonKernelArithmeticCommand *) nil_chk(((GeogebraCommonKernelArithmeticCommand *) check_class_cast([ve unwrap], [GeogebraCommonKernelArithmeticCommand class])))) getName])) isEqual:@"If"];
    }
    else {
      isPlottable = NO;
    }
  }
  if (ve != nil && ![((GeogebraCommonKernelArithmeticAssignmentTypeEnum *) nil_chk([ve getAssignmentType])) isEqual:GeogebraCommonKernelArithmeticAssignmentTypeEnum_get_DELAYED()]) {
    if ([cell showOutput] && ![cell isError] && (isPlottable || ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([ve unwrap])) inspectWithGeogebraCommonKernelArithmeticInspecting:GeogebraCommonKernelArithmeticInspecting_UnplottableChecker_getCheckerWithInt_(dim)])) {
      [((id<GeogebraCommonCasViewMarbleRenderer>) nil_chk(renderer)) setMarbleValueWithBoolean:marbleShown];
      [renderer setMarbleVisibleWithBoolean:YES];
    }
    else {
      [((id<GeogebraCommonCasViewMarbleRenderer>) nil_chk(renderer)) setMarbleVisibleWithBoolean:NO];
    }
  }
  else {
    [((id<GeogebraCommonCasViewMarbleRenderer>) nil_chk(renderer)) setMarbleVisibleWithBoolean:NO];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonCasViewCASInputHandler)
