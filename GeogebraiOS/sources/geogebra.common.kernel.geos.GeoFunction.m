//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/geos/GeoFunction.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/Path.h"
#include "geogebra/common/kernel/PathMover.h"
#include "geogebra/common/kernel/PathMoverGeneric.h"
#include "geogebra/common/kernel/PathParameter.h"
#include "geogebra/common/kernel/RegionParameters.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoFunctionFreehand.h"
#include "geogebra/common/kernel/algos/AlgoMacroInterface.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/arithmetic/BooleanValue.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionNVar.h"
#include "geogebra/common/kernel/arithmetic/FunctionVariable.h"
#include "geogebra/common/kernel/arithmetic/FunctionalNVar.h"
#include "geogebra/common/kernel/arithmetic/IneqTree.h"
#include "geogebra/common/kernel/arithmetic/Inequality.h"
#include "geogebra/common/kernel/arithmetic/MyArbitraryConstant.h"
#include "geogebra/common/kernel/arithmetic/MyDouble.h"
#include "geogebra/common/kernel/arithmetic/MyList.h"
#include "geogebra/common/kernel/arithmetic/MyNumberPair.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/arithmetic/PolyFunction.h"
#include "geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "geogebra/common/kernel/geos/CasEvaluableFunction.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoFunctionNVar.h"
#include "geogebra/common/kernel/geos/GeoFunctionable.h"
#include "geogebra/common/kernel/geos/GeoInterval.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoList.h"
#include "geogebra/common/kernel/geos/GeoNumberValue.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/kernelND/SurfaceEvaluable.h"
#include "geogebra/common/kernel/roots/RealRootFunction.h"
#include "geogebra/common/kernel/roots/RealRootUtil.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/main/MyError.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/util/StringUtil.h"
#include "geogebra/common/util/Unicode.h"
#include "geogebra/common/util/debug/Log.h"
#include "java/lang/Boolean.h"
#include "java/lang/Character.h"
#include "java/lang/Comparable.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/Throwable.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/Iterator.h"
#include "java/util/LinkedList.h"
#include "java/util/TreeSet.h"

@interface GeogebraCommonKernelGeosGeoFunction () {
 @public
  jboolean trace_;
  jboolean includesDivisionByVar__;
  jboolean includesNonContinuousIntegral__;
  jboolean evalSwapped_;
  JavaLangBoolean *isInequality__;
  JavaUtilTreeSet *surfaceEvaluables_;
  GeogebraCommonKernelGeosGeoFunction *derivGeoFun_;
  GeogebraCommonKernelArithmeticFunction *includesNonContinuousIntegralFun_;
  GeogebraCommonKernelArithmeticFunction *includesDivisionByVarFun_;
  jboolean showOnAxis__;
  IOSDoubleArray *bounds_;
}

- (void)checkDefined;

- (void)pointChangedWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P;

- (void)pointChangedBooleanWithBoolean:(jboolean)b
  withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P;

+ (GeogebraCommonKernelArithmeticFunctionNVar *)fromExprWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)sum
                                                                                     withJavaUtilHashMap:(JavaUtilHashMap *)varmap
                                                                                     withJavaUtilTreeSet:(JavaUtilTreeSet *)varNames;

+ (GeogebraCommonKernelArithmeticExpressionNode *)toExprWithGeogebraCommonKernelArithmeticFunctionalNVar:(id<GeogebraCommonKernelArithmeticFunctionalNVar>)lt
                                                                                     withJavaUtilHashMap:(JavaUtilHashMap *)varMap
                                                                          withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel;

+ (jboolean)CASErrorWithNSString:(NSString *)str
                     withBoolean:(jboolean)allowInfinity;

- (jboolean)collectCasesWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)condRoot
                                                   withJavaUtilArrayList:(JavaUtilArrayList *)cases
                                                   withJavaUtilArrayList:(JavaUtilArrayList *)conditions
                          withGeogebraCommonKernelGeosGeoFunction_Bounds:(GeogebraCommonKernelGeosGeoFunction_Bounds *)parentCond;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction, isInequality__, JavaLangBoolean *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction, surfaceEvaluables_, JavaUtilTreeSet *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction, derivGeoFun_, GeogebraCommonKernelGeosGeoFunction *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction, includesNonContinuousIntegralFun_, GeogebraCommonKernelArithmeticFunction *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction, includesDivisionByVarFun_, GeogebraCommonKernelArithmeticFunction *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction, bounds_, IOSDoubleArray *)

static JavaLangStringBuilder *GeogebraCommonKernelGeosGeoFunction_sb_;
J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelGeosGeoFunction, sb_, JavaLangStringBuilder *)
J2OBJC_STATIC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction, sb_, JavaLangStringBuilder *)

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoFunction_setIntervalWithDouble_withDouble_(GeogebraCommonKernelGeosGeoFunction *self, jdouble a, jdouble b);

__attribute__((unused)) static GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(GeogebraCommonKernelGeosGeoFunction *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoFunction_checkDefined(GeogebraCommonKernelGeosGeoFunction *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoFunction_hasInterval(GeogebraCommonKernelGeosGeoFunction *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoFunction_evaluateBooleanWithDouble_(GeogebraCommonKernelGeosGeoFunction *self, jdouble x);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoFunction_pointChangedWithGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelMatrixCoords *P);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoFunction_pointChangedBooleanWithBoolean_withGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelGeosGeoFunction *self, jboolean b, GeogebraCommonKernelMatrixCoords *P);

__attribute__((unused)) static id<GeogebraCommonKernelRootsRealRootFunction> GeogebraCommonKernelGeosGeoFunction_getRealRootFunctionY(GeogebraCommonKernelGeosGeoFunction *self);

__attribute__((unused)) static GeogebraCommonKernelArithmeticFunctionNVar *GeogebraCommonKernelGeosGeoFunction_fromExprWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilHashMap_withJavaUtilTreeSet_(GeogebraCommonKernelArithmeticExpressionNode *sum, JavaUtilHashMap *varmap, JavaUtilTreeSet *varNames);

__attribute__((unused)) static GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelGeosGeoFunction_toExprWithGeogebraCommonKernelArithmeticFunctionalNVar_withJavaUtilHashMap_withGeogebraCommonKernelKernel_(id<GeogebraCommonKernelArithmeticFunctionalNVar> lt, JavaUtilHashMap *varMap, GeogebraCommonKernelKernel *kernel);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoFunction_CASErrorWithNSString_withBoolean_(NSString *str, jboolean allowInfinity);

__attribute__((unused)) static IOSObjectArray *GeogebraCommonKernelGeosGeoFunction_getTempVarCASStringWithBoolean_(GeogebraCommonKernelGeosGeoFunction *self, jboolean symbolic);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoFunction_collectCasesWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilArrayList_withJavaUtilArrayList_withGeogebraCommonKernelGeosGeoFunction_Bounds_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelArithmeticExpressionNode *condRoot, JavaUtilArrayList *cases, JavaUtilArrayList *conditions, GeogebraCommonKernelGeosGeoFunction_Bounds *parentCond);

@interface GeogebraCommonKernelGeosGeoFunction_Bounds () {
 @public
  GeogebraCommonKernelGeosGeoFunction *this$0_;
  jboolean lowerSharp_, upperSharp_;
  JavaLangDouble *lower_, *upper_;
  GeogebraCommonKernelArithmeticExpressionNode *condition_;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction_Bounds, this$0_, GeogebraCommonKernelGeosGeoFunction *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction_Bounds, lower_, JavaLangDouble *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction_Bounds, upper_, JavaLangDouble *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction_Bounds, condition_, GeogebraCommonKernelArithmeticExpressionNode *)

@interface GeogebraCommonKernelGeosGeoFunction_$1 : GeogebraCommonKernelArithmeticFunction {
 @public
  GeogebraCommonKernelGeosGeoFunction *this$0_;
}

- (jdouble)evaluateWithDouble:(jdouble)x;

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$
                             withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)arg$0;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelGeosGeoFunction_$1)

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction_$1, this$0_, GeogebraCommonKernelGeosGeoFunction *)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoFunction_$1_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction_$1 *self, GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoFunction_$1 *new_GeogebraCommonKernelGeosGeoFunction_$1_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelGeosGeoFunction_$1)

@interface GeogebraCommonKernelGeosGeoFunction_$2 : GeogebraCommonKernelArithmeticFunction {
 @public
  GeogebraCommonKernelGeosGeoFunction *this$0_;
}

- (jdouble)evaluateWithDouble:(jdouble)x;

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$
                             withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)arg$0;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelGeosGeoFunction_$2)

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction_$2, this$0_, GeogebraCommonKernelGeosGeoFunction *)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoFunction_$2_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction_$2 *self, GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoFunction_$2 *new_GeogebraCommonKernelGeosGeoFunction_$2_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelGeosGeoFunction_$2)

@interface GeogebraCommonKernelGeosGeoFunction_$3 : GeogebraCommonKernelArithmeticFunction {
 @public
  GeogebraCommonKernelGeosGeoFunction *this$0_;
}

- (jdouble)evaluateWithDouble:(jdouble)x;

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$
                             withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)arg$0;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelGeosGeoFunction_$3)

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction_$3, this$0_, GeogebraCommonKernelGeosGeoFunction *)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoFunction_$3_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction_$3 *self, GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoFunction_$3 *new_GeogebraCommonKernelGeosGeoFunction_$3_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelGeosGeoFunction_$3)

@interface GeogebraCommonKernelGeosGeoFunction_$4 : NSObject < GeogebraCommonKernelRootsRealRootFunction >

- (jdouble)evaluateWithDouble:(jdouble)t;

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelGeosGeoFunction_$4)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoFunction_$4_init(GeogebraCommonKernelGeosGeoFunction_$4 *self);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoFunction_$4 *new_GeogebraCommonKernelGeosGeoFunction_$4_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelGeosGeoFunction_$4)

@interface GeogebraCommonKernelGeosGeoFunction_$5 : NSObject < GeogebraCommonKernelRootsRealRootFunction > {
 @public
  GeogebraCommonKernelGeosGeoFunction *this$0_;
}

- (jdouble)evaluateWithDouble:(jdouble)t;

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(GeogebraCommonKernelGeosGeoFunction_$5)

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoFunction_$5, this$0_, GeogebraCommonKernelGeosGeoFunction *)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoFunction_$5_initWithGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction_$5 *self, GeogebraCommonKernelGeosGeoFunction *outer$);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoFunction_$5 *new_GeogebraCommonKernelGeosGeoFunction_$5_initWithGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(GeogebraCommonKernelGeosGeoFunction_$5)

J2OBJC_INITIALIZED_DEFN(GeogebraCommonKernelGeosGeoFunction)

jint GeogebraCommonKernelGeosGeoFunction_FUNCTION_DIRECT_ = 1;
jint GeogebraCommonKernelGeosGeoFunction_FUNCTION_COMPOSITE_IPOLY_FUNCS_ = 3;
IOSObjectArray *GeogebraCommonKernelGeosGeoFunction_dummy1_;
IOSCharArray *GeogebraCommonKernelGeosGeoFunction_dummy2_;

@implementation GeogebraCommonKernelGeosGeoFunction

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                                            withNSString:(NSString *)label
              withGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)f {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(self, c, label, f);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
              withGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)f {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_(self, c, f);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
         withGeogebraCommonKernelImplicitGeoImplicitPoly:(GeogebraCommonKernelImplicitGeoImplicitPoly *)iPoly
                 withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                 withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)g {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelImplicitGeoImplicitPoly_withGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_(self, c, iPoly, f, g);
  return self;
}

- (void)setVisualStyleWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)g {
  [super setVisualStyleWithGeogebraCommonKernelGeosGeoElement:g];
  if ([g isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) [self setShowOnAxisWithBoolean:((GeogebraCommonKernelGeosGeoFunction *) nil_chk(((GeogebraCommonKernelGeosGeoFunction *) check_class_cast(g, [GeogebraCommonKernelGeosGeoFunction class]))))->showOnAxis__];
}

- (NSString *)getTypeString {
  return (isInequality__ != nil && [isInequality__ booleanValue]) ? @"Inequality" : @"Function";
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_FUNCTION();
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelGeosGeoFunction_(self, f);
  return self;
}

- (GeogebraCommonKernelGeosGeoElement *)copy__ {
  return [new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelGeosGeoFunction_(self) autorelease];
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  GeogebraCommonKernelArithmeticFunction *geoFun = geo == nil ? nil : [((GeogebraCommonKernelGeosGeoFunction *) nil_chk([((id<GeogebraCommonKernelGeosGeoFunctionable>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelGeosGeoFunctionable))) getGeoFunction])) getFunction];
  if (geoFun == nil) {
    GeogebraCommonKernelGeosGeoFunction_set_fun_(self, nil);
    isDefined__ = NO;
    return;
  }
  isDefined__ = [((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isDefined];
  [self setFunctionWithGeogebraCommonKernelArithmeticFunction:[new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelKernel_(geoFun, kernel_) autorelease]];
  if (geo->cons_ != cons_ && [self isAlgoMacroOutput]) {
    if (![geo isIndependent]) {
      id<GeogebraCommonKernelAlgosAlgoMacroInterface> algoMacro = (id<GeogebraCommonKernelAlgosAlgoMacroInterface>) check_protocol_cast([self getParentAlgorithm], @protocol(GeogebraCommonKernelAlgosAlgoMacroInterface));
      [((id<GeogebraCommonKernelAlgosAlgoMacroInterface>) nil_chk(algoMacro)) initFunctionWithGeogebraCommonKernelArithmeticFunctionNVar:self->fun_];
    }
  }
  GeogebraCommonKernelGeosGeoFunction_set_isInequality__(self, nil);
}

- (void)setFunctionWithGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)f {
  GeogebraCommonKernelGeosGeoFunction_set_fun_(self, f);
  for (id<GeogebraCommonKernelKernelNDSurfaceEvaluable> __strong geo in nil_chk(surfaceEvaluables_)) {
    [((id<GeogebraCommonKernelKernelNDSurfaceEvaluable>) nil_chk(geo)) resetDerivatives];
  }
}

- (jboolean)addToUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:(GeogebraCommonKernelAlgosAlgoElement *)algorithm {
  jboolean added = [super addToUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:algorithm];
  if (added) {
    for (jint i = 0; i < [((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(algorithm)) getOutputLength]; i++) {
      GeogebraCommonKernelGeosGeoElement *geo = [algorithm getOutputWithInt:i];
      if ([GeogebraCommonKernelKernelNDSurfaceEvaluable_class_() isInstance:geo]) {
        [((JavaUtilTreeSet *) nil_chk(surfaceEvaluables_)) addWithId:(id<GeogebraCommonKernelKernelNDSurfaceEvaluable>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelKernelNDSurfaceEvaluable))];
      }
    }
  }
  return added;
}

- (jboolean)removeFromUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:(GeogebraCommonKernelAlgosAlgoElement *)algorithm {
  jboolean removed = [super removeFromUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:algorithm];
  if (removed) {
    for (jint i = 0; i < [((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(algorithm)) getOutputLength]; i++) {
      GeogebraCommonKernelGeosGeoElement *geo = [algorithm getOutputWithInt:i];
      if ([GeogebraCommonKernelKernelNDSurfaceEvaluable_class_() isInstance:geo]) {
        [((JavaUtilTreeSet *) nil_chk(surfaceEvaluables_)) removeWithId:geo];
      }
    }
  }
  return removed;
}

- (void)initFunction {
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) initFunction];
  [self setConstructionDefaults];
}

- (GeogebraCommonKernelArithmeticFunction *)getFunction {
  return fun_;
}

- (jboolean)setIntervalWithDouble:(jdouble)a
                       withDouble:(jdouble)b {
  return GeogebraCommonKernelGeosGeoFunction_setIntervalWithDouble_withDouble_(self, a, b);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)getFunctionExpression {
  return GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(self);
}

- (void)replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (fun_ != nil) {
    [fun_ replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:geo];
  }
}

- (GeogebraCommonKernelArithmeticFunction *)getFunctionWithDouble:(jdouble)x {
  return fun_;
}

- (void)setDerivativeWithGeogebraCommonKernelGeosCasEvaluableFunction:(id<GeogebraCommonKernelGeosCasEvaluableFunction>)fd
                                                              withInt:(jint)n
                                                          withBoolean:(jboolean)fast {
  GeogebraCommonKernelGeosGeoFunction *f = (GeogebraCommonKernelGeosGeoFunction *) check_class_cast(fd, [GeogebraCommonKernelGeosGeoFunction class]);
  if ([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) isDefined]) {
    GeogebraCommonKernelGeosGeoFunction_set_fun_(self, [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f->fun_)) getDerivativeWithInt:n withBoolean:fast]);
    GeogebraCommonKernelGeosGeoFunction_checkDefined(self);
  }
  else {
    isDefined__ = NO;
  }
}

- (void)checkDefined {
  GeogebraCommonKernelGeosGeoFunction_checkDefined(self);
}

- (void)setUsingCasCommandWithNSString:(NSString *)ggbCasCmd
withGeogebraCommonKernelGeosCasEvaluableFunction:(id<GeogebraCommonKernelGeosCasEvaluableFunction>)f
                           withBoolean:(jboolean)symbolic
withGeogebraCommonKernelArithmeticMyArbitraryConstant:(GeogebraCommonKernelArithmeticMyArbitraryConstant *)arbconst {
  GeogebraCommonKernelGeosGeoFunction *ff = (GeogebraCommonKernelGeosGeoFunction *) check_class_cast(f, [GeogebraCommonKernelGeosGeoFunction class]);
  if ([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(ff)) isDefined]) {
    GeogebraCommonKernelGeosGeoFunction_set_fun_(self, (GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk(ff->fun_)) evalCasCommandWithNSString:ggbCasCmd withBoolean:symbolic withGeogebraCommonKernelArithmeticMyArbitraryConstant:arbconst], [GeogebraCommonKernelArithmeticFunction class]));
    GeogebraCommonKernelGeosGeoFunction_checkDefined(self);
  }
  else {
    isDefined__ = NO;
  }
}

- (jdouble)evaluateWithDouble:(jdouble)x {
  if (fun_ == nil || !isDefined__) return JavaLangDouble_NaN;
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) evaluateWithDouble:x];
}

- (jdouble)evaluateWithDoubleArray:(IOSDoubleArray *)vals {
  return [self evaluateWithDouble:IOSDoubleArray_Get(nil_chk(vals), 0)];
}

- (jdouble)getIntervalMin {
  return intervalMin_;
}

- (jdouble)getIntervalMax {
  return intervalMax_;
}

- (jboolean)hasInterval {
  return GeogebraCommonKernelGeosGeoFunction_hasInterval(self);
}

- (jboolean)evaluateBooleanWithDouble:(jdouble)x {
  return GeogebraCommonKernelGeosGeoFunction_evaluateBooleanWithDouble_(self, x);
}

- (GeogebraCommonKernelGeosGeoFunction *)getGeoDerivativeWithInt:(jint)order {
  if (derivGeoFun_ == nil) {
    GeogebraCommonKernelGeosGeoFunction_setAndConsume_derivGeoFun_(self, new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(cons_));
  }
  [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(derivGeoFun_)) setDerivativeWithGeogebraCommonKernelGeosCasEvaluableFunction:self withInt:order withBoolean:NO];
  return derivGeoFun_;
}

- (void)translateWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)v {
  [self translateWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(v)) getX] withDouble:[v getY]];
}

- (jboolean)isTranslateable {
  return fun_ != nil && ![self isBooleanFunction];
}

- (void)translateWithDouble:(jdouble)vx
                 withDouble:(jdouble)vy {
  if ([[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoFunctionFreehand class]]) {
    GeogebraCommonKernelAlgosAlgoFunctionFreehand *algo = (GeogebraCommonKernelAlgosAlgoFunctionFreehand *) check_class_cast([self getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoFunctionFreehand class]);
    GeogebraCommonKernelGeosGeoList *list = [((GeogebraCommonKernelAlgosAlgoFunctionFreehand *) nil_chk(algo)) getList];
    [((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(((GeogebraCommonKernelGeosGeoNumeric *) check_class_cast([((GeogebraCommonKernelGeosGeoList *) nil_chk(list)) getWithInt:0], [GeogebraCommonKernelGeosGeoNumeric class])))) setValueWithDouble:[((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(((GeogebraCommonKernelGeosGeoNumeric *) check_class_cast([list getWithInt:0], [GeogebraCommonKernelGeosGeoNumeric class])))) getDouble] + vx];
    [((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(((GeogebraCommonKernelGeosGeoNumeric *) check_class_cast([list getWithInt:1], [GeogebraCommonKernelGeosGeoNumeric class])))) setValueWithDouble:[((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(((GeogebraCommonKernelGeosGeoNumeric *) check_class_cast([list getWithInt:1], [GeogebraCommonKernelGeosGeoNumeric class])))) getDouble] + vx];
    for (jint i = 2; i < [list size]; i++) {
      [((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(((GeogebraCommonKernelGeosGeoNumeric *) check_class_cast([list getWithInt:i], [GeogebraCommonKernelGeosGeoNumeric class])))) setValueWithDouble:[((GeogebraCommonKernelGeosGeoNumeric *) nil_chk(((GeogebraCommonKernelGeosGeoNumeric *) check_class_cast([list getWithInt:i], [GeogebraCommonKernelGeosGeoNumeric class])))) getDouble] + vy];
    }
    [algo compute];
  }
  else {
    [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) translateWithDouble:vx withDouble:vy];
  }
}

- (jboolean)isPolynomialFunctionWithBoolean:(jboolean)forRootFinding
                                withBoolean:(jboolean)symbolic {
  if (![self isDefined]) {
    return NO;
  }
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) isConstantFunction] || (symbolic ? [fun_ getSymbolicPolynomialFactorsWithBoolean:forRootFinding withBoolean:NO] : [fun_ getPolynomialFactorsWithBoolean:forRootFinding]) != nil;
}

- (jboolean)isPolynomialFunctionWithBoolean:(jboolean)forRootFinding {
  return [self isPolynomialFunctionWithBoolean:forRootFinding withBoolean:NO];
}

- (jboolean)includesDivisionByVar {
  if (includesDivisionByVarFun_ != fun_) {
    GeogebraCommonKernelGeosGeoFunction_set_includesDivisionByVarFun_(self, fun_);
    includesDivisionByVar__ = (fun_ != nil && [fun_ includesDivisionByVariable]);
  }
  return includesDivisionByVar__;
}

- (jboolean)includesNonContinuousIntegral {
  if (includesNonContinuousIntegralFun_ != fun_) {
    GeogebraCommonKernelGeosGeoFunction_set_includesNonContinuousIntegralFun_(self, fun_);
    includesNonContinuousIntegral__ = (fun_ != nil && [fun_ includesNonContinuousIntegral]);
  }
  return includesNonContinuousIntegral__;
}

- (jboolean)isDefined {
  return isDefined__ && fun_ != nil;
}

- (jboolean)isFillable {
  if (fun_ != nil && isInequality__ == nil && [self isBooleanFunction]) [self getIneqs];
  return isInequality__ != nil && [isInequality__ booleanValue];
}

- (jboolean)isInverseFillable {
  return [self isFillable];
}

- (void)setDefinedWithBoolean:(jboolean)defined {
  isDefined__ = defined;
}

- (void)setUndefined {
  isDefined__ = NO;
}

- (jboolean)showInAlgebraView {
  return YES;
}

- (jboolean)showInEuclidianView {
  if (fun_ != nil && isInequality__ == nil && [self isBooleanFunction]) [self getIneqs];
  return [self isDefined] && (![self isBooleanFunction] || [((JavaLangBoolean *) nil_chk(isInequality__)) booleanValue]);
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  [((JavaLangStringBuilder *) nil_chk(sbToString_)) setLengthWithInt:0];
  GeogebraCommonKernelGeosGeoFunction_initStringBuilderWithJavaLangStringBuilder_withGeogebraCommonKernelStringTemplate_withNSString_withNSString_withBoolean_withBoolean_(sbToString_, tpl, label_, [self getVarStringWithGeogebraCommonKernelStringTemplate:tpl], [self isLabelSet], [self isBooleanFunction]);
  [sbToString_ appendWithNSString:[self toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
  return [sbToString_ description];
}

+ (void)initStringBuilderWithJavaLangStringBuilder:(JavaLangStringBuilder *)stringBuilder
            withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                      withNSString:(NSString *)label
                                      withNSString:(NSString *)var
                                       withBoolean:(jboolean)isLabelSet
                                       withBoolean:(jboolean)isBooleanFunction {
  GeogebraCommonKernelGeosGeoFunction_initStringBuilderWithJavaLangStringBuilder_withGeogebraCommonKernelStringTemplate_withNSString_withNSString_withBoolean_withBoolean_(stringBuilder, tpl, label, var, isLabelSet, isBooleanFunction);
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (fun_ != nil && [self isDefined]) {
    return [fun_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
}

- (NSString *)toOutputValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if ([self isLocalVariable]) {
    return label_;
  }
  if (fun_ != nil && [self isDefined]) {
    return [fun_ toOutputValueStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
}

- (NSString *)toSymbolicStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (fun_ != nil && [self isDefined]) {
    return [fun_ toStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
}

- (NSString *)toLaTeXStringWithBoolean:(jboolean)symbolic
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (fun_ != nil && [self isDefined]) {
    return [fun_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl];
  }
  return JreStrcat("$$$", @" \\text{", [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"], @"} ");
}

- (void)getXMLWithBoolean:(jboolean)getListenersToo
withJavaLangStringBuilder:(JavaLangStringBuilder *)sbxml {
  if ([self isIndependent] && [self getDefaultGeoType] < 0) {
    [((JavaLangStringBuilder *) nil_chk(sbxml)) appendWithNSString:@"<expression"];
    [sbxml appendWithNSString:@" label =\""];
    [sbxml appendWithNSString:label_];
    [sbxml appendWithNSString:@"\" exp=\""];
    GeogebraCommonUtilStringUtil_encodeXMLWithJavaLangStringBuilder_withNSString_(sbxml, [self toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_xmlTemplate_()]);
    [sbxml appendWithNSString:@"\"/>\n"];
  }
  [((JavaLangStringBuilder *) nil_chk(sbxml)) appendWithNSString:@"<element"];
  [sbxml appendWithNSString:@" type=\"function\""];
  [sbxml appendWithNSString:@" label=\""];
  [sbxml appendWithNSString:label_];
  if ([self getDefaultGeoType] >= 0) {
    [sbxml appendWithNSString:@"\" default=\""];
    [sbxml appendWithInt:[self getDefaultGeoType]];
  }
  [sbxml appendWithNSString:@"\">\n"];
  [self getXMLtagsWithJavaLangStringBuilder:sbxml];
  [self getCaptionXMLWithJavaLangStringBuilder:sbxml];
  if (getListenersToo) [self getListenerTagsXMLWithJavaLangStringBuilder:GeogebraCommonKernelGeosGeoFunction_sb_];
  [sbxml appendWithNSString:@"</element>\n"];
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sbxml {
  [super getXMLtagsWithJavaLangStringBuilder:sbxml];
  [self getLineStyleXMLWithJavaLangStringBuilder:sbxml];
  if ([self showOnAxis]) {
    [((JavaLangStringBuilder *) nil_chk(sbxml)) appendWithNSString:@"<showOnAxis val=\"true\" />"];
  }
}

- (void)getIntervalWithDoubleArray:(IOSDoubleArray *)bounds0 {
  *IOSDoubleArray_GetRef(nil_chk(bounds0), 0) = JavaLangDouble_NEGATIVE_INFINITY;
  *IOSDoubleArray_GetRef(bounds0, 1) = JavaLangDouble_POSITIVE_INFINITY;
  jdouble bound;
  GeogebraCommonKernelArithmeticExpressionNode *inequalityEn = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(self))) getLeft], [GeogebraCommonKernelArithmeticExpressionNode class]);
  GeogebraCommonPluginOperationEnum *op = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(inequalityEn)) getOperation];
  switch ([op ordinal]) {
    default:
    GeogebraCommonUtilDebugLog_errorWithNSString_(@"problem in GeoFunction.getInterval()");
    return;
    case GeogebraCommonPluginOperation_AND_INTERVAL:
    GeogebraCommonKernelGeosGeoInterval_updateBoundariesWithGeogebraCommonKernelArithmeticExpressionNode_withDoubleArray_withNSStringArray_withCharArray_(inequalityEn, bounds0, GeogebraCommonKernelGeosGeoFunction_dummy1_, GeogebraCommonKernelGeosGeoFunction_dummy2_);
    break;
    case GeogebraCommonPluginOperation_LESS:
    case GeogebraCommonPluginOperation_LESS_EQUAL:
    case GeogebraCommonPluginOperation_GREATER:
    case GeogebraCommonPluginOperation_GREATER_EQUAL:
    if ([[inequalityEn getLeft] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
      bound = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([inequalityEn getRight])) evaluateDouble];
    }
    else if ([[inequalityEn getRight] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
      bound = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([inequalityEn getLeft])) evaluateDouble];
      op = [((GeogebraCommonPluginOperationEnum *) nil_chk(op)) reverseLeftToRight];
    }
    else {
      bound = JavaLangDouble_NaN;
    }
    switch ([op ordinal]) {
      case GeogebraCommonPluginOperation_LESS:
      case GeogebraCommonPluginOperation_LESS_EQUAL:
      *IOSDoubleArray_GetRef(bounds0, 1) = bound;
      break;
      case GeogebraCommonPluginOperation_GREATER:
      case GeogebraCommonPluginOperation_GREATER_EQUAL:
      *IOSDoubleArray_GetRef(bounds0, 0) = bound;
      break;
    }
  }
}

- (void)pointChangedWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  GeogebraCommonKernelGeosGeoFunction_pointChangedWithGeogebraCommonKernelMatrixCoords_(self, P);
}

- (void)pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getCoordsInD2];
  GeogebraCommonKernelGeosGeoFunction_pointChangedWithGeogebraCommonKernelMatrixCoords_(self, coords);
  [P setCoords2DWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] withDouble:[coords getY] withDouble:[coords getZ]];
  GeogebraCommonKernelPathParameter *pp = [P getPathParameter];
  ((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_ = [coords getX];
  [P updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:nil];
}

- (void)pointChangedBooleanWithBoolean:(jboolean)b
  withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  GeogebraCommonKernelGeosGeoFunction_pointChangedBooleanWithBoolean_withGeogebraCommonKernelMatrixCoords_(self, b, P);
}

- (jboolean)isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI
                                                    withDouble:(jdouble)eps {
  GeogebraCommonKernelGeosGeoPoint *P = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(PI, [GeogebraCommonKernelGeosGeoPoint class]);
  if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P)) getPath] == self) return YES;
  if (![self isBooleanFunction]) {
    return isDefined__ && JavaLangMath_absWithDouble_([((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) evaluateWithDouble:[P getInhomX]] - [P getInhomY]) <= eps;
  }
  jdouble px = [self isFunctionOfY] ? [P getY] : [P getX];
  if ([P getZ] != 1.0) {
    px = px / [P getZ];
  }
  return GeogebraCommonKernelGeosGeoFunction_evaluateBooleanWithDouble_(self, px);
}

- (void)pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  if (![((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) usePathAndRegionParametersWithGeogebraCommonKernelKernelNDGeoPointND:PI]) {
    [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:PI];
    return;
  }
  GeogebraCommonKernelGeosGeoPoint *P = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(PI, [GeogebraCommonKernelGeosGeoPoint class]);
  GeogebraCommonKernelPathParameter *pp = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P)) getPathParameter];
  [P setXWithDouble:((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_];
  [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
}

- (jboolean)isPath {
  return YES;
}

- (jdouble)getMinParameter {
  if (interval_) {
    return JavaLangMath_maxWithDouble_withDouble_([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getViewsXMinWithGeogebraCommonKernelGeosGeoElement:self], intervalMin_);
  }
  return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getViewsXMinWithGeogebraCommonKernelGeosGeoElement:self];
}

- (jdouble)getMaxParameter {
  if (interval_) {
    return JavaLangMath_minWithDouble_withDouble_([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getViewsXMaxWithGeogebraCommonKernelGeosGeoElement:self], intervalMax_);
  }
  return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getViewsXMaxWithGeogebraCommonKernelGeosGeoElement:self];
}

- (id<GeogebraCommonKernelPathMover>)createPathMover {
  return [new_GeogebraCommonKernelPathMoverGeneric_initWithGeogebraCommonKernelPath_(self) autorelease];
}

- (jboolean)isClosedPath {
  return NO;
}

- (jboolean)isCasEvaluableObject {
  return YES;
}

- (jboolean)isNumberValue {
  return NO;
}

- (jboolean)isTraceable {
  return YES;
}

- (jboolean)getTrace {
  return trace_;
}

- (void)setTraceWithBoolean:(jboolean)trace {
  self->trace_ = trace;
}

- (GeogebraCommonKernelGeosGeoFunction *)getGeoFunction {
  return self;
}

- (jboolean)isGeoFunction {
  if (fun_ != nil) {
    return ![fun_ isBooleanFunction];
  }
  return YES;
}

- (NSString *)getAssignmentLHSWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  [((JavaLangStringBuilder *) nil_chk(sbToString_)) setLengthWithInt:0];
  [sbToString_ appendWithNSString:[((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) printVariableNameWithNSString:label_]];
  [sbToString_ appendWithNSString:@"("];
  [sbToString_ appendWithNSString:[self getVarStringWithGeogebraCommonKernelStringTemplate:tpl]];
  [sbToString_ appendWithNSString:@")"];
  return [sbToString_ description];
}

- (jboolean)isGeoFunctionable {
  return [self isGeoFunction];
}

- (jboolean)isBooleanFunction {
  if (fun_ != nil) {
    return [fun_ isBooleanFunction];
  }
  return NO;
}

- (void)swapEval {
  evalSwapped_ = !evalSwapped_;
}

- (void)evaluateCurveWithDouble:(jdouble)t
                withDoubleArray:(IOSDoubleArray *)outArg {
  if (evalSwapped_) {
    *IOSDoubleArray_GetRef(nil_chk(outArg), 1) = t;
    *IOSDoubleArray_GetRef(outArg, 0) = [self evaluateWithDouble:t];
  }
  else {
    *IOSDoubleArray_GetRef(nil_chk(outArg), 0) = t;
    *IOSDoubleArray_GetRef(outArg, 1) = [self evaluateWithDouble:t];
  }
}

- (jdouble)evaluateCurvatureWithDouble:(jdouble)x {
  GeogebraCommonKernelArithmeticFunction *f1 = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) getDerivativeWithInt:1 withBoolean:YES];
  GeogebraCommonKernelArithmeticFunction *f2 = [fun_ getDerivativeWithInt:2 withBoolean:YES];
  if (f1 == nil || f2 == nil) return JavaLangDouble_NaN;
  jdouble f1eval = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f1)) evaluateWithDouble:x];
  jdouble t = JavaLangMath_sqrtWithDouble_(1 + f1eval * f1eval);
  jdouble t3 = t * t * t;
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f2)) evaluateWithDouble:x] / t3;
}

- (id<GeogebraCommonKernelRootsRealRootFunction>)getRealRootFunctionX {
  return [new_GeogebraCommonKernelGeosGeoFunction_$4_init() autorelease];
}

- (id<GeogebraCommonKernelRootsRealRootFunction>)getRealRootFunctionY {
  return GeogebraCommonKernelGeosGeoFunction_getRealRootFunctionY(self);
}

- (GeogebraCommonKernelGeosGeoVec2D *)evaluateCurveWithDouble:(jdouble)t {
  return [new_GeogebraCommonKernelGeosGeoVec2D_initWithGeogebraCommonKernelKernel_withDouble_withDouble_(kernel_, t, [self evaluateWithDouble:t]) autorelease];
}

- (NSString *)getVarStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (fun_ == nil) {
    return [((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) printVariableNameWithNSString:@"x"];
  }
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) getVarStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (jboolean)isFunctionInX {
  return YES;
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoLine]) {
    return [((GeogebraCommonKernelGeosGeoLine *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoLine class])) isEqualWithGeogebraCommonKernelGeosGeoElement:self];
  }
  if (![geo isGeoFunction] || [((GeogebraCommonPluginGeoClassEnum *) nil_chk([geo getGeoClassType])) isEqual:GeogebraCommonPluginGeoClassEnum_get_INTERVAL()]) {
    return NO;
  }
  if ([((GeogebraCommonPluginGeoClassEnum *) nil_chk([geo getGeoClassType])) isEqual:GeogebraCommonPluginGeoClassEnum_get_FUNCTIONCONDITIONAL()]) {
    return [geo isEqualWithGeogebraCommonKernelGeosGeoElement:self];
  }
  GeogebraCommonKernelGeosGeoFunction *geoFun = (GeogebraCommonKernelGeosGeoFunction *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoFunction class]);
  GeogebraCommonKernelArithmeticPolyFunction *poly1 = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunction])) expandToPolyFunctionWithGeogebraCommonKernelArithmeticExpressionValue:GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(self) withBoolean:NO withBoolean:YES];
  if (poly1 != nil) {
    GeogebraCommonKernelArithmeticPolyFunction *poly2 = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([geoFun getFunction])) expandToPolyFunctionWithGeogebraCommonKernelArithmeticExpressionValue:GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(geoFun) withBoolean:NO withBoolean:YES];
    if (poly2 != nil) {
      return [poly1 isEqualWithGeogebraCommonKernelArithmeticPolyFunction:poly2];
    }
  }
  return [self isDifferenceZeroInCASWithGeogebraCommonKernelGeosGeoElement:geo];
}

+ (GeogebraCommonKernelGeosGeoFunction *)addWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)resultFun
                                            withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)fun1
                                            withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)fun2 {
  return GeogebraCommonKernelGeosGeoFunction_addWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_(resultFun, fun1, fun2);
}

+ (GeogebraCommonKernelArithmeticFunctionNVar *)operationSymbWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op
                                                  withGeogebraCommonKernelArithmeticFunctionalNVar:(id<GeogebraCommonKernelArithmeticFunctionalNVar>)lt
                                                  withGeogebraCommonKernelArithmeticFunctionalNVar:(id<GeogebraCommonKernelArithmeticFunctionalNVar>)rt {
  return GeogebraCommonKernelGeosGeoFunction_operationSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticFunctionalNVar_(op, lt, rt);
}

+ (GeogebraCommonKernelArithmeticFunctionNVar *)fromExprWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)sum
                                                                                     withJavaUtilHashMap:(JavaUtilHashMap *)varmap
                                                                                     withJavaUtilTreeSet:(JavaUtilTreeSet *)varNames {
  return GeogebraCommonKernelGeosGeoFunction_fromExprWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilHashMap_withJavaUtilTreeSet_(sum, varmap, varNames);
}

+ (GeogebraCommonKernelArithmeticExpressionNode *)toExprWithGeogebraCommonKernelArithmeticFunctionalNVar:(id<GeogebraCommonKernelArithmeticFunctionalNVar>)lt
                                                                                     withJavaUtilHashMap:(JavaUtilHashMap *)varMap
                                                                          withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  return GeogebraCommonKernelGeosGeoFunction_toExprWithGeogebraCommonKernelArithmeticFunctionalNVar_withJavaUtilHashMap_withGeogebraCommonKernelKernel_(lt, varMap, kernel);
}

+ (GeogebraCommonKernelArithmeticFunctionNVar *)applyNumberSymbWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op
                                                    withGeogebraCommonKernelArithmeticFunctionalNVar:(id<GeogebraCommonKernelArithmeticFunctionalNVar>)fun1
                                                   withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev
                                                                                         withBoolean:(jboolean)right {
  return GeogebraCommonKernelGeosGeoFunction_applyNumberSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_(op, fun1, ev, right);
}

+ (GeogebraCommonKernelGeosGeoFunction *)subtractWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)resultFun
                                                 withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)fun1
                                                 withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)fun2 {
  return GeogebraCommonKernelGeosGeoFunction_subtractWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_(resultFun, fun1, fun2);
}

+ (GeogebraCommonKernelGeosGeoFunction *)multWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)resultFun
                                                                          withDouble:(jdouble)number
                                             withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)fun {
  return GeogebraCommonKernelGeosGeoFunction_multWithGeogebraCommonKernelGeosGeoFunction_withDouble_withGeogebraCommonKernelGeosGeoFunction_(resultFun, number, fun);
}

- (jboolean)evaluateConditionWithDouble:(jdouble)x {
  if (!interval_) return YES;
  return x > intervalMin_ && x < intervalMax_;
}

- (NSString *)getLimitWithDouble:(jdouble)x
                         withInt:(jint)direction {
  IOSObjectArray *funVarStr = GeogebraCommonKernelGeosGeoFunction_getTempVarCASStringWithBoolean_(self, NO);
  if (GeogebraCommonKernelGeosGeoFunction_sb_ == nil) {
    JreStrongAssignAndConsume(&GeogebraCommonKernelGeosGeoFunction_sb_, nil, new_JavaLangStringBuilder_init());
  }
  else {
    [GeogebraCommonKernelGeosGeoFunction_sb_ setLengthWithInt:0];
  }
  [((JavaLangStringBuilder *) nil_chk(GeogebraCommonKernelGeosGeoFunction_sb_)) setLengthWithInt:0];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"Numeric(Limit"];
  if (direction == -1) {
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"Above"];
  }
  else if (direction == 1) {
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"Below"];
  }
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:'('];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(nil_chk(funVarStr), 0)];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(funVarStr, 1)];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:JavaLangDouble_toStringWithDouble_(x)];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"),"];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"50)"];
  return [GeogebraCommonKernelGeosGeoFunction_sb_ description];
}

- (void)getVerticalAsymptotesWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                           withJavaLangStringBuilder:(JavaLangStringBuilder *)verticalSB
                                                         withBoolean:(jboolean)reverse {
  [self getVerticalAsymptotesStaticWithGeogebraCommonKernelGeosGeoFunction:self withGeogebraCommonKernelGeosGeoFunction:f withJavaLangStringBuilder:verticalSB withBoolean:reverse];
}

- (void)getHorizontalPositiveAsymptoteWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                    withJavaLangStringBuilder:(JavaLangStringBuilder *)SB {
  [self getHorizontalAsymptoteStaticWithGeogebraCommonKernelGeosGeoFunction:self withGeogebraCommonKernelGeosGeoFunction:f withJavaLangStringBuilder:SB withBoolean:YES];
}

- (void)getHorizontalNegativeAsymptoteWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                    withJavaLangStringBuilder:(JavaLangStringBuilder *)SB {
  [self getHorizontalAsymptoteStaticWithGeogebraCommonKernelGeosGeoFunction:self withGeogebraCommonKernelGeosGeoFunction:f withJavaLangStringBuilder:SB withBoolean:NO];
}

- (void)getDiagonalPositiveAsymptoteWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                  withJavaLangStringBuilder:(JavaLangStringBuilder *)SB {
  [self getDiagonalAsymptoteStaticWithGeogebraCommonKernelGeosGeoFunction:self withGeogebraCommonKernelGeosGeoFunction:f withJavaLangStringBuilder:SB withBoolean:YES];
}

- (void)getDiagonalNegativeAsymptoteWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                                  withJavaLangStringBuilder:(JavaLangStringBuilder *)SB {
  [self getDiagonalAsymptoteStaticWithGeogebraCommonKernelGeosGeoFunction:self withGeogebraCommonKernelGeosGeoFunction:f withJavaLangStringBuilder:SB withBoolean:NO];
}

- (void)getDiagonalAsymptoteStaticWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                  withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)parentFunction
                                                withJavaLangStringBuilder:(JavaLangStringBuilder *)SB
                                                              withBoolean:(jboolean)positiveInfinity_ {
  @try {
    GeogebraCommonKernelGeosGeoFunction *deriv = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) getGeoDerivativeWithInt:1];
    IOSObjectArray *derivVarStr = GeogebraCommonKernelGeosGeoFunction_getTempVarCASStringWithBoolean_(nil_chk(deriv), NO);
    IOSObjectArray *funVarStr = GeogebraCommonKernelGeosGeoFunction_getTempVarCASStringWithBoolean_(f, NO);
    if (GeogebraCommonKernelGeosGeoFunction_sb_ == nil) JreStrongAssignAndConsume(&GeogebraCommonKernelGeosGeoFunction_sb_, nil, new_JavaLangStringBuilder_init());
    else [GeogebraCommonKernelGeosGeoFunction_sb_ setLengthWithInt:0];
    NSString *gradientStrMinus = @"";
    NSString *interceptStrMinus = @"";
    [((JavaLangStringBuilder *) nil_chk(GeogebraCommonKernelGeosGeoFunction_sb_)) setLengthWithInt:0];
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"Limit("];
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(nil_chk(derivVarStr), 0)];
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(derivVarStr, 1)];
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
    if (!positiveInfinity_) [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:'-'];
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:GeogebraCommonUtilUnicode_Infinity];
    [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:')'];
    gradientStrMinus = [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) evaluateCachedGeoGebraCASWithNSString:[GeogebraCommonKernelGeosGeoFunction_sb_ description] withGeogebraCommonKernelArithmeticMyArbitraryConstant:nil];
    jdouble grad;
    @try {
      grad = [((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) evaluateToDoubleWithNSString:gradientStrMinus withBoolean:YES];
    }
    @catch (JavaLangException *e) {
      grad = 0;
    }
    if (!GeogebraCommonKernelGeosGeoFunction_CASErrorWithNSString_withBoolean_(gradientStrMinus, NO) && !GeogebraCommonKernelKernel_isZeroWithDouble_(grad)) {
      [GeogebraCommonKernelGeosGeoFunction_sb_ setLengthWithInt:0];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"Limit("];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(nil_chk(funVarStr), 0)];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@" - "];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:gradientStrMinus];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@" * "];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(derivVarStr, 1)];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(derivVarStr, 1)];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
      if (!positiveInfinity_) [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:'-'];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:GeogebraCommonUtilUnicode_Infinity];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:')'];
      interceptStrMinus = [kernel_ evaluateCachedGeoGebraCASWithNSString:[GeogebraCommonKernelGeosGeoFunction_sb_ description] withGeogebraCommonKernelArithmeticMyArbitraryConstant:nil];
      if (!GeogebraCommonKernelGeosGeoFunction_CASErrorWithNSString_withBoolean_(interceptStrMinus, NO)) {
        [GeogebraCommonKernelGeosGeoFunction_sb_ setLengthWithInt:0];
        [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"y = "];
        [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:gradientStrMinus];
        [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@" * x +"];
        [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:interceptStrMinus];
        if (![((NSString *) nil_chk([((JavaLangStringBuilder *) nil_chk(SB)) description])) hasSuffix:[GeogebraCommonKernelGeosGeoFunction_sb_ description]]) {
          if ([SB length] > 1) [SB appendWithChar:','];
          [SB appendWithJavaLangCharSequence:GeogebraCommonKernelGeosGeoFunction_sb_];
        }
      }
    }
  }
  @catch (JavaLangThrowable *e) {
    [((JavaLangThrowable *) nil_chk(e)) printStackTrace];
  }
}

- (void)getHorizontalAsymptoteStaticWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                    withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)parentFunction
                                                  withJavaLangStringBuilder:(JavaLangStringBuilder *)SB
                                                                withBoolean:(jboolean)positiveInfinity_ {
  IOSObjectArray *funVarStr = GeogebraCommonKernelGeosGeoFunction_getTempVarCASStringWithBoolean_(nil_chk(f), NO);
  if (GeogebraCommonKernelGeosGeoFunction_sb_ == nil) JreStrongAssignAndConsume(&GeogebraCommonKernelGeosGeoFunction_sb_, nil, new_JavaLangStringBuilder_init());
  else [GeogebraCommonKernelGeosGeoFunction_sb_ setLengthWithInt:0];
  [((JavaLangStringBuilder *) nil_chk(GeogebraCommonKernelGeosGeoFunction_sb_)) appendWithNSString:@"Limit("];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(nil_chk(funVarStr), 0)];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(funVarStr, 1)];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
  if (!positiveInfinity_) [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:'-'];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:GeogebraCommonUtilUnicode_Infinity];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@")"];
  @try {
    NSString *limit = [((NSString *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) evaluateCachedGeoGebraCASWithNSString:[GeogebraCommonKernelGeosGeoFunction_sb_ description] withGeogebraCommonKernelArithmeticMyArbitraryConstant:nil])) trim];
    if (!GeogebraCommonKernelGeosGeoFunction_CASErrorWithNSString_withBoolean_(limit, NO)) {
      [GeogebraCommonKernelGeosGeoFunction_sb_ setLengthWithInt:0];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"y="];
      [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:limit];
      if (![((NSString *) nil_chk([((JavaLangStringBuilder *) nil_chk(SB)) description])) hasSuffix:[GeogebraCommonKernelGeosGeoFunction_sb_ description]]) {
        if ([SB length] > 1) [SB appendWithChar:','];
        [SB appendWithJavaLangCharSequence:GeogebraCommonKernelGeosGeoFunction_sb_];
      }
    }
  }
  @catch (JavaLangThrowable *t) {
  }
}

- (jchar)getLabelDelimiter {
  return [self isBooleanFunction] ? ':' : '=';
}

- (void)getVerticalAsymptotesStaticWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)f
                                   withGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)parentFunction
                                                 withJavaLangStringBuilder:(JavaLangStringBuilder *)verticalSB
                                                               withBoolean:(jboolean)reverseCondition {
  IOSObjectArray *funVarStr = GeogebraCommonKernelGeosGeoFunction_getTempVarCASStringWithBoolean_(nil_chk(f), NO);
  if (GeogebraCommonKernelGeosGeoFunction_sb_ == nil) JreStrongAssignAndConsume(&GeogebraCommonKernelGeosGeoFunction_sb_, nil, new_JavaLangStringBuilder_init());
  else [GeogebraCommonKernelGeosGeoFunction_sb_ setLengthWithInt:0];
  [((JavaLangStringBuilder *) nil_chk(GeogebraCommonKernelGeosGeoFunction_sb_)) appendWithNSString:@"Solve("];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"Simplify("];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"1/("];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(nil_chk(funVarStr), 0)];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:')'];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@")=0"];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@","];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(funVarStr, 1)];
  [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@")"];
  @try {
    NSString *verticalAsymptotes = [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) evaluateCachedGeoGebraCASWithNSString:[GeogebraCommonKernelGeosGeoFunction_sb_ description] withGeogebraCommonKernelArithmeticMyArbitraryConstant:nil];
    if (!GeogebraCommonKernelGeosGeoFunction_CASErrorWithNSString_withBoolean_(verticalAsymptotes, NO) && ((jint) [((NSString *) nil_chk(verticalAsymptotes)) length]) > 2) {
      verticalAsymptotes = [verticalAsymptotes replace:'{' withChar:' '];
      verticalAsymptotes = [((NSString *) nil_chk(verticalAsymptotes)) replace:'}' withChar:' '];
      verticalAsymptotes = [((NSString *) nil_chk(verticalAsymptotes)) replaceAll:@"x==" withReplacement:@""];
      verticalAsymptotes = [((NSString *) nil_chk(verticalAsymptotes)) replaceAll:@"x =" withReplacement:@""];
      IOSObjectArray *verticalAsymptotesArray = [((NSString *) nil_chk(verticalAsymptotes)) split:@","];
      for (jint i = 0; i < ((IOSObjectArray *) nil_chk(verticalAsymptotesArray))->size_; i++) {
        jboolean repeat = NO;
        if (i > 0 && verticalAsymptotesArray->size_ > 1) {
          for (jint j = 0; j < i; j++) {
            if ([((NSString *) nil_chk(IOSObjectArray_Get(verticalAsymptotesArray, i))) isEqual:IOSObjectArray_Get(verticalAsymptotesArray, j)]) {
              repeat = YES;
              break;
            }
          }
        }
        jboolean isInRange = NO;
        @try {
          if ([((NSString *) nil_chk([((NSString *) nil_chk(IOSObjectArray_Get(verticalAsymptotesArray, i))) trim])) isEqual:@""]) isInRange = NO;
          else isInRange = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(parentFunction)) evaluateConditionWithDouble:[((id<GeogebraCommonKernelGeosGeoNumberValue>) nil_chk([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) evaluateToNumericWithNSString:IOSObjectArray_Get(verticalAsymptotesArray, i) withBoolean:YES])) getDouble]];
        }
        @catch (JavaLangException *e) {
          GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$", @"Error parsing: ", IOSObjectArray_Get(verticalAsymptotesArray, i)));
        }
        if (reverseCondition) isInRange = !isInRange;
        if (!repeat && isInRange) {
          [GeogebraCommonKernelGeosGeoFunction_sb_ setLengthWithInt:0];
          [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"Numeric(Limit("];
          [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(funVarStr, 0)];
          [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithChar:','];
          [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(funVarStr, 1)];
          [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@","];
          [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:IOSObjectArray_Get(verticalAsymptotesArray, i)];
          [GeogebraCommonKernelGeosGeoFunction_sb_ appendWithNSString:@"))"];
          @try {
            NSString *limit = [kernel_ evaluateCachedGeoGebraCASWithNSString:[GeogebraCommonKernelGeosGeoFunction_sb_ description] withGeogebraCommonKernelArithmeticMyArbitraryConstant:nil];
            if ([((NSString *) nil_chk(limit)) isEqual:@"?"] || !GeogebraCommonKernelGeosGeoFunction_CASErrorWithNSString_withBoolean_(limit, YES)) {
              if ([((JavaLangStringBuilder *) nil_chk(verticalSB)) length] > 1) [verticalSB appendWithChar:','];
              [verticalSB appendWithNSString:@"x="];
              [verticalSB appendWithNSString:IOSObjectArray_Get(verticalAsymptotesArray, i)];
            }
          }
          @catch (JavaLangThrowable *e) {
            [((JavaLangThrowable *) nil_chk(e)) printStackTrace];
          }
        }
      }
    }
  }
  @catch (JavaLangThrowable *t) {
    [((JavaLangThrowable *) nil_chk(t)) printStackTrace];
  }
}

+ (jboolean)CASErrorWithNSString:(NSString *)str
                     withBoolean:(jboolean)allowInfinity {
  return GeogebraCommonKernelGeosGeoFunction_CASErrorWithNSString_withBoolean_(str, allowInfinity);
}

- (NSString *)getCASStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                     withBoolean:(jboolean)symbolic {
  return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) getExpression])) getCASstringWithGeogebraCommonKernelStringTemplate:tpl withBoolean:symbolic];
}

- (IOSObjectArray *)getTempVarCASStringWithBoolean:(jboolean)symbolic {
  return GeogebraCommonKernelGeosGeoFunction_getTempVarCASStringWithBoolean_(self, symbolic);
}

- (void)toGeoCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)curve {
  GeogebraCommonKernelArithmeticFunctionVariable *t = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(kernel_, @"t") autorelease];
  GeogebraCommonKernelArithmeticFunctionVariable *x = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) getFunctionVariable];
  GeogebraCommonKernelArithmeticExpressionNode *yExp = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunction])) getExpression])) deepCopyWithGeogebraCommonKernelKernel:kernel_], [GeogebraCommonKernelArithmeticExpressionNode class])))) replaceWithGeogebraCommonKernelArithmeticExpressionValue:x withGeogebraCommonKernelArithmeticExpressionValue:t], [GeogebraCommonKernelArithmeticExpressionNode class]);
  [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(curve)) setFunctionYWithGeogebraCommonKernelArithmeticFunction:[new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(yExp, t) autorelease]];
  GeogebraCommonKernelArithmeticFunction *varFun = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_([new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, t) autorelease], t) autorelease];
  [curve setFunctionXWithGeogebraCommonKernelArithmeticFunction:varFun];
  if (GeogebraCommonKernelGeosGeoFunction_hasInterval(self)) {
    [curve setIntervalWithDouble:intervalMin_ withDouble:intervalMax_];
  }
  else {
    jdouble min = [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getXminForFunctions];
    jdouble max = [kernel_ getXmaxForFunctions];
    [curve setIntervalWithDouble:min withDouble:max];
    [curve setHideRangeInFormulaWithBoolean:YES];
  }
}

- (GeogebraCommonKernelGeosGeoFunction *)threadSafeCopy {
  if (fun_ == nil) return self;
  GeogebraCommonKernelArithmeticFunctionVariable *t = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(kernel_, @"t") autorelease];
  GeogebraCommonKernelArithmeticFunctionVariable *x = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunction])) getFunctionVariable];
  GeogebraCommonKernelArithmeticExpressionNode *yExp = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunction])) getExpression])) deepCopyWithGeogebraCommonKernelKernel:kernel_], [GeogebraCommonKernelArithmeticExpressionNode class])))) replaceWithGeogebraCommonKernelArithmeticExpressionValue:x withGeogebraCommonKernelArithmeticExpressionValue:t], [GeogebraCommonKernelArithmeticExpressionNode class]);
  return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(yExp)) buildFunctionWithGeogebraCommonKernelArithmeticFunctionVariable:t];
}

- (void)mirrorWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  [self dilateWithGeogebraCommonKernelArithmeticNumberValue:[new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, -1.0) autorelease] withGeogebraCommonKernelMatrixCoords:P];
}

- (void)dilateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)r
                       withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)S {
  jdouble rd = [((GeogebraCommonKernelArithmeticMyDouble *) nil_chk([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(r)) getNumber])) getDouble], a = [((GeogebraCommonKernelMatrixCoords *) nil_chk(S)) getX], b = [S getY];
  if (GeogebraCommonKernelKernel_isZeroWithDouble_(rd)) {
    [self setUndefined];
    return;
  }
  GeogebraCommonKernelArithmeticFunctionVariable *oldX = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) getFunctionVariable];
  GeogebraCommonKernelArithmeticExpressionNode *newX = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 1 / rd) autorelease], GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, oldX, GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, a * rd - a) autorelease]) autorelease]) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *oldY = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([fun_ getExpression])) replaceWithGeogebraCommonKernelArithmeticExpressionValue:oldX withGeogebraCommonKernelArithmeticExpressionValue:newX])) wrap];
  if (![self isBooleanFunction]) {
    [fun_ setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, oldY, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), r) autorelease], GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, -b * rd + b) autorelease]) autorelease]];
  }
  else [fun_ setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:oldY];
}

- (jdouble)distanceWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)p {
  return JavaLangMath_absWithDouble_([self evaluateWithDouble:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p)) getInhomX]] - [p getInhomY]);
}

- (jboolean)isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  return [self isInRegionWithDouble:[((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getX2D] withDouble:[P getY2D]];
}

- (jboolean)isInRegionWithDouble:(jdouble)x0
                      withDouble:(jdouble)y0 {
  if ([self isFunctionOfY]) return GeogebraCommonKernelGeosGeoFunction_evaluateBooleanWithDouble_(self, y0);
  return GeogebraCommonKernelGeosGeoFunction_evaluateBooleanWithDouble_(self, x0);
}

- (jboolean)isFunctionOfY {
  return [((NSString *) nil_chk([self getVarStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()])) isEqual:@"y"];
}

- (void)pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  GeogebraCommonKernelMatrixCoords *P = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(PI)) getCoordsInD2];
  if ([((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getZ] == 1.0) {
  }
  else {
    [P setXWithDouble:[P getX] / [P getZ]];
  }
  GeogebraCommonKernelGeosGeoFunction_pointChangedBooleanWithBoolean_withGeogebraCommonKernelMatrixCoords_(self, NO, P);
  [P setZWithDouble:1.0];
  [PI setCoords2DWithDouble:[P getX] withDouble:[P getY] withDouble:[P getZ]];
  GeogebraCommonKernelRegionParameters *pp = [PI getRegionParameters];
  [((GeogebraCommonKernelRegionParameters *) nil_chk(pp)) setT1WithDouble:[P getX]];
  [pp setT2WithDouble:[P getY]];
  [PI updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:nil];
}

- (jboolean)isRegion {
  return [self isBooleanFunction];
}

- (void)regionChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  [self pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:P];
}

- (void)resetIneqs {
  GeogebraCommonKernelGeosGeoFunction_set_isInequality__(self, JavaLangBoolean_valueOfWithBoolean_([((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) initIneqsWithGeogebraCommonKernelArithmeticExpressionNode:GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(self) withGeogebraCommonKernelArithmeticFunctionalNVar:self]));
}

- (GeogebraCommonKernelArithmeticIneqTree *)getIneqs {
  if ([((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) getIneqs] == nil) {
    GeogebraCommonKernelGeosGeoFunction_set_isInequality__(self, JavaLangBoolean_valueOfWithBoolean_([fun_ initIneqsWithGeogebraCommonKernelArithmeticExpressionNode:[fun_ getExpression] withGeogebraCommonKernelArithmeticFunctionalNVar:self]));
  }
  return [fun_ getIneqs];
}

- (jboolean)showOnAxis {
  return showOnAxis__;
}

- (void)setShowOnAxisWithBoolean:(jboolean)showOnAxis {
  self->showOnAxis__ = showOnAxis;
}

- (void)update {
  [super update];
}

- (jboolean)isGeoFunctionBoolean {
  return [self isBooleanFunction];
}

- (jboolean)isLaTeXDrawableGeo {
  return YES;
}

- (NSString *)getFormulaStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                         withBoolean:(jboolean)substituteNumbers {
  NSString *ret = @"";
  if ([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(self))) isConditional]) {
    if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()]) {
      ret = [self conditionalLaTeXWithBoolean:substituteNumbers withGeogebraCommonKernelStringTemplate:tpl];
    }
    else if ([tpl hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_MATHML()]) {
      ret = [self conditionalMathMLWithBoolean:substituteNumbers withGeogebraCommonKernelStringTemplate:tpl];
    }
  }
  else if ([self isGeoFunction]) {
    if ([self isIndependent]) {
      ret = [self toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
    }
    else {
      if ([self getFunction] == nil) {
        ret = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
      }
      else ret = substituteNumbers ? [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunction])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl] : [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunction])) toStringWithGeogebraCommonKernelStringTemplate:tpl];
    }
  }
  else {
    return [super getFormulaStringWithGeogebraCommonKernelStringTemplate:tpl withBoolean:substituteNumbers];
  }
  if ([@"" isEqual:ret]) {
    ret = [self toOutputValueStringWithGeogebraCommonKernelStringTemplate:tpl];
  }
  if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()]) {
    if ([@"?" isEqual:ret]) ret = JreStrcat("$$$", @" \\text{", [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"], @"} ");
    else if ([(JreStrcat("C", GeogebraCommonUtilUnicode_Infinity)) isEqual:ret]) ret = @"\\infty";
    else if ([(GeogebraCommonUtilUnicode_get_MinusInfinity_()) isEqual:ret]) ret = @"-\\infty";
  }
  return ret;
}

- (jint)getMinimumLineThickness {
  return (isInequality__ != nil && [isInequality__ booleanValue]) ? 0 : 1;
}

- (jboolean)isInequality {
  return (isInequality__ != nil && [isInequality__ booleanValue]) ? YES : NO;
}

- (jboolean)isFreehandFunction {
  return [[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoFunctionFreehand class]];
}

- (IOSObjectArray *)getFunctionVariables {
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) getFunctionVariables];
}

- (void)clearCasEvalMapWithNSString:(NSString *)key {
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) clearCasEvalMapWithNSString:key];
}

- (NSString *)conditionalLaTeXWithBoolean:(jboolean)substituteNumbers
   withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  JavaLangStringBuilder *sbLaTeX = [new_JavaLangStringBuilder_init() autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *expr = GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(self);
  if ([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(expr)) getOperation] == GeogebraCommonPluginOperationEnum_get_IF() && ![((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getRight])) wrap])) isConditional]) {
    if (substituteNumbers) {
      [sbLaTeX appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getRight])) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
      [sbLaTeX appendWithNSString:@" \\;\\;\\;\\; \\left("];
      [sbLaTeX appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getLeft])) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
    }
    else {
      [sbLaTeX appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getRight])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
      [sbLaTeX appendWithNSString:@" \\;\\;\\;\\; \\left("];
      [sbLaTeX appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getLeft])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
    }
    [sbLaTeX appendWithNSString:@" \\right)"];
  }
  else {
    JavaUtilArrayList *cases = [new_JavaUtilArrayList_init() autorelease];
    JavaUtilArrayList *conditions = [new_JavaUtilArrayList_init() autorelease];
    jboolean complete = GeogebraCommonKernelGeosGeoFunction_collectCasesWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilArrayList_withJavaUtilArrayList_withGeogebraCommonKernelGeosGeoFunction_Bounds_(self, expr, cases, conditions, [new_GeogebraCommonKernelGeosGeoFunction_Bounds_initWithGeogebraCommonKernelGeosGeoFunction_(self) autorelease]);
    if ([((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getApplication])) isHTML5Applet]) {
      [sbLaTeX appendWithNSString:@"\\openbraceonly{ \\ggbtable{ "];
      for (jint i = 0; i < [cases size]; i++) {
        [sbLaTeX appendWithNSString:@"\\ggbtr{ \\ggbtdL{ "];
        [sbLaTeX appendWithNSString:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cases getWithInt:i])) toLaTeXStringWithBoolean:!substituteNumbers withGeogebraCommonKernelStringTemplate:tpl]];
        [sbLaTeX appendWithNSString:@"} \\ggbtdL{ : \\space "];
        if (i == [cases size] - 1 && complete) {
          [sbLaTeX appendWithNSString:@"\\text{"];
          [sbLaTeX appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"otherwise"]];
          [sbLaTeX appendWithNSString:@"}"];
        }
        else {
          [sbLaTeX appendWithNSString:[((GeogebraCommonKernelGeosGeoFunction_Bounds *) nil_chk([conditions getWithInt:i])) toLaTeXStringWithBoolean:!substituteNumbers withNSString:[self getVarStringWithGeogebraCommonKernelStringTemplate:tpl] withGeogebraCommonKernelStringTemplate:tpl]];
        }
        [sbLaTeX appendWithNSString:@" } } "];
      }
      [sbLaTeX appendWithNSString:@" } } "];
    }
    else {
      [sbLaTeX appendWithNSString:@"\\left\\{\\begin{array}{ll} "];
      for (jint i = 0; i < [cases size]; i++) {
        [sbLaTeX appendWithNSString:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cases getWithInt:i])) toLaTeXStringWithBoolean:!substituteNumbers withGeogebraCommonKernelStringTemplate:tpl]];
        [sbLaTeX appendWithNSString:@"& : "];
        if (i == [cases size] - 1 && complete) {
          [sbLaTeX appendWithNSString:@"\\text{"];
          [sbLaTeX appendWithNSString:[((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"otherwise"]];
          [sbLaTeX appendWithNSString:@"}"];
        }
        else {
          [sbLaTeX appendWithNSString:[((GeogebraCommonKernelGeosGeoFunction_Bounds *) nil_chk([conditions getWithInt:i])) toLaTeXStringWithBoolean:!substituteNumbers withNSString:[self getVarStringWithGeogebraCommonKernelStringTemplate:tpl] withGeogebraCommonKernelStringTemplate:tpl]];
          if (i != [cases size] - 1) [sbLaTeX appendWithNSString:@"\\\\ "];
        }
      }
      [sbLaTeX appendWithNSString:@" \\end{array}\\right. "];
    }
  }
  return [sbLaTeX description];
}

- (NSString *)conditionalMathMLWithBoolean:(jboolean)substituteNumbers
    withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  JavaLangStringBuilder *sbMathml = [new_JavaLangStringBuilder_init() autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *expr = GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(self);
  if ([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(expr)) getOperation] == GeogebraCommonPluginOperationEnum_get_IF() && ![((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getRight])) wrap])) isConditional]) {
    [sbMathml appendWithNSString:@"<piecewise><piece>"];
    if (substituteNumbers) {
      [sbMathml appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getRight])) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
      [sbMathml appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getLeft])) toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
    }
    else {
      [sbMathml appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getRight])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
      [sbMathml appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([expr getLeft])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_latexTemplate_()]];
    }
    [sbMathml appendWithNSString:@"</piece></piecewise>"];
  }
  else {
    [sbMathml appendWithNSString:@"<piecewise>"];
    JavaUtilArrayList *cases = [new_JavaUtilArrayList_init() autorelease];
    JavaUtilArrayList *conditions = [new_JavaUtilArrayList_init() autorelease];
    jboolean complete = GeogebraCommonKernelGeosGeoFunction_collectCasesWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilArrayList_withJavaUtilArrayList_withGeogebraCommonKernelGeosGeoFunction_Bounds_(self, expr, cases, conditions, [new_GeogebraCommonKernelGeosGeoFunction_Bounds_initWithGeogebraCommonKernelGeosGeoFunction_(self) autorelease]);
    for (jint i = 0; i < [cases size]; i++) {
      if (i == [cases size] - 1 && complete) {
        [sbMathml appendWithNSString:@"<otherwise>"];
        [sbMathml appendWithNSString:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cases getWithInt:i])) toLaTeXStringWithBoolean:!substituteNumbers withGeogebraCommonKernelStringTemplate:tpl]];
        [sbMathml appendWithNSString:@"</otherwise>"];
      }
      else {
        [sbMathml appendWithNSString:@"<piece>"];
        [sbMathml appendWithNSString:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([cases getWithInt:i])) toLaTeXStringWithBoolean:!substituteNumbers withGeogebraCommonKernelStringTemplate:tpl]];
        [sbMathml appendWithNSString:[((GeogebraCommonKernelGeosGeoFunction_Bounds *) nil_chk([conditions getWithInt:i])) toLaTeXStringWithBoolean:!substituteNumbers withNSString:[self getVarStringWithGeogebraCommonKernelStringTemplate:tpl] withGeogebraCommonKernelStringTemplate:tpl]];
        [sbMathml appendWithNSString:@"</piece>"];
      }
    }
    [sbMathml appendWithNSString:@"</piecewise>"];
  }
  return [sbMathml description];
}

- (jboolean)collectCasesWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)condRoot
                                                   withJavaUtilArrayList:(JavaUtilArrayList *)cases
                                                   withJavaUtilArrayList:(JavaUtilArrayList *)conditions
                          withGeogebraCommonKernelGeosGeoFunction_Bounds:(GeogebraCommonKernelGeosGeoFunction_Bounds *)parentCond {
  return GeogebraCommonKernelGeosGeoFunction_collectCasesWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilArrayList_withJavaUtilArrayList_withGeogebraCommonKernelGeosGeoFunction_Bounds_(self, condRoot, cases, conditions, parentCond);
}

- (jboolean)hasDrawable3D {
  return YES;
}

- (jboolean)hasLineOpacity {
  return YES;
}

- (IOSDoubleArray *)newDoubleArray {
  return [IOSDoubleArray arrayWithLength:2];
}

- (IOSDoubleArray *)getDefinedIntervalWithDouble:(jdouble)a
                                      withDouble:(jdouble)b {
  return GeogebraCommonKernelRootsRealRootUtil_getDefinedIntervalWithGeogebraCommonKernelRootsRealRootFunction_withDouble_withDouble_(GeogebraCommonKernelGeosGeoFunction_getRealRootFunctionY(self), a, b);
}

- (jdouble)distanceMaxWithDoubleArray:(IOSDoubleArray *)p1
                      withDoubleArray:(IOSDoubleArray *)p2 {
  return JavaLangMath_maxWithDouble_withDouble_(JavaLangMath_absWithDouble_(IOSDoubleArray_Get(nil_chk(p1), 0) - IOSDoubleArray_Get(nil_chk(p2), 0)), JavaLangMath_absWithDouble_(IOSDoubleArray_Get(p1, 1) - IOSDoubleArray_Get(p2, 1)));
}

- (GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)getLastHitType {
  return GeogebraCommonKernelGeosGeoElement_HitTypeEnum_get_ON_BOUNDARY();
}

- (void)dealloc {
  RELEASE_(fun_);
  RELEASE_(isInequality__);
  RELEASE_(iPoly_);
  RELEASE_(substituteFunctions_);
  RELEASE_(surfaceEvaluables_);
  RELEASE_(derivGeoFun_);
  RELEASE_(includesNonContinuousIntegralFun_);
  RELEASE_(includesDivisionByVarFun_);
  RELEASE_(sbToString_);
  RELEASE_(bounds_);
  [super dealloc];
}

+ (void)initialize {
  if (self == [GeogebraCommonKernelGeosGeoFunction class]) {
    JreStrongAssignAndConsume(&GeogebraCommonKernelGeosGeoFunction_dummy1_, nil, [IOSObjectArray newArrayWithObjects:(id[]){ @"", @"" } count:2 type:NSString_class_()]);
    JreStrongAssignAndConsume(&GeogebraCommonKernelGeosGeoFunction_dummy2_, nil, [IOSCharArray newArrayWithChars:(jchar[]){ ' ', ' ' } count:2]);
    J2OBJC_SET_INITIALIZED(GeogebraCommonKernelGeosGeoFunction)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:", "GeoFunction", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withNSString:withGeogebraCommonKernelArithmeticFunction:", "GeoFunction", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelArithmeticFunction:", "GeoFunction", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelImplicitGeoImplicitPoly:withGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:", "GeoFunction", NULL, 0x1, NULL, NULL },
    { "setVisualStyleWithGeogebraCommonKernelGeosGeoElement:", "setVisualStyle", "V", 0x1, NULL, NULL },
    { "getTypeString", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoFunction:", "GeoFunction", NULL, 0x1, NULL, NULL },
    { "copy__", "copy", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "setFunctionWithGeogebraCommonKernelArithmeticFunction:", "setFunction", "V", 0x1, NULL, NULL },
    { "addToUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:", "addToUpdateSets", "Z", 0x1, NULL, NULL },
    { "removeFromUpdateSetsWithGeogebraCommonKernelAlgosAlgoElement:", "removeFromUpdateSets", "Z", 0x1, NULL, NULL },
    { "initFunction", NULL, "V", 0x1, NULL, NULL },
    { "getFunction", NULL, "Lgeogebra.common.kernel.arithmetic.Function;", 0x1, NULL, NULL },
    { "setIntervalWithDouble:withDouble:", "setInterval", "Z", 0x11, NULL, NULL },
    { "getFunctionExpression", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x11, NULL, NULL },
    { "replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:", "replaceChildrenByValues", "V", 0x1, NULL, NULL },
    { "getFunctionWithDouble:", "getFunction", "Lgeogebra.common.kernel.arithmetic.Function;", 0x1, NULL, NULL },
    { "setDerivativeWithGeogebraCommonKernelGeosCasEvaluableFunction:withInt:withBoolean:", "setDerivative", "V", 0x1, NULL, NULL },
    { "checkDefined", NULL, "V", 0x2, NULL, NULL },
    { "setUsingCasCommandWithNSString:withGeogebraCommonKernelGeosCasEvaluableFunction:withBoolean:withGeogebraCommonKernelArithmeticMyArbitraryConstant:", "setUsingCasCommand", "V", 0x1, NULL, NULL },
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "evaluateWithDoubleArray:", "evaluate", "D", 0x1, NULL, NULL },
    { "getIntervalMin", NULL, "D", 0x11, NULL, NULL },
    { "getIntervalMax", NULL, "D", 0x11, NULL, NULL },
    { "hasInterval", NULL, "Z", 0x11, NULL, NULL },
    { "evaluateBooleanWithDouble:", "evaluateBoolean", "Z", 0x11, NULL, NULL },
    { "getGeoDerivativeWithInt:", "getGeoDerivative", "Lgeogebra.common.kernel.geos.GeoFunction;", 0x1, NULL, NULL },
    { "translateWithGeogebraCommonKernelMatrixCoords:", "translate", "V", 0x11, NULL, NULL },
    { "isTranslateable", NULL, "Z", 0x11, NULL, NULL },
    { "translateWithDouble:withDouble:", "translate", "V", 0x1, NULL, NULL },
    { "isPolynomialFunctionWithBoolean:withBoolean:", "isPolynomialFunction", "Z", 0x1, NULL, NULL },
    { "isPolynomialFunctionWithBoolean:", "isPolynomialFunction", "Z", 0x1, NULL, NULL },
    { "includesDivisionByVar", NULL, "Z", 0x11, NULL, NULL },
    { "includesNonContinuousIntegral", NULL, "Z", 0x11, NULL, NULL },
    { "isDefined", NULL, "Z", 0x1, NULL, NULL },
    { "isFillable", NULL, "Z", 0x1, NULL, NULL },
    { "isInverseFillable", NULL, "Z", 0x1, NULL, NULL },
    { "setDefinedWithBoolean:", "setDefined", "V", 0x1, NULL, NULL },
    { "setUndefined", NULL, "V", 0x1, NULL, NULL },
    { "showInAlgebraView", NULL, "Z", 0x1, NULL, NULL },
    { "showInEuclidianView", NULL, "Z", 0x4, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "initStringBuilderWithJavaLangStringBuilder:withGeogebraCommonKernelStringTemplate:withNSString:withNSString:withBoolean:withBoolean:", "initStringBuilder", "V", 0x19, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toOutputValueStringWithGeogebraCommonKernelStringTemplate:", "toOutputValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toSymbolicStringWithGeogebraCommonKernelStringTemplate:", "toSymbolicString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toLaTeXStringWithBoolean:withGeogebraCommonKernelStringTemplate:", "toLaTeXString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getXMLWithBoolean:withJavaLangStringBuilder:", "getXML", "V", 0x11, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "getIntervalWithDoubleArray:", "getInterval", "V", 0x1, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelMatrixCoords:", "pointChanged", "V", 0x2, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChanged", "V", 0x1, NULL, NULL },
    { "pointChangedBooleanWithBoolean:withGeogebraCommonKernelMatrixCoords:", "pointChangedBoolean", "V", 0x2, NULL, NULL },
    { "isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "isOnPath", "Z", 0x1, NULL, NULL },
    { "pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pathChanged", "V", 0x1, NULL, NULL },
    { "isPath", NULL, "Z", 0x1, NULL, NULL },
    { "getMinParameter", NULL, "D", 0x1, NULL, NULL },
    { "getMaxParameter", NULL, "D", 0x1, NULL, NULL },
    { "createPathMover", NULL, "Lgeogebra.common.kernel.PathMover;", 0x1, NULL, NULL },
    { "isClosedPath", NULL, "Z", 0x1, NULL, NULL },
    { "isCasEvaluableObject", NULL, "Z", 0x11, NULL, NULL },
    { "isNumberValue", NULL, "Z", 0x1, NULL, NULL },
    { "isTraceable", NULL, "Z", 0x1, NULL, NULL },
    { "getTrace", NULL, "Z", 0x1, NULL, NULL },
    { "setTraceWithBoolean:", "setTrace", "V", 0x1, NULL, NULL },
    { "getGeoFunction", NULL, "Lgeogebra.common.kernel.geos.GeoFunction;", 0x1, NULL, NULL },
    { "isGeoFunction", NULL, "Z", 0x1, NULL, NULL },
    { "getAssignmentLHSWithGeogebraCommonKernelStringTemplate:", "getAssignmentLHS", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "isGeoFunctionable", NULL, "Z", 0x1, NULL, NULL },
    { "isBooleanFunction", NULL, "Z", 0x1, NULL, NULL },
    { "swapEval", NULL, "V", 0x1, NULL, NULL },
    { "evaluateCurveWithDouble:withDoubleArray:", "evaluateCurve", "V", 0x1, NULL, NULL },
    { "evaluateCurvatureWithDouble:", "evaluateCurvature", "D", 0x1, NULL, NULL },
    { "getRealRootFunctionX", NULL, "Lgeogebra.common.kernel.roots.RealRootFunction;", 0x11, NULL, NULL },
    { "getRealRootFunctionY", NULL, "Lgeogebra.common.kernel.roots.RealRootFunction;", 0x11, NULL, NULL },
    { "evaluateCurveWithDouble:", "evaluateCurve", "Lgeogebra.common.kernel.geos.GeoVec2D;", 0x1, NULL, NULL },
    { "getVarStringWithGeogebraCommonKernelStringTemplate:", "getVarString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "isFunctionInX", NULL, "Z", 0x11, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x1, NULL, NULL },
    { "addWithGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:", "add", "Lgeogebra.common.kernel.geos.GeoFunction;", 0x9, NULL, NULL },
    { "operationSymbWithGeogebraCommonPluginOperationEnum:withGeogebraCommonKernelArithmeticFunctionalNVar:withGeogebraCommonKernelArithmeticFunctionalNVar:", "operationSymb", "Lgeogebra.common.kernel.arithmetic.FunctionNVar;", 0x9, NULL, NULL },
    { "fromExprWithGeogebraCommonKernelArithmeticExpressionNode:withJavaUtilHashMap:withJavaUtilTreeSet:", "fromExpr", "Lgeogebra.common.kernel.arithmetic.FunctionNVar;", 0xa, NULL, NULL },
    { "toExprWithGeogebraCommonKernelArithmeticFunctionalNVar:withJavaUtilHashMap:withGeogebraCommonKernelKernel:", "toExpr", "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0xa, NULL, NULL },
    { "applyNumberSymbWithGeogebraCommonPluginOperationEnum:withGeogebraCommonKernelArithmeticFunctionalNVar:withGeogebraCommonKernelArithmeticExpressionValue:withBoolean:", "applyNumberSymb", "Lgeogebra.common.kernel.arithmetic.FunctionNVar;", 0x9, NULL, NULL },
    { "subtractWithGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:", "subtract", "Lgeogebra.common.kernel.geos.GeoFunction;", 0x9, NULL, NULL },
    { "multWithGeogebraCommonKernelGeosGeoFunction:withDouble:withGeogebraCommonKernelGeosGeoFunction:", "mult", "Lgeogebra.common.kernel.geos.GeoFunction;", 0x9, NULL, NULL },
    { "evaluateConditionWithDouble:", "evaluateCondition", "Z", 0x1, NULL, NULL },
    { "getLimitWithDouble:withInt:", "getLimit", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getVerticalAsymptotesWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:withBoolean:", "getVerticalAsymptotes", "V", 0x1, NULL, NULL },
    { "getHorizontalPositiveAsymptoteWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:", "getHorizontalPositiveAsymptote", "V", 0x1, NULL, NULL },
    { "getHorizontalNegativeAsymptoteWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:", "getHorizontalNegativeAsymptote", "V", 0x1, NULL, NULL },
    { "getDiagonalPositiveAsymptoteWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:", "getDiagonalPositiveAsymptote", "V", 0x1, NULL, NULL },
    { "getDiagonalNegativeAsymptoteWithGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:", "getDiagonalNegativeAsymptote", "V", 0x1, NULL, NULL },
    { "getDiagonalAsymptoteStaticWithGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:withBoolean:", "getDiagonalAsymptoteStatic", "V", 0x4, NULL, NULL },
    { "getHorizontalAsymptoteStaticWithGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:withBoolean:", "getHorizontalAsymptoteStatic", "V", 0x4, NULL, NULL },
    { "getLabelDelimiter", NULL, "C", 0x4, NULL, NULL },
    { "getVerticalAsymptotesStaticWithGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:withJavaLangStringBuilder:withBoolean:", "getVerticalAsymptotesStatic", "V", 0x4, NULL, NULL },
    { "CASErrorWithNSString:withBoolean:", "CASError", "Z", 0x1a, NULL, NULL },
    { "getCASStringWithGeogebraCommonKernelStringTemplate:withBoolean:", "getCASString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getTempVarCASStringWithBoolean:", "getTempVarCASString", "[Ljava.lang.String;", 0x11, NULL, NULL },
    { "toGeoCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:", "toGeoCurveCartesian", "V", 0x1, NULL, NULL },
    { "threadSafeCopy", NULL, "Lgeogebra.common.kernel.geos.GeoFunction;", 0x1, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelMatrixCoords:", "mirror", "V", 0x11, NULL, NULL },
    { "dilateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelMatrixCoords:", "dilate", "V", 0x1, NULL, NULL },
    { "distanceWithGeogebraCommonKernelGeosGeoPoint:", "distance", "D", 0x1, NULL, NULL },
    { "isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:", "isInRegion", "Z", 0x1, NULL, NULL },
    { "isInRegionWithDouble:withDouble:", "isInRegion", "Z", 0x1, NULL, NULL },
    { "isFunctionOfY", NULL, "Z", 0x1, NULL, NULL },
    { "pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChangedForRegion", "V", 0x1, NULL, NULL },
    { "isRegion", NULL, "Z", 0x1, NULL, NULL },
    { "regionChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "regionChanged", "V", 0x1, NULL, NULL },
    { "resetIneqs", NULL, "V", 0x1, NULL, NULL },
    { "getIneqs", NULL, "Lgeogebra.common.kernel.arithmetic.IneqTree;", 0x1, NULL, NULL },
    { "showOnAxis", NULL, "Z", 0x1, NULL, NULL },
    { "setShowOnAxisWithBoolean:", "setShowOnAxis", "V", 0x1, NULL, NULL },
    { "update", NULL, "V", 0x1, NULL, NULL },
    { "isGeoFunctionBoolean", NULL, "Z", 0x1, NULL, NULL },
    { "isLaTeXDrawableGeo", NULL, "Z", 0x1, NULL, NULL },
    { "getFormulaStringWithGeogebraCommonKernelStringTemplate:withBoolean:", "getFormulaString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getMinimumLineThickness", NULL, "I", 0x1, NULL, NULL },
    { "isInequality", NULL, "Z", 0x1, NULL, NULL },
    { "isFreehandFunction", NULL, "Z", 0x1, NULL, NULL },
    { "getFunctionVariables", NULL, "[Lgeogebra.common.kernel.arithmetic.FunctionVariable;", 0x1, NULL, NULL },
    { "clearCasEvalMapWithNSString:", "clearCasEvalMap", "V", 0x1, NULL, NULL },
    { "conditionalLaTeXWithBoolean:withGeogebraCommonKernelStringTemplate:", "conditionalLaTeX", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "conditionalMathMLWithBoolean:withGeogebraCommonKernelStringTemplate:", "conditionalMathML", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "collectCasesWithGeogebraCommonKernelArithmeticExpressionNode:withJavaUtilArrayList:withJavaUtilArrayList:withGeogebraCommonKernelGeosGeoFunction_Bounds:", "collectCases", "Z", 0x2, NULL, NULL },
    { "hasDrawable3D", NULL, "Z", 0x1, NULL, NULL },
    { "hasLineOpacity", NULL, "Z", 0x1, NULL, NULL },
    { "newDoubleArray", NULL, "[D", 0x1, NULL, NULL },
    { "getDefinedIntervalWithDouble:withDouble:", "getDefinedInterval", "[D", 0x1, NULL, NULL },
    { "distanceMaxWithDoubleArray:withDoubleArray:", "distanceMax", "D", 0x1, NULL, NULL },
    { "getLastHitType", NULL, "Lgeogebra.common.kernel.geos.GeoElement$HitType;", 0x11, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "fun_", NULL, 0x4, "Lgeogebra.common.kernel.arithmetic.Function;", NULL, NULL,  },
    { "isDefined__", "isDefined", 0x4, "Z", NULL, NULL,  },
    { "trace_", NULL, 0x2, "Z", NULL, NULL,  },
    { "includesDivisionByVar__", "includesDivisionByVar", 0x2, "Z", NULL, NULL,  },
    { "includesNonContinuousIntegral__", "includesNonContinuousIntegral", 0x2, "Z", NULL, NULL,  },
    { "interval_", NULL, 0x4, "Z", NULL, NULL,  },
    { "intervalMin_", NULL, 0x4, "D", NULL, NULL,  },
    { "intervalMax_", NULL, 0x4, "D", NULL, NULL,  },
    { "evalSwapped_", NULL, 0x2, "Z", NULL, NULL,  },
    { "isInequality__", "isInequality", 0x2, "Ljava.lang.Boolean;", NULL, NULL,  },
    { "iPoly_", NULL, 0x0, "Lgeogebra.common.kernel.implicit.GeoImplicitPoly;", NULL, NULL,  },
    { "substituteFunctions_", NULL, 0x0, "[Lgeogebra.common.kernel.geos.GeoFunction;", NULL, NULL,  },
    { "FUNCTION_DIRECT_", NULL, 0x8, "I", &GeogebraCommonKernelGeosGeoFunction_FUNCTION_DIRECT_, NULL,  },
    { "FUNCTION_COMPOSITE_IPOLY_FUNCS_", NULL, 0x8, "I", &GeogebraCommonKernelGeosGeoFunction_FUNCTION_COMPOSITE_IPOLY_FUNCS_, NULL,  },
    { "geoFunctionType_", NULL, 0x0, "I", NULL, NULL,  },
    { "surfaceEvaluables_", NULL, 0x2, "Ljava.util.TreeSet;", NULL, "Ljava/util/TreeSet<Lgeogebra/common/kernel/kernelND/SurfaceEvaluable;>;",  },
    { "derivGeoFun_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoFunction;", NULL, NULL,  },
    { "includesNonContinuousIntegralFun_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.Function;", NULL, NULL,  },
    { "includesDivisionByVarFun_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.Function;", NULL, NULL,  },
    { "sbToString_", NULL, 0x4, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "showOnAxis__", "showOnAxis", 0x2, "Z", NULL, NULL,  },
    { "dummy1_", NULL, 0x9, "[Ljava.lang.String;", &GeogebraCommonKernelGeosGeoFunction_dummy1_, NULL,  },
    { "dummy2_", NULL, 0x9, "[C", &GeogebraCommonKernelGeosGeoFunction_dummy2_, NULL,  },
    { "bounds_", NULL, 0x2, "[D", NULL, NULL,  },
    { "sb_", NULL, 0xa, "Ljava.lang.StringBuilder;", &GeogebraCommonKernelGeosGeoFunction_sb_, NULL,  },
  };
  static const char *inner_classes[] = {"Lgeogebra.common.kernel.geos.GeoFunction$Bounds;"};
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoFunction = { 2, "GeoFunction", "geogebra.common.kernel.geos", NULL, 0x1, 135, methods, 25, fields, 0, NULL, 1, inner_classes, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoFunction;
}

@end

void GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoElement_initWithGeogebraCommonKernelConstruction_(self, c);
  self->isDefined__ = YES;
  self->includesDivisionByVar__ = NO;
  self->includesNonContinuousIntegral__ = NO;
  self->interval_ = NO;
  GeogebraCommonKernelGeosGeoFunction_set_isInequality__(self, nil);
  self->geoFunctionType_ = GeogebraCommonKernelGeosGeoFunction_FUNCTION_DIRECT_;
  GeogebraCommonKernelGeosGeoFunction_set_includesNonContinuousIntegralFun_(self, nil);
  GeogebraCommonKernelGeosGeoFunction_set_includesDivisionByVarFun_(self, nil);
  GeogebraCommonKernelGeosGeoFunction_setAndConsume_sbToString_(self, new_JavaLangStringBuilder_initWithInt_(80));
  [self setConstructionDefaults];
  GeogebraCommonKernelGeosGeoFunction_setAndConsume_surfaceEvaluables_(self, new_JavaUtilTreeSet_init());
}

GeogebraCommonKernelGeosGeoFunction *new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoFunction *self = [GeogebraCommonKernelGeosGeoFunction alloc];
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

void GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelConstruction *c, NSString *label, GeogebraCommonKernelArithmeticFunction *f) {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_(self, c, f);
  [self setLabelWithNSString:label];
  if ([self isLabelSet] && ![self isBooleanFunction] && [self isFunctionOfY]) {
    [self remove];
    @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSString_([self getLoc], @"InvalidFunction") autorelease];
  }
}

GeogebraCommonKernelGeosGeoFunction *new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelConstruction *c, NSString *label, GeogebraCommonKernelArithmeticFunction *f) {
  GeogebraCommonKernelGeosGeoFunction *self = [GeogebraCommonKernelGeosGeoFunction alloc];
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(self, c, label, f);
  return self;
}

void GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelConstruction *c, GeogebraCommonKernelArithmeticFunction *f) {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(self, c);
  GeogebraCommonKernelGeosGeoFunction_set_fun_(self, f);
  [self initFunction];
}

GeogebraCommonKernelGeosGeoFunction *new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelConstruction *c, GeogebraCommonKernelArithmeticFunction *f) {
  GeogebraCommonKernelGeosGeoFunction *self = [GeogebraCommonKernelGeosGeoFunction alloc];
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_(self, c, f);
  return self;
}

void GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelImplicitGeoImplicitPoly_withGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelConstruction *c, GeogebraCommonKernelImplicitGeoImplicitPoly *iPoly, GeogebraCommonKernelGeosGeoFunction *f, GeogebraCommonKernelGeosGeoFunction *g) {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(self, c);
  GeogebraCommonKernelGeosGeoFunction_set_iPoly_(self, iPoly);
  self->geoFunctionType_ = GeogebraCommonKernelGeosGeoFunction_FUNCTION_COMPOSITE_IPOLY_FUNCS_;
  GeogebraCommonKernelGeosGeoFunction_setAndConsume_substituteFunctions_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoFunction_class_()]);
  IOSObjectArray_Set(self->substituteFunctions_, 0, f);
  IOSObjectArray_Set(self->substituteFunctions_, 1, g);
  if (f == nil && g != nil) {
    GeogebraCommonKernelGeosGeoFunction_setIntervalWithDouble_withDouble_(self, g->intervalMin_, g->intervalMax_);
    GeogebraCommonKernelGeosGeoFunction_setAndConsume_fun_(self, new_GeogebraCommonKernelGeosGeoFunction_$1_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, [((GeogebraCommonKernelConstruction *) nil_chk(c)) getKernel]));
    [self->fun_ setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [new_GeogebraCommonKernelGeosGeoNumeric_initWithGeogebraCommonKernelConstruction_withDouble_(c, 0) autorelease]) autorelease]];
  }
  else if (f != nil && g == nil) {
    GeogebraCommonKernelGeosGeoFunction_setIntervalWithDouble_withDouble_(self, f->intervalMin_, f->intervalMax_);
    GeogebraCommonKernelGeosGeoFunction_setAndConsume_fun_(self, new_GeogebraCommonKernelGeosGeoFunction_$2_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, [((GeogebraCommonKernelConstruction *) nil_chk(c)) getKernel]));
    [self->fun_ setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [new_GeogebraCommonKernelGeosGeoNumeric_initWithGeogebraCommonKernelConstruction_withDouble_(c, 0) autorelease]) autorelease]];
  }
  else if (f != nil && g != nil) {
    GeogebraCommonKernelGeosGeoFunction_setIntervalWithDouble_withDouble_(self, JavaLangMath_maxWithDouble_withDouble_(f->intervalMin_, g->intervalMin_), JavaLangMath_minWithDouble_withDouble_(f->intervalMax_, g->intervalMax_));
    GeogebraCommonKernelGeosGeoFunction_setAndConsume_fun_(self, new_GeogebraCommonKernelGeosGeoFunction_$3_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, [((GeogebraCommonKernelConstruction *) nil_chk(c)) getKernel]));
    [self->fun_ setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [new_GeogebraCommonKernelGeosGeoNumeric_initWithGeogebraCommonKernelConstruction_withDouble_(c, 0) autorelease]) autorelease]];
  }
}

GeogebraCommonKernelGeosGeoFunction *new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelImplicitGeoImplicitPoly_withGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelConstruction *c, GeogebraCommonKernelImplicitGeoImplicitPoly *iPoly, GeogebraCommonKernelGeosGeoFunction *f, GeogebraCommonKernelGeosGeoFunction *g) {
  GeogebraCommonKernelGeosGeoFunction *self = [GeogebraCommonKernelGeosGeoFunction alloc];
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelImplicitGeoImplicitPoly_withGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_(self, c, iPoly, f, g);
  return self;
}

void GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelGeosGeoFunction *f) {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(self, ((GeogebraCommonKernelGeosGeoFunction *) nil_chk(f))->cons_);
  [self setWithGeogebraCommonKernelGeosGeoElement:f];
}

GeogebraCommonKernelGeosGeoFunction *new_GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *f) {
  GeogebraCommonKernelGeosGeoFunction *self = [GeogebraCommonKernelGeosGeoFunction alloc];
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelGeosGeoFunction_(self, f);
  return self;
}

jboolean GeogebraCommonKernelGeosGeoFunction_setIntervalWithDouble_withDouble_(GeogebraCommonKernelGeosGeoFunction *self, jdouble a, jdouble b) {
  if (a <= b) {
    self->interval_ = YES;
    self->intervalMin_ = a;
    self->intervalMax_ = b;
  }
  else {
    self->interval_ = NO;
  }
  return self->interval_;
}

GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(GeogebraCommonKernelGeosGeoFunction *self) {
  if ([self getFunction] == nil) {
    return nil;
  }
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunction])) getExpression];
}

void GeogebraCommonKernelGeosGeoFunction_checkDefined(GeogebraCommonKernelGeosGeoFunction *self) {
  self->isDefined__ = (self->fun_ != nil);
  if (self->fun_ != nil && [@"?" isEqual:[self->fun_ toValueStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
    self->isDefined__ = NO;
  }
}

jboolean GeogebraCommonKernelGeosGeoFunction_hasInterval(GeogebraCommonKernelGeosGeoFunction *self) {
  return self->interval_;
}

jboolean GeogebraCommonKernelGeosGeoFunction_evaluateBooleanWithDouble_(GeogebraCommonKernelGeosGeoFunction *self, jdouble x) {
  if (self->fun_ == nil || !self->isDefined__) {
    return NO;
  }
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk(self->fun_)) evaluateBooleanWithDouble:x];
}

void GeogebraCommonKernelGeosGeoFunction_initStringBuilderWithJavaLangStringBuilder_withGeogebraCommonKernelStringTemplate_withNSString_withNSString_withBoolean_withBoolean_(JavaLangStringBuilder *stringBuilder, GeogebraCommonKernelStringTemplate *tpl, NSString *label, NSString *var, jboolean isLabelSet, jboolean isBooleanFunction) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  [((JavaLangStringBuilder *) nil_chk(stringBuilder)) setLengthWithInt:0];
  if (isLabelSet) {
    [stringBuilder appendWithNSString:label];
    if (isBooleanFunction && ![((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GEOGEBRA_XML()]) [stringBuilder appendWithNSString:@": "];
    else {
      [stringBuilder appendWithNSString:@"("];
      [stringBuilder appendWithNSString:var];
      [stringBuilder appendWithNSString:@") = "];
    }
  }
}

void GeogebraCommonKernelGeosGeoFunction_pointChangedWithGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelMatrixCoords *P) {
  if ([((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getZ] == 1.0) {
  }
  else {
    [P setXWithDouble:[P getX] / [P getZ]];
  }
  if (![self isBooleanFunction]) {
    if (self->interval_) {
      if ([P getX] < self->intervalMin_) {
        [P setXWithDouble:self->intervalMin_];
      }
      else if ([P getX] > self->intervalMax_) {
        [P setXWithDouble:self->intervalMax_];
      }
    }
    else {
      GeogebraCommonKernelArithmeticExpressionNode *exp = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(self->fun_)) getExpression];
      if ([((GeogebraCommonPluginOperationEnum *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exp)) getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_IF()]) {
        id<GeogebraCommonKernelArithmeticExpressionValue> inequality = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([exp getLeft])) unwrap];
        if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(inequality)) isExpressionNode]) {
          jdouble bound;
          jdouble epsilon = 0;
          GeogebraCommonKernelArithmeticExpressionNode *inequalityEn = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(inequality, [GeogebraCommonKernelArithmeticExpressionNode class]);
          GeogebraCommonPluginOperationEnum *op = [inequalityEn getOperation];
          switch ([op ordinal]) {
            case GeogebraCommonPluginOperation_AND_INTERVAL:
            if (self->bounds_ == nil) {
              GeogebraCommonKernelGeosGeoFunction_setAndConsume_bounds_(self, [IOSDoubleArray newArrayWithLength:2]);
            }
            GeogebraCommonKernelGeosGeoInterval_updateBoundariesWithGeogebraCommonKernelArithmeticExpressionNode_withDoubleArray_withNSStringArray_withCharArray_(inequalityEn, self->bounds_, GeogebraCommonKernelGeosGeoFunction_dummy1_, GeogebraCommonKernelGeosGeoFunction_dummy2_);
            if ([P getX] < IOSDoubleArray_Get(nil_chk(self->bounds_), 0)) {
              [P setXWithDouble:IOSDoubleArray_Get(self->bounds_, 0)];
            }
            else if ([P getX] > IOSDoubleArray_Get(self->bounds_, 1)) {
              [P setXWithDouble:IOSDoubleArray_Get(self->bounds_, 1)];
            }
            break;
            case GeogebraCommonPluginOperation_LESS:
            case GeogebraCommonPluginOperation_LESS_EQUAL:
            case GeogebraCommonPluginOperation_GREATER:
            case GeogebraCommonPluginOperation_GREATER_EQUAL:
            if ([[inequalityEn getLeft] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
              bound = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([inequalityEn getRight])) evaluateDouble];
            }
            else if ([[inequalityEn getRight] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
              bound = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([inequalityEn getLeft])) evaluateDouble];
              op = [((GeogebraCommonPluginOperationEnum *) nil_chk(op)) reverseLeftToRight];
            }
            else {
              bound = JavaLangDouble_NaN;
            }
            switch ([op ordinal]) {
              case GeogebraCommonPluginOperation_LESS:
              epsilon = GeogebraCommonKernelKernel_MIN_PRECISION;
              case GeogebraCommonPluginOperation_LESS_EQUAL:
              if ([P getX] >= bound) {
                [P setXWithDouble:bound - epsilon];
              }
              break;
              case GeogebraCommonPluginOperation_GREATER:
              epsilon = GeogebraCommonKernelKernel_MIN_PRECISION;
              case GeogebraCommonPluginOperation_GREATER_EQUAL:
              if ([P getX] < bound) {
                [P setXWithDouble:bound + epsilon];
              }
              break;
            }
          }
        }
      }
    }
    [P setYWithDouble:[self evaluateWithDouble:[P getX]]];
  }
  else {
    GeogebraCommonKernelGeosGeoFunction_pointChangedBooleanWithBoolean_withGeogebraCommonKernelMatrixCoords_(self, YES, P);
  }
  [P setZWithDouble:1.0];
}

void GeogebraCommonKernelGeosGeoFunction_pointChangedBooleanWithBoolean_withGeogebraCommonKernelMatrixCoords_(GeogebraCommonKernelGeosGeoFunction *self, jboolean b, GeogebraCommonKernelMatrixCoords *P) {
  jdouble px;
  jboolean yfun = [self isFunctionOfY];
  if (yfun) {
    if (b) [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setXWithDouble:0.0];
    px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getY];
  }
  else {
    if (b) [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setYWithDouble:0.0];
    px = [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX];
  }
  jdouble bestDist = JavaLangDouble_MAX_VALUE;
  [self getIneqs];
  if (!GeogebraCommonKernelGeosGeoFunction_evaluateBooleanWithDouble_(self, px)) {
    GeogebraCommonKernelArithmeticIneqTree *ineqs = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(self->fun_)) getIneqs];
    jint ineqCount = [((GeogebraCommonKernelArithmeticIneqTree *) nil_chk(ineqs)) getSize];
    for (jint i = 0; i < ineqCount; i++) {
      {
        IOSObjectArray *a__ = [((GeogebraCommonKernelArithmeticInequality *) nil_chk([ineqs getWithInt:i])) getZeros];
        GeogebraCommonKernelGeosGeoPoint * const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
        GeogebraCommonKernelGeosGeoPoint * const *e__ = b__ + a__->size_;
        while (b__ < e__) {
          GeogebraCommonKernelGeosGeoPoint *point = *b__++;
          if (JavaLangMath_absWithDouble_([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(point)) getX] - px) < bestDist) {
            bestDist = JavaLangMath_absWithDouble_([point getX] - px);
            if (yfun) {
              [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setYWithDouble:[point getX]];
            }
            else {
              [((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) setXWithDouble:[point getX]];
            }
          }
        }
      }
    }
  }
}

id<GeogebraCommonKernelRootsRealRootFunction> GeogebraCommonKernelGeosGeoFunction_getRealRootFunctionY(GeogebraCommonKernelGeosGeoFunction *self) {
  return [new_GeogebraCommonKernelGeosGeoFunction_$5_initWithGeogebraCommonKernelGeosGeoFunction_(self) autorelease];
}

GeogebraCommonKernelGeosGeoFunction *GeogebraCommonKernelGeosGeoFunction_addWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *resultFun, GeogebraCommonKernelGeosGeoFunction *fun1, GeogebraCommonKernelGeosGeoFunction *fun2) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  GeogebraCommonKernelKernel *kernel = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(fun1)) getKernel];
  GeogebraCommonKernelArithmeticFunctionVariable *x1 = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([fun1 getFunction])) getFunctionVariable];
  GeogebraCommonKernelArithmeticFunctionVariable *x2 = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(fun2)) getFunction])) getFunctionVariable];
  GeogebraCommonKernelArithmeticFunctionVariable *x = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_(kernel) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *left = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(fun1))) getCopyWithGeogebraCommonKernelKernel:kernel];
  GeogebraCommonKernelArithmeticExpressionNode *right = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(fun2))) getCopyWithGeogebraCommonKernelKernel:kernel];
  GeogebraCommonKernelArithmeticExpressionNode *sum = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_([fun1 getKernel], [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(left)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:x1 withGeogebraCommonKernelArithmeticExpressionValue:x], GeogebraCommonPluginOperationEnum_get_PLUS(), [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(right)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:x2 withGeogebraCommonKernelArithmeticExpressionValue:x]) autorelease];
  GeogebraCommonKernelArithmeticFunction *f = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(sum, x) autorelease];
  [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(resultFun)) setFunctionWithGeogebraCommonKernelArithmeticFunction:f];
  [resultFun setDefinedWithBoolean:YES];
  return resultFun;
}

GeogebraCommonKernelArithmeticFunctionNVar *GeogebraCommonKernelGeosGeoFunction_operationSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticFunctionalNVar_(GeogebraCommonPluginOperationEnum *op, id<GeogebraCommonKernelArithmeticFunctionalNVar> lt, id<GeogebraCommonKernelArithmeticFunctionalNVar> rt) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  GeogebraCommonKernelKernel *kernel = [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(lt)) getFunction])) getKernel];
  JavaUtilTreeSet *varNames = [new_JavaUtilTreeSet_init() autorelease];
  for (jint i = 0; i < [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([lt getFunction])) getVarNumber]; i++) [varNames addWithId:[((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([lt getFunction])) getVarStringWithInt:i withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
  for (jint i = 0; i < [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(rt)) getFunction])) getVarNumber]; i++) [varNames addWithId:[((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([rt getFunction])) getVarStringWithInt:i withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
  JavaUtilHashMap *varmap = [new_JavaUtilHashMap_init() autorelease];
  for (NSString * __strong name in varNames) {
    [varmap putWithId:name withId:[new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(kernel, name) autorelease]];
  }
  GeogebraCommonKernelArithmeticExpressionNode *ltExpr = GeogebraCommonKernelGeosGeoFunction_toExprWithGeogebraCommonKernelArithmeticFunctionalNVar_withJavaUtilHashMap_withGeogebraCommonKernelKernel_(lt, varmap, kernel), *rtExpr = GeogebraCommonKernelGeosGeoFunction_toExprWithGeogebraCommonKernelArithmeticFunctionalNVar_withJavaUtilHashMap_withGeogebraCommonKernelKernel_(rt, varmap, kernel), *sum = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, ltExpr, op, rtExpr) autorelease];
  GeogebraCommonKernelArithmeticFunctionNVar *f = GeogebraCommonKernelGeosGeoFunction_fromExprWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilHashMap_withJavaUtilTreeSet_(sum, varmap, varNames);
  [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(f)) initFunction];
  return f;
}

GeogebraCommonKernelArithmeticFunctionNVar *GeogebraCommonKernelGeosGeoFunction_fromExprWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilHashMap_withJavaUtilTreeSet_(GeogebraCommonKernelArithmeticExpressionNode *sum, JavaUtilHashMap *varmap, JavaUtilTreeSet *varNames) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  jint size = [((JavaUtilHashMap *) nil_chk(varmap)) size];
  if (size > 1) {
    IOSObjectArray *varArray = [IOSObjectArray arrayWithLength:size type:GeogebraCommonKernelArithmeticFunctionVariable_class_()];
    jint i = 0;
    for (NSString * __strong name in nil_chk(varNames)) {
      IOSObjectArray_Set(varArray, i, [varmap getWithId:name]);
      i++;
    }
    GeogebraCommonKernelArithmeticFunctionNVar *f = [new_GeogebraCommonKernelArithmeticFunctionNVar_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariableArray_(sum, varArray) autorelease];
    return f;
  }
  id<JavaUtilIterator> var = [((id<JavaUtilCollection>) nil_chk([varmap values])) iterator];
  return [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(sum, [((id<JavaUtilIterator>) nil_chk(var)) next]) autorelease];
}

GeogebraCommonKernelArithmeticExpressionNode *GeogebraCommonKernelGeosGeoFunction_toExprWithGeogebraCommonKernelArithmeticFunctionalNVar_withJavaUtilHashMap_withGeogebraCommonKernelKernel_(id<GeogebraCommonKernelArithmeticFunctionalNVar> lt, JavaUtilHashMap *varMap, GeogebraCommonKernelKernel *kernel) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  if ([lt isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, lt, GeogebraCommonPluginOperationEnum_get_FUNCTION(), [((JavaUtilHashMap *) nil_chk(varMap)) getWithId:[((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(lt)) getVarStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) autorelease];
  if ([lt isKindOfClass:[GeogebraCommonKernelGeosGeoFunctionNVar class]]) {
    GeogebraCommonKernelArithmeticMyList *varList = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel) autorelease];
    for (jint i = 0; i < [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(lt)) getFunction])) getVarNumber]; i++) {
      [varList addListElementWithGeogebraCommonKernelArithmeticExpressionValue:[((JavaUtilHashMap *) nil_chk(varMap)) getWithId:[((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([lt getFunction])) getVarStringWithInt:i withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]];
    }
    return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, lt, GeogebraCommonPluginOperationEnum_get_FUNCTION_NVAR(), varList) autorelease];
  }
  if ([lt isKindOfClass:[GeogebraCommonKernelArithmeticFunctionNVar class]]) {
    GeogebraCommonKernelArithmeticExpressionNode *ret = [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(lt, [GeogebraCommonKernelArithmeticFunctionNVar class])))) getExpression];
    for (jint i = 0; i < [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(lt, [GeogebraCommonKernelArithmeticFunctionNVar class])))) getVarNumber]; i++) ret = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(ret)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:IOSObjectArray_Get(nil_chk([((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(lt, [GeogebraCommonKernelArithmeticFunctionNVar class])))) getFunctionVariables]), i) withGeogebraCommonKernelArithmeticExpressionValue:[((JavaUtilHashMap *) nil_chk(varMap)) getWithId:[((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(((GeogebraCommonKernelArithmeticFunctionNVar *) check_class_cast(lt, [GeogebraCommonKernelArithmeticFunctionNVar class])))) getVarStringWithInt:i withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]])) wrap];
    return ret;
  }
  return nil;
}

GeogebraCommonKernelArithmeticFunctionNVar *GeogebraCommonKernelGeosGeoFunction_applyNumberSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_(GeogebraCommonPluginOperationEnum *op, id<GeogebraCommonKernelArithmeticFunctionalNVar> fun1, id<GeogebraCommonKernelArithmeticExpressionValue> ev, jboolean right) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  id<GeogebraCommonKernelArithmeticExpressionValue> nv = ev;
  GeogebraCommonKernelKernel *kernel = [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(fun1)) getFunction])) getKernel];
  JavaUtilTreeSet *varNames = [new_JavaUtilTreeSet_init() autorelease];
  for (jint i = 0; i < [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([fun1 getFunction])) getVarNumber]; i++) [varNames addWithId:[((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk([fun1 getFunction])) getVarStringWithInt:i withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
  JavaUtilHashMap *varmap = [new_JavaUtilHashMap_init() autorelease];
  for (NSString * __strong name in varNames) {
    [varmap putWithId:name withId:[new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(kernel, name) autorelease]];
  }
  GeogebraCommonKernelArithmeticExpressionNode *sum, *myExpr;
  myExpr = GeogebraCommonKernelGeosGeoFunction_toExprWithGeogebraCommonKernelArithmeticFunctionalNVar_withJavaUtilHashMap_withGeogebraCommonKernelKernel_(fun1, varmap, kernel);
  if ([nv isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) for (NSString * __strong name in varNames) {
    [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(nv, [GeogebraCommonKernelArithmeticExpressionNode class])))) replaceVariablesWithNSString:name withGeogebraCommonKernelArithmeticFunctionVariable:[varmap getWithId:name]];
  }
  else if ([nv isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) nv = [varmap getWithId:[((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk(((GeogebraCommonKernelArithmeticFunctionVariable *) check_class_cast(nv, [GeogebraCommonKernelArithmeticFunctionVariable class])))) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
  if (right) {
    sum = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, myExpr, op, nv) autorelease];
  }
  else {
    sum = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, nv, op, myExpr) autorelease];
  }
  GeogebraCommonKernelArithmeticFunctionNVar *f = GeogebraCommonKernelGeosGeoFunction_fromExprWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilHashMap_withJavaUtilTreeSet_(sum, varmap, varNames);
  [((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(f)) initFunction];
  return f;
}

GeogebraCommonKernelGeosGeoFunction *GeogebraCommonKernelGeosGeoFunction_subtractWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *resultFun, GeogebraCommonKernelGeosGeoFunction *fun1, GeogebraCommonKernelGeosGeoFunction *fun2) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  GeogebraCommonKernelKernel *kernel = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(fun1)) getKernel];
  GeogebraCommonKernelArithmeticFunctionVariable *x1 = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([fun1 getFunction])) getFunctionVariable];
  GeogebraCommonKernelArithmeticFunctionVariable *x2 = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(fun2)) getFunction])) getFunctionVariable];
  GeogebraCommonKernelArithmeticFunctionVariable *x = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_(kernel) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *left = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(fun1))) getCopyWithGeogebraCommonKernelKernel:kernel];
  GeogebraCommonKernelArithmeticExpressionNode *right = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(fun2))) getCopyWithGeogebraCommonKernelKernel:kernel];
  GeogebraCommonKernelArithmeticExpressionNode *sum = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_([fun1 getKernel], [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(left)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:x1 withGeogebraCommonKernelArithmeticExpressionValue:x], GeogebraCommonPluginOperationEnum_get_MINUS(), [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(right)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:x2 withGeogebraCommonKernelArithmeticExpressionValue:x]) autorelease];
  GeogebraCommonKernelArithmeticFunction *f = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(sum, x) autorelease];
  [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(resultFun)) setFunctionWithGeogebraCommonKernelArithmeticFunction:f];
  [resultFun setDefinedWithBoolean:YES];
  return resultFun;
}

GeogebraCommonKernelGeosGeoFunction *GeogebraCommonKernelGeosGeoFunction_multWithGeogebraCommonKernelGeosGeoFunction_withDouble_withGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *resultFun, jdouble number, GeogebraCommonKernelGeosGeoFunction *fun) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  GeogebraCommonKernelKernel *kernel = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(fun)) getKernel];
  GeogebraCommonKernelArithmeticMyDouble *num = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel, number) autorelease];
  GeogebraCommonKernelArithmeticFunctionVariable *xold = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([fun getFunction])) getFunctionVariable];
  GeogebraCommonKernelArithmeticFunctionVariable *x = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_(kernel) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *left = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, num) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *right = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(GeogebraCommonKernelGeosGeoFunction_getFunctionExpression(fun))) getCopyWithGeogebraCommonKernelKernel:kernel];
  GeogebraCommonKernelArithmeticExpressionNode *product = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, left, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(right)) replaceWithGeogebraCommonKernelArithmeticExpressionValue:xold withGeogebraCommonKernelArithmeticExpressionValue:x])) wrap]) autorelease];
  GeogebraCommonKernelArithmeticFunction *f = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(product, x) autorelease];
  [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(resultFun)) setFunctionWithGeogebraCommonKernelArithmeticFunction:f];
  [resultFun setDefinedWithBoolean:YES];
  return resultFun;
}

jboolean GeogebraCommonKernelGeosGeoFunction_CASErrorWithNSString_withBoolean_(NSString *str, jboolean allowInfinity) {
  GeogebraCommonKernelGeosGeoFunction_initialize();
  NSString *str1 = str;
  if (str1 == nil || ((jint) [str1 length]) == 0) return YES;
  if ([((NSString *) nil_chk(str1)) isEqual:@"?"]) return YES;
  str1 = GeogebraCommonUtilStringUtil_toLowerCaseWithNSString_(str1);
  if ([((NSString *) nil_chk(str1)) charAtWithInt:0] == '\'') return YES;
  if (!allowInfinity && [str1 indexOf:GeogebraCommonUtilUnicode_Infinity] > -1) return YES;
  if (((jint) [str1 length]) > 6) {
    if ([str1 hasPrefix:@"limit"]) return YES;
    if ([str1 hasPrefix:@"solve"]) return YES;
    if ([str1 hasPrefix:@"undefined"]) return YES;
  }
  return NO;
}

IOSObjectArray *GeogebraCommonKernelGeosGeoFunction_getTempVarCASStringWithBoolean_(GeogebraCommonKernelGeosGeoFunction *self, jboolean symbolic) {
  GeogebraCommonKernelStringTemplate *tpl = GeogebraCommonKernelStringTemplate_get_prefixedDefault_();
  IOSObjectArray *ret = [IOSObjectArray arrayWithObjects:(id[]){ [self getCASStringWithGeogebraCommonKernelStringTemplate:tpl withBoolean:symbolic], [self getVarStringWithGeogebraCommonKernelStringTemplate:tpl] } count:2 type:NSString_class_()];
  return ret;
}

jboolean GeogebraCommonKernelGeosGeoFunction_collectCasesWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilArrayList_withJavaUtilArrayList_withGeogebraCommonKernelGeosGeoFunction_Bounds_(GeogebraCommonKernelGeosGeoFunction *self, GeogebraCommonKernelArithmeticExpressionNode *condRoot, JavaUtilArrayList *cases, JavaUtilArrayList *conditions, GeogebraCommonKernelGeosGeoFunction_Bounds *parentCond) {
  if ([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(condRoot)) getOperation] == GeogebraCommonPluginOperationEnum_get_IF_LIST()) {
    GeogebraCommonKernelArithmeticMyList *conds = (GeogebraCommonKernelArithmeticMyList *) check_class_cast([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([condRoot getLeft])) unwrap], [GeogebraCommonKernelArithmeticMyList class]);
    for (jint i = 0; i < [((GeogebraCommonKernelArithmeticMyList *) nil_chk(conds)) size]; i++) {
      [((JavaUtilArrayList *) nil_chk(conditions)) addWithId:[((GeogebraCommonKernelGeosGeoFunction_Bounds *) nil_chk(parentCond)) addRestrictionWithGeogebraCommonKernelArithmeticExpressionNode:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([conds getListElementWithInt:i])) wrap]]];
    }
    GeogebraCommonKernelArithmeticMyList *fns = (GeogebraCommonKernelArithmeticMyList *) check_class_cast([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([condRoot getRight])) unwrap], [GeogebraCommonKernelArithmeticMyList class]);
    for (jint i = 0; i < [((GeogebraCommonKernelArithmeticMyList *) nil_chk(fns)) size]; i++) {
      [((JavaUtilArrayList *) nil_chk(cases)) addWithId:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([fns getListElementWithInt:i])) wrap]];
    }
    return [fns size] > [conds size];
  }
  jboolean complete = [condRoot getOperation] == GeogebraCommonPluginOperationEnum_get_IF_ELSE();
  GeogebraCommonKernelArithmeticExpressionNode *condFun = complete ? [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast([condRoot getLeft], [GeogebraCommonKernelArithmeticMyNumberPair class])))) getX])) wrap] : [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([condRoot getLeft])) wrap];
  GeogebraCommonKernelArithmeticExpressionNode *ifFun = complete ? [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyNumberPair *) nil_chk(((GeogebraCommonKernelArithmeticMyNumberPair *) check_class_cast([condRoot getLeft], [GeogebraCommonKernelArithmeticMyNumberPair class])))) getY])) wrap] : [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([condRoot getRight])) wrap];
  GeogebraCommonKernelArithmeticExpressionNode *elseFun = complete ? [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([condRoot getRight])) wrap] : nil;
  GeogebraCommonKernelGeosGeoFunction_Bounds *positiveCond = [((GeogebraCommonKernelGeosGeoFunction_Bounds *) nil_chk(parentCond)) addRestrictionWithGeogebraCommonKernelArithmeticExpressionNode:condFun];
  GeogebraCommonKernelGeosGeoFunction_Bounds *negativeCond = [parentCond addRestrictionWithGeogebraCommonKernelArithmeticExpressionNode:[condFun negation]];
  if ([ifFun isConditional]) {
    complete &= GeogebraCommonKernelGeosGeoFunction_collectCasesWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilArrayList_withJavaUtilArrayList_withGeogebraCommonKernelGeosGeoFunction_Bounds_(self, ifFun, cases, conditions, positiveCond);
  }
  else {
    [((JavaUtilArrayList *) nil_chk(cases)) addWithId:ifFun];
    [((JavaUtilArrayList *) nil_chk(conditions)) addWithId:positiveCond];
  }
  if (elseFun != nil && [elseFun isConditional]) {
    complete &= GeogebraCommonKernelGeosGeoFunction_collectCasesWithGeogebraCommonKernelArithmeticExpressionNode_withJavaUtilArrayList_withJavaUtilArrayList_withGeogebraCommonKernelGeosGeoFunction_Bounds_(self, elseFun, cases, conditions, negativeCond);
  }
  else if (elseFun != nil) {
    [((JavaUtilArrayList *) nil_chk(cases)) addWithId:elseFun];
    [((JavaUtilArrayList *) nil_chk(conditions)) addWithId:negativeCond];
  }
  return complete;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoFunction)

@implementation GeogebraCommonKernelGeosGeoFunction_Bounds

- (GeogebraCommonKernelGeosGeoFunction_Bounds *)addRestrictionWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)e {
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(e)) getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_AND()]) {
    return [((GeogebraCommonKernelGeosGeoFunction_Bounds *) nil_chk([self addRestrictionWithGeogebraCommonKernelArithmeticExpressionNode:[e getLeftTree]])) addRestrictionWithGeogebraCommonKernelArithmeticExpressionNode:[e getRightTree]];
  }
  GeogebraCommonKernelGeosGeoFunction_Bounds *b = [new_GeogebraCommonKernelGeosGeoFunction_Bounds_initWithGeogebraCommonKernelGeosGeoFunction_(this$0_) autorelease];
  GeogebraCommonKernelGeosGeoFunction_Bounds_set_lower_(b, lower_);
  GeogebraCommonKernelGeosGeoFunction_Bounds_set_upper_(b, upper_);
  b->lowerSharp_ = lowerSharp_;
  b->upperSharp_ = upperSharp_;
  GeogebraCommonKernelGeosGeoFunction_Bounds_set_condition_(b, condition_);
  id<GeogebraCommonKernelArithmeticExpressionValue> lt = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([e getLeft])) unwrap];
  id<GeogebraCommonKernelArithmeticExpressionValue> rt = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([e getRight])) unwrap];
  jboolean simple = [e getOperation] == GeogebraCommonPluginOperationEnum_get_GREATER() || [e getOperation] == GeogebraCommonPluginOperationEnum_get_GREATER_EQUAL() || [e getOperation] == GeogebraCommonPluginOperationEnum_get_LESS() || [e getOperation] == GeogebraCommonPluginOperationEnum_get_LESS_EQUAL() || [e getOperation] == GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN();
  if (simple && [lt isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt] && !([rt isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]])) {
    jdouble d = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble];
    if ([e getOperation] == GeogebraCommonPluginOperationEnum_get_GREATER() && (lower_ == nil || [lower_ doubleValue] <= d)) {
      GeogebraCommonKernelGeosGeoFunction_Bounds_set_lower_(b, JavaLangDouble_valueOfWithDouble_(d));
      b->lowerSharp_ = YES;
    }
    else if (([e getOperation] == GeogebraCommonPluginOperationEnum_get_GREATER_EQUAL() || [e getOperation] == GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()) && (lower_ == nil || [lower_ doubleValue] < d)) {
      GeogebraCommonKernelGeosGeoFunction_Bounds_set_lower_(b, JavaLangDouble_valueOfWithDouble_(d));
      b->lowerSharp_ = NO;
    }
    else if ([e getOperation] == GeogebraCommonPluginOperationEnum_get_LESS() && (upper_ == nil || [upper_ doubleValue] >= d)) {
      GeogebraCommonKernelGeosGeoFunction_Bounds_set_upper_(b, JavaLangDouble_valueOfWithDouble_(d));
      b->upperSharp_ = YES;
    }
    if (([e getOperation] == GeogebraCommonPluginOperationEnum_get_LESS_EQUAL() || [e getOperation] == GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()) && (upper_ == nil || [upper_ doubleValue] > d)) {
      GeogebraCommonKernelGeosGeoFunction_Bounds_set_upper_(b, JavaLangDouble_valueOfWithDouble_(d));
      b->upperSharp_ = NO;
    }
  }
  else if (simple && [rt isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && !([lt isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]])) {
    jdouble d = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble];
    if ([e getOperation] == GeogebraCommonPluginOperationEnum_get_LESS() && (lower_ == nil || [lower_ doubleValue] <= d)) {
      GeogebraCommonKernelGeosGeoFunction_Bounds_set_lower_(b, JavaLangDouble_valueOfWithDouble_(d));
      b->lowerSharp_ = YES;
    }
    else if (([e getOperation] == GeogebraCommonPluginOperationEnum_get_LESS_EQUAL() || [e getOperation] == GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()) && (lower_ == nil || [lower_ doubleValue] < d)) {
      GeogebraCommonKernelGeosGeoFunction_Bounds_set_lower_(b, JavaLangDouble_valueOfWithDouble_(d));
      b->lowerSharp_ = NO;
    }
    else if ([e getOperation] == GeogebraCommonPluginOperationEnum_get_GREATER() && (upper_ == nil || [upper_ doubleValue] >= d)) {
      GeogebraCommonKernelGeosGeoFunction_Bounds_set_upper_(b, JavaLangDouble_valueOfWithDouble_(d));
      b->upperSharp_ = YES;
    }
    if (([e getOperation] == GeogebraCommonPluginOperationEnum_get_GREATER_EQUAL() || [e getOperation] == GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()) && (upper_ == nil || [upper_ doubleValue] > d)) {
      GeogebraCommonKernelGeosGeoFunction_Bounds_set_upper_(b, JavaLangDouble_valueOfWithDouble_(d));
      b->upperSharp_ = NO;
    }
  }
  else {
    if (condition_ == nil) GeogebraCommonKernelGeosGeoFunction_Bounds_set_condition_(b, e);
    else GeogebraCommonKernelGeosGeoFunction_Bounds_set_condition_(b, [condition_ and__WithGeogebraCommonKernelArithmeticExpressionValue:e]);
  }
  if (b->upper_ != nil && b->lower_ != nil && (b->condition_ != nil) && GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([b->upper_ doubleValue], [b->lower_ doubleValue])) {
    [((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk([this$0_ getFunction])) getFunctionVariable])) setWithDouble:[b->upper_ doubleValue]];
    id<GeogebraCommonKernelArithmeticExpressionValue> v = [b->condition_ evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
    if ([GeogebraCommonKernelArithmeticBooleanValue_class_() isInstance:v] && [((id<GeogebraCommonKernelArithmeticBooleanValue>) nil_chk(((id<GeogebraCommonKernelArithmeticBooleanValue>) check_protocol_cast(v, @protocol(GeogebraCommonKernelArithmeticBooleanValue))))) getBoolean]) GeogebraCommonKernelGeosGeoFunction_Bounds_set_condition_(b, nil);
  }
  if (b->condition_ != nil && [b->condition_ getOperation] == GeogebraCommonPluginOperationEnum_get_NOT_EQUAL()) {
    if ([[b->condition_ getLeft] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [[b->condition_ getRight] isKindOfClass:[GeogebraCommonKernelArithmeticMyDouble class]]) {
      jdouble d = [((GeogebraCommonKernelArithmeticMyDouble *) nil_chk(((GeogebraCommonKernelArithmeticMyDouble *) check_class_cast([b->condition_ getRight], [GeogebraCommonKernelArithmeticMyDouble class])))) getDouble];
      if ((b->lower_ != nil && d < [b->lower_ doubleValue]) || (b->upper_ != nil && d > [b->upper_ doubleValue])) GeogebraCommonKernelGeosGeoFunction_Bounds_set_condition_(b, nil);
    }
    else if ([[b->condition_ getRight] isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [[b->condition_ getLeft] isKindOfClass:[GeogebraCommonKernelArithmeticMyDouble class]]) {
      jdouble d = [((GeogebraCommonKernelArithmeticMyDouble *) nil_chk(((GeogebraCommonKernelArithmeticMyDouble *) check_class_cast([b->condition_ getLeft], [GeogebraCommonKernelArithmeticMyDouble class])))) getDouble];
      if ((b->lower_ != nil && d < [b->lower_ doubleValue]) || (b->upper_ != nil && d > [b->upper_ doubleValue])) GeogebraCommonKernelGeosGeoFunction_Bounds_set_condition_(b, nil);
    }
  }
  return b;
}

- (NSString *)toLaTeXStringWithBoolean:(jboolean)symbolic
                          withNSString:(NSString *)varString
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  JavaLangStringBuilder *ret = [new_JavaLangStringBuilder_init() autorelease];
  if ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) hasTypeWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_LATEX()]) {
    if (upper_ == nil && lower_ != nil) {
      [ret appendWithNSString:varString];
      [ret appendWithNSString:@" "];
      [ret appendWithId:lowerSharp_ ? @">" : JavaLangCharacter_valueOfWithChar_(GeogebraCommonUtilUnicode_GREATER_EQUAL)];
      [ret appendWithNSString:@" "];
      [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[lower_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
    }
    else if (lower_ == nil && upper_ != nil) {
      [ret appendWithNSString:varString];
      [ret appendWithNSString:@" "];
      [ret appendWithId:upperSharp_ ? @"<" : JavaLangCharacter_valueOfWithChar_(GeogebraCommonUtilUnicode_LESS_EQUAL)];
      [ret appendWithNSString:@" "];
      [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[upper_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
    }
    else if (lower_ != nil && upper_ != nil) {
      if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([lower_ doubleValue], [upper_ doubleValue]) && !lowerSharp_ && !upperSharp_) {
        [ret appendWithNSString:varString];
        [ret appendWithNSString:@" = "];
        [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[lower_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[lower_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
        [ret appendWithNSString:@" "];
        [ret appendWithId:lowerSharp_ ? @"<" : JavaLangCharacter_valueOfWithChar_(GeogebraCommonUtilUnicode_LESS_EQUAL)];
        [ret appendWithNSString:@" "];
        [ret appendWithNSString:varString];
        [ret appendWithNSString:@" "];
        [ret appendWithId:upperSharp_ ? @"<" : JavaLangCharacter_valueOfWithChar_(GeogebraCommonUtilUnicode_LESS_EQUAL)];
        [ret appendWithNSString:@" "];
        [ret appendWithNSString:[this$0_->kernel_ formatWithDouble:[upper_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    else if (condition_ != nil) {
      return [condition_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl];
    }
    if (condition_ != nil) {
      [ret insertWithInt:0 withNSString:@"("];
      [ret appendWithNSString:@")\\wedge \\left("];
      [ret appendWithNSString:[condition_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl]];
      [ret appendWithNSString:@"\\right)"];
    }
  }
  else {
    if (upper_ == nil && lower_ != nil) {
      [ret appendWithNSString:@"<apply>"];
      [ret appendWithNSString:lowerSharp_ ? @"<gt/>" : @"<geq/>"];
      [ret appendWithNSString:@"<ci>"];
      [ret appendWithNSString:varString];
      [ret appendWithNSString:@"</ci><cn>"];
      [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[lower_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
      [ret appendWithNSString:@"</cn></apply>"];
    }
    else if (lower_ == nil && upper_ != nil) {
      [ret appendWithNSString:@"<apply>"];
      [ret appendWithNSString:upperSharp_ ? @"<lt/>" : @"<leq/>"];
      [ret appendWithNSString:@"<ci>"];
      [ret appendWithNSString:varString];
      [ret appendWithNSString:@"</ci><cn>"];
      [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[upper_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
      [ret appendWithNSString:@"</cn></apply>"];
    }
    else if (lower_ != nil && upper_ != nil) {
      if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([lower_ doubleValue], [upper_ doubleValue]) && !lowerSharp_ && !upperSharp_) {
        [ret appendWithNSString:@"<apply>"];
        [ret appendWithNSString:@"<eq/>"];
        [ret appendWithNSString:@"<ci>"];
        [ret appendWithNSString:varString];
        [ret appendWithNSString:@"</ci><cn>"];
        [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[lower_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
        [ret appendWithNSString:@"</cn></apply>"];
      }
      else {
        if (lowerSharp_ == upperSharp_) {
          [ret appendWithNSString:@"<apply>"];
          [ret appendWithNSString:lowerSharp_ ? @"<lt/>" : @"<leq/>"];
          [ret appendWithNSString:@"<cn>"];
          [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[lower_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
          [ret appendWithNSString:@"</cn>"];
          [ret appendWithNSString:@"<ci>"];
          [ret appendWithNSString:varString];
          [ret appendWithNSString:@"</ci>"];
          [ret appendWithNSString:@"<cn>"];
          [ret appendWithNSString:[this$0_->kernel_ formatWithDouble:[upper_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
          [ret appendWithNSString:@"</cn>"];
          [ret appendWithNSString:@"</apply>"];
        }
        else {
          [ret appendWithNSString:@"<apply>"];
          [ret appendWithNSString:@"<and/>"];
          [ret appendWithNSString:@"<apply>"];
          [ret appendWithNSString:lowerSharp_ ? @"<lt/>" : @"<leq/>"];
          [ret appendWithNSString:@"<cn>"];
          [ret appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(this$0_->kernel_)) formatWithDouble:[lower_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
          [ret appendWithNSString:@"</cn>"];
          [ret appendWithNSString:@"<ci>"];
          [ret appendWithNSString:varString];
          [ret appendWithNSString:@"</ci>"];
          [ret appendWithNSString:@"</apply>"];
          [ret appendWithNSString:@"<apply>"];
          [ret appendWithNSString:upperSharp_ ? @"<lt/>" : @"<leq/>"];
          [ret appendWithNSString:@"<ci>"];
          [ret appendWithNSString:varString];
          [ret appendWithNSString:@"</ci>"];
          [ret appendWithNSString:@"<cn>"];
          [ret appendWithNSString:[this$0_->kernel_ formatWithDouble:[upper_ doubleValue] withGeogebraCommonKernelStringTemplate:tpl]];
          [ret appendWithNSString:@"</cn>"];
          [ret appendWithNSString:@"</apply>"];
          [ret appendWithNSString:@"</apply>"];
        }
      }
    }
    else if (condition_ != nil) {
      return [condition_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl];
    }
    if (condition_ != nil) {
      [ret insertWithInt:0 withNSString:@"<apply><and/>"];
      [ret appendWithNSString:[condition_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl]];
      [ret appendWithNSString:@"</apply>"];
    }
  }
  return [ret description];
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$ {
  GeogebraCommonKernelGeosGeoFunction_Bounds_initWithGeogebraCommonKernelGeosGeoFunction_(self, outer$);
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  RELEASE_(lower_);
  RELEASE_(upper_);
  RELEASE_(condition_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "addRestrictionWithGeogebraCommonKernelArithmeticExpressionNode:", "addRestriction", "Lgeogebra.common.kernel.geos.GeoFunction$Bounds;", 0x1, NULL, NULL },
    { "toLaTeXStringWithBoolean:withNSString:withGeogebraCommonKernelStringTemplate:", "toLaTeXString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoFunction:", "init", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lgeogebra.common.kernel.geos.GeoFunction;", NULL, NULL,  },
    { "lowerSharp_", NULL, 0x2, "Z", NULL, NULL,  },
    { "upperSharp_", NULL, 0x2, "Z", NULL, NULL,  },
    { "lower_", NULL, 0x2, "Ljava.lang.Double;", NULL, NULL,  },
    { "upper_", NULL, 0x2, "Ljava.lang.Double;", NULL, NULL,  },
    { "condition_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoFunction_Bounds = { 2, "Bounds", "geogebra.common.kernel.geos", "GeoFunction", 0x0, 3, methods, 6, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoFunction_Bounds;
}

@end

void GeogebraCommonKernelGeosGeoFunction_Bounds_initWithGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction_Bounds *self, GeogebraCommonKernelGeosGeoFunction *outer$) {
  GeogebraCommonKernelGeosGeoFunction_Bounds_set_this$0_(self, outer$);
  NSObject_init(self);
}

GeogebraCommonKernelGeosGeoFunction_Bounds *new_GeogebraCommonKernelGeosGeoFunction_Bounds_initWithGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *outer$) {
  GeogebraCommonKernelGeosGeoFunction_Bounds *self = [GeogebraCommonKernelGeosGeoFunction_Bounds alloc];
  GeogebraCommonKernelGeosGeoFunction_Bounds_initWithGeogebraCommonKernelGeosGeoFunction_(self, outer$);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoFunction_Bounds)

@implementation GeogebraCommonKernelGeosGeoFunction_$1

- (jdouble)evaluateWithDouble:(jdouble)x {
  return [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(this$0_->iPoly_)) evalPolyAtWithDouble:x withDouble:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(IOSObjectArray_Get(nil_chk(this$0_->substituteFunctions_), 1))) getFunction])) evaluateWithDouble:x]];
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$
                             withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)arg$0 {
  GeogebraCommonKernelGeosGeoFunction_$1_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, outer$, arg$0);
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelKernel:", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lgeogebra.common.kernel.geos.GeoFunction;", NULL, NULL,  },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "GeogebraCommonKernelGeosGeoFunction", "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelImplicitGeoImplicitPoly:withGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:" };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoFunction_$1 = { 2, "", "geogebra.common.kernel.geos", "GeoFunction", 0x8008, 2, methods, 1, fields, 0, NULL, 0, NULL, &enclosing_method, NULL };
  return &_GeogebraCommonKernelGeosGeoFunction_$1;
}

@end

void GeogebraCommonKernelGeosGeoFunction_$1_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction_$1 *self, GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) {
  GeogebraCommonKernelGeosGeoFunction_$1_set_this$0_(self, outer$);
  GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelKernel_(self, arg$0);
}

GeogebraCommonKernelGeosGeoFunction_$1 *new_GeogebraCommonKernelGeosGeoFunction_$1_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) {
  GeogebraCommonKernelGeosGeoFunction_$1 *self = [GeogebraCommonKernelGeosGeoFunction_$1 alloc];
  GeogebraCommonKernelGeosGeoFunction_$1_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, outer$, arg$0);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoFunction_$1)

@implementation GeogebraCommonKernelGeosGeoFunction_$2

- (jdouble)evaluateWithDouble:(jdouble)x {
  return [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(this$0_->iPoly_)) evalPolyAtWithDouble:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(IOSObjectArray_Get(nil_chk(this$0_->substituteFunctions_), 0))) getFunction])) evaluateWithDouble:x] withDouble:x];
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$
                             withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)arg$0 {
  GeogebraCommonKernelGeosGeoFunction_$2_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, outer$, arg$0);
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelKernel:", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lgeogebra.common.kernel.geos.GeoFunction;", NULL, NULL,  },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "GeogebraCommonKernelGeosGeoFunction", "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelImplicitGeoImplicitPoly:withGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:" };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoFunction_$2 = { 2, "", "geogebra.common.kernel.geos", "GeoFunction", 0x8008, 2, methods, 1, fields, 0, NULL, 0, NULL, &enclosing_method, NULL };
  return &_GeogebraCommonKernelGeosGeoFunction_$2;
}

@end

void GeogebraCommonKernelGeosGeoFunction_$2_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction_$2 *self, GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) {
  GeogebraCommonKernelGeosGeoFunction_$2_set_this$0_(self, outer$);
  GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelKernel_(self, arg$0);
}

GeogebraCommonKernelGeosGeoFunction_$2 *new_GeogebraCommonKernelGeosGeoFunction_$2_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) {
  GeogebraCommonKernelGeosGeoFunction_$2 *self = [GeogebraCommonKernelGeosGeoFunction_$2 alloc];
  GeogebraCommonKernelGeosGeoFunction_$2_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, outer$, arg$0);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoFunction_$2)

@implementation GeogebraCommonKernelGeosGeoFunction_$3

- (jdouble)evaluateWithDouble:(jdouble)x {
  return [((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(this$0_->iPoly_)) evalPolyAtWithDouble:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(IOSObjectArray_Get(nil_chk(this$0_->substituteFunctions_), 0))) getFunction])) evaluateWithDouble:x] withDouble:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoFunction *) nil_chk(IOSObjectArray_Get(this$0_->substituteFunctions_, 1))) getFunction])) evaluateWithDouble:x]];
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$
                             withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)arg$0 {
  GeogebraCommonKernelGeosGeoFunction_$3_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, outer$, arg$0);
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelKernel:", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lgeogebra.common.kernel.geos.GeoFunction;", NULL, NULL,  },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "GeogebraCommonKernelGeosGeoFunction", "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelImplicitGeoImplicitPoly:withGeogebraCommonKernelGeosGeoFunction:withGeogebraCommonKernelGeosGeoFunction:" };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoFunction_$3 = { 2, "", "geogebra.common.kernel.geos", "GeoFunction", 0x8008, 2, methods, 1, fields, 0, NULL, 0, NULL, &enclosing_method, NULL };
  return &_GeogebraCommonKernelGeosGeoFunction_$3;
}

@end

void GeogebraCommonKernelGeosGeoFunction_$3_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction_$3 *self, GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) {
  GeogebraCommonKernelGeosGeoFunction_$3_set_this$0_(self, outer$);
  GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelKernel_(self, arg$0);
}

GeogebraCommonKernelGeosGeoFunction_$3 *new_GeogebraCommonKernelGeosGeoFunction_$3_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(GeogebraCommonKernelGeosGeoFunction *outer$, GeogebraCommonKernelKernel *arg$0) {
  GeogebraCommonKernelGeosGeoFunction_$3 *self = [GeogebraCommonKernelGeosGeoFunction_$3 alloc];
  GeogebraCommonKernelGeosGeoFunction_$3_initWithGeogebraCommonKernelGeosGeoFunction_withGeogebraCommonKernelKernel_(self, outer$, arg$0);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoFunction_$3)

@implementation GeogebraCommonKernelGeosGeoFunction_$4

- (jdouble)evaluateWithDouble:(jdouble)t {
  return t;
}

- (instancetype)init {
  GeogebraCommonKernelGeosGeoFunction_$4_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "init", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "GeogebraCommonKernelGeosGeoFunction", "getRealRootFunctionX" };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoFunction_$4 = { 2, "", "geogebra.common.kernel.geos", "GeoFunction", 0x8008, 2, methods, 0, NULL, 0, NULL, 0, NULL, &enclosing_method, NULL };
  return &_GeogebraCommonKernelGeosGeoFunction_$4;
}

@end

void GeogebraCommonKernelGeosGeoFunction_$4_init(GeogebraCommonKernelGeosGeoFunction_$4 *self) {
  NSObject_init(self);
}

GeogebraCommonKernelGeosGeoFunction_$4 *new_GeogebraCommonKernelGeosGeoFunction_$4_init() {
  GeogebraCommonKernelGeosGeoFunction_$4 *self = [GeogebraCommonKernelGeosGeoFunction_$4 alloc];
  GeogebraCommonKernelGeosGeoFunction_$4_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoFunction_$4)

@implementation GeogebraCommonKernelGeosGeoFunction_$5

- (jdouble)evaluateWithDouble:(jdouble)t {
  return [this$0_ evaluateWithDouble:t];
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoFunction:(GeogebraCommonKernelGeosGeoFunction *)outer$ {
  GeogebraCommonKernelGeosGeoFunction_$5_initWithGeogebraCommonKernelGeosGeoFunction_(self, outer$);
  return self;
}

- (void)dealloc {
  RELEASE_(this$0_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoFunction:", "", NULL, 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "this$0_", NULL, 0x1012, "Lgeogebra.common.kernel.geos.GeoFunction;", NULL, NULL,  },
  };
  static const J2ObjCEnclosingMethodInfo enclosing_method = { "GeogebraCommonKernelGeosGeoFunction", "getRealRootFunctionY" };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoFunction_$5 = { 2, "", "geogebra.common.kernel.geos", "GeoFunction", 0x8008, 2, methods, 1, fields, 0, NULL, 0, NULL, &enclosing_method, NULL };
  return &_GeogebraCommonKernelGeosGeoFunction_$5;
}

@end

void GeogebraCommonKernelGeosGeoFunction_$5_initWithGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction_$5 *self, GeogebraCommonKernelGeosGeoFunction *outer$) {
  GeogebraCommonKernelGeosGeoFunction_$5_set_this$0_(self, outer$);
  NSObject_init(self);
}

GeogebraCommonKernelGeosGeoFunction_$5 *new_GeogebraCommonKernelGeosGeoFunction_$5_initWithGeogebraCommonKernelGeosGeoFunction_(GeogebraCommonKernelGeosGeoFunction *outer$) {
  GeogebraCommonKernelGeosGeoFunction_$5 *self = [GeogebraCommonKernelGeosGeoFunction_$5 alloc];
  GeogebraCommonKernelGeosGeoFunction_$5_initWithGeogebraCommonKernelGeosGeoFunction_(self, outer$);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoFunction_$5)
