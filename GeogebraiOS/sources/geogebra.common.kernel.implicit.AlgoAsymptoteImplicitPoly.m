//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/implicit/AlgoAsymptoteImplicitPoly.java
//


#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/EquationSolver.h"
#include "geogebra/common/kernel/EquationSolverInterface.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoList.h"
#include "geogebra/common/kernel/implicit/AlgoAsymptoteImplicitPoly.h"
#include "geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "geogebra/common/kernel/implicit/PolynomialUtils.h"
#include "geogebra/common/plugin/EuclidianStyleConstants.h"
#include "geogebra/common/util/Cloner.h"
#include "java/lang/Double.h"
#include "java/lang/Error.h"
#include "java/lang/Integer.h"
#include "java/util/ArrayList.h"

@interface GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly () {
 @public
  GeogebraCommonKernelImplicitGeoImplicitPoly *ip_;
  GeogebraCommonKernelGeosGeoList *g_;
  id<GeogebraCommonKernelEquationSolverInterface> solver_;
}

- (void)makeLinesWithJavaUtilArrayList:(JavaUtilArrayList *)p
                            withDouble:(jdouble)a
                            withDouble:(jdouble)b;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly, ip_, GeogebraCommonKernelImplicitGeoImplicitPoly *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly, g_, GeogebraCommonKernelGeosGeoList *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly, solver_, id<GeogebraCommonKernelEquationSolverInterface>)

__attribute__((unused)) static void GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_makeLinesWithJavaUtilArrayList_withDouble_withDouble_(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly *self, JavaUtilArrayList *p, jdouble a, jdouble b);

__attribute__((unused)) static void GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_compute(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly *self);

@implementation GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                                            withNSString:(NSString *)label
         withGeogebraCommonKernelImplicitGeoImplicitPoly:(GeogebraCommonKernelImplicitGeoImplicitPoly *)ip {
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelImplicitGeoImplicitPoly_(self, c, label, ip);
  return self;
}

- (GeogebraCommonKernelCommandsCommandsEnum *)getClassName {
  return GeogebraCommonKernelCommandsCommandsEnum_get_Asymptote();
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_setAndConsume_input_(self, [IOSObjectArray newArrayWithLength:1 type:GeogebraCommonKernelGeosGeoElement_class_()]);
  IOSObjectArray_Set(input_, 0, ip_);
  [self setOutputLengthWithInt:1];
  [self setOutputWithInt:0 withGeogebraCommonKernelGeosGeoElement:g_];
  [self setDependencies];
}

- (GeogebraCommonKernelGeosGeoList *)getResult {
  return g_;
}

- (void)makeLinesWithJavaUtilArrayList:(JavaUtilArrayList *)p
                            withDouble:(jdouble)a
                            withDouble:(jdouble)b {
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_makeLinesWithJavaUtilArrayList_withDouble_withDouble_(self, p, a, b);
}

- (void)compute {
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_compute(self);
}

- (void)dealloc {
  RELEASE_(ip_);
  RELEASE_(g_);
  RELEASE_(solver_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withNSString:withGeogebraCommonKernelImplicitGeoImplicitPoly:", "AlgoAsymptoteImplicitPoly", NULL, 0x1, NULL, NULL },
    { "getClassName", NULL, "Lgeogebra.common.kernel.commands.Commands;", 0x1, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x4, NULL, NULL },
    { "getResult", NULL, "Lgeogebra.common.kernel.geos.GeoList;", 0x1, NULL, NULL },
    { "makeLinesWithJavaUtilArrayList:withDouble:withDouble:", "makeLines", "V", 0x2, NULL, NULL },
    { "compute", NULL, "V", 0x11, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "ip_", NULL, 0x2, "Lgeogebra.common.kernel.implicit.GeoImplicitPoly;", NULL, NULL,  },
    { "g_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoList;", NULL, NULL,  },
    { "solver_", NULL, 0x2, "Lgeogebra.common.kernel.EquationSolverInterface;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly = { 2, "AlgoAsymptoteImplicitPoly", "geogebra.common.kernel.implicit", NULL, 0x1, 6, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly;
}

@end

void GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelImplicitGeoImplicitPoly_(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly *self, GeogebraCommonKernelConstruction *c, NSString *label, GeogebraCommonKernelImplicitGeoImplicitPoly *ip) {
  GeogebraCommonKernelAlgosAlgoElement_initWithGeogebraCommonKernelConstruction_(self, c);
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_set_ip_(self, ip);
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_set_solver_(self, [((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) getEquationSolver]);
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_setAndConsume_g_(self, new_GeogebraCommonKernelGeosGeoList_initWithGeogebraCommonKernelConstruction_(self->cons_));
  [self setInputOutput];
  [self->g_ setLineTypeWithInt:GeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_SHORT];
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_compute(self);
  [self->g_ setLabelWithNSString:label];
}

GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly *new_GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelImplicitGeoImplicitPoly_(GeogebraCommonKernelConstruction *c, NSString *label, GeogebraCommonKernelImplicitGeoImplicitPoly *ip) {
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly *self = [GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly alloc];
  GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelImplicitGeoImplicitPoly_(self, c, label, ip);
  return self;
}

void GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_makeLinesWithJavaUtilArrayList_withDouble_withDouble_(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly *self, JavaUtilArrayList *p, jdouble a, jdouble b) {
  IOSDoubleArray *tRoots = [IOSDoubleArray arrayWithLength:[((JavaUtilArrayList *) nil_chk(p)) size]];
  for (jint j = 0; j < [p size]; j++) {
    *IOSDoubleArray_GetRef(tRoots, j) = [((JavaLangDouble *) nil_chk([p getWithInt:[p size] - 1 - j])) doubleValue];
  }
  jint tn = [((id<GeogebraCommonKernelEquationSolverInterface>) nil_chk(self->solver_)) polynomialRootsWithDoubleArray:tRoots withBoolean:NO];
  jint shift = 0;
  for (jint j = 1; j < tn; j++) {
    if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(IOSDoubleArray_Get(tRoots, j - shift - 1), IOSDoubleArray_Get(tRoots, j))) {
      shift++;
    }
    else {
      if (shift > 0) {
        *IOSDoubleArray_GetRef(tRoots, j - shift) = IOSDoubleArray_Get(tRoots, j);
      }
    }
  }
  for (jint j = 0; j < tn - shift; j++) {
    GeogebraCommonKernelGeosGeoLine *line = [new_GeogebraCommonKernelGeosGeoLine_initWithGeogebraCommonKernelConstruction_(self->cons_) autorelease];
    [line setCoordsWithDouble:a withDouble:b withDouble:-IOSDoubleArray_Get(tRoots, j)];
    [line setParentAlgorithmWithGeogebraCommonKernelAlgosAlgoElement:self];
    [((GeogebraCommonKernelGeosGeoList *) nil_chk(self->g_)) addWithGeogebraCommonKernelGeosGeoElement:line];
  }
}

void GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_compute(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly *self) {
  if (![((GeogebraCommonKernelImplicitGeoImplicitPoly *) nil_chk(self->ip_)) isDefined]) {
    [((GeogebraCommonKernelGeosGeoList *) nil_chk(self->g_)) setUndefined];
    return;
  }
  jint deg = [self->ip_ getDeg];
  IOSDoubleArray *roots = [IOSDoubleArray arrayWithLength:deg + 1];
  IOSObjectArray *coeff = [self->ip_ getCoeff];
  for (jint i = 0; i <= deg; i++) {
    if (((IOSObjectArray *) nil_chk(coeff))->size_ > i && ((IOSDoubleArray *) nil_chk(IOSObjectArray_Get(coeff, i)))->size_ > deg - i) *IOSDoubleArray_GetRef(roots, i) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(coeff, i)), deg - i);
    else *IOSDoubleArray_GetRef(roots, i) = 0;
  }
  JavaUtilArrayList *homogenPolys = [new_JavaUtilArrayList_init() autorelease];
  [homogenPolys addWithId:GeogebraCommonUtilCloner_cloneWithDoubleArray_(roots)];
  jint n = [((id<GeogebraCommonKernelEquationSolverInterface>) nil_chk(self->solver_)) polynomialRootsWithDoubleArray:roots withBoolean:NO];
  [((GeogebraCommonKernelGeosGeoList *) nil_chk(self->g_)) clear];
  jdouble last = JavaLangDouble_NaN;
  for (jint i = 0; i < n; i++) {
    if (!GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(last, IOSDoubleArray_Get(roots, i))) {
      jint r = JavaLangInteger_MAX_VALUE;
      JavaUtilArrayList *p = [new_JavaUtilArrayList_init() autorelease];
      IOSDoubleArray *divisor = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ -IOSDoubleArray_Get(roots, i), 1 } count:2];
      jdouble rk = JavaLangDouble_NaN;
      for (jint k = 0; k <= r; k++) {
        IOSDoubleArray *pk = nil;
        if ([homogenPolys size] > k) {
          pk = [homogenPolys getWithInt:k];
        }
        else {
          IOSDoubleArray *c = [IOSDoubleArray arrayWithLength:deg - k + 1];
          for (jint j = 0; j <= deg - k; j++) {
            if (((IOSObjectArray *) nil_chk(coeff))->size_ > j && ((IOSDoubleArray *) nil_chk(IOSObjectArray_Get(coeff, j)))->size_ > deg - j - k) *IOSDoubleArray_GetRef(c, j) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(coeff, j)), deg - j - k);
            else *IOSDoubleArray_GetRef(c, j) = 0;
          }
          pk = c;
          [homogenPolys addWithId:pk];
        }
        jdouble ev = GeogebraCommonKernelImplicitPolynomialUtils_evalWithDoubleArray_withDouble_(pk, IOSDoubleArray_Get(roots, i));
        rk = (((deg - k) & 1) == 0 ? ev : -ev);
        if (r == k) break;
        jint l = 0;
        if (GeogebraCommonKernelImplicitPolynomialUtils_getDegreeWithDoubleArray_(pk) < 0) {
          if (r == JavaLangInteger_MAX_VALUE) @throw [new_JavaLangError_initWithNSString_(@"Zero Polynomial") autorelease];
          l = r - k;
        }
        else {
          while (GeogebraCommonKernelKernel_isZeroWithDouble_(rk)) {
            if (r - k <= l) {
              rk = 0;
              break;
            }
            pk = GeogebraCommonKernelImplicitPolynomialUtils_polynomialDivisionWithDoubleArray_withDoubleArray_(pk, divisor);
            l++;
            ev = GeogebraCommonKernelImplicitPolynomialUtils_evalWithDoubleArray_withDouble_(pk, IOSDoubleArray_Get(roots, i));
            rk = (((deg - k + l) & 1) == 0 ? ev : -ev);
          }
        }
        if (r == JavaLangInteger_MAX_VALUE) {
          r = l;
        }
        if (r - k <= l) [p addWithId:JavaLangDouble_valueOfWithDouble_(rk)];
        else {
          [p clear];
          r = l + k;
          if (l > 0) [p addWithId:JavaLangDouble_valueOfWithDouble_(rk)];
        }
      }
      [p addWithId:JavaLangDouble_valueOfWithDouble_(rk)];
      GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_makeLinesWithJavaUtilArrayList_withDouble_withDouble_(self, p, 1, -IOSDoubleArray_Get(roots, i));
    }
    last = IOSDoubleArray_Get(roots, i);
  }
  IOSDoubleArray *pk = [homogenPolys getWithInt:0];
  if (GeogebraCommonKernelImplicitPolynomialUtils_getDegreeWithDoubleArray_(pk) < deg) {
    jint r = JavaLangInteger_MAX_VALUE;
    JavaUtilArrayList *p = [new_JavaUtilArrayList_init() autorelease];
    for (jint k = 0; k <= r; k++) {
      if ([homogenPolys size] > k) {
        pk = [homogenPolys getWithInt:k];
      }
      else {
        IOSDoubleArray *c = [IOSDoubleArray arrayWithLength:deg - k + 1];
        for (jint j = 0; j <= deg - k; j++) {
          if (((IOSObjectArray *) nil_chk(coeff))->size_ > j && ((IOSDoubleArray *) nil_chk(IOSObjectArray_Get(coeff, j)))->size_ > deg - j - k) *IOSDoubleArray_GetRef(c, j) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(coeff, j)), deg - j - k);
          else *IOSDoubleArray_GetRef(c, j) = 0;
        }
        pk = c;
      }
      if (r == k) {
        [p addWithId:JavaLangDouble_valueOfWithDouble_(IOSDoubleArray_Get(nil_chk(pk), deg - k))];
        break;
      }
      jint l = 0;
      jint d = GeogebraCommonKernelImplicitPolynomialUtils_getDegreeWithDoubleArray_(pk);
      if (d < deg - r) {
        l = r - k;
      }
      else {
        l = deg - k - d;
      }
      if (r == JavaLangInteger_MAX_VALUE) {
        r = l;
      }
      if (r - k <= l) [p addWithId:JavaLangDouble_valueOfWithDouble_(IOSDoubleArray_Get(nil_chk(pk), deg - k - l))];
      else {
        [p clear];
        [p addWithId:JavaLangDouble_valueOfWithDouble_(IOSDoubleArray_Get(nil_chk(pk), deg - k - l))];
        r = l + k;
      }
    }
    GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly_makeLinesWithJavaUtilArrayList_withDouble_withDouble_(self, p, 0, 1);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelImplicitAlgoAsymptoteImplicitPoly)
