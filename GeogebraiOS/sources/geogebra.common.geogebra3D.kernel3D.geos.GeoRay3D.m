//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/geogebra3D/kernel3D/geos/GeoRay3D.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/geogebra3D/kernel3D/algos/AlgoJoinPoints3D.h"
#include "geogebra/common/geogebra3D/kernel3D/algos/AlgoRayPointVector3D.h"
#include "geogebra/common/geogebra3D/kernel3D/geos/GeoCoordSys1D.h"
#include "geogebra/common/geogebra3D/kernel3D/geos/GeoLine3D.h"
#include "geogebra/common/geogebra3D/kernel3D/geos/GeoRay3D.h"
#include "geogebra/common/geogebra3D/kernel3D/geos/GeoVector3D.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Manager3DInterface.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/Transform.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/kernelND/GeoRayND.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "java/lang/StringBuilder.h"

@interface GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D () {
 @public
  jboolean allowOutlyingIntersections__;
  jboolean keepTypeOnGeometricTransform_;
}

@end

@implementation GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
              withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)O
              withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)Q {
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_withGeogebraCommonKernelKernelNDGeoPointND_(self, c, O, Q);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
              withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)O {
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_(self, c, O);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)construction {
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_(self, construction);
  return self;
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_RAY3D();
}

- (GeogebraCommonGeogebra3DKernel3DGeosGeoCoordSys1D *)createWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons {
  return [new_GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_(cons) autorelease];
}

- (jdouble)getMinParameter {
  return 0;
}

- (jboolean)isValidCoordWithDouble:(jdouble)x {
  return (x >= 0);
}

- (jboolean)isOnPathWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)p
                                              withDouble:(jdouble)eps {
  if (![super isOnPathWithGeogebraCommonKernelMatrixCoords:p withDouble:eps]) return NO;
  return [self respectLimitedPathWithGeogebraCommonKernelMatrixCoords:p withDouble:eps];
}

- (jboolean)respectLimitedPathWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)p
                                                        withDouble:(jdouble)eps {
  if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_([((GeogebraCommonKernelMatrixCoords *) nil_chk(p)) getW], 0, eps)) return NO;
  jdouble d = [((GeogebraCommonKernelMatrixCoords *) nil_chk([p subWithGeogebraCommonKernelMatrixCoords:[self getStartInhomCoords]])) dotproductWithGeogebraCommonKernelMatrixCoords:[self getDirectionInD3]];
  if (d < -eps) return NO;
  return YES;
}

- (jboolean)isLimitedPath {
  return YES;
}

- (jboolean)allowOutlyingIntersections {
  return allowOutlyingIntersections__;
}

- (void)setAllowOutlyingIntersectionsWithBoolean:(jboolean)flag {
  allowOutlyingIntersections__ = flag;
}

- (jboolean)keepsTypeOnGeometricTransform {
  return keepTypeOnGeometricTransform_;
}

- (void)setKeepTypeOnGeometricTransformWithBoolean:(jboolean)flag {
  keepTypeOnGeometricTransform_ = flag;
}

- (IOSObjectArray *)createTransformedObjectWithGeogebraCommonKernelTransform:(GeogebraCommonKernelTransform *)t
                                                                withNSString:(NSString *)label {
  GeogebraCommonKernelAlgosAlgoElement *algoParent = keepTypeOnGeometricTransform_ ? [self getParentAlgorithm] : nil;
  if ([algoParent isKindOfClass:[GeogebraCommonGeogebra3DKernel3DAlgosAlgoJoinPoints3D class]] && [((GeogebraCommonKernelTransform *) nil_chk(t)) isAffine]) {
    GeogebraCommonGeogebra3DKernel3DAlgosAlgoJoinPoints3D *algo = (GeogebraCommonGeogebra3DKernel3DAlgosAlgoJoinPoints3D *) check_class_cast(algoParent, [GeogebraCommonGeogebra3DKernel3DAlgosAlgoJoinPoints3D class]);
    IOSObjectArray *points = [IOSObjectArray arrayWithObjects:(id[]){ [algo getP], [algo getQ] } count:2 type:GeogebraCommonKernelKernelNDGeoPointND_class_()];
    points = [t transformPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:points];
    GeogebraCommonKernelGeosGeoElement *ray = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([((id<GeogebraCommonKernelManager3DInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getManager3D])) Ray3DWithNSString:label withGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(nil_chk(points), 0) withGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(points, 1)], [GeogebraCommonKernelGeosGeoElement class]);
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(ray)) setVisualStyleForTransformationsWithGeogebraCommonKernelGeosGeoElement:self];
    IOSObjectArray *geos = [IOSObjectArray arrayWithObjects:(id[]){ ray, (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, 0), [GeogebraCommonKernelGeosGeoElement class]), (GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(points, 1), [GeogebraCommonKernelGeosGeoElement class]) } count:3 type:GeogebraCommonKernelGeosGeoElement_class_()];
    return geos;
  }
  else {
    GeogebraCommonKernelGeosGeoElement *transformedLine = [((GeogebraCommonKernelTransform *) nil_chk(t)) getTransformedLineWithGeogebraCommonKernelKernelNDGeoLineND:self];
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(transformedLine)) setLabelWithNSString:label];
    IOSObjectArray *ret = [IOSObjectArray arrayWithObjects:(id[]){ transformedLine } count:1 type:GeogebraCommonKernelGeosGeoElement_class_()];
    return ret;
  }
}

- (jboolean)isAllEndpointsLabelsSet {
  return [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(startPoint_)) isLabelSet];
}

- (jboolean)isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)p
                                                                 withDouble:(jdouble)eps {
  if (allowOutlyingIntersections__) return [self isOnFullLineWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p)) getCoordsInD3] withDouble:eps];
  else return [self isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:p withDouble:eps];
}

- (GeogebraCommonKernelGeosGeoElement *)copyInternalWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons {
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *ray = [new_GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_(cons, (id<GeogebraCommonKernelKernelNDGeoPointND>) check_protocol_cast([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(startPoint_)) copyInternalWithGeogebraCommonKernelConstruction:cons], @protocol(GeogebraCommonKernelKernelNDGeoPointND))) autorelease];
  [ray setWithGeogebraCommonKernelGeosGeoElement:self];
  return ray;
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  [super setWithGeogebraCommonKernelGeosGeoElement:geo];
  if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoRay]) return;
  if (![geo isDefined]) [self setUndefined];
  id<GeogebraCommonKernelKernelNDGeoRayND> ray = (id<GeogebraCommonKernelKernelNDGeoRayND>) check_protocol_cast(geo, @protocol(GeogebraCommonKernelKernelNDGeoRayND));
  [self setKeepTypeOnGeometricTransformWithBoolean:[ray keepsTypeOnGeometricTransform]];
  [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(startPoint_)) setWithGeogebraCommonKernelKernelNDGeoPointND:[ray getStartPoint]];
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [super getXMLtagsWithJavaLangStringBuilder:sb];
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\t<outlyingIntersections val=\""];
  [sb appendWithBoolean:allowOutlyingIntersections__];
  [sb appendWithNSString:@"\"/>\n"];
  [sb appendWithNSString:@"\t<keepTypeOnTransform val=\""];
  [sb appendWithBoolean:keepTypeOnGeometricTransform_];
  [sb appendWithNSString:@"\"/>\n"];
}

- (jboolean)isGeoRay {
  return YES;
}

- (jboolean)respectLimitedPathWithDouble:(jdouble)parameter {
  return GeogebraCommonKernelKernel_isGreaterEqualWithDouble_withDouble_(parameter, 0);
}

- (void)getCoordsXMLWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
}

- (GeogebraCommonKernelGeosGeoElement *)copyFreeRay {
  id<GeogebraCommonKernelKernelNDGeoPointND> startPoint1 = (id<GeogebraCommonKernelKernelNDGeoPointND>) check_protocol_cast([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk([self getStartPoint])) copyInternalWithGeogebraCommonKernelConstruction:cons_], @protocol(GeogebraCommonKernelKernelNDGeoPointND));
  GeogebraCommonKernelMatrixCoords *direction = [self getDirectionInD3];
  GeogebraCommonGeogebra3DKernel3DGeosGeoVector3D *directionVec = [new_GeogebraCommonGeogebra3DKernel3DGeosGeoVector3D_initWithGeogebraCommonKernelConstruction_(cons_) autorelease];
  [directionVec setCoordsWithGeogebraCommonKernelMatrixCoords:direction];
  GeogebraCommonGeogebra3DKernel3DAlgosAlgoRayPointVector3D *algo = [new_GeogebraCommonGeogebra3DKernel3DAlgosAlgoRayPointVector3D_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelKernelNDGeoPointND_withGeogebraCommonKernelKernelNDGeoVectorND_(cons_, nil, startPoint1, directionVec) autorelease];
  return [algo getOutputWithInt:0];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelKernelNDGeoPointND:withGeogebraCommonKernelKernelNDGeoPointND:", "GeoRay3D", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelKernelNDGeoPointND:", "GeoRay3D", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:", "GeoRay3D", NULL, 0x1, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "createWithGeogebraCommonKernelConstruction:", "create", "Lgeogebra.common.geogebra3D.kernel3D.geos.GeoCoordSys1D;", 0x4, NULL, NULL },
    { "getMinParameter", NULL, "D", 0x1, NULL, NULL },
    { "isValidCoordWithDouble:", "isValidCoord", "Z", 0x1, NULL, NULL },
    { "isOnPathWithGeogebraCommonKernelMatrixCoords:withDouble:", "isOnPath", "Z", 0x1, NULL, NULL },
    { "respectLimitedPathWithGeogebraCommonKernelMatrixCoords:withDouble:", "respectLimitedPath", "Z", 0x1, NULL, NULL },
    { "isLimitedPath", NULL, "Z", 0x11, NULL, NULL },
    { "allowOutlyingIntersections", NULL, "Z", 0x1, NULL, NULL },
    { "setAllowOutlyingIntersectionsWithBoolean:", "setAllowOutlyingIntersections", "V", 0x1, NULL, NULL },
    { "keepsTypeOnGeometricTransform", NULL, "Z", 0x1, NULL, NULL },
    { "setKeepTypeOnGeometricTransformWithBoolean:", "setKeepTypeOnGeometricTransform", "V", 0x1, NULL, NULL },
    { "createTransformedObjectWithGeogebraCommonKernelTransform:withNSString:", "createTransformedObject", "[Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "isAllEndpointsLabelsSet", NULL, "Z", 0x1, NULL, NULL },
    { "isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:withDouble:", "isIntersectionPointIncident", "Z", 0x1, NULL, NULL },
    { "copyInternalWithGeogebraCommonKernelConstruction:", "copyInternal", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "isGeoRay", NULL, "Z", 0x1, NULL, NULL },
    { "respectLimitedPathWithDouble:", "respectLimitedPath", "Z", 0x1, NULL, NULL },
    { "getCoordsXMLWithJavaLangStringBuilder:", "getCoordsXML", "V", 0x14, NULL, NULL },
    { "copyFreeRay", NULL, "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "allowOutlyingIntersections__", "allowOutlyingIntersections", 0x2, "Z", NULL, NULL,  },
    { "keepTypeOnGeometricTransform_", NULL, 0x2, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D = { 2, "GeoRay3D", "geogebra.common.geogebra3D.kernel3D.geos", NULL, 0x1, 24, methods, 2, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D;
}

@end

void GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_withGeogebraCommonKernelKernelNDGeoPointND_(GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *self, GeogebraCommonKernelConstruction *c, id<GeogebraCommonKernelKernelNDGeoPointND> O, id<GeogebraCommonKernelKernelNDGeoPointND> Q) {
  GeogebraCommonGeogebra3DKernel3DGeosGeoLine3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_withGeogebraCommonKernelKernelNDGeoPointND_(self, c, O, Q);
  self->allowOutlyingIntersections__ = NO;
  self->keepTypeOnGeometricTransform_ = YES;
  [self setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:O];
}

GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *new_GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_withGeogebraCommonKernelKernelNDGeoPointND_(GeogebraCommonKernelConstruction *c, id<GeogebraCommonKernelKernelNDGeoPointND> O, id<GeogebraCommonKernelKernelNDGeoPointND> Q) {
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *self = [GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D alloc];
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_withGeogebraCommonKernelKernelNDGeoPointND_(self, c, O, Q);
  return self;
}

void GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_(GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *self, GeogebraCommonKernelConstruction *c, id<GeogebraCommonKernelKernelNDGeoPointND> O) {
  GeogebraCommonGeogebra3DKernel3DGeosGeoLine3D_initWithGeogebraCommonKernelConstruction_(self, c);
  self->allowOutlyingIntersections__ = NO;
  self->keepTypeOnGeometricTransform_ = YES;
  [self setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:O];
}

GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *new_GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_(GeogebraCommonKernelConstruction *c, id<GeogebraCommonKernelKernelNDGeoPointND> O) {
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *self = [GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D alloc];
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointND_(self, c, O);
  return self;
}

void GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_(GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *self, GeogebraCommonKernelConstruction *construction) {
  GeogebraCommonGeogebra3DKernel3DGeosGeoLine3D_initWithGeogebraCommonKernelConstruction_(self, construction);
  self->allowOutlyingIntersections__ = NO;
  self->keepTypeOnGeometricTransform_ = YES;
}

GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *new_GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *construction) {
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D *self = [GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D alloc];
  GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D_initWithGeogebraCommonKernelConstruction_(self, construction);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonGeogebra3DKernel3DGeosGeoRay3D)
