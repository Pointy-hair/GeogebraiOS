//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/algos/AlgoIntersectConics.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/euclidian/EuclidianConstants.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/EquationSolver.h"
#include "geogebra/common/kernel/EquationSolverInterface.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/LocusEquation.h"
#include "geogebra/common/kernel/PointPair.h"
#include "geogebra/common/kernel/PointPairList.h"
#include "geogebra/common/kernel/SystemOfEquationsSolver.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoIntersect.h"
#include "geogebra/common/kernel/algos/AlgoIntersectConics.h"
#include "geogebra/common/kernel/algos/AlgoIntersectLineConic.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/algos/EquationElementInterface.h"
#include "geogebra/common/kernel/algos/EquationScopeInterface.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoConic.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/kernelND/AlgoIntersectND.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/prover/NoSymbolicParametersException.h"
#include "geogebra/common/kernel/prover/polynomial/Polynomial.h"
#include "geogebra/common/kernel/prover/polynomial/Variable.h"
#include "geogebra/common/main/App.h"
#include "java/lang/Double.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/Arrays.h"
#include "java/util/HashMap.h"
#include "java/util/Iterator.h"
#include "java/util/Set.h"

@interface GeogebraCommonKernelAlgosAlgoIntersectConics () {
 @public
  GeogebraCommonKernelGeosGeoConic *A_, *B_;
  IOSObjectArray *P_, *D_, *Q_;
  JavaUtilHashMap *botanaPolynomials_;
  JavaUtilHashMap *botanaVars_;
  GeogebraCommonKernelGeosGeoConic *degConic_;
  GeogebraCommonKernelGeosGeoLine *tempLine_;
  IOSIntArray *age_;
  IOSIntArray *permutation_;
  IOSObjectArray *distTable_;
  IOSBooleanArray *isQonPath_;
  IOSBooleanArray *isPalive_;
  jboolean firstIntersection_;
  jboolean isLimitedPathSituation_;
  jboolean isPermutationNeeded_;
  jboolean possibleSpecialCase_;
  jint specialCasePointOnCircleIndex_;
  GeogebraCommonKernelPointPairList *pointList_;
  id<GeogebraCommonKernelEquationSolverInterface> eqnSolver_;
  GeogebraCommonKernelSystemOfEquationsSolver *sysSolver_;
}

- (void)addIncidence;

- (void)matchExistingIntersections;

- (jboolean)handleSpecialCase;

+ (id<GeogebraCommonKernelKernelNDGeoPointND>)getPointFrom1on2WithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)A
                                                              withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)B;

- (void)computeNonContinous;

- (void)computeContinuous;

- (void)handleLimitedPaths;

- (void)updateQonPath;

- (jboolean)pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)Pt;

- (jboolean)isSingularitySituation;

+ (void)moveDefinedPointsToFrontWithGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points;

+ (void)intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)conic
                               withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)degConic
                          withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points
                                                         withDouble:(jdouble)eps;

+ (jboolean)testPointsWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)A
                      withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)B
                 withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)P
                                                withDouble:(jdouble)eps;

+ (jdouble)absCrossProductWithDouble:(jdouble)a1
                          withDouble:(jdouble)a2
                          withDouble:(jdouble)b1
                          withDouble:(jdouble)b2;

- (jboolean)calcIntersectionPointsWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)A
                                  withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)B
                             withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points
                                                            withDouble:(jdouble)eps;

- (jboolean)intersectConicsWithEqualSubmatrixSWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c1
                                              withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c2
                                         withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points
                                                                        withDouble:(jdouble)eps;

+ (void)normalizeArrayWithDoubleArray:(IOSDoubleArray *)array;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, A_, GeogebraCommonKernelGeosGeoConic *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, B_, GeogebraCommonKernelGeosGeoConic *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, P_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, D_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, Q_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, botanaPolynomials_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, botanaVars_, JavaUtilHashMap *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, degConic_, GeogebraCommonKernelGeosGeoConic *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, tempLine_, GeogebraCommonKernelGeosGeoLine *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, age_, IOSIntArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, permutation_, IOSIntArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, distTable_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, isQonPath_, IOSBooleanArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, isPalive_, IOSBooleanArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, pointList_, GeogebraCommonKernelPointPairList *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, eqnSolver_, id<GeogebraCommonKernelEquationSolverInterface>)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIntersectConics, sysSolver_, GeogebraCommonKernelSystemOfEquationsSolver *)

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_addIncidence(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_initForNearToRelationship(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_compute(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_matchExistingIntersections(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_handleSpecialCase(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static id<GeogebraCommonKernelKernelNDGeoPointND> GeogebraCommonKernelAlgosAlgoIntersectConics_getPointFrom1on2WithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(GeogebraCommonKernelGeosGeoConic *A, GeogebraCommonKernelGeosGeoConic *B);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_computeNonContinous(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_computeContinuous(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_handleLimitedPaths(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_updateQonPath(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelGeosGeoPoint *Pt);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_isSingularitySituation(GeogebraCommonKernelAlgosAlgoIntersectConics *self);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelGeosGeoConic *conic1, GeogebraCommonKernelGeosGeoConic *conic2, IOSObjectArray *points);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_moveDefinedPointsToFrontWithGeogebraCommonKernelGeosGeoPointArray_(IOSObjectArray *points);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelGeosGeoConic *conic, GeogebraCommonKernelGeosGeoConic *degConic, IOSObjectArray *points, jdouble eps);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelGeosGeoConic *A, GeogebraCommonKernelGeosGeoConic *B, IOSObjectArray *P, jdouble eps);

__attribute__((unused)) static jdouble GeogebraCommonKernelAlgosAlgoIntersectConics_absCrossProductWithDouble_withDouble_withDouble_withDouble_(jdouble a1, jdouble a2, jdouble b1, jdouble b2);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_calcIntersectionPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelGeosGeoConic *A, GeogebraCommonKernelGeosGeoConic *B, IOSObjectArray *points, jdouble eps);

__attribute__((unused)) static jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithEqualSubmatrixSWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelGeosGeoConic *c1, GeogebraCommonKernelGeosGeoConic *c2, IOSObjectArray *points, jdouble eps);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIntersectConics_normalizeArrayWithDoubleArray_(IOSDoubleArray *array);

@implementation GeogebraCommonKernelAlgosAlgoIntersectConics

- (GeogebraCommonKernelCommandsCommandsEnum *)getClassName {
  return GeogebraCommonKernelCommandsCommandsEnum_get_Intersect();
}

- (jint)getRelatedModeID {
  return GeogebraCommonEuclidianEuclidianConstants_MODE_INTERSECT;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_(self, cons);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                    withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)A
                    withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)B {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(self, cons, A, B);
  return self;
}

- (void)addIncidence {
  GeogebraCommonKernelAlgosAlgoIntersectConics_addIncidence(self);
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_setAndConsume_input_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoElement_class_()]);
  IOSObjectArray_Set(input_, 0, A_);
  IOSObjectArray_Set(input_, 1, B_);
  [super setOutputWithGeogebraCommonKernelGeosGeoElementArray:P_];
  [self noUndefinedPointsInAlgebraView];
  [self setDependencies];
}

- (IOSObjectArray *)getIntersectionPoints {
  return P_;
}

- (GeogebraCommonKernelGeosGeoConic *)getA {
  return A_;
}

- (GeogebraCommonKernelGeosGeoConic *)getB {
  return B_;
}

- (IOSObjectArray *)getLastDefinedIntersectionPoints {
  return D_;
}

- (jboolean)isNearToAlgorithm {
  return YES;
}

- (void)initForNearToRelationship {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initForNearToRelationship(self);
}

- (void)compute {
  GeogebraCommonKernelAlgosAlgoIntersectConics_compute(self);
}

- (void)matchExistingIntersections {
  GeogebraCommonKernelAlgosAlgoIntersectConics_matchExistingIntersections(self);
}

- (jboolean)handleSpecialCase {
  return GeogebraCommonKernelAlgosAlgoIntersectConics_handleSpecialCase(self);
}

+ (id<GeogebraCommonKernelKernelNDGeoPointND>)getPointFrom1on2WithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)A
                                                              withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)B {
  return GeogebraCommonKernelAlgosAlgoIntersectConics_getPointFrom1on2WithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(A, B);
}

- (void)computeNonContinous {
  GeogebraCommonKernelAlgosAlgoIntersectConics_computeNonContinous(self);
}

- (void)computeContinuous {
  GeogebraCommonKernelAlgosAlgoIntersectConics_computeContinuous(self);
}

- (void)handleLimitedPaths {
  GeogebraCommonKernelAlgosAlgoIntersectConics_handleLimitedPaths(self);
}

- (void)updateQonPath {
  GeogebraCommonKernelAlgosAlgoIntersectConics_updateQonPath(self);
}

- (jboolean)pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)Pt {
  return GeogebraCommonKernelAlgosAlgoIntersectConics_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, Pt);
}

- (jboolean)isSingularitySituation {
  return GeogebraCommonKernelAlgosAlgoIntersectConics_isSingularitySituation(self);
}

- (void)intersectConicsWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)conic1
                       withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)conic2
                  withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points {
  GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(self, conic1, conic2, points);
}

+ (void)moveDefinedPointsToFrontWithGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points {
  GeogebraCommonKernelAlgosAlgoIntersectConics_moveDefinedPointsToFrontWithGeogebraCommonKernelGeosGeoPointArray_(points);
}

+ (void)intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)conic
                               withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)degConic
                          withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points
                                                         withDouble:(jdouble)eps {
  GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(conic, degConic, points, eps);
}

+ (jboolean)testPointsWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)A
                      withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)B
                 withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)P
                                                withDouble:(jdouble)eps {
  return GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(A, B, P, eps);
}

+ (jdouble)absCrossProductWithDouble:(jdouble)a1
                          withDouble:(jdouble)a2
                          withDouble:(jdouble)b1
                          withDouble:(jdouble)b2 {
  return GeogebraCommonKernelAlgosAlgoIntersectConics_absCrossProductWithDouble_withDouble_withDouble_withDouble_(a1, a2, b1, b2);
}

- (jboolean)calcIntersectionPointsWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)A
                                  withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)B
                             withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points
                                                            withDouble:(jdouble)eps {
  return GeogebraCommonKernelAlgosAlgoIntersectConics_calcIntersectionPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self, A, B, points, eps);
}

- (jboolean)intersectConicsWithEqualSubmatrixSWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c1
                                              withGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c2
                                         withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points
                                                                        withDouble:(jdouble)eps {
  return GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithEqualSubmatrixSWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self, c1, c2, points, eps);
}

+ (void)normalizeArrayWithDoubleArray:(IOSDoubleArray *)array {
  GeogebraCommonKernelAlgosAlgoIntersectConics_normalizeArrayWithDoubleArray_(array);
}

+ (void)distanceTableWithGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)D
                                                  withIntArray:(IOSIntArray *)age
                     withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)Q
                                              withDoubleArray2:(IOSObjectArray *)table {
  GeogebraCommonKernelAlgosAlgoIntersectConics_distanceTableWithGeogebraCommonKernelGeosGeoPointArray_withIntArray_withGeogebraCommonKernelGeosGeoPointArray_withDoubleArray2_(D, age, Q, table);
}

+ (void)setNearToWithGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)P
                                          withBooleanArray:(IOSBooleanArray *)isPalive
                 withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)Q
                                          withBooleanArray:(IOSBooleanArray *)isQonPath
                                          withDoubleArray2:(IOSObjectArray *)distTable
                     withGeogebraCommonKernelPointPairList:(GeogebraCommonKernelPointPairList *)pointList
                                              withIntArray:(IOSIntArray *)permutation
                                               withBoolean:(jboolean)needStrict
                                                withDouble:(jdouble)eps {
  GeogebraCommonKernelAlgosAlgoIntersectConics_setNearToWithGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withDoubleArray2_withGeogebraCommonKernelPointPairList_withIntArray_withBoolean_withDouble_(P, isPalive, Q, isQonPath, distTable, pointList, permutation, needStrict, eps);
}

+ (void)setNearToWithGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)P
                                          withBooleanArray:(IOSBooleanArray *)isPalive
                 withGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)Q
                                          withBooleanArray:(IOSBooleanArray *)isQonPath
                                          withDoubleArray2:(IOSObjectArray *)distTable
                     withGeogebraCommonKernelPointPairList:(GeogebraCommonKernelPointPairList *)pointList
                                              withIntArray:(IOSIntArray *)permutation {
  GeogebraCommonKernelAlgosAlgoIntersectConics_setNearToWithGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withDoubleArray2_withGeogebraCommonKernelPointPairList_withIntArray_(P, isPalive, Q, isQonPath, distTable, pointList, permutation);
}

- (IOSObjectArray *)getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  return [((JavaUtilHashMap *) nil_chk(botanaVars_)) getWithId:geo];
}

- (IOSObjectArray *)getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (botanaPolynomials_ != nil) {
    IOSObjectArray *ret = [botanaPolynomials_ getWithId:geo];
    if (ret != nil) return ret;
  }
  if (A_ != nil && B_ != nil && [A_ isCircle] && [B_ isCircle]) {
    IOSObjectArray *botanaVarsThis = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
    if (botanaVars_ == nil) {
      GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_botanaVars_(self, new_JavaUtilHashMap_init());
    }
    if ([((JavaUtilHashMap *) nil_chk(botanaVars_)) containsKeyWithId:geo]) {
      botanaVarsThis = [botanaVars_ getWithId:geo];
    }
    else {
      botanaVarsThis = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
      IOSObjectArray_SetAndConsume(botanaVarsThis, 0, new_GeogebraCommonKernelProverPolynomialVariable_init());
      IOSObjectArray_SetAndConsume(botanaVarsThis, 1, new_GeogebraCommonKernelProverPolynomialVariable_init());
      [botanaVars_ putWithId:geo withId:botanaVarsThis];
    }
    IOSObjectArray *botanaPolynomialsThis = nil;
    IOSObjectArray *botanaVarsOther = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
    id<JavaUtilIterator> it = [((id<JavaUtilSet>) nil_chk([botanaVars_ keySet])) iterator];
    jboolean found = NO;
    while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
      GeogebraCommonKernelGeosGeoElement *otherGeo = [it next];
      if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(otherGeo)) isEqual:geo]) {
        botanaPolynomialsThis = [IOSObjectArray arrayWithLength:3 type:GeogebraCommonKernelProverPolynomialPolynomial_class_()];
        botanaVarsOther = [botanaVars_ getWithId:otherGeo];
        IOSObjectArray_Set(botanaPolynomialsThis, 2, [((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(GeogebraCommonKernelProverPolynomialPolynomial_sqrDistanceWithGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_(IOSObjectArray_Get(nil_chk(botanaVarsThis), 0), IOSObjectArray_Get(botanaVarsThis, 1), IOSObjectArray_Get(nil_chk(botanaVarsOther), 0), IOSObjectArray_Get(botanaVarsOther, 1)))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:[new_GeogebraCommonKernelProverPolynomialPolynomial_initWithGeogebraCommonKernelProverPolynomialVariable_([new_GeogebraCommonKernelProverPolynomialVariable_init() autorelease]) autorelease]]))) subtractWithGeogebraCommonKernelProverPolynomialPolynomial:[new_GeogebraCommonKernelProverPolynomialPolynomial_initWithInt_(1) autorelease]]);
        found = YES;
      }
    }
    if (!found) {
      botanaPolynomialsThis = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialPolynomial_class_()];
    }
    IOSObjectArray *vA = [A_ getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
    IOSObjectArray *vB = [B_ getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:geo];
    IOSObjectArray_Set(nil_chk(botanaPolynomialsThis), 0, GeogebraCommonKernelProverPolynomialPolynomial_equidistantWithGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_(IOSObjectArray_Get(nil_chk(vA), 2), IOSObjectArray_Get(vA, 3), IOSObjectArray_Get(vA, 0), IOSObjectArray_Get(vA, 1), IOSObjectArray_Get(nil_chk(botanaVarsThis), 0), IOSObjectArray_Get(botanaVarsThis, 1)));
    IOSObjectArray_Set(botanaPolynomialsThis, 1, GeogebraCommonKernelProverPolynomialPolynomial_equidistantWithGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_(IOSObjectArray_Get(nil_chk(vB), 2), IOSObjectArray_Get(vB, 3), IOSObjectArray_Get(vB, 0), IOSObjectArray_Get(vB, 1), IOSObjectArray_Get(botanaVarsThis, 0), IOSObjectArray_Get(botanaVarsThis, 1)));
    if (botanaPolynomials_ == nil) {
      GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_botanaPolynomials_(self, new_JavaUtilHashMap_init());
    }
    [((JavaUtilHashMap *) nil_chk(botanaPolynomials_)) putWithId:geo withId:botanaPolynomialsThis];
    return botanaPolynomialsThis;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (jboolean)isLocusEquable {
  return YES;
}

- (id<GeogebraCommonKernelAlgosEquationElementInterface>)buildEquationElementForGeoWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo
                                                                      withGeogebraCommonKernelAlgosEquationScopeInterface:(id<GeogebraCommonKernelAlgosEquationScopeInterface>)scope {
  return GeogebraCommonKernelLocusEquation_eqnIntersectConicsWithGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelAlgosAlgoElement_withGeogebraCommonKernelAlgosEquationScopeInterface_(geo, self, scope);
}

- (void)dealloc {
  RELEASE_(A_);
  RELEASE_(B_);
  RELEASE_(P_);
  RELEASE_(D_);
  RELEASE_(Q_);
  RELEASE_(preexistPoints_);
  RELEASE_(newPoints_);
  RELEASE_(botanaPolynomials_);
  RELEASE_(botanaVars_);
  RELEASE_(degConic_);
  RELEASE_(tempLine_);
  RELEASE_(age_);
  RELEASE_(permutation_);
  RELEASE_(distTable_);
  RELEASE_(isQonPath_);
  RELEASE_(isPalive_);
  RELEASE_(pointList_);
  RELEASE_(eqnSolver_);
  RELEASE_(sysSolver_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getClassName", NULL, "Lgeogebra.common.kernel.commands.Commands;", 0x1, NULL, NULL },
    { "getRelatedModeID", NULL, "I", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:", "AlgoIntersectConics", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoConic:", "AlgoIntersectConics", NULL, 0x1, NULL, NULL },
    { "addIncidence", NULL, "V", 0x2, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x1, NULL, NULL },
    { "getIntersectionPoints", NULL, "[Lgeogebra.common.kernel.geos.GeoPoint;", 0x1, NULL, NULL },
    { "getA", NULL, "Lgeogebra.common.kernel.geos.GeoConic;", 0x1, NULL, NULL },
    { "getB", NULL, "Lgeogebra.common.kernel.geos.GeoConic;", 0x1, NULL, NULL },
    { "getLastDefinedIntersectionPoints", NULL, "[Lgeogebra.common.kernel.geos.GeoPoint;", 0x4, NULL, NULL },
    { "isNearToAlgorithm", NULL, "Z", 0x1, NULL, NULL },
    { "initForNearToRelationship", NULL, "V", 0x11, NULL, NULL },
    { "compute", NULL, "V", 0x11, NULL, NULL },
    { "matchExistingIntersections", NULL, "V", 0x2, NULL, NULL },
    { "handleSpecialCase", NULL, "Z", 0x2, NULL, NULL },
    { "getPointFrom1on2WithGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoConic:", "getPointFrom1on2", "Lgeogebra.common.kernel.kernelND.GeoPointND;", 0xa, NULL, NULL },
    { "computeNonContinous", NULL, "V", 0x2, NULL, NULL },
    { "computeContinuous", NULL, "V", 0x12, NULL, NULL },
    { "handleLimitedPaths", NULL, "V", 0x2, NULL, NULL },
    { "updateQonPath", NULL, "V", 0x2, NULL, NULL },
    { "pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint:", "pointLiesOnBothPaths", "Z", 0x2, NULL, NULL },
    { "isSingularitySituation", NULL, "Z", 0x2, NULL, NULL },
    { "intersectConicsWithGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoPointArray:", "intersectConics", "V", 0x11, NULL, NULL },
    { "moveDefinedPointsToFrontWithGeogebraCommonKernelGeosGeoPointArray:", "moveDefinedPointsToFront", "V", 0xa, NULL, NULL },
    { "intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoPointArray:withDouble:", "intersectWithDegenerate", "V", 0x1a, NULL, NULL },
    { "testPointsWithGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoPointArray:withDouble:", "testPoints", "Z", 0x1a, NULL, NULL },
    { "absCrossProductWithDouble:withDouble:withDouble:withDouble:", "absCrossProduct", "D", 0x1a, NULL, NULL },
    { "calcIntersectionPointsWithGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoPointArray:withDouble:", "calcIntersectionPoints", "Z", 0x12, NULL, NULL },
    { "intersectConicsWithEqualSubmatrixSWithGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoConic:withGeogebraCommonKernelGeosGeoPointArray:withDouble:", "intersectConicsWithEqualSubmatrixS", "Z", 0x2, NULL, NULL },
    { "normalizeArrayWithDoubleArray:", "normalizeArray", "V", 0xa, NULL, NULL },
    { "distanceTableWithGeogebraCommonKernelGeosGeoPointArray:withIntArray:withGeogebraCommonKernelGeosGeoPointArray:withDoubleArray2:", "distanceTable", "V", 0x19, NULL, NULL },
    { "setNearToWithGeogebraCommonKernelGeosGeoPointArray:withBooleanArray:withGeogebraCommonKernelGeosGeoPointArray:withBooleanArray:withDoubleArray2:withGeogebraCommonKernelPointPairList:withIntArray:withBoolean:withDouble:", "setNearTo", "V", 0x18, NULL, NULL },
    { "setNearToWithGeogebraCommonKernelGeosGeoPointArray:withBooleanArray:withGeogebraCommonKernelGeosGeoPointArray:withBooleanArray:withDoubleArray2:withGeogebraCommonKernelPointPairList:withIntArray:", "setNearTo", "V", 0x18, NULL, NULL },
    { "getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:", "getBotanaVars", "[Lgeogebra.common.kernel.prover.polynomial.Variable;", 0x1, NULL, NULL },
    { "getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:", "getBotanaPolynomials", "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "isLocusEquable", NULL, "Z", 0x1, NULL, NULL },
    { "buildEquationElementForGeoWithGeogebraCommonKernelGeosGeoElement:withGeogebraCommonKernelAlgosEquationScopeInterface:", "buildEquationElementForGeo", "Lgeogebra.common.kernel.algos.EquationElementInterface;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "DIST_MEMORY_SIZE_", NULL, 0x18, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelAlgosAlgoIntersectConics_DIST_MEMORY_SIZE },
    { "A_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoConic;", NULL, NULL,  },
    { "B_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoConic;", NULL, NULL,  },
    { "P_", NULL, 0x2, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "D_", NULL, 0x2, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "Q_", NULL, 0x2, "[Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "preexistPoints_", NULL, 0x0, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/kernelND/GeoPointND;>;",  },
    { "newPoints_", NULL, 0x0, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/geos/GeoPoint;>;",  },
    { "botanaPolynomials_", NULL, 0x2, "Ljava.util.HashMap;", NULL, "Ljava/util/HashMap<Lgeogebra/common/kernel/geos/GeoElement;L[Lgeogebra/common/kernel/prover/polynomial/Polynomial;;>;",  },
    { "botanaVars_", NULL, 0x2, "Ljava.util.HashMap;", NULL, "Ljava/util/HashMap<Lgeogebra/common/kernel/geos/GeoElement;L[Lgeogebra/common/kernel/prover/polynomial/Variable;;>;",  },
    { "degConic_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoConic;", NULL, NULL,  },
    { "tempLine_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoLine;", NULL, NULL,  },
    { "age_", NULL, 0x2, "[I", NULL, NULL,  },
    { "permutation_", NULL, 0x2, "[I", NULL, NULL,  },
    { "distTable_", NULL, 0x2, "[[D", NULL, NULL,  },
    { "isQonPath_", NULL, 0x2, "[Z", NULL, NULL,  },
    { "isPalive_", NULL, 0x2, "[Z", NULL, NULL,  },
    { "firstIntersection_", NULL, 0x2, "Z", NULL, NULL,  },
    { "isLimitedPathSituation_", NULL, 0x2, "Z", NULL, NULL,  },
    { "isPermutationNeeded_", NULL, 0x2, "Z", NULL, NULL,  },
    { "possibleSpecialCase_", NULL, 0x2, "Z", NULL, NULL,  },
    { "specialCasePointOnCircleIndex_", NULL, 0x2, "I", NULL, NULL,  },
    { "pointList_", NULL, 0x2, "Lgeogebra.common.kernel.PointPairList;", NULL, NULL,  },
    { "eqnSolver_", NULL, 0x2, "Lgeogebra.common.kernel.EquationSolverInterface;", NULL, NULL,  },
    { "sysSolver_", NULL, 0x2, "Lgeogebra.common.kernel.SystemOfEquationsSolver;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelAlgosAlgoIntersectConics = { 2, "AlgoIntersectConics", "geogebra.common.kernel.algos", NULL, 0x1, 37, methods, 25, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelAlgosAlgoIntersectConics;
}

@end

void GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelConstruction *cons) {
  GeogebraCommonKernelAlgosAlgoIntersect_initWithGeogebraCommonKernelConstruction_(self, cons);
  self->firstIntersection_ = YES;
  self->isPermutationNeeded_ = YES;
  self->possibleSpecialCase_ = NO;
  self->specialCasePointOnCircleIndex_ = 0;
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_pointList_(self, new_GeogebraCommonKernelPointPairList_init());
  GeogebraCommonKernelAlgosAlgoIntersectConics_set_eqnSolver_(self, [((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonKernelConstruction *) nil_chk(cons)) getKernel])) getEquationSolver]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_set_sysSolver_(self, [((GeogebraCommonKernelKernel *) nil_chk([cons getKernel])) getSystemOfEquationsSolverWithGeogebraCommonKernelEquationSolverInterface:self->eqnSolver_]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_degConic_(self, new_GeogebraCommonKernelGeosGeoConic_initWithGeogebraCommonKernelConstruction_(cons));
}

GeogebraCommonKernelAlgosAlgoIntersectConics *new_GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *cons) {
  GeogebraCommonKernelAlgosAlgoIntersectConics *self = [GeogebraCommonKernelAlgosAlgoIntersectConics alloc];
  GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_(self, cons);
  return self;
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelConstruction *cons, GeogebraCommonKernelGeosGeoConic *A, GeogebraCommonKernelGeosGeoConic *B) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_(self, cons);
  GeogebraCommonKernelAlgosAlgoIntersectConics_set_A_(self, A);
  GeogebraCommonKernelAlgosAlgoIntersectConics_set_B_(self, B);
  self->isLimitedPathSituation_ = ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(A)) isLimitedPath] || [((GeogebraCommonKernelGeosGeoConic *) nil_chk(B)) isLimitedPath]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_P_(self, [IOSObjectArray newArrayWithLength:4 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_D_(self, [IOSObjectArray newArrayWithLength:4 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_Q_(self, [IOSObjectArray newArrayWithLength:4 type:GeogebraCommonKernelGeosGeoPoint_class_()]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_preexistPoints_(self, new_JavaUtilArrayList_init());
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_newPoints_(self, new_JavaUtilArrayList_init());
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_isQonPath_(self, [IOSBooleanArray newArrayWithLength:4]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_isPalive_(self, [IOSBooleanArray newArrayWithLength:4]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_age_(self, [IOSIntArray newArrayWithLength:4]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_permutation_(self, [IOSIntArray newArrayWithInts:(jint[]){ 0, 1, 2, 3 } count:4]);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_distTable_(self, [IOSDoubleArray newArrayWithDimensions:2 lengths:(jint[]){ 4, 4 }]);
  for (jint i = 0; i < 4; i++) {
    IOSObjectArray_SetAndConsume(self->P_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons));
    IOSObjectArray_SetAndConsume(self->Q_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons));
    IOSObjectArray_SetAndConsume(self->D_, i, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons));
  }
  self->possibleSpecialCase_ = GeogebraCommonKernelAlgosAlgoIntersectConics_handleSpecialCase(self);
  [self setInputOutput];
  JavaUtilArrayList *list1 = [A getPointsOnConic];
  JavaUtilArrayList *list2 = [((GeogebraCommonKernelGeosGeoConic *) nil_chk(B)) getPointsOnConic];
  if (list1 != nil && list2 != nil) {
    for (jint i = 0; i < [list1 size]; i++) {
      if ([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk([list1 getWithInt:i])) getIncidenceList] != nil && [((JavaUtilArrayList *) nil_chk([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk([list1 getWithInt:i])) getIncidenceList])) containsWithId:B]) [self->preexistPoints_ addWithId:[list1 getWithInt:i]];
    }
  }
  GeogebraCommonKernelAlgosAlgoIntersectConics_initForNearToRelationship(self);
  GeogebraCommonKernelAlgosAlgoIntersectConics_compute(self);
  GeogebraCommonKernelAlgosAlgoIntersectConics_addIncidence(self);
}

GeogebraCommonKernelAlgosAlgoIntersectConics *new_GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(GeogebraCommonKernelConstruction *cons, GeogebraCommonKernelGeosGeoConic *A, GeogebraCommonKernelGeosGeoConic *B) {
  GeogebraCommonKernelAlgosAlgoIntersectConics *self = [GeogebraCommonKernelAlgosAlgoIntersectConics alloc];
  GeogebraCommonKernelAlgosAlgoIntersectConics_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(self, cons, A, B);
  return self;
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_addIncidence(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  for (jint i = 0; i < 4; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), i))) addIncidenceWithGeogebraCommonKernelGeosGeoElement:self->A_ withBoolean:NO];
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) addIncidenceWithGeogebraCommonKernelGeosGeoElement:self->B_ withBoolean:NO];
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_initForNearToRelationship(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  self->isPermutationNeeded_ = YES;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->P_))->size_; i++) {
    *IOSIntArray_GetRef(nil_chk(self->age_), i) = 0;
    *IOSBooleanArray_GetRef(nil_chk(self->isQonPath_), i) = YES;
    *IOSBooleanArray_GetRef(nil_chk(self->isPalive_), i) = NO;
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_compute(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  if (IOSIntArray_Get(nil_chk(self->permutation_), 3) == 0) {
    GeogebraCommonMainApp_errorWithNSString_(@"error in AlgoIntersectConics");
  }
  if (!([((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->A_)) isDefined] && [((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->B_)) isDefined])) {
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->P_))->size_; i++) {
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setUndefined];
    }
    return;
  }
  if (self->possibleSpecialCase_) {
    if (GeogebraCommonKernelAlgosAlgoIntersectConics_handleSpecialCase(self)) return;
  }
  jboolean continuous = self->isPermutationNeeded_ || [((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) isContinuous];
  if (continuous) {
    GeogebraCommonKernelAlgosAlgoIntersectConics_computeContinuous(self);
  }
  else {
    GeogebraCommonKernelAlgosAlgoIntersectConics_computeNonContinous(self);
  }
  GeogebraCommonKernelAlgosAlgoIntersectConics_matchExistingIntersections(self);
  [self avoidDoubleTangentPoint];
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_matchExistingIntersections(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  if ([((JavaUtilArrayList *) nil_chk(self->preexistPoints_)) size] == 0) return;
  [((JavaUtilArrayList *) nil_chk(self->newPoints_)) clear];
  for (jint i = 0; i < 4; i++) {
    if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), i))) isDefined]) [self->newPoints_ addWithId:IOSObjectArray_Get(self->P_, i)];
  }
  if ([self->newPoints_ size] == 0) return;
  jdouble gap = JavaLangDouble_POSITIVE_INFINITY;
  jdouble minDistance = JavaLangDouble_POSITIVE_INFINITY;
  jdouble d = JavaLangDouble_POSITIVE_INFINITY;
  jint closestPointIndex = 0;
  for (jint i = 0; i < 4; i++) {
    for (jint j = i + 1; j < 4; j++) {
      if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), i))) isDefined] && [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, j))) isDefined]) {
        d = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) distanceWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(self->P_, j)];
        if (d < gap) gap = d;
      }
    }
  }
  for (jint i = 0; i < 4; i++) {
    if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), i))) isDefined]) {
      minDistance = JavaLangDouble_POSITIVE_INFINITY;
      for (jint j = 0; j < [self->preexistPoints_ size]; j++) {
        d = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk([self->preexistPoints_ getWithInt:j])) distanceWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(self->P_, i)];
        if (d < minDistance) {
          minDistance = d;
          closestPointIndex = j;
        }
      }
      if (GeogebraCommonKernelKernel_isGreaterEqualWithDouble_withDouble_(gap / 2, minDistance)) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setCoordsFromPointWithGeogebraCommonKernelKernelNDGeoPointND:[self->preexistPoints_ getWithInt:closestPointIndex]];
    }
  }
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_handleSpecialCase(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  if (((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->A_))->type_ != GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE || ((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->B_))->type_ != GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE) return NO;
  id<GeogebraCommonKernelKernelNDGeoPointND> pointOnConic = GeogebraCommonKernelAlgosAlgoIntersectConics_getPointFrom1on2WithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(self->A_, self->B_);
  if (pointOnConic == nil) pointOnConic = GeogebraCommonKernelAlgosAlgoIntersectConics_getPointFrom1on2WithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(self->B_, self->A_);
  if (pointOnConic == nil) return NO;
  GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithEqualSubmatrixSWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self, self->A_, self->B_, self->Q_, GeogebraCommonKernelKernel_STANDARD_PRECISION);
  jint firstIndex = self->specialCasePointOnCircleIndex_;
  jint secondIndex = (firstIndex + 1) % 2;
  if (self->firstIntersection_ && [self didSetIntersectionPointWithInt:firstIndex]) {
    if (![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), firstIndex))) isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *) check_class_cast(pointOnConic, [GeogebraCommonKernelGeosGeoElement class])]) {
      jint temp = firstIndex;
      firstIndex = secondIndex;
      secondIndex = temp;
      self->specialCasePointOnCircleIndex_ = firstIndex;
    }
    self->firstIntersection_ = NO;
  }
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), firstIndex))) setCoordsFromPointWithGeogebraCommonKernelKernelNDGeoPointND:pointOnConic];
  jboolean didSetP1 = NO;
  for (jint i = 0; i < 2; i++) {
    if (![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->Q_), i))) isEqualWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(self->P_, firstIndex)]) {
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, secondIndex))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->Q_, i)];
      didSetP1 = YES;
      break;
    }
  }
  if (!didSetP1) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, secondIndex))) setCoordsFromPointWithGeogebraCommonKernelKernelNDGeoPointND:pointOnConic];
  }
  if (self->isLimitedPathSituation_) {
    for (jint i = 0; i < 2; i++) {
      if (!GeogebraCommonKernelAlgosAlgoIntersectConics_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->P_, i))) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setUndefined];
    }
  }
  return YES;
}

id<GeogebraCommonKernelKernelNDGeoPointND> GeogebraCommonKernelAlgosAlgoIntersectConics_getPointFrom1on2WithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_(GeogebraCommonKernelGeosGeoConic *A, GeogebraCommonKernelGeosGeoConic *B) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  id<GeogebraCommonKernelKernelNDGeoPointND> pointOnConic = nil;
  JavaUtilArrayList *pointsOnConic = [((GeogebraCommonKernelGeosGeoConic *) nil_chk(A)) getPointsOnConic];
  if (pointsOnConic != nil) {
    jint size = [pointsOnConic size];
    for (jint i = 0; i < size; i++) {
      id<GeogebraCommonKernelKernelNDGeoPointND> p = [pointsOnConic getWithInt:i];
      if ([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(p)) isLabelSet] && [p getIncidenceList] != nil && [((JavaUtilArrayList *) nil_chk([p getIncidenceList])) containsWithId:B]) {
        if ([A isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:p withDouble:GeogebraCommonKernelKernel_STANDARD_PRECISION] && [((GeogebraCommonKernelGeosGeoConic *) nil_chk(B)) isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:p withDouble:GeogebraCommonKernelKernel_STANDARD_PRECISION]) pointOnConic = p;
        break;
      }
    }
  }
  return pointOnConic;
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_computeNonContinous(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(self, self->A_, self->B_, self->Q_);
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->P_))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(nil_chk(self->Q_), IOSIntArray_Get(nil_chk(self->permutation_), i))];
  }
  if (self->isLimitedPathSituation_) {
    for (jint i = 0; i < self->P_->size_; i++) {
      if (!GeogebraCommonKernelAlgosAlgoIntersectConics_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->P_, i))) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setUndefined];
    }
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_computeContinuous(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  jboolean noSingularity = !GeogebraCommonKernelAlgosAlgoIntersectConics_isSingularitySituation(self);
  for (jint i = 0; i < 4; i++) {
    jboolean finite = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), i))) isFinite];
    if (noSingularity && finite) {
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->D_), i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->P_, i)];
      *IOSIntArray_GetRef(nil_chk(self->age_), i) = 0;
    }
    else {
      (*IOSIntArray_GetRef(nil_chk(self->age_), i))++;
    }
    *IOSBooleanArray_GetRef(nil_chk(self->isPalive_), i) = (IOSBooleanArray_Get(self->isPalive_, i) || finite || ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i)))->labelSet_);
  }
  GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(self, self->A_, self->B_, self->Q_);
  if (self->isLimitedPathSituation_) {
    GeogebraCommonKernelAlgosAlgoIntersectConics_updateQonPath(self);
  }
  if (self->firstIntersection_) {
    jint count = 0;
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->Q_))->size_; i++) {
      if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->Q_, i))) isDefined] && GeogebraCommonKernelAlgosAlgoIntersectConics_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->Q_, i))) {
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->P_), count))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->Q_, i)];
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->D_), count))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->P_, count)];
        self->firstIntersection_ = NO;
        count++;
      }
    }
    return;
  }
  GeogebraCommonKernelAlgosAlgoIntersectConics_distanceTableWithGeogebraCommonKernelGeosGeoPointArray_withIntArray_withGeogebraCommonKernelGeosGeoPointArray_withDoubleArray2_(self->D_, self->age_, self->Q_, self->distTable_);
  GeogebraCommonKernelAlgosAlgoIntersectConics_setNearToWithGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withDoubleArray2_withGeogebraCommonKernelPointPairList_withIntArray_withBoolean_withDouble_(self->P_, self->isPalive_, self->Q_, self->isQonPath_, self->distTable_, self->pointList_, self->permutation_, !self->isPermutationNeeded_, 1.0 / JavaLangMath_minWithDouble_withDouble_([((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) getXscale], [((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) getYscale]));
  self->isPermutationNeeded_ = NO;
  if (self->isLimitedPathSituation_) GeogebraCommonKernelAlgosAlgoIntersectConics_handleLimitedPaths(self);
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_handleLimitedPaths(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  jboolean noSingularity = !GeogebraCommonKernelAlgosAlgoIntersectConics_isSingularitySituation(self);
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->P_))->size_; i++) {
    if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) isDefined]) {
      if (!GeogebraCommonKernelAlgosAlgoIntersectConics_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->P_, i))) {
        if (noSingularity && [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) isFinite]) {
          [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(self->D_), i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(self->P_, i)];
          *IOSIntArray_GetRef(nil_chk(self->age_), i) = -1;
        }
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) setUndefined];
      }
    }
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_updateQonPath(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->Q_))->size_; i++) {
    *IOSBooleanArray_GetRef(nil_chk(self->isQonPath_), i) = GeogebraCommonKernelAlgosAlgoIntersectConics_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(self, IOSObjectArray_Get(self->Q_, i));
  }
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_pointLiesOnBothPathsWithGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelGeosGeoPoint *Pt) {
  return [((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->A_)) isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:Pt withDouble:GeogebraCommonKernelKernel_MIN_PRECISION] && [((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->B_)) isIntersectionPointIncidentWithGeogebraCommonKernelGeosGeoPoint:Pt withDouble:GeogebraCommonKernelKernel_MIN_PRECISION];
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_isSingularitySituation(GeogebraCommonKernelAlgosAlgoIntersectConics *self) {
  jint count = 0;
  IOSIntArray *index = [IOSIntArray arrayWithLength:((IOSObjectArray *) nil_chk(self->P_))->size_];
  for (jint i = 0; i < self->P_->size_; i++) {
    if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, i))) isDefined]) {
      *IOSIntArray_GetRef(index, count) = i;
      count++;
      if (count > 2) return NO;
    }
  }
  jboolean ret = (count == 2 && [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(self->P_, IOSIntArray_Get(index, 0)))) isEqualWithGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(self->P_, IOSIntArray_Get(index, 1))]);
  return ret;
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelGeosGeoConic *conic1, GeogebraCommonKernelGeosGeoConic *conic2, IOSObjectArray *points) {
  if (!([((GeogebraCommonKernelGeosGeoConic *) nil_chk(conic1)) isDefined] && [((GeogebraCommonKernelGeosGeoConic *) nil_chk(conic2)) isDefined])) {
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(points))->size_; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, i))) setUndefined];
    return;
  }
  jboolean ok = NO;
  jint i = 0;
  if ([conic1 isEqual:conic2]) {
    for (i = 0; i < ((IOSObjectArray *) nil_chk(points))->size_; i++) {
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, i))) setUndefined];
    }
    return;
  }
  if ([conic1 isLineConic]) {
    GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(conic2, conic1, points, GeogebraCommonKernelKernel_STANDARD_PRECISION);
    ok = GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(conic1, conic2, points, GeogebraCommonKernelKernel_MIN_PRECISION);
  }
  else if ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(conic2)) isLineConic]) {
    GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(conic1, conic2, points, GeogebraCommonKernelKernel_STANDARD_PRECISION);
    ok = GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(conic1, conic2, points, GeogebraCommonKernelKernel_MIN_PRECISION);
  }
  jdouble epsilon = GeogebraCommonKernelKernel_MAX_PRECISION;
  while (!ok && epsilon <= GeogebraCommonKernelKernel_MIN_PRECISION) {
    ok = GeogebraCommonKernelAlgosAlgoIntersectConics_calcIntersectionPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self, conic1, conic2, points, epsilon);
    epsilon *= 10.0;
  }
  if (!ok) {
    for (i = 0; i < ((IOSObjectArray *) nil_chk(points))->size_; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, i))) setUndefined];
  }
  else if (![((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) isContinuous]) {
    GeogebraCommonKernelAlgosAlgoIntersectConics_moveDefinedPointsToFrontWithGeogebraCommonKernelGeosGeoPointArray_(points);
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_moveDefinedPointsToFrontWithGeogebraCommonKernelGeosGeoPointArray_(IOSObjectArray *points) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(points))->size_; i++) {
    if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, i))) isDefined]) {
      jint j = i - 1;
      jboolean move = NO;
      while (j >= 0 && ![((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, j))) isDefined]) {
        move = YES;
        j--;
      }
      if (move) {
        j++;
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, j))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(points, i)];
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, i))) setUndefined];
      }
    }
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelGeosGeoConic *conic, GeogebraCommonKernelGeosGeoConic *degConic, IOSObjectArray *points, jdouble eps) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  if ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(degConic)) isDefined]) {
    switch ([degConic getType]) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_INTERSECTING_LINES:
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
      GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectLineConicWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelKernelNDGeoConicND_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(IOSObjectArray_Get(nil_chk(degConic->lines_), 0), conic, points, eps);
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(points), 2))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(points, 0)];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, 3))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(points, 1)];
      GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectLineConicWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelKernelNDGeoConicND_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(IOSObjectArray_Get(degConic->lines_, 1), conic, points, eps);
      return;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_EMPTY:
      [degConic enforceDoubleLine];
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_DOUBLE_LINE:
      GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectLineConicWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelKernelNDGeoConicND_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(IOSObjectArray_Get(nil_chk(degConic->lines_), 0), conic, points, eps);
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(points), 2))) setUndefined];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, 3))) setUndefined];
      return;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_SINGLE_POINT:
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(points), 0))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:[degConic getSinglePoint]];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, 1))) setUndefined];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, 2))) setUndefined];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(points, 3))) setUndefined];
      return;
    }
  }
  for (jint i = 0; i < 4; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(points), i))) setUndefined];
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelGeosGeoConic *A, GeogebraCommonKernelGeosGeoConic *B, IOSObjectArray *P, jdouble eps) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  jboolean foundPoint = NO;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(P))->size_; i++) {
    if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(P, i))) isDefined]) {
      if (!([((GeogebraCommonKernelGeosGeoConic *) nil_chk(A)) isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(P, i) withDouble:eps] && [((GeogebraCommonKernelGeosGeoConic *) nil_chk(B)) isOnFullConicWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(P, i) withDouble:eps])) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(P, i))) setUndefined];
      else foundPoint = YES;
    }
  }
  return foundPoint;
}

jdouble GeogebraCommonKernelAlgosAlgoIntersectConics_absCrossProductWithDouble_withDouble_withDouble_withDouble_(jdouble a1, jdouble a2, jdouble b1, jdouble b2) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  return JavaLangMath_absWithDouble_(a1 * b2 - a2 * b1);
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_calcIntersectionPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelGeosGeoConic *A, GeogebraCommonKernelGeosGeoConic *B, IOSObjectArray *points, jdouble eps) {
  IOSDoubleArray *flatDeg = [IOSDoubleArray arrayWithLength:6];
  IOSDoubleArray *Amatrix = [((GeogebraCommonKernelGeosGeoConic *) nil_chk(A)) getFlatMatrix];
  IOSDoubleArray *Bmatrix = [((GeogebraCommonKernelGeosGeoConic *) nil_chk(B)) getFlatMatrix];
  if (GeogebraCommonKernelAlgosAlgoIntersectConics_absCrossProductWithDouble_withDouble_withDouble_withDouble_(IOSDoubleArray_Get(nil_chk(Amatrix), 0), IOSDoubleArray_Get(Amatrix, 1), IOSDoubleArray_Get(nil_chk(Bmatrix), 0), IOSDoubleArray_Get(Bmatrix, 1)) < eps && GeogebraCommonKernelAlgosAlgoIntersectConics_absCrossProductWithDouble_withDouble_withDouble_withDouble_(IOSDoubleArray_Get(Amatrix, 0), IOSDoubleArray_Get(Amatrix, 3), IOSDoubleArray_Get(Bmatrix, 0), IOSDoubleArray_Get(Bmatrix, 3)) < eps && GeogebraCommonKernelAlgosAlgoIntersectConics_absCrossProductWithDouble_withDouble_withDouble_withDouble_(IOSDoubleArray_Get(Amatrix, 1), IOSDoubleArray_Get(Amatrix, 3), IOSDoubleArray_Get(Bmatrix, 1), IOSDoubleArray_Get(Bmatrix, 3)) < eps) {
    return GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithEqualSubmatrixSWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self, A, B, points, eps);
  }
  IOSDoubleArray *eqn = [IOSDoubleArray arrayWithLength:4];
  IOSDoubleArray *sol = [IOSDoubleArray arrayWithLength:3];
  IOSDoubleArray *flatA = [IOSDoubleArray arrayWithLength:6];
  IOSDoubleArray *flatB = [IOSDoubleArray arrayWithLength:6];
  for (jint i = 0; i < 6; i++) {
    *IOSDoubleArray_GetRef(flatA, i) = IOSDoubleArray_Get(Amatrix, i);
    *IOSDoubleArray_GetRef(flatB, i) = IOSDoubleArray_Get(Bmatrix, i);
  }
  GeogebraCommonKernelAlgosAlgoIntersectConics_normalizeArrayWithDoubleArray_(flatA);
  GeogebraCommonKernelAlgosAlgoIntersectConics_normalizeArrayWithDoubleArray_(flatB);
  *IOSDoubleArray_GetRef(eqn, 0) = IOSDoubleArray_Get(flatA, 2) * (IOSDoubleArray_Get(flatA, 0) * IOSDoubleArray_Get(flatA, 1) - IOSDoubleArray_Get(flatA, 3) * IOSDoubleArray_Get(flatA, 3)) + IOSDoubleArray_Get(flatA, 4) * (2.0 * IOSDoubleArray_Get(flatA, 3) * IOSDoubleArray_Get(flatA, 5) - IOSDoubleArray_Get(flatA, 1) * IOSDoubleArray_Get(flatA, 4)) - IOSDoubleArray_Get(flatA, 0) * IOSDoubleArray_Get(flatA, 5) * IOSDoubleArray_Get(flatA, 5);
  *IOSDoubleArray_GetRef(eqn, 1) = IOSDoubleArray_Get(flatB, 0) * (IOSDoubleArray_Get(flatA, 1) * IOSDoubleArray_Get(flatA, 2) - IOSDoubleArray_Get(flatA, 5) * IOSDoubleArray_Get(flatA, 5)) + IOSDoubleArray_Get(flatB, 1) * (IOSDoubleArray_Get(flatA, 0) * IOSDoubleArray_Get(flatA, 2) - IOSDoubleArray_Get(flatA, 4) * IOSDoubleArray_Get(flatA, 4)) + IOSDoubleArray_Get(flatB, 2) * (IOSDoubleArray_Get(flatA, 0) * IOSDoubleArray_Get(flatA, 1) - IOSDoubleArray_Get(flatA, 3) * IOSDoubleArray_Get(flatA, 3)) + 2.0 * (IOSDoubleArray_Get(flatB, 3) * (IOSDoubleArray_Get(flatA, 4) * IOSDoubleArray_Get(flatA, 5) - IOSDoubleArray_Get(flatA, 2) * IOSDoubleArray_Get(flatA, 3)) + IOSDoubleArray_Get(flatB, 4) * (IOSDoubleArray_Get(flatA, 3) * IOSDoubleArray_Get(flatA, 5) - IOSDoubleArray_Get(flatA, 1) * IOSDoubleArray_Get(flatA, 4)) + IOSDoubleArray_Get(flatB, 5) * (IOSDoubleArray_Get(flatA, 3) * IOSDoubleArray_Get(flatA, 4) - IOSDoubleArray_Get(flatA, 0) * IOSDoubleArray_Get(flatA, 5)));
  *IOSDoubleArray_GetRef(eqn, 2) = IOSDoubleArray_Get(flatA, 0) * (IOSDoubleArray_Get(flatB, 1) * IOSDoubleArray_Get(flatB, 2) - IOSDoubleArray_Get(flatB, 5) * IOSDoubleArray_Get(flatB, 5)) + IOSDoubleArray_Get(flatA, 1) * (IOSDoubleArray_Get(flatB, 0) * IOSDoubleArray_Get(flatB, 2) - IOSDoubleArray_Get(flatB, 4) * IOSDoubleArray_Get(flatB, 4)) + IOSDoubleArray_Get(flatA, 2) * (IOSDoubleArray_Get(flatB, 0) * IOSDoubleArray_Get(flatB, 1) - IOSDoubleArray_Get(flatB, 3) * IOSDoubleArray_Get(flatB, 3)) + 2.0 * (IOSDoubleArray_Get(flatA, 3) * (IOSDoubleArray_Get(flatB, 4) * IOSDoubleArray_Get(flatB, 5) - IOSDoubleArray_Get(flatB, 2) * IOSDoubleArray_Get(flatB, 3)) + IOSDoubleArray_Get(flatA, 4) * (IOSDoubleArray_Get(flatB, 3) * IOSDoubleArray_Get(flatB, 5) - IOSDoubleArray_Get(flatB, 1) * IOSDoubleArray_Get(flatB, 4)) + IOSDoubleArray_Get(flatA, 5) * (IOSDoubleArray_Get(flatB, 3) * IOSDoubleArray_Get(flatB, 4) - IOSDoubleArray_Get(flatB, 0) * IOSDoubleArray_Get(flatB, 5)));
  *IOSDoubleArray_GetRef(eqn, 3) = IOSDoubleArray_Get(flatB, 2) * (IOSDoubleArray_Get(flatB, 0) * IOSDoubleArray_Get(flatB, 1) - IOSDoubleArray_Get(flatB, 3) * IOSDoubleArray_Get(flatB, 3)) + IOSDoubleArray_Get(flatB, 4) * (2.0 * IOSDoubleArray_Get(flatB, 3) * IOSDoubleArray_Get(flatB, 5) - IOSDoubleArray_Get(flatB, 1) * IOSDoubleArray_Get(flatB, 4)) - IOSDoubleArray_Get(flatB, 0) * IOSDoubleArray_Get(flatB, 5) * IOSDoubleArray_Get(flatB, 5);
  jint solnr = [((id<GeogebraCommonKernelEquationSolverInterface>) nil_chk(self->eqnSolver_)) solveCubicWithDoubleArray:eqn withDoubleArray:sol withDouble:eps];
  if (solnr > -1) JavaUtilArrays_sortWithDoubleArray_withInt_withInt_(sol, 0, solnr);
  for (jint i = 0; i < solnr; i++) {
    for (jint j = 0; j < 6; j++) {
      *IOSDoubleArray_GetRef(flatDeg, j) = (IOSDoubleArray_Get(flatA, j) + IOSDoubleArray_Get(sol, i) * IOSDoubleArray_Get(flatB, j));
    }
    [((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->degConic_)) setDegenerateMatrixFromArrayWithDoubleArray:flatDeg];
    GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(A, self->degConic_, points, eps);
    if (GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(A, B, points, GeogebraCommonKernelKernel_MIN_PRECISION)) return YES;
    GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(B, self->degConic_, points, eps);
    if (GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(A, B, points, GeogebraCommonKernelKernel_MIN_PRECISION)) return YES;
  }
  jdouble temp = IOSDoubleArray_Get(eqn, 0);
  *IOSDoubleArray_GetRef(eqn, 0) = IOSDoubleArray_Get(eqn, 3);
  *IOSDoubleArray_GetRef(eqn, 3) = temp;
  temp = IOSDoubleArray_Get(eqn, 1);
  *IOSDoubleArray_GetRef(eqn, 1) = IOSDoubleArray_Get(eqn, 2);
  *IOSDoubleArray_GetRef(eqn, 2) = temp;
  solnr = [self->eqnSolver_ solveCubicWithDoubleArray:eqn withDoubleArray:sol withDouble:eps];
  if (solnr > -1) JavaUtilArrays_sortWithDoubleArray_withInt_withInt_(sol, 0, solnr);
  for (jint i = 0; i < solnr; i++) {
    for (jint j = 0; j < 6; j++) {
      *IOSDoubleArray_GetRef(flatDeg, j) = (IOSDoubleArray_Get(sol, i) * IOSDoubleArray_Get(flatA, j) + IOSDoubleArray_Get(flatB, j));
    }
    [((GeogebraCommonKernelGeosGeoConic *) nil_chk(self->degConic_)) setDegenerateMatrixFromArrayWithDoubleArray:flatDeg];
    GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(A, self->degConic_, points, eps);
    if (GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(A, B, points, GeogebraCommonKernelKernel_MIN_PRECISION)) return YES;
    GeogebraCommonKernelAlgosAlgoIntersectConics_intersectWithDegenerateWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(B, self->degConic_, points, eps);
    if (GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(A, B, points, GeogebraCommonKernelKernel_MIN_PRECISION)) return YES;
  }
  IOSDoubleArray *param1 = [IOSDoubleArray arrayWithLength:6];
  *IOSDoubleArray_GetRef(param1, 0) = IOSDoubleArray_Get(Amatrix, 0);
  *IOSDoubleArray_GetRef(param1, 1) = 2 * IOSDoubleArray_Get(Amatrix, 3);
  *IOSDoubleArray_GetRef(param1, 2) = IOSDoubleArray_Get(Amatrix, 1);
  *IOSDoubleArray_GetRef(param1, 3) = 2 * IOSDoubleArray_Get(Amatrix, 4);
  *IOSDoubleArray_GetRef(param1, 4) = 2 * IOSDoubleArray_Get(Amatrix, 5);
  *IOSDoubleArray_GetRef(param1, 5) = IOSDoubleArray_Get(Amatrix, 2);
  IOSDoubleArray *param2 = [IOSDoubleArray arrayWithLength:6];
  *IOSDoubleArray_GetRef(param2, 0) = IOSDoubleArray_Get(Bmatrix, 0);
  *IOSDoubleArray_GetRef(param2, 1) = 2 * IOSDoubleArray_Get(Bmatrix, 3);
  *IOSDoubleArray_GetRef(param2, 2) = IOSDoubleArray_Get(Bmatrix, 1);
  *IOSDoubleArray_GetRef(param2, 3) = 2 * IOSDoubleArray_Get(Bmatrix, 4);
  *IOSDoubleArray_GetRef(param2, 4) = 2 * IOSDoubleArray_Get(Bmatrix, 5);
  *IOSDoubleArray_GetRef(param2, 5) = IOSDoubleArray_Get(Bmatrix, 2);
  IOSObjectArray *res = [IOSDoubleArray arrayWithDimensions:2 lengths:(jint[]){ 4, 2 }];
  solnr = [((GeogebraCommonKernelSystemOfEquationsSolver *) nil_chk(self->sysSolver_)) solveSystemOfQuadraticEquationsWithDoubleArray:param1 withDoubleArray:param2 withDoubleArray2:res withDouble:eps];
  if (solnr == -1) {
    return NO;
  }
  for (jint i = 0; i < solnr; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(points), i))) setCoordsWithDouble:IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(res, i)), 0) withDouble:IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(res, i)), 1) withDouble:1.0];
  for (jint i = solnr; i < 4; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(nil_chk(points), i))) setUndefined];
  if (GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(A, B, points, GeogebraCommonKernelKernel_MIN_PRECISION)) return YES;
  return NO;
}

jboolean GeogebraCommonKernelAlgosAlgoIntersectConics_intersectConicsWithEqualSubmatrixSWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(GeogebraCommonKernelAlgosAlgoIntersectConics *self, GeogebraCommonKernelGeosGeoConic *c1, GeogebraCommonKernelGeosGeoConic *c2, IOSObjectArray *points, jdouble eps) {
  if (self->tempLine_ == nil) {
    GeogebraCommonKernelAlgosAlgoIntersectConics_setAndConsume_tempLine_(self, new_GeogebraCommonKernelGeosGeoLine_initWithGeogebraCommonKernelConstruction_(self->cons_));
  }
  IOSDoubleArray *c1matrix = [((GeogebraCommonKernelGeosGeoConic *) nil_chk(c1)) getFlatMatrix];
  IOSDoubleArray *c2matrix = [((GeogebraCommonKernelGeosGeoConic *) nil_chk(c2)) getFlatMatrix];
  jdouble m2 = JavaLangDouble_NaN;
  for (jint i = 0; i < 6 && JavaLangDouble_isNaNWithDouble_(m2); i++) {
    jdouble m1 = IOSDoubleArray_Get(nil_chk(c1matrix), i);
    if (!GeogebraCommonKernelKernel_isZeroWithDouble_withDouble_(m1, eps)) {
      m2 = JavaLangMath_absWithDouble_(IOSDoubleArray_Get(nil_chk(c2matrix), i)) / m1;
    }
  }
  [((GeogebraCommonKernelGeosGeoLine *) nil_chk(self->tempLine_)) setCoordsWithDouble:2 * (IOSDoubleArray_Get(nil_chk(c1matrix), 4) * m2 - IOSDoubleArray_Get(nil_chk(c2matrix), 4)) withDouble:2 * (IOSDoubleArray_Get(c1matrix, 5) * m2 - IOSDoubleArray_Get(c2matrix, 5)) withDouble:IOSDoubleArray_Get(c1matrix, 2) * m2 - IOSDoubleArray_Get(c2matrix, 2)];
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectLineConicWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelKernelNDGeoConicND_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self->tempLine_, c1, points, eps);
  if (GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(c1, c2, points, GeogebraCommonKernelKernel_MIN_PRECISION)) return YES;
  GeogebraCommonKernelAlgosAlgoIntersectLineConic_intersectLineConicWithGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelKernelNDGeoConicND_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(self->tempLine_, c2, points, eps);
  if (GeogebraCommonKernelAlgosAlgoIntersectConics_testPointsWithGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoConic_withGeogebraCommonKernelGeosGeoPointArray_withDouble_(c1, c2, points, GeogebraCommonKernelKernel_MIN_PRECISION)) return YES;
  return NO;
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_normalizeArrayWithDoubleArray_(IOSDoubleArray *array) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  jdouble max = 0;
  for (jint i = 0; i < ((IOSDoubleArray *) nil_chk(array))->size_; i++) {
    jdouble abs = JavaLangMath_absWithDouble_(IOSDoubleArray_Get(array, i));
    if (abs > max) max = abs;
  }
  for (jint i = 0; i < array->size_; i++) {
    *IOSDoubleArray_GetRef(array, i) /= max;
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_distanceTableWithGeogebraCommonKernelGeosGeoPointArray_withIntArray_withGeogebraCommonKernelGeosGeoPointArray_withDoubleArray2_(IOSObjectArray *D, IOSIntArray *age, IOSObjectArray *Q, IOSObjectArray *table) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  jint i, j;
  jboolean foundUndefined = NO;
  jdouble dist, max = -1.0;
  for (i = 0; i < ((IOSObjectArray *) nil_chk(D))->size_; i++) {
    for (j = 0; j < ((IOSObjectArray *) nil_chk(Q))->size_; j++) {
      dist = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(D, i))) distanceSqrWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q, j)] + IOSIntArray_Get(nil_chk(age), i);
      if (JavaLangDouble_isInfiniteWithDouble_(dist) || JavaLangDouble_isNaNWithDouble_(dist)) {
        dist = -1;
        foundUndefined = YES;
      }
      else if (dist > max) {
        max = dist;
      }
      *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(table), i)), j) = dist;
    }
  }
  if (foundUndefined) {
    max = max + 1;
    for (j = 0; j < ((IOSObjectArray *) nil_chk(Q))->size_; j++) {
      for (i = 0; i < D->size_; i++) {
        if (IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(table), i)), j) == -1) {
          *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(table, i)), j) = max;
        }
      }
    }
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_setNearToWithGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withDoubleArray2_withGeogebraCommonKernelPointPairList_withIntArray_withBoolean_withDouble_(IOSObjectArray *P, IOSBooleanArray *isPalive, IOSObjectArray *Q, IOSBooleanArray *isQonPath, IOSObjectArray *distTable, GeogebraCommonKernelPointPairList *pointList, IOSIntArray *permutation, jboolean needStrict, jdouble eps) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  jint indexP, indexQ;
  [((GeogebraCommonKernelPointPairList *) nil_chk(pointList)) clear];
  for (indexP = 0; indexP < ((IOSObjectArray *) nil_chk(P))->size_; indexP++) {
    for (indexQ = 0; indexQ < ((IOSObjectArray *) nil_chk(Q))->size_; indexQ++) {
      [pointList insertPointPairWithInt:indexP withBoolean:IOSBooleanArray_Get(nil_chk(isPalive), indexP) withInt:indexQ withBoolean:IOSBooleanArray_Get(nil_chk(isQonPath), indexQ) withDouble:IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(distTable), indexP)), indexQ)];
    }
  }
  jdouble gap = JavaLangDouble_POSITIVE_INFINITY;
  jdouble temp;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(Q))->size_; i++) {
    for (jint j = i + 1; j < Q->size_; j++) {
      temp = [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(Q, i))) distanceSqrWithGeogebraCommonKernelGeosGeoPoint:IOSObjectArray_Get(Q, j)];
      if (temp < gap) gap = temp;
    }
  }
  if (!needStrict || (gap > eps * eps)) {
    GeogebraCommonKernelPointPair *pair;
    jint currentSize = -1;
    while (![pointList isEmpty] && [pointList size] != currentSize) {
      currentSize = [pointList size];
      pair = [pointList getHead];
      indexP = ((GeogebraCommonKernelPointPair *) nil_chk(pair))->indexP_;
      indexQ = pair->indexQ_;
      if (pair->isPalive_ && pair->isQonPath_ && [pointList getClosestPWithindexQWithInt:pair->indexQ_] == pair->indexP_ && [pointList getClosestQWithindexPWithInt:pair->indexP_] == pair->indexQ_) {
        [pointList removeAllPairsWithGeogebraCommonKernelPointPair:pair];
      }
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(P, indexP))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(Q, indexQ)];
      *IOSIntArray_GetRef(nil_chk(permutation), indexP) = indexQ;
    }
    while (![pointList isEmpty]) {
      pair = [pointList getHead];
      indexP = ((GeogebraCommonKernelPointPair *) nil_chk(pair))->indexP_;
      indexQ = pair->indexQ_;
      [pointList removeAllPairsWithGeogebraCommonKernelPointPair:pair];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(P, indexP))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(Q, indexQ)];
      *IOSIntArray_GetRef(nil_chk(permutation), indexP) = indexQ;
    }
  }
  else {
    for (jint i = 0; i < P->size_; i++) {
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(P, i))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(Q, IOSIntArray_Get(nil_chk(permutation), i))];
    }
  }
}

void GeogebraCommonKernelAlgosAlgoIntersectConics_setNearToWithGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withGeogebraCommonKernelGeosGeoPointArray_withBooleanArray_withDoubleArray2_withGeogebraCommonKernelPointPairList_withIntArray_(IOSObjectArray *P, IOSBooleanArray *isPalive, IOSObjectArray *Q, IOSBooleanArray *isQonPath, IOSObjectArray *distTable, GeogebraCommonKernelPointPairList *pointList, IOSIntArray *permutation) {
  GeogebraCommonKernelAlgosAlgoIntersectConics_initialize();
  jint indexP, indexQ;
  [((GeogebraCommonKernelPointPairList *) nil_chk(pointList)) clear];
  for (indexP = 0; indexP < ((IOSObjectArray *) nil_chk(P))->size_; indexP++) {
    for (indexQ = 0; indexQ < ((IOSObjectArray *) nil_chk(Q))->size_; indexQ++) {
      [pointList insertPointPairWithInt:indexP withBoolean:IOSBooleanArray_Get(nil_chk(isPalive), indexP) withInt:indexQ withBoolean:IOSBooleanArray_Get(nil_chk(isQonPath), indexQ) withDouble:IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(distTable), indexP)), indexQ)];
    }
  }
  if ([pointList isStrict]) {
    GeogebraCommonMainApp_debugWithNSString_(@"strict list");
    GeogebraCommonKernelPointPair *pair;
    while (![pointList isEmpty]) {
      pair = [pointList getHead];
      indexP = ((GeogebraCommonKernelPointPair *) nil_chk(pair))->indexP_;
      indexQ = pair->indexQ_;
      [pointList removeAllPairsWithGeogebraCommonKernelPointPair:pair];
      [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(IOSObjectArray_Get(P, indexP))) setCoordsWithGeogebraCommonKernelGeosGeoVec3D:IOSObjectArray_Get(nil_chk(Q), indexQ)];
      *IOSIntArray_GetRef(nil_chk(permutation), indexP) = indexQ;
    }
  }
  else {
    GeogebraCommonMainApp_debugWithNSString_(@"non strict list");
    for (jint i = 0; i < P->size_; i++) {
      IOSObjectArray_Set(P, i, IOSObjectArray_Get(nil_chk(Q), IOSIntArray_Get(nil_chk(permutation), i)));
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelAlgosAlgoIntersectConics)
