//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/locusequ/arith/EquationExpression.java
//


#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/locusequ/EquationTranslator.h"
#include "geogebra/common/kernel/locusequ/arith/EquationExpression.h"
#include "geogebra/common/kernel/locusequ/arith/EquationInverseOperator.h"
#include "geogebra/common/kernel/locusequ/arith/EquationOppositeOperator.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"

@interface GeogebraCommonKernelLocusequArithEquationExpression () {
 @public
  JavaLangBoolean *containsSymbolicValues__;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelLocusequArithEquationExpression, containsSymbolicValues__, JavaLangBoolean *)

@implementation GeogebraCommonKernelLocusequArithEquationExpression

- (GeogebraCommonKernelLocusequArithEquationExpression *)getOpposite {
  if (self->opposite_ == nil) {
    GeogebraCommonKernelLocusequArithEquationExpression_setAndConsume_opposite_(self, new_GeogebraCommonKernelLocusequArithEquationOppositeOperator_initWithGeogebraCommonKernelLocusequArithEquationExpression_(self));
  }
  return self->opposite_;
}

- (GeogebraCommonKernelLocusequArithEquationExpression *)getInverse {
  if (self->inverse_ == nil) {
    GeogebraCommonKernelLocusequArithEquationExpression_setAndConsume_inverse_(self, new_GeogebraCommonKernelLocusequArithEquationInverseOperator_initWithGeogebraCommonKernelLocusequArithEquationExpression_(self));
  }
  return self->inverse_;
}

- (jboolean)isTerm {
  return NO;
}

- (jboolean)isNumericValue {
  return NO;
}

- (jboolean)isAuxiliarSymbolicValue {
  return NO;
}

- (jboolean)isSymbolicValue {
  return NO;
}

- (jboolean)isSpecialSymbolicValue {
  return NO;
}

- (jboolean)isAnySymbolicValue {
  return [self isAuxiliarSymbolicValue] || [self isSymbolicValue] || [self isSpecialSymbolicValue];
}

- (jboolean)isOperator {
  return NO;
}

- (jboolean)isSum {
  return NO;
}

- (jboolean)isDiff {
  return NO;
}

- (jboolean)isProduct {
  return NO;
}

- (jboolean)isDiv {
  return NO;
}

- (jboolean)isExp {
  return NO;
}

- (jboolean)isSqrt {
  return NO;
}

- (jboolean)isOpposite {
  return NO;
}

- (jboolean)isInverse {
  return NO;
}

- (jboolean)isAbs {
  return NO;
}

- (jboolean)containsSymbolicValues {
  if (self->containsSymbolicValues__ == nil) {
    GeogebraCommonKernelLocusequArithEquationExpression_set_containsSymbolicValues__(self, JavaLangBoolean_valueOfWithBoolean_([self containsSymbolicValuesImpl]));
  }
  return [((JavaLangBoolean *) nil_chk(self->containsSymbolicValues__)) booleanValue];
}

- (jboolean)containsSymbolicValuesImpl {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jdouble)computeValue {
  if ([self containsSymbolicValuesImpl]) {
    return JavaLangDouble_NaN;
  }
  return [self computeValueImpl];
}

- (jdouble)computeValueImpl {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)translateImplWithGeogebraCommonKernelLocusequEquationTranslator:(GeogebraCommonKernelLocusequEquationTranslator *)translator {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)translateWithGeogebraCommonKernelLocusequEquationTranslator:(GeogebraCommonKernelLocusequEquationTranslator *)translator {
  return [self translateImplWithGeogebraCommonKernelLocusequEquationTranslator:translator];
}

- (jlong)toLong {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jboolean)isSimplifiable {
  return ![self containsSymbolicValues] && !JavaLangDouble_isNaNWithDouble_([self computeValue]);
}

- (NSString *)description {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (instancetype)init {
  GeogebraCommonKernelLocusequArithEquationExpression_init(self);
  return self;
}

- (void)dealloc {
  RELEASE_(opposite_);
  RELEASE_(inverse_);
  RELEASE_(containsSymbolicValues__);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getOpposite", NULL, "Lgeogebra.common.kernel.locusequ.arith.EquationExpression;", 0x1, NULL, NULL },
    { "getInverse", NULL, "Lgeogebra.common.kernel.locusequ.arith.EquationExpression;", 0x1, NULL, NULL },
    { "isTerm", NULL, "Z", 0x1, NULL, NULL },
    { "isNumericValue", NULL, "Z", 0x1, NULL, NULL },
    { "isAuxiliarSymbolicValue", NULL, "Z", 0x1, NULL, NULL },
    { "isSymbolicValue", NULL, "Z", 0x1, NULL, NULL },
    { "isSpecialSymbolicValue", NULL, "Z", 0x1, NULL, NULL },
    { "isAnySymbolicValue", NULL, "Z", 0x1, NULL, NULL },
    { "isOperator", NULL, "Z", 0x1, NULL, NULL },
    { "isSum", NULL, "Z", 0x1, NULL, NULL },
    { "isDiff", NULL, "Z", 0x1, NULL, NULL },
    { "isProduct", NULL, "Z", 0x1, NULL, NULL },
    { "isDiv", NULL, "Z", 0x1, NULL, NULL },
    { "isExp", NULL, "Z", 0x1, NULL, NULL },
    { "isSqrt", NULL, "Z", 0x1, NULL, NULL },
    { "isOpposite", NULL, "Z", 0x1, NULL, NULL },
    { "isInverse", NULL, "Z", 0x1, NULL, NULL },
    { "isAbs", NULL, "Z", 0x1, NULL, NULL },
    { "containsSymbolicValues", NULL, "Z", 0x1, NULL, NULL },
    { "containsSymbolicValuesImpl", NULL, "Z", 0x404, NULL, NULL },
    { "computeValue", NULL, "D", 0x1, NULL, NULL },
    { "computeValueImpl", NULL, "D", 0x404, NULL, NULL },
    { "translateImplWithGeogebraCommonKernelLocusequEquationTranslator:", "translateImpl", "TT;", 0x404, NULL, "<T:Ljava/lang/Object;>(Lgeogebra/common/kernel/locusequ/EquationTranslator<TT;>;)TT;" },
    { "translateWithGeogebraCommonKernelLocusequEquationTranslator:", "translate", "TT;", 0x1, NULL, "<T:Ljava/lang/Object;>(Lgeogebra/common/kernel/locusequ/EquationTranslator<TT;>;)TT;" },
    { "toLong", NULL, "J", 0x401, NULL, NULL },
    { "isSimplifiable", NULL, "Z", 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x401, NULL, NULL },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "opposite_", NULL, 0x4, "Lgeogebra.common.kernel.locusequ.arith.EquationExpression;", NULL, NULL,  },
    { "inverse_", NULL, 0x4, "Lgeogebra.common.kernel.locusequ.arith.EquationExpression;", NULL, NULL,  },
    { "containsSymbolicValues__", "containsSymbolicValues", 0x2, "Ljava.lang.Boolean;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelLocusequArithEquationExpression = { 2, "EquationExpression", "geogebra.common.kernel.locusequ.arith", NULL, 0x401, 28, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelLocusequArithEquationExpression;
}

@end

void GeogebraCommonKernelLocusequArithEquationExpression_init(GeogebraCommonKernelLocusequArithEquationExpression *self) {
  NSObject_init(self);
  GeogebraCommonKernelLocusequArithEquationExpression_set_opposite_(self, nil);
  GeogebraCommonKernelLocusequArithEquationExpression_set_inverse_(self, nil);
  GeogebraCommonKernelLocusequArithEquationExpression_set_containsSymbolicValues__(self, nil);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelLocusequArithEquationExpression)
