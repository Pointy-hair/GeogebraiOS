//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/kernelND/GeoConicPartParameters.java
//


#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/PathParameter.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/integration/EllipticArcLength.h"
#include "geogebra/common/kernel/kernelND/GeoConicND.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoConicPartND.h"
#include "geogebra/common/kernel/kernelND/GeoConicPartParameters.h"
#include "java/lang/Double.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"

@interface GeogebraCommonKernelKernelNDGeoConicPartParameters () {
 @public
  GeogebraCommonKernelKernelNDGeoConicND *conic_;
}

- (jdouble)computeArgWithDouble:(jdouble)x0
                     withDouble:(jdouble)y0;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelKernelNDGeoConicPartParameters, conic_, GeogebraCommonKernelKernelNDGeoConicND *)

__attribute__((unused)) static jdouble GeogebraCommonKernelKernelNDGeoConicPartParameters_computeArgWithDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicPartParameters *self, jdouble x0, jdouble y0);

@implementation GeogebraCommonKernelKernelNDGeoConicPartParameters

- (instancetype)initWithGeogebraCommonKernelKernelNDGeoConicND:(GeogebraCommonKernelKernelNDGeoConicND *)conic
                                                       withInt:(jint)type {
  GeogebraCommonKernelKernelNDGeoConicPartParameters_initWithGeogebraCommonKernelKernelNDGeoConicND_withInt_(self, conic, type);
  return self;
}

- (void)setWithGeogebraCommonKernelKernelNDGeoConicPartParameters:(GeogebraCommonKernelKernelNDGeoConicPartParameters *)cp {
  paramStart_ = ((GeogebraCommonKernelKernelNDGeoConicPartParameters *) nil_chk(cp))->paramStart_;
  paramEnd_ = cp->paramEnd_;
  paramExtent_ = cp->paramExtent_;
  posOrientation_ = cp->posOrientation_;
  conic_part_type_ = cp->conic_part_type_;
  value_ = cp->value_;
  area_ = cp->area_;
  value_defined_ = cp->value_defined_;
  keepTypeOnGeometricTransform_ = cp->keepTypeOnGeometricTransform_;
}

- (jboolean)isEqualWithGeogebraCommonKernelKernelNDGeoConicPartParameters:(GeogebraCommonKernelKernelNDGeoConicPartParameters *)other {
  return posOrientation_ == ((GeogebraCommonKernelKernelNDGeoConicPartParameters *) nil_chk(other))->posOrientation_ && conic_part_type_ == other->conic_part_type_ && GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(paramStart_, other->paramStart_) && GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(paramEnd_, other->paramEnd_);
}

- (void)setParametersWithBoolean:(jboolean)isDefined
                      withDouble:(jdouble)start
                      withDouble:(jdouble)end
                     withBoolean:(jboolean)positiveOrientation {
  jdouble startParam = start;
  jdouble endParam = end;
  value_defined_ = isDefined;
  if (!value_defined_) {
    value_ = JavaLangDouble_NaN;
    return;
  }
  posOrientation_ = positiveOrientation;
  if (!posOrientation_) {
    jdouble tmp = startParam;
    startParam = endParam;
    endParam = tmp;
  }
  {
    jdouble r;
    switch ([((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(conic_)) getType]) {
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
      paramStart_ = GeogebraCommonKernelKernel_convertToAngleValueWithDouble_(startParam);
      paramEnd_ = GeogebraCommonKernelKernel_convertToAngleValueWithDouble_(endParam);
      paramExtent_ = paramEnd_ - paramStart_;
      if (paramExtent_ < 0) paramExtent_ += GeogebraCommonKernelKernel_PI_2;
      r = [conic_ getHalfAxisWithInt:0];
      arcLength_ = r * paramExtent_;
      if (conic_part_type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC) {
        value_ = arcLength_;
        area_ = r * r * (paramExtent_ - JavaLangMath_sinWithDouble_(paramExtent_)) / 2.0;
      }
      else {
        value_ = r * r * paramExtent_ / 2.0;
        area_ = value_;
      }
      value_defined_ = (!JavaLangDouble_isNaNWithDouble_(value_) && !JavaLangDouble_isInfiniteWithDouble_(value_));
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
      paramStart_ = GeogebraCommonKernelKernel_convertToAngleValueWithDouble_(startParam);
      paramEnd_ = GeogebraCommonKernelKernel_convertToAngleValueWithDouble_(endParam);
      paramExtent_ = paramEnd_ - paramStart_;
      if (paramExtent_ < 0) paramExtent_ += GeogebraCommonKernelKernel_PI_2;
      if (ellipticArcLength_ == nil) GeogebraCommonKernelKernelNDGeoConicPartParameters_setAndConsume_ellipticArcLength_(self, new_GeogebraCommonKernelIntegrationEllipticArcLength_initWithGeogebraCommonKernelKernelNDGeoConicND_(conic_));
      if (conic_part_type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC) {
        value_ = [((GeogebraCommonKernelIntegrationEllipticArcLength *) nil_chk(ellipticArcLength_)) computeWithDouble:paramStart_ withDouble:paramEnd_];
      }
      else {
        value_ = [conic_ getHalfAxisWithInt:0] * [conic_ getHalfAxisWithInt:1] * paramExtent_ / 2.0;
      }
      value_defined_ = (!JavaLangDouble_isNaNWithDouble_(value_) && !JavaLangDouble_isInfiniteWithDouble_(value_));
      break;
      case GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARALLEL_LINES:
      if (conic_part_type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC && posOrientation_) {
        GeogebraCommonKernelGeosGeoPoint *startPoint = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(nil_chk(conic_->lines_), 0))) getStartPoint];
        GeogebraCommonKernelGeosGeoPoint *endPoint = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(IOSObjectArray_Get(conic_->lines_, 0))) getEndPoint];
        if (startPoint != nil && endPoint != nil) {
          value_ = [startPoint distanceWithGeogebraCommonKernelGeosGeoPoint:endPoint];
        }
        else {
          value_ = JavaLangDouble_POSITIVE_INFINITY;
          value_defined_ = NO;
          break;
        }
      }
      else {
        value_ = JavaLangDouble_POSITIVE_INFINITY;
      }
      value_defined_ = YES;
      break;
      default:
      value_defined_ = NO;
    }
  }
}

- (jdouble)getValue {
  if (!value_defined_) return JavaLangDouble_NaN;
  return value_;
}

- (jdouble)getArcLength {
  if (!value_defined_) return JavaLangDouble_NaN;
  return arcLength_;
}

- (jdouble)getArea {
  if (!value_defined_) return JavaLangDouble_NaN;
  return area_;
}

- (void)setEllipseParameterWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                          withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp {
  [((id<GeogebraCommonKernelKernelNDGeoConicPartND>) nil_chk(((id<GeogebraCommonKernelKernelNDGeoConicPartND>) check_protocol_cast(conic_, @protocol(GeogebraCommonKernelKernelNDGeoConicPartND))))) superPointChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
  if (((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_ < 0) pp->t_ += GeogebraCommonKernelKernel_PI_2;
  jdouble t = pp->t_ - paramStart_;
  if (t < 0) t += GeogebraCommonKernelKernel_PI_2;
  pp->t_ = t / paramExtent_;
}

- (void)clipEllipseParameterWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P
                           withGeogebraCommonKernelPathParameter:(GeogebraCommonKernelPathParameter *)pp {
  if (((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_ > 0.5 + JavaLangMath_PI / paramExtent_) {
    if (posOrientation_) pp->t_ = 0;
    else pp->t_ = 1;
    [((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(conic_)) pathChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
  }
  else if (pp->t_ > 1) {
    if (posOrientation_) pp->t_ = 1;
    else pp->t_ = 0;
    [((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(conic_)) pathChangedWithGeogebraCommonKernelMatrixCoords:P withGeogebraCommonKernelPathParameter:pp];
  }
  else if (!posOrientation_) {
    pp->t_ = 1.0 - pp->t_;
  }
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\t<outlyingIntersections val=\""];
  [sb appendWithBoolean:allowOutlyingIntersections_];
  [sb appendWithNSString:@"\"/>\n"];
  [sb appendWithNSString:@"\t<keepTypeOnTransform val=\""];
  [sb appendWithBoolean:keepTypeOnGeometricTransform_];
  [sb appendWithNSString:@"\"/>\n"];
}

- (jboolean)isInRegionWithDouble:(jdouble)x0
                      withDouble:(jdouble)y0 {
  if (conic_part_type_ == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR) {
    jdouble arg = GeogebraCommonKernelKernelNDGeoConicPartParameters_computeArgWithDouble_withDouble_(self, x0, y0);
    if (arg < 0) arg += GeogebraCommonKernelKernel_PI_2;
    return ((arg >= -GeogebraCommonKernelKernel_STANDARD_PRECISION) && (arg <= paramExtent_ + GeogebraCommonKernelKernel_STANDARD_PRECISION));
  }
  GeogebraCommonKernelMatrixCoords *midPoint = [((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(conic_)) getMidpoint2D];
  GeogebraCommonKernelMatrixCoords *firstVec = [((GeogebraCommonKernelMatrixCoords *) nil_chk([((GeogebraCommonKernelMatrixCoords *) nil_chk([conic_ getEigenvecWithInt:0])) mulWithDouble:[conic_ getHalfAxisWithInt:0] * JavaLangMath_cosWithDouble_(paramStart_)])) addWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelMatrixCoords *) nil_chk([conic_ getEigenvecWithInt:1])) mulWithDouble:[conic_ getHalfAxisWithInt:1] * JavaLangMath_sinWithDouble_(paramStart_)]];
  GeogebraCommonKernelMatrixCoords *secondVec = [((GeogebraCommonKernelMatrixCoords *) nil_chk([((GeogebraCommonKernelMatrixCoords *) nil_chk([conic_ getEigenvecWithInt:0])) mulWithDouble:[conic_ getHalfAxisWithInt:0] * JavaLangMath_cosWithDouble_(paramEnd_)])) addWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelMatrixCoords *) nil_chk([conic_ getEigenvecWithInt:1])) mulWithDouble:[conic_ getHalfAxisWithInt:1] * JavaLangMath_sinWithDouble_(paramEnd_)]];
  jdouble vx = (x0 - [((GeogebraCommonKernelMatrixCoords *) nil_chk(midPoint)) getX]) - [((GeogebraCommonKernelMatrixCoords *) nil_chk(firstVec)) getX], vy = (y0 - [midPoint getY]) - [firstVec getY];
  jdouble lx = [((GeogebraCommonKernelMatrixCoords *) nil_chk(secondVec)) getX] - [firstVec getX], ly = [secondVec getY] - [firstVec getY];
  return (vx * ly - vy * lx > 0);
}

- (jdouble)computeArgWithDouble:(jdouble)x0
                     withDouble:(jdouble)y0 {
  return GeogebraCommonKernelKernelNDGeoConicPartParameters_computeArgWithDouble_withDouble_(self, x0, y0);
}

- (void)dealloc {
  RELEASE_(conic_);
  RELEASE_(ellipticArcLength_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelKernelNDGeoConicND:withInt:", "GeoConicPartParameters", NULL, 0x1, NULL, NULL },
    { "setWithGeogebraCommonKernelKernelNDGeoConicPartParameters:", "set", "V", 0x1, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelKernelNDGeoConicPartParameters:", "isEqual", "Z", 0x11, NULL, NULL },
    { "setParametersWithBoolean:withDouble:withDouble:withBoolean:", "setParameters", "V", 0x11, NULL, NULL },
    { "getValue", NULL, "D", 0x11, NULL, NULL },
    { "getArcLength", NULL, "D", 0x11, NULL, NULL },
    { "getArea", NULL, "D", 0x11, NULL, NULL },
    { "setEllipseParameterWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:", "setEllipseParameter", "V", 0x1, NULL, NULL },
    { "clipEllipseParameterWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelPathParameter:", "clipEllipseParameter", "V", 0x1, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x1, NULL, NULL },
    { "isInRegionWithDouble:withDouble:", "isInRegion", "Z", 0x1, NULL, NULL },
    { "computeArgWithDouble:withDouble:", "computeArg", "D", 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "conic_", NULL, 0x2, "Lgeogebra.common.kernel.kernelND.GeoConicND;", NULL, NULL,  },
    { "paramStart_", NULL, 0x1, "D", NULL, NULL,  },
    { "paramEnd_", NULL, 0x1, "D", NULL, NULL,  },
    { "paramExtent_", NULL, 0x1, "D", NULL, NULL,  },
    { "posOrientation_", NULL, 0x1, "Z", NULL, NULL,  },
    { "conic_part_type_", NULL, 0x1, "I", NULL, NULL,  },
    { "value_", NULL, 0x1, "D", NULL, NULL,  },
    { "area_", NULL, 0x1, "D", NULL, NULL,  },
    { "arcLength_", NULL, 0x1, "D", NULL, NULL,  },
    { "value_defined_", NULL, 0x1, "Z", NULL, NULL,  },
    { "ellipticArcLength_", NULL, 0x1, "Lgeogebra.common.kernel.integration.EllipticArcLength;", NULL, NULL,  },
    { "allowOutlyingIntersections_", NULL, 0x1, "Z", NULL, NULL,  },
    { "keepTypeOnGeometricTransform_", NULL, 0x1, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelKernelNDGeoConicPartParameters = { 2, "GeoConicPartParameters", "geogebra.common.kernel.kernelND", NULL, 0x1, 12, methods, 13, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelKernelNDGeoConicPartParameters;
}

@end

void GeogebraCommonKernelKernelNDGeoConicPartParameters_initWithGeogebraCommonKernelKernelNDGeoConicND_withInt_(GeogebraCommonKernelKernelNDGeoConicPartParameters *self, GeogebraCommonKernelKernelNDGeoConicND *conic, jint type) {
  NSObject_init(self);
  self->posOrientation_ = YES;
  self->allowOutlyingIntersections_ = NO;
  self->keepTypeOnGeometricTransform_ = YES;
  GeogebraCommonKernelKernelNDGeoConicPartParameters_set_conic_(self, conic);
  self->conic_part_type_ = type;
}

GeogebraCommonKernelKernelNDGeoConicPartParameters *new_GeogebraCommonKernelKernelNDGeoConicPartParameters_initWithGeogebraCommonKernelKernelNDGeoConicND_withInt_(GeogebraCommonKernelKernelNDGeoConicND *conic, jint type) {
  GeogebraCommonKernelKernelNDGeoConicPartParameters *self = [GeogebraCommonKernelKernelNDGeoConicPartParameters alloc];
  GeogebraCommonKernelKernelNDGeoConicPartParameters_initWithGeogebraCommonKernelKernelNDGeoConicND_withInt_(self, conic, type);
  return self;
}

jdouble GeogebraCommonKernelKernelNDGeoConicPartParameters_computeArgWithDouble_withDouble_(GeogebraCommonKernelKernelNDGeoConicPartParameters *self, jdouble x0, jdouble y0) {
  GeogebraCommonKernelMatrixCoords *b = [((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(self->conic_)) getMidpoint2D];
  jdouble px = x0 - [((GeogebraCommonKernelMatrixCoords *) nil_chk(b)) getX];
  jdouble py = y0 - [b getY];
  jdouble px2 = px * [((GeogebraCommonKernelMatrixCoords *) nil_chk([self->conic_ getEigenvecWithInt:0])) getX] + py * [((GeogebraCommonKernelMatrixCoords *) nil_chk([self->conic_ getEigenvecWithInt:0])) getY];
  py = px * [((GeogebraCommonKernelMatrixCoords *) nil_chk([self->conic_ getEigenvecWithInt:1])) getX] + py * [((GeogebraCommonKernelMatrixCoords *) nil_chk([self->conic_ getEigenvecWithInt:1])) getY];
  jdouble arg = JavaLangMath_atan2WithDouble_withDouble_([self->conic_ getHalfAxisWithInt:0] * py, [self->conic_ getHalfAxisWithInt:1] * px2);
  if (arg < 0) arg += GeogebraCommonKernelKernel_PI_2;
  return arg - self->paramStart_;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelKernelNDGeoConicPartParameters)
