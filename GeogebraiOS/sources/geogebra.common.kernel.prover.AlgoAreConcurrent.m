//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/prover/AlgoAreConcurrent.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/SymbolicParameters.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoBoolean.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/prover/AlgoAreConcurrent.h"
#include "geogebra/common/kernel/prover/NoSymbolicParametersException.h"
#include "geogebra/common/kernel/prover/polynomial/Polynomial.h"
#include "geogebra/common/kernel/prover/polynomial/Variable.h"
#include "java/lang/Math.h"
#include "java/math/BigInteger.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"

@interface GeogebraCommonKernelProverAlgoAreConcurrent () {
 @public
  GeogebraCommonKernelGeosGeoLine *inputLine1_, *inputLine2_, *inputLine3_;
  GeogebraCommonKernelGeosGeoBoolean *outputBoolean_;
  IOSObjectArray *polynomials_;
  IOSObjectArray *botanaPolynomials_;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelProverAlgoAreConcurrent, inputLine1_, GeogebraCommonKernelGeosGeoLine *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelProverAlgoAreConcurrent, inputLine2_, GeogebraCommonKernelGeosGeoLine *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelProverAlgoAreConcurrent, inputLine3_, GeogebraCommonKernelGeosGeoLine *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelProverAlgoAreConcurrent, outputBoolean_, GeogebraCommonKernelGeosGeoBoolean *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelProverAlgoAreConcurrent, polynomials_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelProverAlgoAreConcurrent, botanaPolynomials_, IOSObjectArray *)

__attribute__((unused)) static void GeogebraCommonKernelProverAlgoAreConcurrent_compute(GeogebraCommonKernelProverAlgoAreConcurrent *self);

@implementation GeogebraCommonKernelProverAlgoAreConcurrent

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                                            withNSString:(NSString *)label
                     withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)inputLine1
                     withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)inputLine2
                     withGeogebraCommonKernelGeosGeoLine:(GeogebraCommonKernelGeosGeoLine *)inputLine3 {
  GeogebraCommonKernelProverAlgoAreConcurrent_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoLine_(self, cons, label, inputLine1, inputLine2, inputLine3);
  return self;
}

- (GeogebraCommonKernelCommandsCommandsEnum *)getClassName {
  return GeogebraCommonKernelCommandsCommandsEnum_get_AreConcurrent();
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_setAndConsume_input_(self, [IOSObjectArray newArrayWithLength:3 type:GeogebraCommonKernelGeosGeoElement_class_()]);
  IOSObjectArray_Set(input_, 0, inputLine1_);
  IOSObjectArray_Set(input_, 1, inputLine2_);
  IOSObjectArray_Set(input_, 2, inputLine3_);
  [super setOutputLengthWithInt:1];
  [super setOutputWithInt:0 withGeogebraCommonKernelGeosGeoElement:outputBoolean_];
  [self setDependencies];
}

- (GeogebraCommonKernelGeosGeoBoolean *)getResult {
  return outputBoolean_;
}

- (void)compute {
  GeogebraCommonKernelProverAlgoAreConcurrent_compute(self);
}

- (GeogebraCommonKernelAlgosSymbolicParameters *)getSymbolicParameters {
  return [new_GeogebraCommonKernelAlgosSymbolicParameters_initWithGeogebraCommonKernelAlgosSymbolicParametersAlgo_(self) autorelease];
}

- (void)getFreeVariablesWithJavaUtilHashSet:(JavaUtilHashSet *)variables {
  if (([inputLine1_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) || ([inputLine2_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) || ([inputLine3_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]])) {
    @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  }
  if (inputLine1_ != nil && inputLine2_ != nil && inputLine3_ != nil) {
    [inputLine1_ getFreeVariablesWithJavaUtilHashSet:variables];
    [inputLine2_ getFreeVariablesWithJavaUtilHashSet:variables];
    [inputLine3_ getFreeVariablesWithJavaUtilHashSet:variables];
    return;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSIntArray *)getDegrees {
  if (([inputLine1_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) || ([inputLine2_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) || ([inputLine3_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]])) {
    @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  }
  if (inputLine1_ != nil && inputLine2_ != nil && inputLine3_ != nil) {
    IOSIntArray *degree1 = [inputLine1_ getDegrees];
    IOSIntArray *degree2 = [inputLine2_ getDegrees];
    IOSIntArray *degree3 = [inputLine3_ getDegrees];
    IOSIntArray *result = [IOSIntArray arrayWithLength:1];
    *IOSIntArray_GetRef(result, 0) = JavaLangMath_maxWithInt_withInt_(IOSIntArray_Get(nil_chk(degree1), 0) + IOSIntArray_Get(nil_chk(degree2), 1) + IOSIntArray_Get(nil_chk(degree3), 2), JavaLangMath_maxWithInt_withInt_(IOSIntArray_Get(degree2, 0) + IOSIntArray_Get(degree3, 1) + IOSIntArray_Get(degree1, 2), JavaLangMath_maxWithInt_withInt_(IOSIntArray_Get(degree3, 0) + IOSIntArray_Get(degree1, 1) + IOSIntArray_Get(degree2, 2), JavaLangMath_maxWithInt_withInt_(IOSIntArray_Get(degree3, 0) + IOSIntArray_Get(degree2, 1) + IOSIntArray_Get(degree1, 2), JavaLangMath_maxWithInt_withInt_(IOSIntArray_Get(degree2, 0) + IOSIntArray_Get(degree1, 1) + IOSIntArray_Get(degree3, 2), IOSIntArray_Get(degree1, 0) + IOSIntArray_Get(degree3, 1) + IOSIntArray_Get(degree2, 2))))));
    return result;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getExactCoordinatesWithJavaUtilHashMap:(JavaUtilHashMap *)values {
  if (([inputLine1_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) || ([inputLine2_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) || ([inputLine3_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]])) {
    @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  }
  if (inputLine1_ != nil && inputLine2_ != nil && inputLine3_ != nil) {
    IOSObjectArray *coords1 = [inputLine1_ getExactCoordinatesWithJavaUtilHashMap:values];
    IOSObjectArray *coords2 = [inputLine2_ getExactCoordinatesWithJavaUtilHashMap:values];
    IOSObjectArray *coords3 = [inputLine3_ getExactCoordinatesWithJavaUtilHashMap:values];
    IOSObjectArray *coords = [IOSObjectArray arrayWithLength:1 type:JavaMathBigInteger_class_()];
    IOSObjectArray_Set(coords, 0, [((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk(IOSObjectArray_Get(nil_chk(coords1), 0))) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(nil_chk(coords2), 1)])) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(nil_chk(coords3), 2)])) addWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk(IOSObjectArray_Get(coords2, 0))) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords3, 1)])) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords1, 2)]])) addWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk(IOSObjectArray_Get(coords3, 0))) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords1, 1)])) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords2, 2)]])) subtractWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk(IOSObjectArray_Get(coords3, 0))) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords2, 1)])) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords1, 2)])) addWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk(IOSObjectArray_Get(coords2, 0))) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords1, 1)])) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords3, 2)]])) addWithJavaMathBigInteger:[((JavaMathBigInteger *) nil_chk([((JavaMathBigInteger *) nil_chk(IOSObjectArray_Get(coords1, 0))) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords3, 1)])) multiplyWithJavaMathBigInteger:IOSObjectArray_Get(coords2, 2)]]]);
    return coords;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getPolynomials {
  if (polynomials_ != nil) {
    return polynomials_;
  }
  if (([inputLine1_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) || ([inputLine2_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]]) || ([inputLine3_ isKindOfClass:[GeogebraCommonKernelGeosGeoSegment class]])) {
    @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  }
  if (inputLine1_ != nil && inputLine2_ != nil && inputLine3_ != nil) {
    IOSObjectArray *coords1 = [inputLine1_ getPolynomials];
    IOSObjectArray *coords2 = [inputLine2_ getPolynomials];
    IOSObjectArray *coords3 = [inputLine3_ getPolynomials];
    GeogebraCommonKernelProverAlgoAreConcurrent_setAndConsume_polynomials_(self, [IOSObjectArray newArrayWithLength:1 type:GeogebraCommonKernelProverPolynomialPolynomial_class_()]);
    IOSObjectArray_Set(polynomials_, 0, [((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(IOSObjectArray_Get(nil_chk(coords1), 0))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(nil_chk(coords2), 1)])) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(nil_chk(coords3), 2)])) addWithGeogebraCommonKernelProverPolynomialPolynomial:[((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(IOSObjectArray_Get(coords2, 0))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords3, 1)])) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords1, 2)]])) addWithGeogebraCommonKernelProverPolynomialPolynomial:[((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(IOSObjectArray_Get(coords3, 0))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords1, 1)])) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords2, 2)]])) subtractWithGeogebraCommonKernelProverPolynomialPolynomial:[((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(IOSObjectArray_Get(coords3, 0))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords2, 1)])) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords1, 2)])) addWithGeogebraCommonKernelProverPolynomialPolynomial:[((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(IOSObjectArray_Get(coords2, 0))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords1, 1)])) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords3, 2)]])) addWithGeogebraCommonKernelProverPolynomialPolynomial:[((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk([((GeogebraCommonKernelProverPolynomialPolynomial *) nil_chk(IOSObjectArray_Get(coords1, 0))) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords3, 1)])) multiplyWithGeogebraCommonKernelProverPolynomialPolynomial:IOSObjectArray_Get(coords2, 2)]]]);
    return polynomials_;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getBotanaPolynomials {
  if (botanaPolynomials_ != nil) {
    return botanaPolynomials_;
  }
  if (inputLine1_ != nil && inputLine2_ != nil && inputLine3_ != nil) {
    IOSObjectArray *v = [IOSObjectArray arrayWithDimensions:2 lengths:(jint[]){ 3, 4 } type:GeogebraCommonKernelProverPolynomialVariable_class_()];
    IOSObjectArray_Set(v, 0, [inputLine1_ getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:inputLine1_]);
    IOSObjectArray_Set(v, 1, [inputLine2_ getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:inputLine2_]);
    IOSObjectArray_Set(v, 2, [inputLine3_ getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:inputLine3_]);
    IOSObjectArray *nv = [IOSObjectArray arrayWithLength:2 type:GeogebraCommonKernelProverPolynomialVariable_class_()];
    IOSObjectArray_SetAndConsume(nv, 0, new_GeogebraCommonKernelProverPolynomialVariable_init());
    IOSObjectArray_SetAndConsume(nv, 1, new_GeogebraCommonKernelProverPolynomialVariable_init());
    GeogebraCommonKernelProverAlgoAreConcurrent_setAndConsume_botanaPolynomials_(self, [IOSObjectArray newArrayWithDimensions:2 lengths:(jint[]){ 1, 3 } type:GeogebraCommonKernelProverPolynomialPolynomial_class_()]);
    for (jint i = 0; i < 3; ++i) IOSObjectArray_Set(nil_chk(IOSObjectArray_Get(botanaPolynomials_, 0)), i, GeogebraCommonKernelProverPolynomialPolynomial_collinearWithGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_withGeogebraCommonKernelProverPolynomialVariable_(IOSObjectArray_Get(nil_chk(IOSObjectArray_Get(v, i)), 0), IOSObjectArray_Get(nil_chk(IOSObjectArray_Get(v, i)), 1), IOSObjectArray_Get(nil_chk(IOSObjectArray_Get(v, i)), 2), IOSObjectArray_Get(nil_chk(IOSObjectArray_Get(v, i)), 3), IOSObjectArray_Get(nv, 0), IOSObjectArray_Get(nv, 1)));
    return botanaPolynomials_;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (void)dealloc {
  RELEASE_(inputLine1_);
  RELEASE_(inputLine2_);
  RELEASE_(inputLine3_);
  RELEASE_(outputBoolean_);
  RELEASE_(polynomials_);
  RELEASE_(botanaPolynomials_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withNSString:withGeogebraCommonKernelGeosGeoLine:withGeogebraCommonKernelGeosGeoLine:withGeogebraCommonKernelGeosGeoLine:", "AlgoAreConcurrent", NULL, 0x1, NULL, NULL },
    { "getClassName", NULL, "Lgeogebra.common.kernel.commands.Commands;", 0x1, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x4, NULL, NULL },
    { "getResult", NULL, "Lgeogebra.common.kernel.geos.GeoBoolean;", 0x1, NULL, NULL },
    { "compute", NULL, "V", 0x11, NULL, NULL },
    { "getSymbolicParameters", NULL, "Lgeogebra.common.kernel.algos.SymbolicParameters;", 0x1, NULL, NULL },
    { "getFreeVariablesWithJavaUtilHashSet:", "getFreeVariables", "V", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getDegrees", NULL, "[I", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getExactCoordinatesWithJavaUtilHashMap:", "getExactCoordinates", "[Ljava.math.BigInteger;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getPolynomials", NULL, "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getBotanaPolynomials", NULL, "[[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "inputLine1_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoLine;", NULL, NULL,  },
    { "inputLine2_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoLine;", NULL, NULL,  },
    { "inputLine3_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoLine;", NULL, NULL,  },
    { "outputBoolean_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoBoolean;", NULL, NULL,  },
    { "polynomials_", NULL, 0x2, "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", NULL, NULL,  },
    { "botanaPolynomials_", NULL, 0x2, "[[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelProverAlgoAreConcurrent = { 2, "AlgoAreConcurrent", "geogebra.common.kernel.prover", NULL, 0x1, 11, methods, 6, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelProverAlgoAreConcurrent;
}

@end

void GeogebraCommonKernelProverAlgoAreConcurrent_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoLine_(GeogebraCommonKernelProverAlgoAreConcurrent *self, GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelGeosGeoLine *inputLine1, GeogebraCommonKernelGeosGeoLine *inputLine2, GeogebraCommonKernelGeosGeoLine *inputLine3) {
  GeogebraCommonKernelAlgosAlgoElement_initWithGeogebraCommonKernelConstruction_(self, cons);
  GeogebraCommonKernelProverAlgoAreConcurrent_set_inputLine1_(self, inputLine1);
  GeogebraCommonKernelProverAlgoAreConcurrent_set_inputLine2_(self, inputLine2);
  GeogebraCommonKernelProverAlgoAreConcurrent_set_inputLine3_(self, inputLine3);
  GeogebraCommonKernelProverAlgoAreConcurrent_setAndConsume_outputBoolean_(self, new_GeogebraCommonKernelGeosGeoBoolean_initWithGeogebraCommonKernelConstruction_(cons));
  [self setInputOutput];
  GeogebraCommonKernelProverAlgoAreConcurrent_compute(self);
}

GeogebraCommonKernelProverAlgoAreConcurrent *new_GeogebraCommonKernelProverAlgoAreConcurrent_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoLine_(GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelGeosGeoLine *inputLine1, GeogebraCommonKernelGeosGeoLine *inputLine2, GeogebraCommonKernelGeosGeoLine *inputLine3) {
  GeogebraCommonKernelProverAlgoAreConcurrent *self = [GeogebraCommonKernelProverAlgoAreConcurrent alloc];
  GeogebraCommonKernelProverAlgoAreConcurrent_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoLine_withGeogebraCommonKernelGeosGeoLine_(self, cons, label, inputLine1, inputLine2, inputLine3);
  return self;
}

void GeogebraCommonKernelProverAlgoAreConcurrent_compute(GeogebraCommonKernelProverAlgoAreConcurrent *self) {
  jdouble det = [((GeogebraCommonKernelGeosGeoLine *) nil_chk(self->inputLine1_)) getX] * [((GeogebraCommonKernelGeosGeoLine *) nil_chk(self->inputLine2_)) getY] * [((GeogebraCommonKernelGeosGeoLine *) nil_chk(self->inputLine3_)) getZ] + [self->inputLine2_ getX] * [self->inputLine3_ getY] * [self->inputLine1_ getZ] + [self->inputLine3_ getX] * [self->inputLine1_ getY] * [self->inputLine2_ getZ] - [self->inputLine3_ getX] * [self->inputLine2_ getY] * [self->inputLine1_ getZ] - [self->inputLine2_ getX] * [self->inputLine1_ getY] * [self->inputLine3_ getZ] - [self->inputLine1_ getX] * [self->inputLine3_ getY] * [self->inputLine2_ getZ];
  [((GeogebraCommonKernelGeosGeoBoolean *) nil_chk(self->outputBoolean_)) setValueWithBoolean:GeogebraCommonKernelKernel_isZeroWithDouble_(det)];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelProverAlgoAreConcurrent)
