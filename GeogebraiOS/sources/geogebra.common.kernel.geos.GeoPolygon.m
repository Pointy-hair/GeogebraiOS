//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/geos/GeoPolygon.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GColor.h"
#include "geogebra/common/euclidian/EuclidianView.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/CoordMatrix4x4.h"
#include "geogebra/common/kernel/Matrix/CoordSys.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/MatrixTransformable.h"
#include "geogebra/common/kernel/Path.h"
#include "geogebra/common/kernel/PathMover.h"
#include "geogebra/common/kernel/PathMoverGeneric.h"
#include "geogebra/common/kernel/PathParameter.h"
#include "geogebra/common/kernel/RegionParameters.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoJoinPointsSegment.h"
#include "geogebra/common/kernel/algos/AlgoJoinPointsSegmentInterface.h"
#include "geogebra/common/kernel/algos/AlgoPolygon.h"
#include "geogebra/common/kernel/algos/AlgoPolygonRegularND.h"
#include "geogebra/common/kernel/algos/AlgoTransformation.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/algos/GetCommand.h"
#include "geogebra/common/kernel/algos/PolygonAlgo.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/MyDouble.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/ChangeableCoordParent.h"
#include "geogebra/common/kernel/geos/GeoBoolean.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoPolyLine.h"
#include "geogebra/common/kernel/geos/GeoPolygon.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/kernelND/GeoLineND.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/kernelND/GeoSegmentND.h"
#include "geogebra/common/kernel/prover/NoSymbolicParametersException.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "geogebra/common/util/MyMath.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/ArrayList.h"
#include "java/util/TreeSet.h"

@interface GeogebraCommonKernelGeosGeoPolygon () {
 @public
  jboolean defined_;
  jboolean createSegments_;
  jboolean notFixedPointsLength_;
  JavaUtilArrayList *segmentsArray_;
  JavaUtilArrayList *pointsArray_;
  JavaLangStringBuilder *sbToString_;
  jboolean asBoundary__;
  jboolean trace_;
  jint convexOrientation_;
  GeogebraCommonKernelMatrixCoords *labelPosition_;
  GeogebraCommonKernelGeosChangeableCoordParent *changeableCoordParent_;
  IOSDoubleArray *tmp3_;
  JavaUtilTreeSet *metas_;
  jboolean reverseNormalForDrawing_;
}

- (void)defaultSegmentLabels;

+ (void)setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND:(id<GeogebraCommonKernelKernelNDGeoSegmentND>)s
                  withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p;

+ (jint)intersectOxWithDouble:(jdouble)px1
                   withDouble:(jdouble)py1
                   withDouble:(jdouble)px2
                   withDouble:(jdouble)py2;

- (void)updatePathRegion;

- (void)setPointSizeWithInt:(jint)size;

- (void)setPointNotVisibile;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoPolygon, segmentsArray_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoPolygon, pointsArray_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoPolygon, sbToString_, JavaLangStringBuilder *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoPolygon, labelPosition_, GeogebraCommonKernelMatrixCoords *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoPolygon, changeableCoordParent_, GeogebraCommonKernelGeosChangeableCoordParent *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoPolygon, tmp3_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoPolygon, metas_, JavaUtilTreeSet *)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_defaultSegmentLabels(GeogebraCommonKernelGeosGeoPolygon *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND_withGeogebraCommonKernelKernelNDGeoPointND_(id<GeogebraCommonKernelKernelNDGeoSegmentND> s, id<GeogebraCommonKernelKernelNDGeoPointND> p);

__attribute__((unused)) static id<GeogebraCommonKernelKernelNDGeoPointND> GeogebraCommonKernelGeosGeoPolygon_getPointNDWithInt_(GeogebraCommonKernelGeosGeoPolygon *self, jint i);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_setAreaWithDouble_(GeogebraCommonKernelGeosGeoPolygon *self, jdouble area);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_updateRegionCSWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelGeosGeoPolygon *self, GeogebraCommonKernelGeosGeoPoint *newp0, GeogebraCommonKernelGeosGeoPoint *newp1, GeogebraCommonKernelGeosGeoPoint *newp2);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_updateRegionCS(GeogebraCommonKernelGeosGeoPolygon *self);

__attribute__((unused)) static jint GeogebraCommonKernelGeosGeoPolygon_intersectOxWithDouble_withDouble_withDouble_withDouble_(jdouble px1, jdouble py1, jdouble px2, jdouble py2);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_setChangeableCoordParentWithGeogebraCommonKernelGeosGeoNumeric_withGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoPolygon *self, GeogebraCommonKernelGeosGeoNumeric *number, GeogebraCommonKernelGeosGeoElement *direction);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(GeogebraCommonKernelGeosGeoPolygon *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_setPointSizeWithInt_(GeogebraCommonKernelGeosGeoPolygon *self, jint size);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoPolygon_setPointNotVisibile(GeogebraCommonKernelGeosGeoPolygon *self);

@implementation GeogebraCommonKernelGeosGeoPolygon

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
         withGeogebraCommonKernelKernelNDGeoPointNDArray:(IOSObjectArray *)points {
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_(self, c, points);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
         withGeogebraCommonKernelKernelNDGeoPointNDArray:(IOSObjectArray *)points
                  withGeogebraCommonKernelMatrixCoordSys:(GeogebraCommonKernelMatrixCoordSys *)cs
                                             withBoolean:(jboolean)createSegments {
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_withGeogebraCommonKernelMatrixCoordSys_withBoolean_(self, c, points, cs, createSegments);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons {
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_(self, cons);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                                             withBoolean:(jboolean)isIntersection {
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withBoolean_(self, cons, isIntersection);
  return self;
}

- (void)setCoordSysWithGeogebraCommonKernelMatrixCoordSys:(GeogebraCommonKernelMatrixCoordSys *)cs {
}

- (void)setCoordSysWithGeogebraCommonKernelGeosGeoPolygon:(GeogebraCommonKernelGeosGeoPolygon *)poly {
}

- (void)setCoordSysAndPoints3DWithGeogebraCommonKernelGeosGeoPolygon:(GeogebraCommonKernelGeosGeoPolygon *)p {
}

- (void)setNotFixedPointsLengthWithBoolean:(jboolean)flag {
  notFixedPointsLength_ = flag;
}

- (NSString *)getTypeString {
  if (notFixedPointsLength_ || points_ == nil) return @"Polygon";
  switch ([self getPointsLength]) {
    case 3:
    return @"Triangle";
    case 4:
    return @"Quadrilateral";
    case 5:
    return @"Pentagon";
    case 6:
    return @"Hexagon";
    default:
    return @"Polygon";
  }
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_POLYGON();
}

- (void)setPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:(IOSObjectArray *)points {
  [self setPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:points withGeogebraCommonKernelMatrixCoordSys:nil withBoolean:YES];
}

- (void)setPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:(IOSObjectArray *)points
                          withGeogebraCommonKernelMatrixCoordSys:(GeogebraCommonKernelMatrixCoordSys *)cs
                                                     withBoolean:(jboolean)createSegments {
  GeogebraCommonKernelGeosGeoPolygon_set_points_(self, points);
  [self setCoordSysWithGeogebraCommonKernelMatrixCoordSys:cs];
  if (createSegments) [self updateSegments];
}

- (jint)getPointsLength {
  if ([self getPoints] == nil) return 0;
  return ((IOSObjectArray *) nil_chk([self getPoints]))->size_;
}

- (jdouble)getPointXWithInt:(jint)i {
  return ((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i]))->inhomX_;
}

- (jdouble)getPointYWithInt:(jint)i {
  return ((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i]))->inhomY_;
}

- (void)initLabelsWithNSStringArray:(IOSObjectArray *)labels {
  if ([((GeogebraCommonKernelConstruction *) nil_chk(cons_)) isSuppressLabelsActive]) return;
  initLabelsCalled_ = YES;
  if (labels == nil || labels->size_ == 0) {
    [self setLabelWithNSString:nil];
    if (segments_ != nil) {
      GeogebraCommonKernelGeosGeoPolygon_defaultSegmentLabels(self);
    }
    return;
  }
  [self setLabelWithNSString:IOSObjectArray_Get(nil_chk(labels), 0)];
  if (points_ != nil && segments_ != nil) {
    if (labels->size_ == 1 + segments_->size_ + [self getPointsLength] - 2) {
      jint i = 1;
      for (jint k = 0; k < segments_->size_; k++, i++) {
        [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, k))) setLabelWithNSString:IOSObjectArray_Get(labels, i)];
      }
      for (jint k = 2; k < [self getPointsLength]; k++, i++) {
        [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(points_, k))) setLabelWithNSString:IOSObjectArray_Get(labels, i)];
      }
    }
    else if (labels->size_ == 1 + segments_->size_) {
      jint i = 1;
      for (jint k = 0; k < segments_->size_; k++, i++) {
        [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, k))) setLabelWithNSString:IOSObjectArray_Get(labels, i)];
      }
    }
    else {
      GeogebraCommonKernelGeosGeoPolygon_defaultSegmentLabels(self);
    }
  }
}

- (jboolean)wasInitLabelsCalled {
  return initLabelsCalled_;
}

- (void)defaultSegmentLabels {
  GeogebraCommonKernelGeosGeoPolygon_defaultSegmentLabels(self);
}

+ (void)setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND:(id<GeogebraCommonKernelKernelNDGeoSegmentND>)s
                  withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p {
  GeogebraCommonKernelGeosGeoPolygon_setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND_withGeogebraCommonKernelKernelNDGeoPointND_(s, p);
}

- (void)updateSegments {
  if (points_ == nil) return;
  [self setDefined];
  jboolean euclidianVisible;
  if (segmentsArray_ == nil) {
    GeogebraCommonKernelGeosGeoPolygon_setAndConsume_segmentsArray_(self, new_JavaUtilArrayList_init());
  }
  if ([((JavaUtilArrayList *) nil_chk(segmentsArray_)) size] < 1) {
    euclidianVisible = [self isEuclidianVisible];
  }
  else {
    euclidianVisible = [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk([segmentsArray_ getWithInt:0])) isEuclidianVisible];
  }
  GeogebraCommonKernelGeosGeoPolygon_setAndConsume_segments_(self, [IOSObjectArray newArrayWithLength:[self getPointsLength] type:GeogebraCommonKernelKernelNDGeoSegmentND_class_()]);
  for (jint i = 0; i < [segmentsArray_ size] && i < ((IOSObjectArray *) nil_chk(points_))->size_; i++) {
    id<GeogebraCommonKernelKernelNDGeoPointND> startPoint = IOSObjectArray_Get(nil_chk(points_), i);
    id<GeogebraCommonKernelKernelNDGeoPointND> endPoint = IOSObjectArray_Get(points_, (i + 1) % [self getPointsLength]);
    id<GeogebraCommonKernelKernelNDGeoSegmentND> segment = [segmentsArray_ getWithInt:i];
    id<GeogebraCommonKernelAlgosAlgoJoinPointsSegmentInterface> algo = (id<GeogebraCommonKernelAlgosAlgoJoinPointsSegmentInterface>) check_protocol_cast([((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(segment)) getParentAlgorithm], @protocol(GeogebraCommonKernelAlgosAlgoJoinPointsSegmentInterface));
    [((id<GeogebraCommonKernelAlgosAlgoJoinPointsSegmentInterface>) nil_chk(algo)) modifyInputPointsWithGeogebraCommonKernelKernelNDGeoPointND:startPoint withGeogebraCommonKernelKernelNDGeoPointND:endPoint];
    [algo compute];
    IOSObjectArray_Set(segments_, i, segment);
    [segment setEuclidianVisibleWithBoolean:euclidianVisible];
  }
  for (jint i = [segmentsArray_ size]; i < ((IOSObjectArray *) nil_chk(points_))->size_; i++) {
    id<GeogebraCommonKernelKernelNDGeoPointND> startPoint = IOSObjectArray_Get(points_, i);
    id<GeogebraCommonKernelKernelNDGeoPointND> endPoint = IOSObjectArray_Get(points_, (i + 1) % [self getPointsLength]);
    id<GeogebraCommonKernelKernelNDGeoSegmentND> segment = [self createSegmentWithGeogebraCommonKernelKernelNDGeoPointND:startPoint withGeogebraCommonKernelKernelNDGeoPointND:endPoint withBoolean:euclidianVisible];
    [((GeogebraCommonKernelAlgosAlgoElement *) nil_chk([((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(segment)) getParentAlgorithm])) setProtectedInputWithBoolean:YES];
    [segmentsArray_ addWithId:segment];
    IOSObjectArray_Set(segments_, i, segment);
  }
  for (jint i = points_->size_; i < [segmentsArray_ size]; i++) {
    [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk([segmentsArray_ getWithInt:i])) setUndefined];
  }
}

- (id<GeogebraCommonKernelKernelNDGeoSegmentND>)createSegmentWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)startPoint
                                                             withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)endPoint
                                                                                            withBoolean:(jboolean)euclidianVisible {
  GeogebraCommonKernelAlgosAlgoJoinPointsSegment *algoSegment = [new_GeogebraCommonKernelAlgosAlgoJoinPointsSegment_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPolygon_(cons_, (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(startPoint, [GeogebraCommonKernelGeosGeoPoint class]), (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(endPoint, [GeogebraCommonKernelGeosGeoPoint class]), self) autorelease];
  [((GeogebraCommonKernelConstruction *) nil_chk(cons_)) removeFromConstructionListWithGeogebraCommonKernelAlgosConstructionElement:algoSegment];
  return [self createSegmentWithGeogebraCommonKernelKernelNDGeoSegmentND:[algoSegment getSegment] withBoolean:euclidianVisible];
}

- (id<GeogebraCommonKernelKernelNDGeoSegmentND>)createSegmentWithGeogebraCommonKernelKernelNDGeoSegmentND:(id<GeogebraCommonKernelKernelNDGeoSegmentND>)segment
                                                                                              withBoolean:(jboolean)euclidianVisible {
  [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(segment)) setObjColorWithGeogebraCommonAwtGColor:[self getObjectColor]];
  [segment setLineThicknessWithInt:[self getLineThickness]];
  [segment setLineTypeWithInt:[self getLineType]];
  [segment setEuclidianVisibleWithBoolean:euclidianVisible];
  if (condShowObject_ != nil) {
    @try {
      [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(segment, [GeogebraCommonKernelGeosGeoElement class])) setShowObjectConditionWithGeogebraCommonKernelGeosGeoBoolean:[self getShowObjectCondition]];
    }
    @catch (JavaLangException *e) {
    }
  }
  return segment;
}

- (GeogebraCommonKernelGeosGeoElement *)copy__ {
  return [new_GeogebraCommonKernelGeosGeoNumeric_initWithGeogebraCommonKernelConstruction_withDouble_(cons_, [self getArea]) autorelease];
}

- (GeogebraCommonKernelGeosGeoElement *)copyInternalWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons1 {
  GeogebraCommonKernelGeosGeoPolygon *ret = [self newGeoPolygonWithGeogebraCommonKernelConstruction:cons1];
  [self copyInternalWithGeogebraCommonKernelConstruction:cons1 withGeogebraCommonKernelGeosGeoPolygon:ret];
  return ret;
}

- (void)copyInternalWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons1
                  withGeogebraCommonKernelGeosGeoPolygon:(GeogebraCommonKernelGeosGeoPolygon *)ret {
  [((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(ret)) setPoints2DWithGeogebraCommonKernelGeosGeoPointArray:GeogebraCommonKernelGeosGeoElement_copyPointsWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_(cons1, [self getPoints])];
  [ret setWithGeogebraCommonKernelGeosGeoElement:self];
}

- (GeogebraCommonKernelGeosGeoPolygon *)newGeoPolygonWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons1 {
  return [new_GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_(cons_, nil) autorelease];
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  GeogebraCommonKernelGeosGeoPolygon *poly = (GeogebraCommonKernelGeosGeoPolygon *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoPolygon class]);
  area_ = ((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(poly))->area_;
  [self setReverseNormalForDrawingWithBoolean:[poly getReverseNormalForDrawing]];
  if (!notFixedPointsLength_) {
    notFixedPointsLength_ = poly->notFixedPointsLength_;
  }
  if ([poly getPoints] == nil) {
    [self setUndefined];
    return;
  }
  jint polyLength = ((IOSObjectArray *) nil_chk([poly getPoints]))->size_;
  [self setPointsLengthWithInt:polyLength withGeogebraCommonKernelKernelNDGeoPointNDArray:nil];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk([self getPoints]))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) setWithGeogebraCommonKernelGeosGeoElement:[((GeogebraCommonKernelGeosGeoPoint *) nil_chk([poly getPointWithInt:i])) toGeoElement]];
  }
  [self setCoordSysAndPoints3DWithGeogebraCommonKernelGeosGeoPolygon:poly];
  [self updateSegments];
  defined_ = poly->defined_;
  if ([poly hasChangeableCoordParentNumbers]) GeogebraCommonKernelGeosGeoPolygon_setChangeableCoordParentWithGeogebraCommonKernelGeosGeoNumeric_withGeogebraCommonKernelGeosGeoElement_(self, [((GeogebraCommonKernelGeosChangeableCoordParent *) nil_chk(poly->changeableCoordParent_)) getNumber], [poly->changeableCoordParent_ getDirector]);
  GeogebraCommonKernelGeosGeoPolygon_updateRegionCS(self);
}

- (void)setPointsAndSegmentsWithGeogebraCommonKernelKernelNDGeoPointNDArray:(IOSObjectArray *)geos {
  [self setPointsLengthWithInt:((IOSObjectArray *) nil_chk(geos))->size_ withGeogebraCommonKernelKernelNDGeoPointNDArray:geos];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk([self getPoints]))->size_; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) setWithGeogebraCommonKernelKernelNDGeoPointND:IOSObjectArray_Get(geos, i)];
  }
  [self updateSegments];
}

- (void)setPointsAndSegmentsLengthWithInt:(jint)polyLength {
  [self setPointsLengthWithInt:polyLength withGeogebraCommonKernelKernelNDGeoPointNDArray:nil];
  [self updateSegments];
}

- (void)setPointsLengthWithInt:(jint)polyLength
withGeogebraCommonKernelKernelNDGeoPointNDArray:(IOSObjectArray *)template_ {
  if (pointsArray_ == nil) {
    GeogebraCommonKernelGeosGeoPolygon_setAndConsume_pointsArray_(self, new_JavaUtilArrayList_init());
  }
  for (jint i = [((JavaUtilArrayList *) nil_chk(pointsArray_)) size]; i < polyLength; i++) {
    if (template_ != nil && template_->size_ > i && [IOSObjectArray_Get(template_, i) isKindOfClass:[GeogebraCommonKernelGeosGeoPoint class]]) {
      [pointsArray_ addWithId:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(template_, i), [GeogebraCommonKernelGeosGeoPoint class])];
    }
    else {
      [pointsArray_ addWithId:[new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons_) autorelease]];
    }
  }
  for (jint i = polyLength; i < [pointsArray_ size]; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([pointsArray_ getWithInt:i])) setUndefined];
  }
  if ([self getPoints] == nil || ((IOSObjectArray *) nil_chk([self getPoints]))->size_ != polyLength) {
    IOSObjectArray *tempPoints = [IOSObjectArray arrayWithLength:polyLength type:GeogebraCommonKernelGeosGeoPoint_class_()];
    for (jint i = 0; i < polyLength; i++) {
      IOSObjectArray_Set(tempPoints, i, [pointsArray_ getWithInt:i]);
    }
    [self setPoints2DWithGeogebraCommonKernelGeosGeoPointArray:tempPoints];
  }
}

- (GeogebraCommonKernelGeosGeoPoint *)getPointWithInt:(jint)i {
  return (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(IOSObjectArray_Get(nil_chk(points_), i), [GeogebraCommonKernelGeosGeoPoint class]);
}

- (IOSObjectArray *)getPoints {
  return points_;
}

- (void)setPoints2DWithGeogebraCommonKernelGeosGeoPointArray:(IOSObjectArray *)points {
  GeogebraCommonKernelGeosGeoPolygon_set_points_(self, points);
}

- (IOSObjectArray *)getPointsND {
  return points_;
}

- (id<GeogebraCommonKernelKernelNDGeoPointND>)getPointNDWithInt:(jint)i {
  return GeogebraCommonKernelGeosGeoPolygon_getPointNDWithInt_(self, i);
}

- (IOSObjectArray *)getSegments {
  return segments_;
}

- (void)setSegmentsWithGeogebraCommonKernelKernelNDGeoSegmentNDArray:(IOSObjectArray *)segments {
  GeogebraCommonKernelGeosGeoPolygon_set_segments_(self, segments);
}

- (jboolean)isFillable {
  return YES;
}

- (jboolean)isInverseFillable {
  return [self isFillable];
}

- (void)setAreaWithDouble:(jdouble)area {
  GeogebraCommonKernelGeosGeoPolygon_setAreaWithDouble_(self, area);
}

- (jdouble)getArea {
  if ([self isDefined]) {
    return JavaLangMath_absWithDouble_(area_);
  }
  return JavaLangDouble_NaN;
}

- (jdouble)getMeasure {
  return [self getArea];
}

- (id<GeogebraCommonKernelPath>)getBoundary {
  jboolean suppress = [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) isSuppressLabelsActive];
  [((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonKernelConstruction *) nil_chk([self getConstruction])) getKernel])) setSilentModeWithBoolean:YES];
  IOSObjectArray *pointsForPolyLine = [IOSObjectArray arrayWithLength:[self getPointsLength] + 1 type:GeogebraCommonKernelKernelNDGeoPointND_class_()];
  JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(points_, 0, pointsForPolyLine, 0, [self getPointsLength]);
  IOSObjectArray_Set(pointsForPolyLine, [self getPointsLength], IOSObjectArray_Get(pointsForPolyLine, 0));
  GeogebraCommonKernelGeosGeoPolyLine *pl = [new_GeogebraCommonKernelGeosGeoPolyLine_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_([self getConstruction], pointsForPolyLine) autorelease];
  [((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonKernelConstruction *) nil_chk([self getConstruction])) getKernel])) setSilentModeWithBoolean:NO];
  [cons_ setSuppressLabelCreationWithBoolean:suppress];
  return pl;
}

- (jdouble)getDirection {
  if (defined_) {
    return GeogebraCommonUtilMyMath_sgnWithGeogebraCommonKernelKernel_withDouble_(kernel_, area_);
  }
  return JavaLangDouble_NaN;
}

- (jdouble)getAreaWithSign {
  if (defined_) {
    return area_;
  }
  return JavaLangDouble_NaN;
}

- (jboolean)isDefined {
  return defined_;
}

- (void)setDefined {
  defined_ = YES;
}

- (void)setUndefined {
  defined_ = NO;
}

- (jboolean)showInAlgebraView {
  return YES;
}

- (jboolean)hasLineOpacity {
  return YES;
}

- (void)setLineOpacityWithInt:(jint)lineOpacity {
  [self setLineOpacityWithInt:lineOpacity withBoolean:YES];
}

- (void)setLineOpacityWithInt:(jint)lineOpacity
                  withBoolean:(jboolean)updateSegments {
  [super setLineOpacityWithInt:lineOpacity];
  if (updateSegments && segments_ != nil) {
    for (jint i = 0; i < segments_->size_; i++) {
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) setLineOpacityWithInt:lineOpacity];
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) updateVisualStyle];
    }
  }
}

- (jboolean)hasSameAreaWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoPolygon]) {
    return GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([self getArea], [((GeogebraCommonKernelGeosGeoPolygon *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoPolygon class])) getArea]);
  }
  return NO;
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoElement3D]) {
    return [geo isEqualWithGeogebraCommonKernelGeosGeoElement:self];
  }
  if ([geo isGeoPolygon]) {
    GeogebraCommonKernelGeosGeoPolygon *g = (GeogebraCommonKernelGeosGeoPolygon *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoPolygon class]);
    jint gLength = [g getPointsLength];
    if (gLength == [self getPointsLength]) {
      GeogebraCommonKernelGeosGeoPoint *firstPoint = [self getPointWithInt:0];
      jboolean fPointFound = NO;
      jint iFirstPoint = 0;
      while ((!fPointFound) && (iFirstPoint < gLength)) {
        if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(firstPoint)) isEqualWithGeogebraCommonKernelGeosGeoElement:[g getPointWithInt:iFirstPoint]]) {
          fPointFound = YES;
        }
        else {
          iFirstPoint++;
        }
      }
      if (fPointFound) {
        jboolean sPointFound = NO;
        jint step = 1;
        if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:1])) isEqualWithGeogebraCommonKernelGeosGeoElement:[g getPointWithInt:(iFirstPoint + step) % gLength]]) {
          sPointFound = YES;
        }
        else {
          step = -1;
          jint j = iFirstPoint + step;
          if (j < 0) j = gLength - 1;
          if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:1])) isEqualWithGeogebraCommonKernelGeosGeoElement:[g getPointWithInt:j]]) {
            sPointFound = YES;
          }
        }
        if (sPointFound) {
          jint i = 2;
          jint j = iFirstPoint + step + step;
          if (j < 0) j = j + gLength;
          j = j % gLength;
          jboolean pointOK = YES;
          while ((pointOK) && (i < gLength)) {
            pointOK = ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) isEqualWithGeogebraCommonKernelGeosGeoElement:[g getPointWithInt:j]]);
            if (pointOK) {
              j = j + step;
              if (j < 0) j = gLength - 1;
              j = j % gLength;
              i++;
            }
            return pointOK;
          }
        }
      }
    }
  }
  return NO;
}

- (void)setEuclidianVisibleWithBoolean:(jboolean)visible {
  [self setEuclidianVisibleWithBoolean:visible withBoolean:YES];
}

- (void)setEuclidianVisibleWithBoolean:(jboolean)visible
                           withBoolean:(jboolean)updateSegments {
  [super setEuclidianVisibleWithBoolean:visible];
  if (updateSegments && segments_ != nil) {
    for (jint i = 0; i < segments_->size_; i++) {
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) setEuclidianVisibleWithBoolean:visible];
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) updateVisualStyle];
    }
  }
}

- (void)setObjColorWithGeogebraCommonAwtGColor:(GeogebraCommonAwtGColor *)color {
  [super setObjColorWithGeogebraCommonAwtGColor:color];
  if (segments_ != nil && createSegments_) {
    for (jint i = 0; i < segments_->size_; i++) {
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) setObjColorWithGeogebraCommonAwtGColor:color];
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) updateVisualStyle];
    }
  }
}

- (void)setLineTypeWithInt:(jint)type {
  [self setLineTypeWithInt:type withBoolean:YES];
}

- (void)setLineTypeWithInt:(jint)type
               withBoolean:(jboolean)updateSegments {
  [super setLineTypeWithInt:type];
  if (updateSegments) if (segments_ != nil) {
    for (jint i = 0; i < segments_->size_; i++) {
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) setLineTypeWithInt:type];
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) updateVisualStyle];
    }
  }
}

- (void)setLineTypeHiddenWithInt:(jint)type {
  [self setLineTypeHiddenWithInt:type withBoolean:YES];
}

- (void)setLineTypeHiddenWithInt:(jint)type
                     withBoolean:(jboolean)updateSegments {
  [super setLineTypeHiddenWithInt:type];
  if (updateSegments) if (segments_ != nil) {
    for (jint i = 0; i < segments_->size_; i++) {
      [((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(segments_, i), [GeogebraCommonKernelGeosGeoElement class])))) setLineTypeHiddenWithInt:type];
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) updateVisualStyle];
    }
  }
}

- (void)setLineThicknessWithInt:(jint)th {
  [self setLineThicknessWithInt:th withBoolean:YES];
}

- (void)setLineThicknessWithInt:(jint)th
                    withBoolean:(jboolean)updateSegments {
  [super setLineThicknessWithInt:th];
  if (updateSegments) if (segments_ != nil) {
    for (jint i = 0; i < segments_->size_; i++) {
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) setLineThicknessWithInt:th];
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) updateVisualStyle];
    }
  }
}

- (void)setLineThicknessOrVisibilityWithInt:(jint)th {
  [super setLineThicknessWithInt:th];
  if (segments_ != nil) {
    for (jint i = 0; i < segments_->size_; i++) {
      [((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast(IOSObjectArray_Get(segments_, i), [GeogebraCommonKernelGeosGeoElement class])))) setLineThicknessOrVisibilityWithInt:th];
      [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) updateVisualStyle];
    }
  }
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  [((JavaLangStringBuilder *) nil_chk(sbToString_)) setLengthWithInt:0];
  [sbToString_ appendWithNSString:label_];
  [sbToString_ appendWithNSString:@" = "];
  [sbToString_ appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatWithDouble:[self getArea] withGeogebraCommonKernelStringTemplate:tpl]];
  return [sbToString_ description];
}

- (NSString *)toStringMinimalWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  [((JavaLangStringBuilder *) nil_chk(sbToString_)) setLengthWithInt:0];
  [sbToString_ appendWithNSString:[self regrFormatWithDouble:[self getArea]]];
  return [sbToString_ description];
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatWithDouble:[self getArea] withGeogebraCommonKernelStringTemplate:tpl];
}

- (GeogebraCommonKernelArithmeticMyDouble *)getNumber {
  return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [self getArea]) autorelease];
}

- (jdouble)getDouble {
  return [self getArea];
}

- (jboolean)showInEuclidianView {
  return defined_;
}

- (jboolean)isNumberValue {
  return YES;
}

- (jboolean)isGeoPolygon {
  return YES;
}

- (jboolean)isPath {
  return YES;
}

- (id<GeogebraCommonKernelPathMover>)createPathMover {
  return [new_GeogebraCommonKernelPathMoverGeneric_initWithGeogebraCommonKernelPath_(self) autorelease];
}

- (jdouble)getMaxParameter {
  return [self getPointsLength];
}

- (jdouble)getMinParameter {
  return 0;
}

- (jboolean)isClosedPath {
  return YES;
}

- (jboolean)isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI
                                                    withDouble:(jdouble)eps {
  GeogebraCommonKernelGeosGeoPoint *P = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(PI, [GeogebraCommonKernelGeosGeoPoint class]);
  if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P)) getPath] == self) return YES;
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(segments_))->size_; i++) {
    if ([((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:P withDouble:eps]) return YES;
  }
  return NO;
}

- (jboolean)isOnPathWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)coords
                                              withDouble:(jdouble)eps {
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(segments_))->size_; i++) {
    if ([((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) isOnPathWithGeogebraCommonKernelMatrixCoords:coords withDouble:eps]) return YES;
  }
  return NO;
}

- (void)pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  if (![((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) usePathAndRegionParametersWithGeogebraCommonKernelKernelNDGeoPointND:PI]) {
    [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:PI];
    return;
  }
  GeogebraCommonKernelPathParameter *pp = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(PI)) getPathParameter];
  ((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_ = fmod(pp->t_, ((IOSObjectArray *) nil_chk(segments_))->size_);
  if (pp->t_ < 0) pp->t_ += segments_->size_;
  jint index = J2ObjCFpToInt(JavaLangMath_floorWithDouble_(pp->t_));
  id<GeogebraCommonKernelKernelNDGeoSegmentND> seg = IOSObjectArray_Get(segments_, index);
  jdouble segParameter = pp->t_ - index;
  [PI setCoords2DWithDouble:[((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(seg)) getPointXWithDouble:segParameter] withDouble:[seg getPointYWithDouble:segParameter] withDouble:1];
}

- (void)pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(PI)) getCoordsInD2];
  jdouble qx = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] / [coords getZ];
  jdouble qy = [coords getY] / [coords getZ];
  jdouble minDist = JavaLangDouble_POSITIVE_INFINITY;
  jdouble resx = 0, resy = 0, resz = 0, param = 0;
  GeogebraCommonKernelPathParameter *pp = [PI getPathParameter];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(segments_))->size_; i++) {
    [PI setCoords2DWithDouble:qx withDouble:qy withDouble:1];
    [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(IOSObjectArray_Get(segments_, i))) pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:PI];
    coords = [PI getCoordsInD2];
    jdouble x = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] / [coords getZ] - qx;
    jdouble y = [coords getY] / [coords getZ] - qy;
    jdouble dist = x * x + y * y;
    if (dist < minDist) {
      minDist = dist;
      resx = [coords getX];
      resy = [coords getY];
      resz = [coords getZ];
      param = i + ((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_;
    }
  }
  [PI setCoords2DWithDouble:resx withDouble:resy withDouble:resz];
  ((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_ = param;
}

- (jboolean)isRegion {
  return YES;
}

- (jboolean)isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI
                                                     withBoolean:(jboolean)update {
  GeogebraCommonKernelMatrixCoords *coords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(PI)) getCoordsInD2];
  return [self isInRegionWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] / [coords getZ] withDouble:[coords getY] / [coords getZ]];
}

- (jboolean)isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  return [self isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:PI withBoolean:NO];
}

- (jboolean)isInRegionWithDouble:(jdouble)x0
                      withDouble:(jdouble)y0 {
  jdouble x1, y1, x2, y2;
  jint numPoints = [self getPointsLength];
  x1 = [self getPointXWithInt:numPoints - 1] - x0;
  y1 = [self getPointYWithInt:numPoints - 1] - y0;
  jboolean ret = NO;
  for (jint i = 0; i < numPoints; i++) {
    x2 = [self getPointXWithInt:i] - x0;
    y2 = [self getPointYWithInt:i] - y0;
    jint inter = GeogebraCommonKernelGeosGeoPolygon_intersectOxWithDouble_withDouble_withDouble_withDouble_(x1, y1, x2, y2);
    if (inter == 2) return YES;
    ret = (ret ^ (inter == 1));
    x1 = x2;
    y1 = y2;
  }
  return ret;
}

- (void)regionChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  if (![((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) usePathAndRegionParametersWithGeogebraCommonKernelKernelNDGeoPointND:P]) {
    [self pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:P];
    return;
  }
  GeogebraCommonKernelRegionParameters *rp = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getRegionParameters];
  if ([((GeogebraCommonKernelRegionParameters *) nil_chk(rp)) isOnPath]) [self pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
  else {
    jdouble xu = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p1_))->inhomX_ - ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p0_))->inhomX_;
    jdouble yu = p1_->inhomY_ - p0_->inhomY_;
    jdouble xv = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p2_))->inhomX_ - p0_->inhomX_;
    jdouble yv = p2_->inhomY_ - p0_->inhomY_;
    [self setRegionChangedWithGeogebraCommonKernelKernelNDGeoPointND:P withDouble:p0_->inhomX_ + [rp getT1] * xu + [rp getT2] * xv withDouble:p0_->inhomY_ + [rp getT1] * yu + [rp getT2] * yv];
    if (![self isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:P withBoolean:NO]) {
      [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
      [rp setIsOnPathWithBoolean:YES];
    }
  }
}

- (void)setRegionChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI
                                                        withDouble:(jdouble)x
                                                        withDouble:(jdouble)y {
  GeogebraCommonKernelGeosGeoPoint *P = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(PI, [GeogebraCommonKernelGeosGeoPoint class]);
  ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P))->x_ = x;
  P->y_ = y;
  P->z_ = 1;
}

- (void)pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) updateCoords2D];
  GeogebraCommonKernelRegionParameters *rp = [P getRegionParameters];
  if (![self isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:P]) {
    [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
    [((GeogebraCommonKernelRegionParameters *) nil_chk(rp)) setIsOnPathWithBoolean:YES];
  }
  else {
    if (numCS_ != 3) {
      [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
      [((GeogebraCommonKernelRegionParameters *) nil_chk(rp)) setIsOnPathWithBoolean:YES];
    }
    else {
      [((GeogebraCommonKernelRegionParameters *) nil_chk(rp)) setIsOnPathWithBoolean:NO];
      jdouble xu = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p1_))->inhomX_ - ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p0_))->inhomX_;
      jdouble yu = p1_->inhomY_ - p0_->inhomY_;
      jdouble xv = ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p2_))->inhomX_ - p0_->inhomX_;
      jdouble yv = p2_->inhomY_ - p0_->inhomY_;
      jdouble x = [P getX2D] - p0_->inhomX_;
      jdouble y = [P getY2D] - p0_->inhomY_;
      [rp setT1WithDouble:(xv * y - x * yv) / (xv * yu - xu * yv)];
      [rp setT2WithDouble:(x * yu - xu * y) / (xv * yu - xu * yv)];
      [P updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:nil];
    }
  }
}

- (void)updateRegionCSWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)newp0
                      withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)newp1
                      withGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)newp2 {
  GeogebraCommonKernelGeosGeoPolygon_updateRegionCSWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(self, newp0, newp1, newp2);
}

- (void)updateRegionCSWithFirstPoints {
  GeogebraCommonKernelGeosGeoPolygon_updateRegionCSWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(self, [self getPointWithInt:0], [self getPointWithInt:1], [self getPointWithInt:2]);
}

- (void)updateRegionCS {
  GeogebraCommonKernelGeosGeoPolygon_updateRegionCS(self);
}

- (void)setRoleWithBoolean:(jboolean)isAsBoundary {
  self->asBoundary__ = isAsBoundary;
}

- (jboolean)asBoundary {
  return asBoundary__;
}

+ (jint)intersectOxWithDouble:(jdouble)px1
                   withDouble:(jdouble)py1
                   withDouble:(jdouble)px2
                   withDouble:(jdouble)py2 {
  return GeogebraCommonKernelGeosGeoPolygon_intersectOxWithDouble_withDouble_withDouble_withDouble_(px1, py1, px2, py2);
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [self getLineStyleXMLWithJavaLangStringBuilder:sb];
  [self getXMLvisualTagsWithJavaLangStringBuilder:sb];
  [self getXMLanimationTagsWithJavaLangStringBuilder:sb];
  [self getXMLfixedTagWithJavaLangStringBuilder:sb];
  [self getAuxiliaryXMLWithJavaLangStringBuilder:sb];
  [self getBreakpointXMLWithJavaLangStringBuilder:sb];
  [self getScriptTagsWithJavaLangStringBuilder:sb];
}

- (jint)getMinimumLineThickness {
  return 0;
}

- (jboolean)isTraceable {
  return YES;
}

- (void)setTraceWithBoolean:(jboolean)trace {
  self->trace_ = trace;
}

- (jboolean)getTrace {
  return trace_;
}

- (GeogebraCommonKernelMatrixCoords *)getPoint3DWithInt:(jint)i {
  return [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) getInhomCoordsInD3];
}

- (jboolean)isPartOfClosedSurface {
  return NO;
}

- (jboolean)isConvex {
  JavaUtilArrayList *xList = [new_JavaUtilArrayList_init() autorelease];
  JavaUtilArrayList *yList = [new_JavaUtilArrayList_init() autorelease];
  jdouble x0 = [self getPointXWithInt:0];
  jdouble y0 = [self getPointYWithInt:0];
  [xList addWithId:JavaLangDouble_valueOfWithDouble_(x0)];
  [yList addWithId:JavaLangDouble_valueOfWithDouble_(y0)];
  for (jint i = 1; i < [self getPointsLength]; i++) {
    jdouble x1 = [self getPointXWithInt:i];
    jdouble y1 = [self getPointYWithInt:i];
    if (!GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(x0, x1) || !GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(y0, y1)) {
      [xList addWithId:JavaLangDouble_valueOfWithDouble_(x1)];
      [yList addWithId:JavaLangDouble_valueOfWithDouble_(y1)];
      x0 = x1;
      y0 = y1;
    }
  }
  jint n = [xList size];
  if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([((JavaLangDouble *) nil_chk([xList getWithInt:0])) doubleValue], [((JavaLangDouble *) nil_chk([xList getWithInt:n - 1])) doubleValue]) && GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([((JavaLangDouble *) nil_chk([yList getWithInt:0])) doubleValue], [((JavaLangDouble *) nil_chk([yList getWithInt:n - 1])) doubleValue])) {
    [xList removeWithInt:n - 1];
    [yList removeWithInt:n - 1];
    n--;
  }
  jboolean answer = YES;
  jboolean hasAngle360 = NO;
  jdouble x1 = [((JavaLangDouble *) nil_chk([xList getWithInt:n - 1])) doubleValue];
  jdouble y1 = [((JavaLangDouble *) nil_chk([yList getWithInt:n - 1])) doubleValue];
  jdouble dx1 = x1 - [((JavaLangDouble *) nil_chk([xList getWithInt:n - 2])) doubleValue];
  jdouble dy1 = y1 - [((JavaLangDouble *) nil_chk([yList getWithInt:n - 2])) doubleValue];
  jdouble x2 = [((JavaLangDouble *) nil_chk([xList getWithInt:0])) doubleValue];
  jdouble y2 = [((JavaLangDouble *) nil_chk([yList getWithInt:0])) doubleValue];
  jdouble dx2 = x2 - x1;
  jdouble dy2 = y2 - y1;
  jint orientation = GeogebraCommonKernelKernel_compareWithDouble_withDouble_(dy1 * dx2, dx1 * dy2);
  if (orientation == 0) {
    if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(0, dx1 * dx2 + dy1 * dy2)) {
      answer = NO;
    }
  }
  jint i = 1;
  while ((answer == YES) && (i < n)) {
    dx1 = dx2;
    dy1 = dy2;
    x1 = x2;
    y1 = y2;
    x2 = [((JavaLangDouble *) nil_chk([xList getWithInt:i])) doubleValue];
    y2 = [((JavaLangDouble *) nil_chk([yList getWithInt:i])) doubleValue];
    dx2 = x2 - x1;
    dy2 = y2 - y1;
    jint orientation2 = GeogebraCommonKernelKernel_compareWithDouble_withDouble_(dy1 * dx2, dx1 * dy2);
    if (!hasAngle360 && orientation2 == 0) {
      if (GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(0, dx1 * dx2 + dy1 * dy2)) {
        answer = NO;
      }
    }
    if (answer) {
      if (orientation == 0) {
        orientation = orientation2;
      }
      else {
        if (orientation2 != 0 && orientation2 != orientation) {
          answer = NO;
        }
      }
    }
    i++;
  }
  if (answer) {
    convexOrientation_ = orientation;
  }
  return answer;
}

- (jboolean)isConvexInverseDirection {
  return (convexOrientation_ > 0);
}

- (jboolean)hasDrawable3D {
  return YES;
}

- (GeogebraCommonKernelMatrixCoords *)getLabelPosition {
  jdouble x = 0;
  jdouble y = 0;
  jdouble z = 0;
  for (jint i = 0; i < [self getPointsLength]; i++) {
    GeogebraCommonKernelMatrixCoords *coords = [self getPoint3DWithInt:i];
    x += [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX];
    y += [coords getY];
    z += [coords getZ];
  }
  if (labelPosition_ == nil) {
    GeogebraCommonKernelGeosGeoPolygon_setAndConsume_labelPosition_(self, new_GeogebraCommonKernelMatrixCoords_initWithDouble_withDouble_withDouble_withDouble_(x / [self getPointsLength], y / [self getPointsLength], z / [self getPointsLength], 1));
  }
  else {
    [labelPosition_ setXWithDouble:x / [self getPointsLength]];
    [labelPosition_ setYWithDouble:y / [self getPointsLength]];
    [labelPosition_ setZWithDouble:z / [self getPointsLength]];
  }
  return labelPosition_;
}

- (GeogebraCommonKernelMatrixCoordSys *)getCoordSys {
  return GeogebraCommonKernelMatrixCoordSys_get_Identity3D_();
}

- (GeogebraCommonKernelMatrixCoords *)getPointWithDouble:(jdouble)x2d
                                              withDouble:(jdouble)y2d {
  return [((GeogebraCommonKernelMatrixCoordSys *) nil_chk([self getCoordSys])) getPointWithDouble:x2d withDouble:y2d];
}

- (IOSObjectArray *)getNormalProjectionWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)coords {
  return [((GeogebraCommonKernelMatrixCoordSys *) nil_chk([self getCoordSys])) getNormalProjectionWithGeogebraCommonKernelMatrixCoords:coords];
}

- (IOSObjectArray *)getProjectionWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)oldCoords
                                 withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)willingCoords
                                 withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)willingDirection {
  IOSObjectArray *result = [IOSObjectArray arrayWithObjects:(id[]){ [new_GeogebraCommonKernelMatrixCoords_initWithInt_(4) autorelease], [new_GeogebraCommonKernelMatrixCoords_initWithInt_(4) autorelease] } count:2 type:GeogebraCommonKernelMatrixCoords_class_()];
  [((GeogebraCommonKernelMatrixCoords *) nil_chk(willingCoords)) projectPlaneThruVIfPossibleWithGeogebraCommonKernelMatrixCoordMatrix:[((GeogebraCommonKernelMatrixCoordSys *) nil_chk([self getCoordSys])) getMatrixOrthonormal] withGeogebraCommonKernelMatrixCoords:oldCoords withGeogebraCommonKernelMatrixCoords:willingDirection withGeogebraCommonKernelMatrixCoords:IOSObjectArray_Get(result, 0) withGeogebraCommonKernelMatrixCoords:IOSObjectArray_Get(result, 1)];
  return result;
}

- (void)setChangeableCoordParentWithGeogebraCommonKernelGeosGeoNumeric:(GeogebraCommonKernelGeosGeoNumeric *)number
                                withGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)direction {
  GeogebraCommonKernelGeosGeoPolygon_setChangeableCoordParentWithGeogebraCommonKernelGeosGeoNumeric_withGeogebraCommonKernelGeosGeoElement_(self, number, direction);
}

- (jboolean)hasChangeableCoordParentNumbers {
  return (changeableCoordParent_ != nil);
}

- (void)recordChangeableCoordParentNumbers {
  [((GeogebraCommonKernelGeosChangeableCoordParent *) nil_chk(changeableCoordParent_)) record];
}

- (jboolean)moveFromChangeableCoordParentNumbersWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)rwTransVec
                                                withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)endPosition
                                                withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)viewDirection
                                                               withJavaUtilArrayList:(JavaUtilArrayList *)updateGeos
                                                               withJavaUtilArrayList:(JavaUtilArrayList *)tempMoveObjectList
                                            withGeogebraCommonEuclidianEuclidianView:(GeogebraCommonEuclidianEuclidianView *)view {
  if (changeableCoordParent_ == nil) {
    return NO;
  }
  return [((GeogebraCommonKernelGeosChangeableCoordParent *) nil_chk(changeableCoordParent_)) moveWithGeogebraCommonKernelMatrixCoords:rwTransVec withGeogebraCommonKernelMatrixCoords:endPosition withGeogebraCommonKernelMatrixCoords:viewDirection withJavaUtilArrayList:updateGeos withJavaUtilArrayList:tempMoveObjectList withGeogebraCommonEuclidianEuclidianView:view];
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)r {
  for (jint i = 0; i < [self getPointsLength]; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) rotateWithGeogebraCommonKernelArithmeticNumberValue:r];
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)r
                 withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)S {
  GeogebraCommonKernelMatrixCoords *Scoords = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(S)) getInhomCoords];
  for (jint i = 0; i < [self getPointsLength]; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) rotateWithGeogebraCommonKernelArithmeticNumberValue:r withGeogebraCommonKernelMatrixCoords:Scoords];
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (void)matrixTransformWithDouble:(jdouble)a00
                       withDouble:(jdouble)a01
                       withDouble:(jdouble)a10
                       withDouble:(jdouble)a11 {
  for (jint i = 0; i < [self getPointsLength]; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) matrixTransformWithDouble:a00 withDouble:a01 withDouble:a10 withDouble:a11];
  [self calcArea];
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (void)translateWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)v {
  for (jint i = 0; i < [self getPointsLength]; i++) {
    [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) translateWithGeogebraCommonKernelMatrixCoords:v];
  }
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (void)dilateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)r
                       withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)S {
  for (jint i = 0; i < [self getPointsLength]; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) dilateWithGeogebraCommonKernelArithmeticNumberValue:r withGeogebraCommonKernelMatrixCoords:S];
  [self calcArea];
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (void)mirrorWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)Q {
  area_ *= -1;
  for (jint i = 0; i < [self getPointsLength]; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) mirrorWithGeogebraCommonKernelMatrixCoords:Q];
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (void)updatePathRegion {
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (void)mirrorWithGeogebraCommonKernelKernelNDGeoLineND:(id<GeogebraCommonKernelKernelNDGeoLineND>)g {
  area_ *= -1;
  for (jint i = 0; i < [self getPointsLength]; i++) [((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) mirrorWithGeogebraCommonKernelKernelNDGeoLineND:g];
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (jboolean)isAllVertexLabelsSet {
  for (jint i = 0; i < [self getPointsLength]; i++) if (![((GeogebraCommonKernelGeosGeoPoint *) nil_chk([self getPointWithInt:i])) isLabelSet]) return NO;
  return YES;
}

- (jboolean)isVertexCountFixed {
  if ([[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoPolygonRegularND class]]) return NO;
  if (((IOSObjectArray *) nil_chk([((GeogebraCommonKernelAlgosAlgoElement *) nil_chk([self getParentAlgorithm])) getInput]))->size_ < 3) return NO;
  return YES;
}

- (GeogebraCommonKernelMatrixCoords *)getDirectionInD3 {
  return GeogebraCommonKernelMatrixCoords_get_VZ_();
}

- (void)matrixTransformWithDouble:(jdouble)a00
                       withDouble:(jdouble)a01
                       withDouble:(jdouble)a02
                       withDouble:(jdouble)a10
                       withDouble:(jdouble)a11
                       withDouble:(jdouble)a12
                       withDouble:(jdouble)a20
                       withDouble:(jdouble)a21
                       withDouble:(jdouble)a22 {
  for (jint i = 0; i < [self getPointsLength]; i++) {
    [((id<GeogebraCommonKernelMatrixTransformable>) nil_chk(((id<GeogebraCommonKernelMatrixTransformable>) check_protocol_cast(GeogebraCommonKernelGeosGeoPolygon_getPointNDWithInt_(self, i), @protocol(GeogebraCommonKernelMatrixTransformable))))) matrixTransformWithDouble:a00 withDouble:a01 withDouble:a02 withDouble:a10 withDouble:a11 withDouble:a12 withDouble:a20 withDouble:a21 withDouble:a22];
  }
  [self calcArea];
  GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(self);
}

- (void)calcArea {
  if ([algoParent_ isKindOfClass:[GeogebraCommonKernelAlgosAlgoTransformation class]]) {
    GeogebraCommonKernelAlgosAlgoTransformation *algo = (GeogebraCommonKernelAlgosAlgoTransformation *) check_class_cast(algoParent_, [GeogebraCommonKernelAlgosAlgoTransformation class]);
    jdouble sf = [((GeogebraCommonKernelAlgosAlgoTransformation *) nil_chk(algo)) getAreaScaleFactor];
    GeogebraCommonKernelGeosGeoPolygon *input = (GeogebraCommonKernelGeosGeoPolygon *) check_class_cast([algo getInputWithInt:[((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(algoParent_)) getClassName] == GeogebraCommonKernelCommandsCommandsEnum_get_ApplyMatrix() ? 1 : 0], [GeogebraCommonKernelGeosGeoPolygon class]);
    GeogebraCommonKernelGeosGeoPolygon_setAreaWithDouble_(self, [((GeogebraCommonKernelGeosGeoPolygon *) nil_chk(input)) getAreaWithSign] * sf);
    return;
  }
  if ([GeogebraCommonKernelAlgosPolygonAlgo_class_() isInstance:algoParent_]) {
    [((id<GeogebraCommonKernelAlgosPolygonAlgo>) nil_chk(((id<GeogebraCommonKernelAlgosPolygonAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosPolygonAlgo))))) calcArea];
  }
  GeogebraCommonKernelGeosGeoPolygon_setAreaWithDouble_(self, GeogebraCommonKernelAlgosAlgoPolygon_calcAreaWithSignWithGeogebraCommonKernelKernelNDGeoPointNDArray_([self getPoints]));
}

- (void)calcCentroidWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p {
  if ([GeogebraCommonKernelAlgosPolygonAlgo_class_() isInstance:algoParent_]) {
    [((id<GeogebraCommonKernelAlgosPolygonAlgo>) nil_chk(((id<GeogebraCommonKernelAlgosPolygonAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosPolygonAlgo))))) calcCentroidWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(p, [GeogebraCommonKernelGeosGeoPoint class])];
    return;
  }
  if (tmp3_ == nil) {
    GeogebraCommonKernelGeosGeoPolygon_setAndConsume_tmp3_(self, [IOSDoubleArray newArrayWithLength:3]);
  }
  GeogebraCommonKernelAlgosAlgoPolygon_calcCentroidWithDoubleArray_withDouble_withGeogebraCommonKernelKernelNDGeoPointNDArray_(tmp3_, area_, [self getPoints]);
  if (JavaLangDouble_isNaNWithDouble_(IOSDoubleArray_Get(nil_chk(tmp3_), 0))) {
    [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(p)) setUndefined];
  }
  else {
    [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(p)) setCoordsWithDouble:IOSDoubleArray_Get(tmp3_, 0) withDouble:IOSDoubleArray_Get(tmp3_, 1) withDouble:IOSDoubleArray_Get(tmp3_, 2)];
  }
}

- (void)toGeoCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)curve {
  [((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(curve)) setFromPolyLineWithGeogebraCommonKernelKernelNDGeoPointNDArray:points_ withBoolean:YES];
}

- (NSString *)getDefaultLabelWithCharArray:(IOSCharArray *)chars
                               withBoolean:(jboolean)isInteger {
  if (chars != nil) return [super getDefaultLabelWithCharArray:chars withBoolean:isInteger];
  jint counter = 0;
  NSString *str;
  NSString *name;
  if ([self getMetasLength] == 1) name = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainLabelWithNSString:@"face"];
  else name = [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainLabelWithNSString:@"polygon"];
  do {
    counter++;
    str = JreStrcat("$$", name, [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) internationalizeDigitsWithNSString:JreStrcat("I", counter) withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
  }
  while (![((GeogebraCommonKernelConstruction *) nil_chk(cons_)) isFreeLabelWithNSString:str]);
  return str;
}

- (void)modifyInputPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:(IOSObjectArray *)newPoints {
  GeogebraCommonKernelAlgosAlgoPolygon *algo = (GeogebraCommonKernelAlgosAlgoPolygon *) check_class_cast([self getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoPolygon class]);
  [((GeogebraCommonKernelAlgosAlgoPolygon *) nil_chk(algo)) modifyInputPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:newPoints];
}

- (IOSObjectArray *)getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  return nil;
}

- (IOSObjectArray *)getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  return nil;
}

- (jint)getMetasLength {
  if (metas_ == nil) {
    return 0;
  }
  return [((JavaUtilTreeSet *) nil_chk(metas_)) size];
}

- (IOSObjectArray *)getMetas {
  IOSObjectArray *ret = [IOSObjectArray arrayWithLength:[((JavaUtilTreeSet *) nil_chk(metas_)) size] type:GeogebraCommonKernelGeosGeoElement_class_()];
  [metas_ toArrayWithNSObjectArray:ret];
  return ret;
}

- (void)addMetaWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)polyhedron {
  if (metas_ == nil) {
    GeogebraCommonKernelGeosGeoPolygon_setAndConsume_metas_(self, new_JavaUtilTreeSet_init());
  }
  [((JavaUtilTreeSet *) nil_chk(metas_)) addWithId:polyhedron];
}

- (void)removeMetaWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)polyhedron {
  if (metas_ != nil) {
    [metas_ removeWithId:polyhedron];
  }
}

- (jdouble)distanceWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)p {
  jdouble d = JavaLangDouble_POSITIVE_INFINITY;
  {
    IOSObjectArray *a__ = [self getSegments];
    id<GeogebraCommonKernelKernelNDGeoSegmentND> const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    id<GeogebraCommonKernelKernelNDGeoSegmentND> const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      id<GeogebraCommonKernelKernelNDGeoSegmentND> seg = *b__++;
      jdouble d1 = [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(seg)) distanceWithGeogebraCommonKernelKernelNDGeoPointND:p];
      if (d1 < d) {
        d = d1;
      }
    }
  }
  return d;
}

- (void)setReverseNormalForDrawingWithBoolean:(jboolean)flag {
  reverseNormalForDrawing_ = flag;
}

- (jboolean)getReverseNormalForDrawing {
  return reverseNormalForDrawing_;
}

- (void)setPointSizeOrVisibilityWithInt:(jint)size {
  if (size > 0) {
    GeogebraCommonKernelGeosGeoPolygon_setPointSizeWithInt_(self, size);
  }
  else {
    GeogebraCommonKernelGeosGeoPolygon_setPointNotVisibile(self);
  }
}

- (void)setPointSizeWithInt:(jint)size {
  GeogebraCommonKernelGeosGeoPolygon_setPointSizeWithInt_(self, size);
}

- (void)setPointNotVisibile {
  GeogebraCommonKernelGeosGeoPolygon_setPointNotVisibile(self);
}

- (GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)getLastHitType {
  return GeogebraCommonKernelGeosGeoElement_HitTypeEnum_get_ON_FILLING();
}

- (id<GeogebraCommonKernelKernelNDGeoPointND>)newGeoPointWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons {
  return [new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(cons) autorelease];
}

- (void)dealloc {
  RELEASE_(points_);
  RELEASE_(segments_);
  RELEASE_(p0_);
  RELEASE_(p1_);
  RELEASE_(p2_);
  RELEASE_(segmentsArray_);
  RELEASE_(pointsArray_);
  RELEASE_(sbToString_);
  RELEASE_(labelPosition_);
  RELEASE_(changeableCoordParent_);
  RELEASE_(tmp3_);
  RELEASE_(metas_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelKernelNDGeoPointNDArray:", "GeoPolygon", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelKernelNDGeoPointNDArray:withGeogebraCommonKernelMatrixCoordSys:withBoolean:", "GeoPolygon", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:", "GeoPolygon", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withBoolean:", "GeoPolygon", NULL, 0x1, NULL, NULL },
    { "setCoordSysWithGeogebraCommonKernelMatrixCoordSys:", "setCoordSys", "V", 0x1, NULL, NULL },
    { "setCoordSysWithGeogebraCommonKernelGeosGeoPolygon:", "setCoordSys", "V", 0x1, NULL, NULL },
    { "setCoordSysAndPoints3DWithGeogebraCommonKernelGeosGeoPolygon:", "setCoordSysAndPoints3D", "V", 0x1, NULL, NULL },
    { "setNotFixedPointsLengthWithBoolean:", "setNotFixedPointsLength", "V", 0x1, NULL, NULL },
    { "getTypeString", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "setPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:", "setPoints", "V", 0x11, NULL, NULL },
    { "setPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:withGeogebraCommonKernelMatrixCoordSys:withBoolean:", "setPoints", "V", 0x1, NULL, NULL },
    { "getPointsLength", NULL, "I", 0x1, NULL, NULL },
    { "getPointXWithInt:", "getPointX", "D", 0x1, NULL, NULL },
    { "getPointYWithInt:", "getPointY", "D", 0x1, NULL, NULL },
    { "initLabelsWithNSStringArray:", "initLabels", "V", 0x1, NULL, NULL },
    { "wasInitLabelsCalled", NULL, "Z", 0x11, NULL, NULL },
    { "defaultSegmentLabels", NULL, "V", 0x2, NULL, NULL },
    { "setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND:withGeogebraCommonKernelKernelNDGeoPointND:", "setLabel", "V", 0xa, NULL, NULL },
    { "updateSegments", NULL, "V", 0x4, NULL, NULL },
    { "createSegmentWithGeogebraCommonKernelKernelNDGeoPointND:withGeogebraCommonKernelKernelNDGeoPointND:withBoolean:", "createSegment", "Lgeogebra.common.kernel.kernelND.GeoSegmentND;", 0x1, NULL, NULL },
    { "createSegmentWithGeogebraCommonKernelKernelNDGeoSegmentND:withBoolean:", "createSegment", "Lgeogebra.common.kernel.kernelND.GeoSegmentND;", 0x4, NULL, NULL },
    { "copy__", "copy", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "copyInternalWithGeogebraCommonKernelConstruction:", "copyInternal", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "copyInternalWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelGeosGeoPolygon:", "copyInternal", "V", 0x1, NULL, NULL },
    { "newGeoPolygonWithGeogebraCommonKernelConstruction:", "newGeoPolygon", "Lgeogebra.common.kernel.geos.GeoPolygon;", 0x4, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "setPointsAndSegmentsWithGeogebraCommonKernelKernelNDGeoPointNDArray:", "setPointsAndSegments", "V", 0x1, NULL, NULL },
    { "setPointsAndSegmentsLengthWithInt:", "setPointsAndSegmentsLength", "V", 0x1, NULL, NULL },
    { "setPointsLengthWithInt:withGeogebraCommonKernelKernelNDGeoPointNDArray:", "setPointsLength", "V", 0x4, NULL, NULL },
    { "getPointWithInt:", "getPoint", "Lgeogebra.common.kernel.geos.GeoPoint;", 0x1, NULL, NULL },
    { "getPoints", NULL, "[Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x1, NULL, NULL },
    { "setPoints2DWithGeogebraCommonKernelGeosGeoPointArray:", "setPoints2D", "V", 0x1, NULL, NULL },
    { "getPointsND", NULL, "[Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x11, NULL, NULL },
    { "getPointNDWithInt:", "getPointND", "Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x11, NULL, NULL },
    { "getSegments", NULL, "[Lgeogebra.common.kernel.kernelND.GeoSegmentND;", 0x1, NULL, NULL },
    { "setSegmentsWithGeogebraCommonKernelKernelNDGeoSegmentNDArray:", "setSegments", "V", 0x1, NULL, NULL },
    { "isFillable", NULL, "Z", 0x1, NULL, NULL },
    { "isInverseFillable", NULL, "Z", 0x1, NULL, NULL },
    { "setAreaWithDouble:", "setArea", "V", 0x11, NULL, NULL },
    { "getArea", NULL, "D", 0x1, NULL, NULL },
    { "getMeasure", NULL, "D", 0x1, NULL, NULL },
    { "getBoundary", NULL, "Lgeogebra.common.kernel.Path;", 0x1, NULL, NULL },
    { "getDirection", NULL, "D", 0x1, NULL, NULL },
    { "getAreaWithSign", NULL, "D", 0x1, NULL, NULL },
    { "isDefined", NULL, "Z", 0x1, NULL, NULL },
    { "setDefined", NULL, "V", 0x1, NULL, NULL },
    { "setUndefined", NULL, "V", 0x1, NULL, NULL },
    { "showInAlgebraView", NULL, "Z", 0x11, NULL, NULL },
    { "hasLineOpacity", NULL, "Z", 0x1, NULL, NULL },
    { "setLineOpacityWithInt:", "setLineOpacity", "V", 0x1, NULL, NULL },
    { "setLineOpacityWithInt:withBoolean:", "setLineOpacity", "V", 0x1, NULL, NULL },
    { "hasSameAreaWithGeogebraCommonKernelGeosGeoElement:", "hasSameArea", "Z", 0x1, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x1, NULL, NULL },
    { "setEuclidianVisibleWithBoolean:", "setEuclidianVisible", "V", 0x1, NULL, NULL },
    { "setEuclidianVisibleWithBoolean:withBoolean:", "setEuclidianVisible", "V", 0x1, NULL, NULL },
    { "setObjColorWithGeogebraCommonAwtGColor:", "setObjColor", "V", 0x1, NULL, NULL },
    { "setLineTypeWithInt:", "setLineType", "V", 0x1, NULL, NULL },
    { "setLineTypeWithInt:withBoolean:", "setLineType", "V", 0x1, NULL, NULL },
    { "setLineTypeHiddenWithInt:", "setLineTypeHidden", "V", 0x1, NULL, NULL },
    { "setLineTypeHiddenWithInt:withBoolean:", "setLineTypeHidden", "V", 0x1, NULL, NULL },
    { "setLineThicknessWithInt:", "setLineThickness", "V", 0x1, NULL, NULL },
    { "setLineThicknessWithInt:withBoolean:", "setLineThickness", "V", 0x1, NULL, NULL },
    { "setLineThicknessOrVisibilityWithInt:", "setLineThicknessOrVisibility", "V", 0x1, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "toStringMinimalWithGeogebraCommonKernelStringTemplate:", "toStringMinimal", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "getNumber", NULL, "Lgeogebra.common.kernel.arithmetic.MyDouble;", 0x1, NULL, NULL },
    { "getDouble", NULL, "D", 0x11, NULL, NULL },
    { "showInEuclidianView", NULL, "Z", 0x4, NULL, NULL },
    { "isNumberValue", NULL, "Z", 0x1, NULL, NULL },
    { "isGeoPolygon", NULL, "Z", 0x1, NULL, NULL },
    { "isPath", NULL, "Z", 0x1, NULL, NULL },
    { "createPathMover", NULL, "Lgeogebra.common.kernel.PathMover;", 0x1, NULL, NULL },
    { "getMaxParameter", NULL, "D", 0x1, NULL, NULL },
    { "getMinParameter", NULL, "D", 0x1, NULL, NULL },
    { "isClosedPath", NULL, "Z", 0x1, NULL, NULL },
    { "isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "isOnPath", "Z", 0x1, NULL, NULL },
    { "isOnPathWithGeogebraCommonKernelMatrixCoords:withDouble:", "isOnPath", "Z", 0x1, NULL, NULL },
    { "pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pathChanged", "V", 0x1, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChanged", "V", 0x1, NULL, NULL },
    { "isRegion", NULL, "Z", 0x1, NULL, NULL },
    { "isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:withBoolean:", "isInRegion", "Z", 0x1, NULL, NULL },
    { "isInRegionWithGeogebraCommonKernelKernelNDGeoPointND:", "isInRegion", "Z", 0x1, NULL, NULL },
    { "isInRegionWithDouble:withDouble:", "isInRegion", "Z", 0x1, NULL, NULL },
    { "regionChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "regionChanged", "V", 0x11, NULL, NULL },
    { "setRegionChangedWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:withDouble:", "setRegionChanged", "V", 0x1, NULL, NULL },
    { "pointChangedForRegionWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChangedForRegion", "V", 0x1, NULL, NULL },
    { "updateRegionCSWithGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoPoint:withGeogebraCommonKernelGeosGeoPoint:", "updateRegionCS", "V", 0x11, NULL, NULL },
    { "updateRegionCSWithFirstPoints", NULL, "V", 0x11, NULL, NULL },
    { "updateRegionCS", NULL, "V", 0x11, NULL, NULL },
    { "setRoleWithBoolean:", "setRole", "V", 0x1, NULL, NULL },
    { "asBoundary", NULL, "Z", 0x1, NULL, NULL },
    { "intersectOxWithDouble:withDouble:withDouble:withDouble:", "intersectOx", "I", 0xa, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "getMinimumLineThickness", NULL, "I", 0x1, NULL, NULL },
    { "isTraceable", NULL, "Z", 0x1, NULL, NULL },
    { "setTraceWithBoolean:", "setTrace", "V", 0x1, NULL, NULL },
    { "getTrace", NULL, "Z", 0x1, NULL, NULL },
    { "getPoint3DWithInt:", "getPoint3D", "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "isPartOfClosedSurface", NULL, "Z", 0x1, NULL, NULL },
    { "isConvex", NULL, "Z", 0x1, NULL, NULL },
    { "isConvexInverseDirection", NULL, "Z", 0x1, NULL, NULL },
    { "hasDrawable3D", NULL, "Z", 0x1, NULL, NULL },
    { "getLabelPosition", NULL, "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getCoordSys", NULL, "Lgeogebra.common.kernel.Matrix.CoordSys;", 0x1, NULL, NULL },
    { "getPointWithDouble:withDouble:", "getPoint", "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getNormalProjectionWithGeogebraCommonKernelMatrixCoords:", "getNormalProjection", "[Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getProjectionWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelMatrixCoords:", "getProjection", "[Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "setChangeableCoordParentWithGeogebraCommonKernelGeosGeoNumeric:withGeogebraCommonKernelGeosGeoElement:", "setChangeableCoordParent", "V", 0x11, NULL, NULL },
    { "hasChangeableCoordParentNumbers", NULL, "Z", 0x1, NULL, NULL },
    { "recordChangeableCoordParentNumbers", NULL, "V", 0x1, NULL, NULL },
    { "moveFromChangeableCoordParentNumbersWithGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelMatrixCoords:withGeogebraCommonKernelMatrixCoords:withJavaUtilArrayList:withJavaUtilArrayList:withGeogebraCommonEuclidianEuclidianView:", "moveFromChangeableCoordParentNumbers", "Z", 0x1, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:", "rotate", "V", 0x1, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelKernelNDGeoPointND:", "rotate", "V", 0x1, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "translateWithGeogebraCommonKernelMatrixCoords:", "translate", "V", 0x1, NULL, NULL },
    { "dilateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelMatrixCoords:", "dilate", "V", 0x1, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelMatrixCoords:", "mirror", "V", 0x1, NULL, NULL },
    { "updatePathRegion", NULL, "V", 0x2, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelKernelNDGeoLineND:", "mirror", "V", 0x1, NULL, NULL },
    { "isAllVertexLabelsSet", NULL, "Z", 0x1, NULL, NULL },
    { "isVertexCountFixed", NULL, "Z", 0x1, NULL, NULL },
    { "getDirectionInD3", NULL, "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "calcArea", NULL, "V", 0x1, NULL, NULL },
    { "calcCentroidWithGeogebraCommonKernelKernelNDGeoPointND:", "calcCentroid", "V", 0x1, NULL, NULL },
    { "toGeoCurveCartesianWithGeogebraCommonKernelGeosGeoCurveCartesian:", "toGeoCurveCartesian", "V", 0x1, NULL, NULL },
    { "getDefaultLabelWithCharArray:withBoolean:", "getDefaultLabel", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "modifyInputPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:", "modifyInputPoints", "V", 0x1, NULL, NULL },
    { "getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:", "getBotanaVars", "[Lgeogebra.common.kernel.prover.polynomial.Variable;", 0x1, NULL, NULL },
    { "getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:", "getBotanaPolynomials", "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getMetasLength", NULL, "I", 0x1, NULL, NULL },
    { "getMetas", NULL, "[Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "addMetaWithGeogebraCommonKernelGeosGeoElement:", "addMeta", "V", 0x1, NULL, NULL },
    { "removeMetaWithGeogebraCommonKernelGeosGeoElement:", "removeMeta", "V", 0x1, NULL, NULL },
    { "distanceWithGeogebraCommonKernelGeosGeoPoint:", "distance", "D", 0x1, NULL, NULL },
    { "setReverseNormalForDrawingWithBoolean:", "setReverseNormalForDrawing", "V", 0x1, NULL, NULL },
    { "getReverseNormalForDrawing", NULL, "Z", 0x1, NULL, NULL },
    { "setPointSizeOrVisibilityWithInt:", "setPointSizeOrVisibility", "V", 0x1, NULL, NULL },
    { "setPointSizeWithInt:", "setPointSize", "V", 0x2, NULL, NULL },
    { "setPointNotVisibile", NULL, "V", 0x2, NULL, NULL },
    { "getLastHitType", NULL, "Lgeogebra.common.kernel.geos.GeoElement$HitType;", 0x11, NULL, NULL },
    { "newGeoPointWithGeogebraCommonKernelConstruction:", "newGeoPoint", "Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "POLYGON_MAX_POINTS_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelGeosGeoPolygon_POLYGON_MAX_POINTS },
    { "points_", NULL, 0x4, "[Lgeogebra.common.kernel.kernelND.GeoPointND;", NULL, NULL,  },
    { "segments_", NULL, 0x4, "[Lgeogebra.common.kernel.kernelND.GeoSegmentND;", NULL, NULL,  },
    { "p0_", NULL, 0x4, "Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "p1_", NULL, 0x4, "Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "p2_", NULL, 0x4, "Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "numCS_", NULL, 0x4, "I", NULL, NULL,  },
    { "area_", NULL, 0x4, "D", NULL, NULL,  },
    { "defined_", NULL, 0x2, "Z", NULL, NULL,  },
    { "initLabelsCalled_", NULL, 0x4, "Z", NULL, NULL,  },
    { "createSegments_", NULL, 0x2, "Z", NULL, NULL,  },
    { "isIntersection_", NULL, 0x4, "Z", NULL, NULL,  },
    { "notFixedPointsLength_", NULL, 0x2, "Z", NULL, NULL,  },
    { "segmentsArray_", NULL, 0x2, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/kernelND/GeoSegmentND;>;",  },
    { "pointsArray_", NULL, 0x2, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/geos/GeoPoint;>;",  },
    { "sbToString_", NULL, 0x2, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "asBoundary__", "asBoundary", 0x2, "Z", NULL, NULL,  },
    { "trace_", NULL, 0x2, "Z", NULL, NULL,  },
    { "convexOrientation_", NULL, 0x2, "I", NULL, NULL,  },
    { "labelPosition_", NULL, 0x2, "Lgeogebra.common.kernel.Matrix.Coords;", NULL, NULL,  },
    { "changeableCoordParent_", NULL, 0x2, "Lgeogebra.common.kernel.geos.ChangeableCoordParent;", NULL, NULL,  },
    { "tmp3_", NULL, 0x2, "[D", NULL, NULL,  },
    { "metas_", NULL, 0x2, "Ljava.util.TreeSet;", NULL, "Ljava/util/TreeSet<Lgeogebra/common/kernel/geos/GeoElement;>;",  },
    { "reverseNormalForDrawing_", NULL, 0x2, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoPolygon = { 2, "GeoPolygon", "geogebra.common.kernel.geos", NULL, 0x1, 144, methods, 24, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoPolygon;
}

@end

void GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_(GeogebraCommonKernelGeosGeoPolygon *self, GeogebraCommonKernelConstruction *c, IOSObjectArray *points) {
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_withGeogebraCommonKernelMatrixCoordSys_withBoolean_(self, c, points, nil, YES);
}

GeogebraCommonKernelGeosGeoPolygon *new_GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_(GeogebraCommonKernelConstruction *c, IOSObjectArray *points) {
  GeogebraCommonKernelGeosGeoPolygon *self = [GeogebraCommonKernelGeosGeoPolygon alloc];
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_(self, c, points);
  return self;
}

void GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_withGeogebraCommonKernelMatrixCoordSys_withBoolean_(GeogebraCommonKernelGeosGeoPolygon *self, GeogebraCommonKernelConstruction *c, IOSObjectArray *points, GeogebraCommonKernelMatrixCoordSys *cs, jboolean createSegments) {
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_(self, c);
  self->createSegments_ = createSegments;
  [self setPointsWithGeogebraCommonKernelKernelNDGeoPointNDArray:points withGeogebraCommonKernelMatrixCoordSys:cs withBoolean:createSegments];
  [self setLabelVisibleWithBoolean:NO];
}

GeogebraCommonKernelGeosGeoPolygon *new_GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_withGeogebraCommonKernelMatrixCoordSys_withBoolean_(GeogebraCommonKernelConstruction *c, IOSObjectArray *points, GeogebraCommonKernelMatrixCoordSys *cs, jboolean createSegments) {
  GeogebraCommonKernelGeosGeoPolygon *self = [GeogebraCommonKernelGeosGeoPolygon alloc];
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelKernelNDGeoPointNDArray_withGeogebraCommonKernelMatrixCoordSys_withBoolean_(self, c, points, cs, createSegments);
  return self;
}

void GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelGeosGeoPolygon *self, GeogebraCommonKernelConstruction *cons) {
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withBoolean_(self, cons, NO);
}

GeogebraCommonKernelGeosGeoPolygon *new_GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *cons) {
  GeogebraCommonKernelGeosGeoPolygon *self = [GeogebraCommonKernelGeosGeoPolygon alloc];
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_(self, cons);
  return self;
}

void GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withBoolean_(GeogebraCommonKernelGeosGeoPolygon *self, GeogebraCommonKernelConstruction *cons, jboolean isIntersection) {
  GeogebraCommonKernelGeosGeoElement_initWithGeogebraCommonKernelConstruction_(self, cons);
  self->numCS_ = 0;
  self->defined_ = NO;
  self->initLabelsCalled_ = NO;
  self->createSegments_ = YES;
  self->notFixedPointsLength_ = NO;
  GeogebraCommonKernelGeosGeoPolygon_setAndConsume_sbToString_(self, new_JavaLangStringBuilder_initWithInt_(50));
  self->asBoundary__ = NO;
  GeogebraCommonKernelGeosGeoPolygon_set_changeableCoordParent_(self, nil);
  self->reverseNormalForDrawing_ = NO;
  self->isIntersection_ = isIntersection;
  [self setConstructionDefaults];
}

GeogebraCommonKernelGeosGeoPolygon *new_GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withBoolean_(GeogebraCommonKernelConstruction *cons, jboolean isIntersection) {
  GeogebraCommonKernelGeosGeoPolygon *self = [GeogebraCommonKernelGeosGeoPolygon alloc];
  GeogebraCommonKernelGeosGeoPolygon_initWithGeogebraCommonKernelConstruction_withBoolean_(self, cons, isIntersection);
  return self;
}

void GeogebraCommonKernelGeosGeoPolygon_defaultSegmentLabels(GeogebraCommonKernelGeosGeoPolygon *self) {
  if ([self getPointsLength] == 3) {
    if ([[self getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoPolygonRegularND class]]) [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(nil_chk(self->points_), 2))) setLabelWithNSString:nil];
    GeogebraCommonKernelGeosGeoPolygon_setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND_withGeogebraCommonKernelKernelNDGeoPointND_(IOSObjectArray_Get(nil_chk(self->segments_), 0), IOSObjectArray_Get(nil_chk(self->points_), 2));
    GeogebraCommonKernelGeosGeoPolygon_setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND_withGeogebraCommonKernelKernelNDGeoPointND_(IOSObjectArray_Get(self->segments_, 1), IOSObjectArray_Get(self->points_, 0));
    GeogebraCommonKernelGeosGeoPolygon_setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND_withGeogebraCommonKernelKernelNDGeoPointND_(IOSObjectArray_Get(self->segments_, 2), IOSObjectArray_Get(self->points_, 1));
  }
  else {
    for (jint i = 0; i < [self getPointsLength]; i++) {
      GeogebraCommonKernelGeosGeoPolygon_setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND_withGeogebraCommonKernelKernelNDGeoPointND_(IOSObjectArray_Get(nil_chk(self->segments_), i), IOSObjectArray_Get(nil_chk(self->points_), i));
    }
  }
}

void GeogebraCommonKernelGeosGeoPolygon_setLabelWithGeogebraCommonKernelKernelNDGeoSegmentND_withGeogebraCommonKernelKernelNDGeoPointND_(id<GeogebraCommonKernelKernelNDGeoSegmentND> s, id<GeogebraCommonKernelKernelNDGeoPointND> p) {
  GeogebraCommonKernelGeosGeoPolygon_initialize();
  if (![((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(p)) isLabelSet] || [p getLabelWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()] == nil) {
    [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(s)) setLabelWithNSString:nil];
  }
  else {
    NSString *lowerCaseLabel = [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(p, [GeogebraCommonKernelGeosGeoElement class])) getFreeLabelWithNSString:[((NSString *) nil_chk([p getLabelWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_getWithGeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_(GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GEOGEBRA())])) lowercaseString]];
    [((id<GeogebraCommonKernelKernelNDGeoSegmentND>) nil_chk(s)) setLabelWithNSString:lowerCaseLabel];
  }
}

id<GeogebraCommonKernelKernelNDGeoPointND> GeogebraCommonKernelGeosGeoPolygon_getPointNDWithInt_(GeogebraCommonKernelGeosGeoPolygon *self, jint i) {
  return IOSObjectArray_Get(nil_chk(self->points_), i);
}

void GeogebraCommonKernelGeosGeoPolygon_setAreaWithDouble_(GeogebraCommonKernelGeosGeoPolygon *self, jdouble area) {
  self->area_ = area;
  self->defined_ = !(JavaLangDouble_isNaNWithDouble_(area) || JavaLangDouble_isInfiniteWithDouble_(area));
}

void GeogebraCommonKernelGeosGeoPolygon_updateRegionCSWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(GeogebraCommonKernelGeosGeoPolygon *self, GeogebraCommonKernelGeosGeoPoint *newp0, GeogebraCommonKernelGeosGeoPoint *newp1, GeogebraCommonKernelGeosGeoPoint *newp2) {
  GeogebraCommonKernelGeosGeoPolygon_set_p0_(self, newp0);
  GeogebraCommonKernelGeosGeoPolygon_set_p1_(self, newp1);
  GeogebraCommonKernelGeosGeoPolygon_set_p2_(self, newp2);
  self->numCS_ = 3;
}

void GeogebraCommonKernelGeosGeoPolygon_updateRegionCS(GeogebraCommonKernelGeosGeoPolygon *self) {
  if ([self getPoints] == nil) {
    return;
  }
  if (self->p2_ == nil || GeogebraCommonKernelGeosGeoPoint_collinearWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(self->p0_, self->p1_, self->p2_)) {
    GeogebraCommonKernelGeosGeoPolygon_set_p0_(self, [self getPointWithInt:0]);
    self->numCS_ = 1;
    jint secondPoint = -1;
    jboolean secondPointFound = NO;
    for (secondPoint = 1; secondPoint < ((IOSObjectArray *) nil_chk([self getPoints]))->size_ && !secondPointFound; secondPoint++) {
      GeogebraCommonKernelGeosGeoPolygon_set_p1_(self, [self getPointWithInt:secondPoint]);
      if (!GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_(((GeogebraCommonKernelGeosGeoPoint *) nil_chk(self->p0_))->inhomX_, ((GeogebraCommonKernelGeosGeoPoint *) nil_chk(self->p1_))->inhomX_, GeogebraCommonKernelKernel_STANDARD_PRECISION)) secondPointFound = YES;
      else if (!GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_(self->p0_->inhomY_, self->p1_->inhomY_, GeogebraCommonKernelKernel_STANDARD_PRECISION)) secondPointFound = YES;
    }
    jint thirdPoint = -1;
    if (secondPointFound) {
      self->numCS_++;
      secondPoint--;
      jboolean thirdPointFound = NO;
      for (thirdPoint = ((IOSObjectArray *) nil_chk([self getPoints]))->size_ - 1; thirdPoint > secondPoint && !thirdPointFound; thirdPoint--) {
        GeogebraCommonKernelGeosGeoPolygon_set_p2_(self, [self getPointWithInt:thirdPoint]);
        if (!GeogebraCommonKernelGeosGeoPoint_collinearWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(self->p0_, self->p1_, self->p2_)) {
          thirdPointFound = YES;
          self->numCS_++;
        }
      }
    }
  }
}

jint GeogebraCommonKernelGeosGeoPolygon_intersectOxWithDouble_withDouble_withDouble_withDouble_(jdouble px1, jdouble py1, jdouble px2, jdouble py2) {
  GeogebraCommonKernelGeosGeoPolygon_initialize();
  jdouble x1 = px1, x2 = px2, y1 = py1, y2 = py2;
  jdouble eps = GeogebraCommonKernelKernel_STANDARD_PRECISION;
  if (GeogebraCommonKernelKernel_isZeroWithDouble_(y1)) {
    if (GeogebraCommonKernelKernel_isZeroWithDouble_(y2)) {
      if (GeogebraCommonKernelKernel_isGreaterEqualWithDouble_withDouble_(0, x1 * x2)) return 2;
      return -1;
    }
    if (GeogebraCommonKernelKernel_isZeroWithDouble_(x1)) return 2;
    return y2 > eps && x1 > eps ? 1 : -1;
  }
  else if (GeogebraCommonKernelKernel_isZeroWithDouble_(y2)) {
    if (GeogebraCommonKernelKernel_isZeroWithDouble_(x2)) return 2;
    return y1 > eps && x2 > eps ? 1 : -1;
  }
  else if (y1 * y2 > eps) return -1;
  else {
    if (y1 > y2) {
      jdouble y = y1;
      y1 = y2;
      y2 = y;
      jdouble x = x1;
      x1 = x2;
      x2 = x;
    }
    if ((x1 + eps < 0) && (x2 + eps < 0)) return -1;
    else if ((x1 > eps) && (x2 > eps)) return 1;
    else if (x1 * y2 > x2 * y1 + eps) return 1;
    else if (x1 * y2 + eps < x2 * y1) return -1;
    else return 2;
  }
}

void GeogebraCommonKernelGeosGeoPolygon_setChangeableCoordParentWithGeogebraCommonKernelGeosGeoNumeric_withGeogebraCommonKernelGeosGeoElement_(GeogebraCommonKernelGeosGeoPolygon *self, GeogebraCommonKernelGeosGeoNumeric *number, GeogebraCommonKernelGeosGeoElement *direction) {
  GeogebraCommonKernelGeosGeoPolygon_setAndConsume_changeableCoordParent_(self, new_GeogebraCommonKernelGeosChangeableCoordParent_initWithGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoNumeric_withGeogebraCommonKernelGeosGeoElement_(self, number, direction));
}

void GeogebraCommonKernelGeosGeoPolygon_updatePathRegion(GeogebraCommonKernelGeosGeoPolygon *self) {
  GeogebraCommonKernelGeosGeoPolygon_updateRegionCS(self);
  [self updateSegments];
}

void GeogebraCommonKernelGeosGeoPolygon_setPointSizeWithInt_(GeogebraCommonKernelGeosGeoPolygon *self, jint size) {
  {
    IOSObjectArray *a__ = self->points_;
    id<GeogebraCommonKernelKernelNDGeoPointND> const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    id<GeogebraCommonKernelKernelNDGeoPointND> const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      id<GeogebraCommonKernelKernelNDGeoPointND> point = *b__++;
      [((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast(point, [GeogebraCommonKernelGeosGeoElement class])))) setEuclidianVisibleIfNoConditionToShowObjectWithBoolean:YES];
      [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(point)) setPointSizeWithInt:size];
      [point updateRepaint];
    }
  }
}

void GeogebraCommonKernelGeosGeoPolygon_setPointNotVisibile(GeogebraCommonKernelGeosGeoPolygon *self) {
  {
    IOSObjectArray *a__ = self->points_;
    id<GeogebraCommonKernelKernelNDGeoPointND> const *b__ = ((IOSObjectArray *) nil_chk(a__))->buffer_;
    id<GeogebraCommonKernelKernelNDGeoPointND> const *e__ = b__ + a__->size_;
    while (b__ < e__) {
      id<GeogebraCommonKernelKernelNDGeoPointND> point = *b__++;
      [((GeogebraCommonKernelGeosGeoElement *) nil_chk(((GeogebraCommonKernelGeosGeoElement *) check_class_cast(point, [GeogebraCommonKernelGeosGeoElement class])))) setEuclidianVisibleIfNoConditionToShowObjectWithBoolean:NO];
      [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(point)) updateRepaint];
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoPolygon)
