//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/arithmetic/Equation.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/arithmetic/Equation.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/FunctionVariable.h"
#include "geogebra/common/kernel/arithmetic/Inspecting.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/arithmetic/Polynomial.h"
#include "geogebra/common/kernel/arithmetic/Traversing.h"
#include "geogebra/common/kernel/arithmetic/ValidExpression.h"
#include "geogebra/common/kernel/arithmetic/Variable.h"
#include "geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/plugin/Operation.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/Set.h"

@interface GeogebraCommonKernelArithmeticEquation () {
 @public
  GeogebraCommonKernelArithmeticExpressionNode *lhs_;
  GeogebraCommonKernelArithmeticExpressionNode *rhs_;
  GeogebraCommonKernelArithmeticPolynomial *leftPoly_, *rightPoly_;
  GeogebraCommonKernelArithmeticPolynomial *normalForm_;
  jboolean isFunctionDependent__;
  GeogebraCommonKernelKernel *kernel_;
  jboolean forcePlane_, forceLine_;
  jboolean forceConic_, forceImplicitPoly_;
  jboolean forceQuadric_;
  JavaUtilArrayList *variableDegrees_;
  jboolean isPolynomial__;
}

+ (jboolean)containsVarWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v
                                                                withChar:(jchar)var;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticEquation, lhs_, GeogebraCommonKernelArithmeticExpressionNode *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticEquation, rhs_, GeogebraCommonKernelArithmeticExpressionNode *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticEquation, leftPoly_, GeogebraCommonKernelArithmeticPolynomial *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticEquation, rightPoly_, GeogebraCommonKernelArithmeticPolynomial *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticEquation, normalForm_, GeogebraCommonKernelArithmeticPolynomial *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticEquation, kernel_, GeogebraCommonKernelKernel *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticEquation, variableDegrees_, JavaUtilArrayList *)

__attribute__((unused)) static NSString *GeogebraCommonKernelArithmeticEquation_toValueStringWithGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelArithmeticEquation *self, GeogebraCommonKernelStringTemplate *tpl);

__attribute__((unused)) static jboolean GeogebraCommonKernelArithmeticEquation_containsVarWithGeogebraCommonKernelArithmeticExpressionValue_withChar_(id<GeogebraCommonKernelArithmeticExpressionValue> v, jchar var);

@implementation GeogebraCommonKernelArithmeticEquation

- (instancetype)initWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lhs
 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rhs {
  GeogebraCommonKernelArithmeticEquation_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(self, kernel, lhs, rhs);
  return self;
}

- (GeogebraCommonKernelArithmeticExpressionNode *)getRHS {
  return rhs_;
}

- (void)setRHSWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)rhs {
  if (rhs != nil) GeogebraCommonKernelArithmeticEquation_set_rhs_(self, rhs);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)getLHS {
  return lhs_;
}

- (void)setLHSWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)lhs {
  if (lhs != nil) GeogebraCommonKernelArithmeticEquation_set_lhs_(self, lhs);
}

- (void)setForceLine {
  forceLine_ = YES;
}

- (jboolean)isForcedLine {
  return forceLine_;
}

- (void)setForcePlane {
  forcePlane_ = YES;
}

- (jboolean)isForcedPlane {
  return forcePlane_;
}

- (void)setForceQuadric {
  forceQuadric_ = YES;
}

- (jboolean)isForcedQuadric {
  return forceQuadric_;
}

- (jboolean)isForcedConic {
  return forceConic_;
}

- (void)setForceConic {
  self->forceConic_ = YES;
}

- (jboolean)isForcedImplicitPoly {
  return forceImplicitPoly_;
}

- (void)setForceImplicitPoly {
  self->forceImplicitPoly_ = YES;
}

- (void)applyOperationWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation
          withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev
                                                withBoolean:(jboolean)switchOrder {
  id<GeogebraCommonKernelArithmeticExpressionValue> left, right;
  if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticEquation class]]) {
    GeogebraCommonKernelArithmeticEquation *equ = (GeogebraCommonKernelArithmeticEquation *) check_class_cast(ev, [GeogebraCommonKernelArithmeticEquation class]);
    left = ((GeogebraCommonKernelArithmeticEquation *) nil_chk(equ))->lhs_;
    right = equ->rhs_;
  }
  else {
    left = ev;
    right = ev;
  }
  if (switchOrder) {
    GeogebraCommonKernelArithmeticEquation_setAndConsume_lhs_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, left, operation, lhs_));
    GeogebraCommonKernelArithmeticEquation_setAndConsume_rhs_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, right, operation, rhs_));
  }
  else {
    GeogebraCommonKernelArithmeticEquation_setAndConsume_lhs_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, lhs_, operation, left));
    GeogebraCommonKernelArithmeticEquation_setAndConsume_rhs_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, rhs_, operation, right));
  }
}

- (void)initEquation {
  if ([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) isLeaf] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([lhs_ getLeft])) isVariable]) {
    GeogebraCommonKernelArithmeticVariable *leftVar = (GeogebraCommonKernelArithmeticVariable *) check_class_cast([lhs_ getLeft], [GeogebraCommonKernelArithmeticVariable class]);
    [lhs_ setLeftWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticVariable *) nil_chk(leftVar)) resolveWithBoolean:NO withBoolean:YES]];
  }
  else {
    [lhs_ resolveVariables];
  }
  [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) resolveVariables];
  self->isPolynomial__ = YES;
  GeogebraCommonKernelArithmeticEquation_set_variableDegrees_(self, nil);
  GeogebraCommonKernelArithmeticEquation_set_leftPoly_(self, GeogebraCommonKernelArithmeticPolynomial_fromNodeWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticEquation_(lhs_, self));
  GeogebraCommonKernelArithmeticEquation_set_rightPoly_(self, GeogebraCommonKernelArithmeticPolynomial_fromNodeWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticEquation_(rhs_, self));
  GeogebraCommonKernelArithmeticEquation_setAndConsume_normalForm_(self, new_GeogebraCommonKernelArithmeticPolynomial_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticPolynomial_(kernel_, rightPoly_));
  [normalForm_ multiplyWithDouble:-1.0];
  [normalForm_ addWithGeogebraCommonKernelArithmeticPolynomial:leftPoly_ withGeogebraCommonKernelArithmeticEquation:self];
}

- (void)setFunctionDependentWithBoolean:(jboolean)isFunctionDependent {
  self->isFunctionDependent__ = isFunctionDependent;
}

- (jboolean)isFunctionDependent {
  return isFunctionDependent__;
}

- (GeogebraCommonKernelArithmeticPolynomial *)getNormalForm {
  return normalForm_;
}

- (jint)degree {
  return [((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(normalForm_)) degree];
}

- (jint)singleDegree {
  return [((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(normalForm_)) singleDegree];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)getCoefficientWithNSString:(NSString *)variables {
  return [((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(normalForm_)) getCoefficientWithNSString:variables];
}

- (jdouble)getCoeffValueWithNSString:(NSString *)variables {
  id<GeogebraCommonKernelArithmeticExpressionValue> ev = [self getCoefficientWithNSString:variables];
  @try {
    id<GeogebraCommonKernelArithmeticNumberValue> nv = (id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(ev, @protocol(GeogebraCommonKernelArithmeticNumberValue));
    return [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(nv)) getDouble];
  }
  @catch (JavaLangException *e) {
    GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$$$@", @"getCoeffValue(", variables, @") failed:", e));
    return JavaLangDouble_NaN;
  }
}

- (IOSObjectArray *)getGeoElementVariables {
  id<JavaUtilSet> varSet;
  id<JavaUtilSet> leftVars = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) getVariables];
  id<JavaUtilSet> rightVars = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) getVariables];
  if (leftVars == nil) {
    varSet = rightVars;
  }
  else if (rightVars == nil) {
    varSet = leftVars;
  }
  else {
    [leftVars addAllWithJavaUtilCollection:rightVars];
    varSet = leftVars;
  }
  if (varSet == nil) {
    return [IOSObjectArray arrayWithLength:0 type:GeogebraCommonKernelGeosGeoElement_class_()];
  }
  id<JavaUtilIterator> i = [((id<JavaUtilSet>) nil_chk(varSet)) iterator];
  IOSObjectArray *ret = [IOSObjectArray arrayWithLength:[varSet size] type:GeogebraCommonKernelGeosGeoElement_class_()];
  jint j = 0;
  while ([((id<JavaUtilIterator>) nil_chk(i)) hasNext]) {
    IOSObjectArray_Set(ret, j++, [i next]);
  }
  return ret;
}

- (jboolean)isExplicitWithNSString:(NSString *)var {
  GeogebraCommonKernelArithmeticPolynomial *lhsp = leftPoly_;
  GeogebraCommonKernelArithmeticPolynomial *rhsp = rightPoly_;
  return ([((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(lhsp)) length] == 1 && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([lhsp getCoefficientWithNSString:var])) evaluateDouble] == 1 && ![((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(rhsp)) containsWithNSString:var]) || ([((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(rhsp)) length] == 1 && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([rhsp getCoefficientWithNSString:var])) evaluateDouble] == 1 && ![lhsp containsWithNSString:var]);
}

- (jboolean)isImplicit {
  return ![self isExplicitWithNSString:@"x"] && ![self isExplicitWithNSString:@"y"] && ![self isExplicitWithNSString:@"z"];
}

- (jboolean)containsWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)ev {
  return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:ev] || [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) containsWithGeogebraCommonKernelArithmeticExpressionValue:ev];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)deepCopyWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel1 {
  GeogebraCommonKernelArithmeticEquation *ret = [new_GeogebraCommonKernelArithmeticEquation_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(kernel1, [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) getCopyWithGeogebraCommonKernelKernel:kernel1], [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) getCopyWithGeogebraCommonKernelKernel:kernel1]) autorelease];
  ret->forceConic_ = forceConic_;
  ret->forceLine_ = forceLine_;
  ret->forcePlane_ = forcePlane_;
  ret->forceQuadric_ = forceQuadric_;
  ret->forceImplicitPoly_ = forceImplicitPoly_;
  return ret;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)evaluateWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  jboolean oldFlag = [((GeogebraCommonKernelConstruction *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getConstruction])) isSuppressLabelsActive];
  [((GeogebraCommonKernelConstruction *) nil_chk([kernel_ getConstruction])) setSuppressLabelCreationWithBoolean:YES];
  GeogebraCommonKernelGeosGeoElement *ge = IOSObjectArray_Get(nil_chk([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) processEquationWithGeogebraCommonKernelArithmeticEquation:self]), 0);
  [((GeogebraCommonKernelConstruction *) nil_chk([kernel_ getConstruction])) setSuppressLabelCreationWithBoolean:oldFlag];
  return ge;
}

- (JavaUtilHashSet *)getVariables {
  JavaUtilHashSet *leftVars = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) getVariables];
  JavaUtilHashSet *rightVars = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) getVariables];
  if (leftVars == nil) {
    return rightVars;
  }
  else if (rightVars == nil) {
    return leftVars;
  }
  else {
    [leftVars addAllWithJavaUtilCollection:rightVars];
    return leftVars;
  }
}

- (jboolean)isConstant {
  return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) isConstant] && [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) isConstant];
}

- (jboolean)isLeaf {
  return NO;
}

- (jboolean)isNumberValue {
  return NO;
}

- (void)resolveVariables {
  [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) resolveVariables];
  [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) resolveVariables];
}

- (NSString *)toLaTeXStringWithBoolean:(jboolean)symbolic
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  if (lhs_ != nil) [sb appendWithNSString:[lhs_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl]];
  else [sb appendWithChar:'0'];
  [sb appendWithNSString:@" = "];
  if (rhs_ != nil) [sb appendWithNSString:[rhs_ toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl]];
  else [sb appendWithChar:'0'];
  return [sb description];
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return GeogebraCommonKernelArithmeticEquation_toValueStringWithGeogebraCommonKernelStringTemplate_(self, tpl);
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [self toStringWithGeogebraCommonKernelStringTemplate:tpl withGeogebraCommonKernelArithmeticExpressionNode:self->lhs_];
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
            withGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)lhs1 {
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  if (lhs1 != nil) [sb appendWithNSString:[lhs1 toStringWithGeogebraCommonKernelStringTemplate:tpl]];
  else [sb appendWithChar:'0'];
  if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getStringType])) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
    if ([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs1)) evaluatesToList] || [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) evaluatesToList]) {
      [sb appendWithNSString:@"%="];
    }
    else {
      [sb appendWithNSString:@"="];
    }
  }
  else {
    [sb appendWithNSString:@" = "];
  }
  if (rhs_ != nil) [sb appendWithNSString:[rhs_ toStringWithGeogebraCommonKernelStringTemplate:tpl]];
  else [sb appendWithChar:'0'];
  return [sb description];
}

- (NSString *)getAssignmentOperator {
  return @": ";
}

- (NSString *)getAssignmentOperatorLaTeX {
  return @": \\, ";
}

- (NSString *)toOutputValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return GeogebraCommonKernelArithmeticEquation_toValueStringWithGeogebraCommonKernelStringTemplate_(self, tpl);
}

- (GeogebraCommonKernelKernel *)getKernel {
  return kernel_;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)traverseWithGeogebraCommonKernelArithmeticTraversing:(id<GeogebraCommonKernelArithmeticTraversing>)t {
  id<GeogebraCommonKernelArithmeticExpressionValue> v = [((id<GeogebraCommonKernelArithmeticTraversing>) nil_chk(t)) processWithGeogebraCommonKernelArithmeticExpressionValue:self];
  GeogebraCommonKernelArithmeticEquation_set_lhs_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) traverseWithGeogebraCommonKernelArithmeticTraversing:t])) wrap]);
  GeogebraCommonKernelArithmeticEquation_set_rhs_(self, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) traverseWithGeogebraCommonKernelArithmeticTraversing:t])) wrap]);
  return v;
}

- (jboolean)inspectWithGeogebraCommonKernelArithmeticInspecting:(id<GeogebraCommonKernelArithmeticInspecting>)t {
  return [((id<GeogebraCommonKernelArithmeticInspecting>) nil_chk(t)) checkWithGeogebraCommonKernelArithmeticExpressionValue:self] || [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(lhs_)) inspectWithGeogebraCommonKernelArithmeticInspecting:t] || [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(rhs_)) inspectWithGeogebraCommonKernelArithmeticInspecting:t];
}

- (jboolean)containsZ {
  return GeogebraCommonKernelArithmeticEquation_containsVarWithGeogebraCommonKernelArithmeticExpressionValue_withChar_(lhs_, 'z') || GeogebraCommonKernelArithmeticEquation_containsVarWithGeogebraCommonKernelArithmeticExpressionValue_withChar_(rhs_, 'z');
}

+ (jboolean)containsVarWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)v
                                                                withChar:(jchar)var {
  return GeogebraCommonKernelArithmeticEquation_containsVarWithGeogebraCommonKernelArithmeticExpressionValue_withChar_(v, var);
}

- (void)addVariableDegreeWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)gn {
  if (self->variableDegrees_ == nil) {
    GeogebraCommonKernelArithmeticEquation_setAndConsume_variableDegrees_(self, new_JavaUtilArrayList_init());
  }
  [((JavaUtilArrayList *) nil_chk(self->variableDegrees_)) addWithId:gn];
}

- (jboolean)hasVariableDegree {
  return variableDegrees_ != nil;
}

- (void)setIsPolynomialWithBoolean:(jboolean)b {
  self->isPolynomial__ = b;
}

- (jboolean)isPolynomial {
  if (!isPolynomial__) {
    return NO;
  }
  if (self->variableDegrees_ == nil) {
    return YES;
  }
  for (id<GeogebraCommonKernelArithmeticExpressionValue> __strong ev in nil_chk(self->variableDegrees_)) {
    jdouble exp = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) evaluateDouble];
    if (!GeogebraCommonKernelKernel_isIntegerWithDouble_(exp) || GeogebraCommonKernelKernel_isGreaterWithDouble_withDouble_(0, exp)) {
      return NO;
    }
  }
  return YES;
}

- (jboolean)mayBePolynomial {
  return isPolynomial__;
}

- (GeogebraCommonKernelArithmeticExpressionNode *)wrap {
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, self) autorelease];
}

- (void)dealloc {
  RELEASE_(lhs_);
  RELEASE_(rhs_);
  RELEASE_(leftPoly_);
  RELEASE_(rightPoly_);
  RELEASE_(normalForm_);
  RELEASE_(kernel_);
  RELEASE_(variableDegrees_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelKernel:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "Equation", NULL, 0x1, NULL, NULL },
    { "getRHS", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "setRHSWithGeogebraCommonKernelArithmeticExpressionNode:", "setRHS", "V", 0x1, NULL, NULL },
    { "getLHS", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
    { "setLHSWithGeogebraCommonKernelArithmeticExpressionNode:", "setLHS", "V", 0x1, NULL, NULL },
    { "setForceLine", NULL, "V", 0x1, NULL, NULL },
    { "isForcedLine", NULL, "Z", 0x11, NULL, NULL },
    { "setForcePlane", NULL, "V", 0x11, NULL, NULL },
    { "isForcedPlane", NULL, "Z", 0x11, NULL, NULL },
    { "setForceQuadric", NULL, "V", 0x11, NULL, NULL },
    { "isForcedQuadric", NULL, "Z", 0x11, NULL, NULL },
    { "isForcedConic", NULL, "Z", 0x1, NULL, NULL },
    { "setForceConic", NULL, "V", 0x1, NULL, NULL },
    { "isForcedImplicitPoly", NULL, "Z", 0x1, NULL, NULL },
    { "setForceImplicitPoly", NULL, "V", 0x1, NULL, NULL },
    { "applyOperationWithGeogebraCommonPluginOperationEnum:withGeogebraCommonKernelArithmeticExpressionValue:withBoolean:", "applyOperation", "V", 0x1, NULL, NULL },
    { "initEquation", NULL, "V", 0x1, NULL, NULL },
    { "setFunctionDependentWithBoolean:", "setFunctionDependent", "V", 0x1, NULL, NULL },
    { "isFunctionDependent", NULL, "Z", 0x1, NULL, NULL },
    { "getNormalForm", NULL, "Lgeogebra.common.kernel.arithmetic.Polynomial;", 0x1, NULL, NULL },
    { "degree", NULL, "I", 0x1, NULL, NULL },
    { "singleDegree", NULL, "I", 0x1, NULL, NULL },
    { "getCoefficientWithNSString:", "getCoefficient", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "getCoeffValueWithNSString:", "getCoeffValue", "D", 0x1, NULL, NULL },
    { "getGeoElementVariables", NULL, "[Lgeogebra.common.kernel.geos.GeoElement;", 0x11, NULL, NULL },
    { "isExplicitWithNSString:", "isExplicit", "Z", 0x1, NULL, NULL },
    { "isImplicit", NULL, "Z", 0x1, NULL, NULL },
    { "containsWithGeogebraCommonKernelArithmeticExpressionValue:", "contains", "Z", 0x1, NULL, NULL },
    { "deepCopyWithGeogebraCommonKernelKernel:", "deepCopy", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "evaluateWithGeogebraCommonKernelStringTemplate:", "evaluate", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "getVariables", NULL, "Ljava.util.HashSet;", 0x1, NULL, NULL },
    { "isConstant", NULL, "Z", 0x1, NULL, NULL },
    { "isLeaf", NULL, "Z", 0x1, NULL, NULL },
    { "isNumberValue", NULL, "Z", 0x1, NULL, NULL },
    { "resolveVariables", NULL, "V", 0x1, NULL, NULL },
    { "toLaTeXStringWithBoolean:withGeogebraCommonKernelStringTemplate:", "toLaTeXString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:withGeogebraCommonKernelArithmeticExpressionNode:", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getAssignmentOperator", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getAssignmentOperatorLaTeX", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toOutputValueStringWithGeogebraCommonKernelStringTemplate:", "toOutputValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getKernel", NULL, "Lgeogebra.common.kernel.Kernel;", 0x1, NULL, NULL },
    { "traverseWithGeogebraCommonKernelArithmeticTraversing:", "traverse", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "inspectWithGeogebraCommonKernelArithmeticInspecting:", "inspect", "Z", 0x1, NULL, NULL },
    { "containsZ", NULL, "Z", 0x1, NULL, NULL },
    { "containsVarWithGeogebraCommonKernelArithmeticExpressionValue:withChar:", "containsVar", "Z", 0x1a, NULL, NULL },
    { "addVariableDegreeWithGeogebraCommonKernelArithmeticExpressionValue:", "addVariableDegree", "V", 0x1, NULL, NULL },
    { "hasVariableDegree", NULL, "Z", 0x1, NULL, NULL },
    { "setIsPolynomialWithBoolean:", "setIsPolynomial", "V", 0x1, NULL, NULL },
    { "isPolynomial", NULL, "Z", 0x1, NULL, NULL },
    { "mayBePolynomial", NULL, "Z", 0x1, NULL, NULL },
    { "wrap", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "lhs_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", NULL, NULL,  },
    { "rhs_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", NULL, NULL,  },
    { "leftPoly_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.Polynomial;", NULL, NULL,  },
    { "rightPoly_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.Polynomial;", NULL, NULL,  },
    { "normalForm_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.Polynomial;", NULL, NULL,  },
    { "isFunctionDependent__", "isFunctionDependent", 0x2, "Z", NULL, NULL,  },
    { "kernel_", NULL, 0x2, "Lgeogebra.common.kernel.Kernel;", NULL, NULL,  },
    { "forcePlane_", NULL, 0x2, "Z", NULL, NULL,  },
    { "forceLine_", NULL, 0x2, "Z", NULL, NULL,  },
    { "forceConic_", NULL, 0x2, "Z", NULL, NULL,  },
    { "forceImplicitPoly_", NULL, 0x2, "Z", NULL, NULL,  },
    { "forceQuadric_", NULL, 0x2, "Z", NULL, NULL,  },
    { "variableDegrees_", NULL, 0x2, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/arithmetic/ExpressionValue;>;",  },
    { "isPolynomial__", "isPolynomial", 0x2, "Z", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelArithmeticEquation = { 2, "Equation", "geogebra.common.kernel.arithmetic", NULL, 0x1, 53, methods, 14, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelArithmeticEquation;
}

@end

void GeogebraCommonKernelArithmeticEquation_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelArithmeticEquation *self, GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> lhs, id<GeogebraCommonKernelArithmeticExpressionValue> rhs) {
  GeogebraCommonKernelArithmeticValidExpression_init(self);
  self->forcePlane_ = NO;
  self->forceLine_ = NO;
  self->forceConic_ = NO;
  self->forceImplicitPoly_ = NO;
  self->forceQuadric_ = NO;
  GeogebraCommonKernelArithmeticEquation_set_variableDegrees_(self, nil);
  self->isPolynomial__ = YES;
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lhs)) isExpressionNode]) GeogebraCommonKernelArithmeticEquation_set_lhs_(self, (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(lhs, [GeogebraCommonKernelArithmeticExpressionNode class]));
  else GeogebraCommonKernelArithmeticEquation_setAndConsume_lhs_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, lhs));
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rhs)) isExpressionNode]) GeogebraCommonKernelArithmeticEquation_set_rhs_(self, (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(rhs, [GeogebraCommonKernelArithmeticExpressionNode class]));
  else GeogebraCommonKernelArithmeticEquation_setAndConsume_rhs_(self, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, rhs));
  GeogebraCommonKernelArithmeticEquation_set_kernel_(self, kernel);
  self->isFunctionDependent__ = NO;
}

GeogebraCommonKernelArithmeticEquation *new_GeogebraCommonKernelArithmeticEquation_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> lhs, id<GeogebraCommonKernelArithmeticExpressionValue> rhs) {
  GeogebraCommonKernelArithmeticEquation *self = [GeogebraCommonKernelArithmeticEquation alloc];
  GeogebraCommonKernelArithmeticEquation_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(self, kernel, lhs, rhs);
  return self;
}

NSString *GeogebraCommonKernelArithmeticEquation_toValueStringWithGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelArithmeticEquation *self, GeogebraCommonKernelStringTemplate *tpl) {
  JavaLangStringBuilder *sb = [new_JavaLangStringBuilder_init() autorelease];
  if (self->lhs_ != nil) [sb appendWithNSString:[self->lhs_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
  else [sb appendWithChar:'0'];
  if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getStringType])) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
    if ([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(self->lhs_)) evaluatesToList] || [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(self->rhs_)) evaluatesToList]) {
      [sb appendWithNSString:@"%="];
    }
    else {
      [sb appendWithNSString:@"="];
    }
  }
  else {
    [sb appendWithNSString:@" = "];
  }
  if (self->rhs_ != nil) {
    [sb appendWithNSString:[self->rhs_ toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
  }
  else {
    [sb appendWithChar:'0'];
  }
  return [sb description];
}

jboolean GeogebraCommonKernelArithmeticEquation_containsVarWithGeogebraCommonKernelArithmeticExpressionValue_withChar_(id<GeogebraCommonKernelArithmeticExpressionValue> v, jchar var) {
  GeogebraCommonKernelArithmeticEquation_initialize();
  if (v == nil) {
    return NO;
  }
  if ([v isKindOfClass:[GeogebraCommonKernelArithmeticExpressionNode class]]) {
    GeogebraCommonKernelArithmeticExpressionNode *node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(v, [GeogebraCommonKernelArithmeticExpressionNode class]);
    if (GeogebraCommonKernelArithmeticEquation_containsVarWithGeogebraCommonKernelArithmeticExpressionValue_withChar_([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(node)) getLeft], var)) {
      return YES;
    }
    return GeogebraCommonKernelArithmeticEquation_containsVarWithGeogebraCommonKernelArithmeticExpressionValue_withChar_([node getRight], var);
  }
  if ([v isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]]) {
    NSString *vVar = [((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk(((GeogebraCommonKernelArithmeticFunctionVariable *) check_class_cast(v, [GeogebraCommonKernelArithmeticFunctionVariable class])))) getSetVarString];
    return ((jint) [((NSString *) nil_chk(vVar)) length]) == 1 && [vVar charAtWithInt:0] == var;
  }
  if ([v isKindOfClass:[GeogebraCommonKernelArithmeticPolynomial class]]) {
    return ![((GeogebraCommonKernelArithmeticPolynomial *) nil_chk(((GeogebraCommonKernelArithmeticPolynomial *) check_class_cast(v, [GeogebraCommonKernelArithmeticPolynomial class])))) isFreeOfWithChar:var];
  }
  return NO;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelArithmeticEquation)
