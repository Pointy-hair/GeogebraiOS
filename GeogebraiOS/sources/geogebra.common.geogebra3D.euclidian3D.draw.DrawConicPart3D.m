//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/geogebra3D/euclidian3D/draw/DrawConicPart3D.java
//


#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/geogebra3D/euclidian3D/EuclidianView3D.h"
#include "geogebra/common/geogebra3D/euclidian3D/draw/DrawConic3D.h"
#include "geogebra/common/geogebra3D/euclidian3D/draw/DrawConicPart3D.h"
#include "geogebra/common/geogebra3D/euclidian3D/draw/Drawable3D.h"
#include "geogebra/common/geogebra3D/euclidian3D/openGL/PlotterBrush.h"
#include "geogebra/common/geogebra3D/euclidian3D/openGL/PlotterSurface.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/kernelND/GeoConicND.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoConicPartND.h"
#include "java/lang/Math.h"

@interface GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D ()

- (void)updateSectorSegmentsWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:(GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *)brush
                                                                           withDouble:(jdouble)start
                                                                           withDouble:(jdouble)end;

@end

__attribute__((unused)) static void GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_updateSectorSegmentsWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush_withDouble_withDouble_(GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D *self, GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *brush, jdouble start, jdouble end);

@implementation GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D

- (instancetype)initWithGeogebraCommonGeogebra3DEuclidian3DEuclidianView3D:(GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *)view3d
                            withGeogebraCommonKernelKernelNDGeoConicPartND:(id<GeogebraCommonKernelKernelNDGeoConicPartND>)conic {
  GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_initWithGeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_withGeogebraCommonKernelKernelNDGeoConicPartND_(self, view3d, conic);
  return self;
}

- (jdouble)getEllipseSurfaceStart {
  return [((id<GeogebraCommonKernelKernelNDGeoConicPartND>) nil_chk(((id<GeogebraCommonKernelKernelNDGeoConicPartND>) check_protocol_cast([self getGeoElement], @protocol(GeogebraCommonKernelKernelNDGeoConicPartND))))) getParameterStart];
}

- (jdouble)getEllipseSurfaceExtent {
  return [((id<GeogebraCommonKernelKernelNDGeoConicPartND>) nil_chk(((id<GeogebraCommonKernelKernelNDGeoConicPartND>) check_protocol_cast([self getGeoElement], @protocol(GeogebraCommonKernelKernelNDGeoConicPartND))))) getParameterExtent];
}

- (void)updateCircleWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:(GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *)brush {
  jdouble start = [self getEllipseSurfaceStart];
  jdouble extent = [self getEllipseSurfaceExtent];
  [((GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *) nil_chk(brush)) arcWithGeogebraCommonKernelMatrixCoords:m_ withGeogebraCommonKernelMatrixCoords:ev1_ withGeogebraCommonKernelMatrixCoords:ev2_ withDouble:e1_ withDouble:start withDouble:extent withInt:longitude_];
  GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_updateSectorSegmentsWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush_withDouble_withDouble_(self, brush, start, start + extent);
}

- (void)updateEllipseWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:(GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *)brush {
  jdouble start = [self getEllipseSurfaceStart];
  jdouble extent = [self getEllipseSurfaceExtent];
  [((GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *) nil_chk(brush)) arcEllipseWithGeogebraCommonKernelMatrixCoords:m_ withGeogebraCommonKernelMatrixCoords:ev1_ withGeogebraCommonKernelMatrixCoords:ev2_ withDouble:e1_ withDouble:e2_ withDouble:start withDouble:extent];
  GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_updateSectorSegmentsWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush_withDouble_withDouble_(self, brush, start, start + extent);
}

- (void)updateSectorSegmentsWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:(GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *)brush
                                                                           withDouble:(jdouble)start
                                                                           withDouble:(jdouble)end {
  GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_updateSectorSegmentsWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush_withDouble_withDouble_(self, brush, start, end);
}

- (void)updateLinesWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:(GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *)brush {
  if ([((id<GeogebraCommonKernelKernelNDGeoConicPartND>) nil_chk(((id<GeogebraCommonKernelKernelNDGeoConicPartND>) check_protocol_cast(conic_, @protocol(GeogebraCommonKernelKernelNDGeoConicPartND))))) positiveOrientation]) {
    [((GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *) nil_chk(brush)) segmentWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(conic_)) getOrigin3DWithInt:0] withGeogebraCommonKernelMatrixCoords:[((id<GeogebraCommonKernelKernelNDGeoConicPartND>) check_protocol_cast(conic_, @protocol(GeogebraCommonKernelKernelNDGeoConicPartND))) getSegmentEnd3D]];
  }
  else {
    GeogebraCommonGeogebra3DEuclidian3DDrawDrawConic3D_set_m_(self, [((GeogebraCommonKernelKernelNDGeoConicND *) nil_chk(conic_)) getOrigin3DWithInt:0]);
    GeogebraCommonGeogebra3DEuclidian3DDrawDrawConic3D_set_d_(self, [((GeogebraCommonKernelMatrixCoords *) nil_chk([((id<GeogebraCommonKernelKernelNDGeoConicPartND>) check_protocol_cast(conic_, @protocol(GeogebraCommonKernelKernelNDGeoConicPartND))) getSegmentEnd3D])) subWithGeogebraCommonKernelMatrixCoords:m_]);
    GeogebraCommonGeogebra3DEuclidian3DDrawDrawConic3D_set_minmax_(self, [self getLineMinMaxWithInt:0]);
    [((GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *) nil_chk(brush)) segmentWithGeogebraCommonKernelMatrixCoords:m_ withGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelMatrixCoords *) nil_chk(m_)) addWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelMatrixCoords *) nil_chk(d_)) mulWithDouble:IOSDoubleArray_Get(nil_chk(minmax_), 0)]]];
    [brush segmentWithGeogebraCommonKernelMatrixCoords:[conic_ getOrigin3DWithInt:1] withGeogebraCommonKernelMatrixCoords:[m_ addWithGeogebraCommonKernelMatrixCoords:[d_ mulWithDouble:IOSDoubleArray_Get(minmax_, 1)]]];
  }
}

- (void)updateParallelLinesWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterSurface:(GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterSurface *)surface {
}

- (void)updateSinglePointWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterSurface:(GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterSurface *)surface {
  [self setGeometryIndexWithInt:-1];
}

- (jboolean)isSector {
  return [((id<GeogebraCommonKernelKernelNDGeoConicPartND>) nil_chk(((id<GeogebraCommonKernelKernelNDGeoConicPartND>) check_protocol_cast(conic_, @protocol(GeogebraCommonKernelKernelNDGeoConicPartND))))) getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonGeogebra3DEuclidian3DEuclidianView3D:withGeogebraCommonKernelKernelNDGeoConicPartND:", "DrawConicPart3D", NULL, 0x1, NULL, NULL },
    { "getEllipseSurfaceStart", NULL, "D", 0x4, NULL, NULL },
    { "getEllipseSurfaceExtent", NULL, "D", 0x4, NULL, NULL },
    { "updateCircleWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:", "updateCircle", "V", 0x4, NULL, NULL },
    { "updateEllipseWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:", "updateEllipse", "V", 0x4, NULL, NULL },
    { "updateSectorSegmentsWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:withDouble:withDouble:", "updateSectorSegments", "V", 0x2, NULL, NULL },
    { "updateLinesWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush:", "updateLines", "V", 0x4, NULL, NULL },
    { "updateParallelLinesWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterSurface:", "updateParallelLines", "V", 0x4, NULL, NULL },
    { "updateSinglePointWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterSurface:", "updateSinglePoint", "V", 0x4, NULL, NULL },
    { "isSector", NULL, "Z", 0x4, NULL, NULL },
  };
  static const J2ObjcClassInfo _GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D = { 2, "DrawConicPart3D", "geogebra.common.geogebra3D.euclidian3D.draw", NULL, 0x1, 10, methods, 0, NULL, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D;
}

@end

void GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_initWithGeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_withGeogebraCommonKernelKernelNDGeoConicPartND_(GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D *self, GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *view3d, id<GeogebraCommonKernelKernelNDGeoConicPartND> conic) {
  GeogebraCommonGeogebra3DEuclidian3DDrawDrawConic3D_initWithGeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_withGeogebraCommonKernelKernelNDGeoConicND_(self, view3d, (GeogebraCommonKernelKernelNDGeoConicND *) check_class_cast(conic, [GeogebraCommonKernelKernelNDGeoConicND class]));
}

GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D *new_GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_initWithGeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_withGeogebraCommonKernelKernelNDGeoConicPartND_(GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *view3d, id<GeogebraCommonKernelKernelNDGeoConicPartND> conic) {
  GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D *self = [GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D alloc];
  GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_initWithGeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_withGeogebraCommonKernelKernelNDGeoConicPartND_(self, view3d, conic);
  return self;
}

void GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D_updateSectorSegmentsWithGeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush_withDouble_withDouble_(GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D *self, GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *brush, jdouble start, jdouble end) {
  if ([((id<GeogebraCommonKernelKernelNDGeoConicPartND>) nil_chk(((id<GeogebraCommonKernelKernelNDGeoConicPartND>) check_protocol_cast([self getGeoElement], @protocol(GeogebraCommonKernelKernelNDGeoConicPartND))))) getConicPartType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR) {
    [((GeogebraCommonGeogebra3DEuclidian3DOpenGLPlotterBrush *) nil_chk(brush)) setAffineTextureWithFloat:0.5f withFloat:0.25f];
    [brush segmentWithGeogebraCommonKernelMatrixCoords:self->m_ withGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelMatrixCoords *) nil_chk([((GeogebraCommonKernelMatrixCoords *) nil_chk(self->m_)) addWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelMatrixCoords *) nil_chk(self->ev1_)) mulWithDouble:self->e1_ * JavaLangMath_cosWithDouble_(start)]])) addWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelMatrixCoords *) nil_chk(self->ev2_)) mulWithDouble:self->e2_ * JavaLangMath_sinWithDouble_(start)]]];
    [brush segmentWithGeogebraCommonKernelMatrixCoords:self->m_ withGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelMatrixCoords *) nil_chk([self->m_ addWithGeogebraCommonKernelMatrixCoords:[self->ev1_ mulWithDouble:self->e1_ * JavaLangMath_cosWithDouble_(end)]])) addWithGeogebraCommonKernelMatrixCoords:[self->ev2_ mulWithDouble:self->e2_ * JavaLangMath_sinWithDouble_(end)]]];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonGeogebra3DEuclidian3DDrawDrawConicPart3D)
