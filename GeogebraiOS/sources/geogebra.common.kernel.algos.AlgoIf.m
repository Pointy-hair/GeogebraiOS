//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/algos/AlgoIf.java
//


#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoIf.h"
#include "geogebra/common/kernel/algos/DrawInformationAlgo.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/MyList.h"
#include "geogebra/common/kernel/arithmetic/MyNumberPair.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoBoolean.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/Test.h"
#include "geogebra/common/plugin/Operation.h"
#include "java/lang/Exception.h"
#include "java/util/ArrayList.h"

@interface GeogebraCommonKernelAlgosAlgoIf () {
 @public
  GeogebraCommonKernelGeosGeoElement *result_;
  JavaUtilArrayList *alternatives_;
  JavaUtilArrayList *conditions_;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIf, result_, GeogebraCommonKernelGeosGeoElement *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIf, alternatives_, JavaUtilArrayList *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoIf, conditions_, JavaUtilArrayList *)

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoIf_compute(GeogebraCommonKernelAlgosAlgoIf *self);

@implementation GeogebraCommonKernelAlgosAlgoIf

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                                            withNSString:(NSString *)label
                                   withJavaUtilArrayList:(JavaUtilArrayList *)conditions
                                   withJavaUtilArrayList:(JavaUtilArrayList *)alternatives {
  GeogebraCommonKernelAlgosAlgoIf_initWithGeogebraCommonKernelConstruction_withNSString_withJavaUtilArrayList_withJavaUtilArrayList_(self, cons, label, conditions, alternatives);
  return self;
}

- (GeogebraCommonKernelCommandsCommandsEnum *)getClassName {
  return GeogebraCommonKernelCommandsCommandsEnum_get_If();
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_setAndConsume_input_(self, [IOSObjectArray newArrayWithLength:[((JavaUtilArrayList *) nil_chk(conditions_)) size] + [((JavaUtilArrayList *) nil_chk(alternatives_)) size] type:GeogebraCommonKernelGeosGeoElement_class_()]);
  for (jint i = 0; i < [self->conditions_ size]; i++) {
    IOSObjectArray_Set(input_, 2 * i, [conditions_ getWithInt:i]);
    IOSObjectArray_Set(input_, 2 * i + 1, [alternatives_ getWithInt:i]);
  }
  if ([alternatives_ size] > [conditions_ size]) {
    IOSObjectArray_Set(input_, input_->size_ - 1, [alternatives_ getWithInt:[alternatives_ size] - 1]);
  }
  [super setOutputLengthWithInt:1];
  [super setOutputWithInt:0 withGeogebraCommonKernelGeosGeoElement:result_];
  [self setDependencies];
}

- (GeogebraCommonKernelGeosGeoElement *)getGeoElement {
  return result_;
}

- (void)compute {
  GeogebraCommonKernelAlgosAlgoIf_compute(self);
}

- (GeogebraCommonKernelArithmeticExpressionNode *)toExpression {
  if ([((JavaUtilArrayList *) nil_chk(self->alternatives_)) size] == 1) {
    return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) convertNumberValueToExpressionNodeWithGeogebraCommonKernelGeosGeoElement:[((JavaUtilArrayList *) nil_chk(self->conditions_)) getWithInt:0]], GeogebraCommonPluginOperationEnum_get_IF(), [kernel_ convertNumberValueToExpressionNodeWithGeogebraCommonKernelGeosGeoElement:[self->alternatives_ getWithInt:0]]) autorelease];
  }
  else if ([((JavaUtilArrayList *) nil_chk(self->conditions_)) size] == 1) {
    return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [new_GeogebraCommonKernelArithmeticMyNumberPair_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) convertNumberValueToExpressionNodeWithGeogebraCommonKernelGeosGeoElement:[self->conditions_ getWithInt:0]], [kernel_ convertNumberValueToExpressionNodeWithGeogebraCommonKernelGeosGeoElement:[self->alternatives_ getWithInt:0]]) autorelease], GeogebraCommonPluginOperationEnum_get_IF_ELSE(), [kernel_ convertNumberValueToExpressionNodeWithGeogebraCommonKernelGeosGeoElement:[self->alternatives_ getWithInt:1]]) autorelease];
  }
  GeogebraCommonKernelArithmeticMyList *cond = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel_) autorelease], *funs = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel_) autorelease];
  for (GeogebraCommonKernelGeosGeoBoolean * __strong f in nil_chk(conditions_)) {
    [cond addListElementWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelKernel *) nil_chk(kernel_)) convertNumberValueToExpressionNodeWithGeogebraCommonKernelGeosGeoElement:f]];
  }
  for (GeogebraCommonKernelGeosGeoElement * __strong f in alternatives_) {
    [funs addListElementWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelKernel *) nil_chk(kernel_)) convertNumberValueToExpressionNodeWithGeogebraCommonKernelGeosGeoElement:f]];
  }
  return [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, cond, GeogebraCommonPluginOperationEnum_get_IF_LIST(), funs) autorelease];
}

- (void)dealloc {
  RELEASE_(result_);
  RELEASE_(alternatives_);
  RELEASE_(conditions_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withNSString:withJavaUtilArrayList:withJavaUtilArrayList:", "AlgoIf", NULL, 0x1, NULL, NULL },
    { "getClassName", NULL, "Lgeogebra.common.kernel.commands.Commands;", 0x1, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x4, NULL, NULL },
    { "getGeoElement", NULL, "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "compute", NULL, "V", 0x11, NULL, NULL },
    { "toExpression", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "result_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoElement;", NULL, NULL,  },
    { "alternatives_", NULL, 0x2, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/geos/GeoElement;>;",  },
    { "conditions_", NULL, 0x2, "Ljava.util.ArrayList;", NULL, "Ljava/util/ArrayList<Lgeogebra/common/kernel/geos/GeoBoolean;>;",  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelAlgosAlgoIf = { 2, "AlgoIf", "geogebra.common.kernel.algos", NULL, 0x1, 6, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelAlgosAlgoIf;
}

@end

void GeogebraCommonKernelAlgosAlgoIf_initWithGeogebraCommonKernelConstruction_withNSString_withJavaUtilArrayList_withJavaUtilArrayList_(GeogebraCommonKernelAlgosAlgoIf *self, GeogebraCommonKernelConstruction *cons, NSString *label, JavaUtilArrayList *conditions, JavaUtilArrayList *alternatives) {
  GeogebraCommonKernelAlgosAlgoElement_initWithGeogebraCommonKernelConstruction_(self, cons);
  GeogebraCommonKernelAlgosAlgoIf_set_conditions_(self, conditions);
  GeogebraCommonKernelAlgosAlgoIf_set_alternatives_(self, alternatives);
  GeogebraCommonKernelAlgosAlgoIf_set_result_(self, [((JavaUtilArrayList *) nil_chk(alternatives)) getWithInt:0]);
  jint i = 1;
  while (i < [alternatives size] && GeogebraCommonKernelGeosTestEnum_canSetWithGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_([alternatives getWithInt:i], self->result_)) {
    GeogebraCommonKernelAlgosAlgoIf_set_result_(self, [alternatives getWithInt:i]);
    i++;
  }
  GeogebraCommonKernelAlgosAlgoIf_set_result_(self, [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->result_)) copyInternalWithGeogebraCommonKernelConstruction:cons]);
  [self setInputOutput];
  GeogebraCommonKernelAlgosAlgoIf_compute(self);
  [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->result_)) setLabelWithNSString:label];
}

GeogebraCommonKernelAlgosAlgoIf *new_GeogebraCommonKernelAlgosAlgoIf_initWithGeogebraCommonKernelConstruction_withNSString_withJavaUtilArrayList_withJavaUtilArrayList_(GeogebraCommonKernelConstruction *cons, NSString *label, JavaUtilArrayList *conditions, JavaUtilArrayList *alternatives) {
  GeogebraCommonKernelAlgosAlgoIf *self = [GeogebraCommonKernelAlgosAlgoIf alloc];
  GeogebraCommonKernelAlgosAlgoIf_initWithGeogebraCommonKernelConstruction_withNSString_withJavaUtilArrayList_withJavaUtilArrayList_(self, cons, label, conditions, alternatives);
  return self;
}

void GeogebraCommonKernelAlgosAlgoIf_compute(GeogebraCommonKernelAlgosAlgoIf *self) {
  @try {
    for (jint i = 0; i < [((JavaUtilArrayList *) nil_chk(self->conditions_)) size]; i++) {
      if ([((GeogebraCommonKernelGeosGeoBoolean *) nil_chk([self->conditions_ getWithInt:i])) getBoolean]) {
        [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->result_)) setWithGeogebraCommonKernelGeosGeoElement:[((JavaUtilArrayList *) nil_chk(self->alternatives_)) getWithInt:i]];
        if ([GeogebraCommonKernelAlgosDrawInformationAlgo_class_() isInstance:[((GeogebraCommonKernelGeosGeoElement *) nil_chk([self->alternatives_ getWithInt:i])) getDrawAlgorithm]]) {
          [self->result_ setDrawAlgorithmWithGeogebraCommonKernelAlgosDrawInformationAlgo:[((id<GeogebraCommonKernelAlgosDrawInformationAlgo>) nil_chk(((id<GeogebraCommonKernelAlgosDrawInformationAlgo>) check_protocol_cast([((GeogebraCommonKernelGeosGeoElement *) nil_chk([self->alternatives_ getWithInt:i])) getDrawAlgorithm], @protocol(GeogebraCommonKernelAlgosDrawInformationAlgo))))) copy__]];
        }
        return;
      }
      GeogebraCommonKernelGeosGeoElement *last = [self->alternatives_ getWithInt:[((JavaUtilArrayList *) nil_chk(self->alternatives_)) size] - 1];
      if ([self->conditions_ size] == [self->alternatives_ size]) [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->result_)) setUndefined];
      else [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->result_)) setWithGeogebraCommonKernelGeosGeoElement:last];
      if ([GeogebraCommonKernelAlgosDrawInformationAlgo_class_() isInstance:[((GeogebraCommonKernelGeosGeoElement *) nil_chk(last)) getDrawAlgorithm]]) {
        [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->result_)) setDrawAlgorithmWithGeogebraCommonKernelAlgosDrawInformationAlgo:[((id<GeogebraCommonKernelAlgosDrawInformationAlgo>) nil_chk(((id<GeogebraCommonKernelAlgosDrawInformationAlgo>) check_protocol_cast([last getDrawAlgorithm], @protocol(GeogebraCommonKernelAlgosDrawInformationAlgo))))) copy__]];
      }
    }
  }
  @catch (JavaLangException *e) {
    [((GeogebraCommonKernelGeosGeoElement *) nil_chk(self->result_)) setUndefined];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelAlgosAlgoIf)
