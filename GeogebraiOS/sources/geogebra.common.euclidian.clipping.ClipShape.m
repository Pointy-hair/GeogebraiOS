//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/euclidian/clipping/ClipShape.java
//


#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GAffineTransform.h"
#include "geogebra/common/awt/GCubicCurve2D.h"
#include "geogebra/common/awt/GGeneralPath.h"
#include "geogebra/common/awt/GPathIterator.h"
#include "geogebra/common/awt/GRectangle2D.h"
#include "geogebra/common/awt/GShape.h"
#include "geogebra/common/euclidian/clipping/ClipShape.h"
#include "geogebra/common/euclidian/clipping/DoubleArrayFactory.h"
#include "geogebra/common/factories/AwtFactory.h"
#include "java/lang/Math.h"
#include "java/lang/RuntimeException.h"
#include "java/util/Arrays.h"
#include "java/util/Stack.h"

#define GeogebraCommonEuclidianClippingClipShape_TOLERANCE 1.0E-10

J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonEuclidianClippingClipShape, TOLERANCE, jdouble)

@interface GeogebraCommonEuclidianClippingClipShape_ClippedPath () {
 @public
  JavaUtilStack *uncommittedPoints_;
  jdouble initialX_, initialY_;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonEuclidianClippingClipShape_ClippedPath, uncommittedPoints_, JavaUtilStack *)

@interface GeogebraCommonEuclidianClippingClipShape_Function : NSObject
@end

@interface GeogebraCommonEuclidianClippingClipShape_LFunction () {
 @public
  jdouble slope_, intercept_;
}

@end

@interface GeogebraCommonEuclidianClippingClipShape_QFunction () {
 @public
  jdouble a_, b_, c_;
}

@end

@interface GeogebraCommonEuclidianClippingClipShape_CFunction () {
 @public
  jdouble a_, b_, c_, d_;
}

@end

J2OBJC_INITIALIZED_DEFN(GeogebraCommonEuclidianClippingClipShape)

GeogebraCommonEuclidianClippingDoubleArrayFactory *GeogebraCommonEuclidianClippingClipShape_doubleFactory_;

@implementation GeogebraCommonEuclidianClippingClipShape

+ (id<GeogebraCommonAwtGGeneralPath>)clipToRectWithGeogebraCommonAwtGShape:(id<GeogebraCommonAwtGShape>)s
                                     withGeogebraCommonAwtGAffineTransform:(id<GeogebraCommonAwtGAffineTransform>)t
                                         withGeogebraCommonAwtGRectangle2D:(id<GeogebraCommonAwtGRectangle2D>)r {
  return GeogebraCommonEuclidianClippingClipShape_clipToRectWithGeogebraCommonAwtGShape_withGeogebraCommonAwtGAffineTransform_withGeogebraCommonAwtGRectangle2D_(s, t, r);
}

- (instancetype)init {
  GeogebraCommonEuclidianClippingClipShape_init(self);
  return self;
}

+ (void)initialize {
  if (self == [GeogebraCommonEuclidianClippingClipShape class]) {
    JreStrongAssignAndConsume(&GeogebraCommonEuclidianClippingClipShape_doubleFactory_, nil, new_GeogebraCommonEuclidianClippingDoubleArrayFactory_init());
    J2OBJC_SET_INITIALIZED(GeogebraCommonEuclidianClippingClipShape)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "clipToRectWithGeogebraCommonAwtGShape:withGeogebraCommonAwtGAffineTransform:withGeogebraCommonAwtGRectangle2D:", "clipToRect", "Lgeogebra.common.awt.GGeneralPath;", 0x9, NULL, NULL },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "doubleFactory_", NULL, 0x18, "Lgeogebra.common.euclidian.clipping.DoubleArrayFactory;", &GeogebraCommonEuclidianClippingClipShape_doubleFactory_, NULL,  },
    { "TOLERANCE_", NULL, 0x1a, "D", NULL, NULL, .constantValue.asDouble = GeogebraCommonEuclidianClippingClipShape_TOLERANCE },
  };
  static const char *inner_classes[] = {"Lgeogebra.common.euclidian.clipping.ClipShape$ClippedPath;", "Lgeogebra.common.euclidian.clipping.ClipShape$Function;", "Lgeogebra.common.euclidian.clipping.ClipShape$LFunction;", "Lgeogebra.common.euclidian.clipping.ClipShape$QFunction;", "Lgeogebra.common.euclidian.clipping.ClipShape$CFunction;"};
  static const J2ObjcClassInfo _GeogebraCommonEuclidianClippingClipShape = { 2, "ClipShape", "geogebra.common.euclidian.clipping", NULL, 0x1, 2, methods, 2, fields, 0, NULL, 5, inner_classes, NULL, NULL };
  return &_GeogebraCommonEuclidianClippingClipShape;
}

@end

id<GeogebraCommonAwtGGeneralPath> GeogebraCommonEuclidianClippingClipShape_clipToRectWithGeogebraCommonAwtGShape_withGeogebraCommonAwtGAffineTransform_withGeogebraCommonAwtGRectangle2D_(id<GeogebraCommonAwtGShape> s, id<GeogebraCommonAwtGAffineTransform> t, id<GeogebraCommonAwtGRectangle2D> r) {
  GeogebraCommonEuclidianClippingClipShape_initialize();
  id<GeogebraCommonAwtGPathIterator> i = [((id<GeogebraCommonAwtGShape>) nil_chk(s)) getPathIteratorWithGeogebraCommonAwtGAffineTransform:t];
  GeogebraCommonEuclidianClippingClipShape_ClippedPath *p = [new_GeogebraCommonEuclidianClippingClipShape_ClippedPath_initWithInt_([((id<GeogebraCommonAwtGPathIterator>) nil_chk(i)) getWindingRule]) autorelease];
  jdouble initialX = 0;
  jdouble initialY = 0;
  jint k;
  IOSDoubleArray *f = [((GeogebraCommonEuclidianClippingDoubleArrayFactory *) nil_chk(GeogebraCommonEuclidianClippingClipShape_doubleFactory_)) getArrayWithInt:6];
  jdouble rTop = [((id<GeogebraCommonAwtGRectangle2D>) nil_chk(r)) getY];
  jdouble rLeft = [r getX];
  jdouble rRight = ([r getX] + [r getWidth]);
  jdouble rBottom = ([r getY] + [r getHeight]);
  jboolean shouldClose = NO;
  jdouble lastX = 0;
  jdouble lastY = 0;
  jboolean lastValueWasCapped, thisValueIsCapped, midValueInvalid;
  jdouble cappedX, cappedY, x, y, x2, y2;
  GeogebraCommonEuclidianClippingClipShape_LFunction *lxf = [new_GeogebraCommonEuclidianClippingClipShape_LFunction_init() autorelease];
  GeogebraCommonEuclidianClippingClipShape_LFunction *lyf = [new_GeogebraCommonEuclidianClippingClipShape_LFunction_init() autorelease];
  GeogebraCommonEuclidianClippingClipShape_QFunction *qxf = [new_GeogebraCommonEuclidianClippingClipShape_QFunction_init() autorelease];
  GeogebraCommonEuclidianClippingClipShape_QFunction *qyf = [new_GeogebraCommonEuclidianClippingClipShape_QFunction_init() autorelease];
  GeogebraCommonEuclidianClippingClipShape_CFunction *cxf = [new_GeogebraCommonEuclidianClippingClipShape_CFunction_init() autorelease];
  GeogebraCommonEuclidianClippingClipShape_CFunction *cyf = [new_GeogebraCommonEuclidianClippingClipShape_CFunction_init() autorelease];
  id<GeogebraCommonEuclidianClippingClipShape_Function> xf = nil;
  id<GeogebraCommonEuclidianClippingClipShape_Function> yf = nil;
  IOSDoubleArray *interestingTimes = [IOSDoubleArray arrayWithLength:16];
  jint tCtr;
  while ([i isDone] == NO) {
    k = [i currentSegmentWithDoubleArray:f];
    if (k == GeogebraCommonAwtGPathIterator_SEG_MOVETO) {
      initialX = IOSDoubleArray_Get(nil_chk(f), 0);
      initialY = IOSDoubleArray_Get(f, 1);
      cappedX = IOSDoubleArray_Get(f, 0);
      cappedY = IOSDoubleArray_Get(f, 1);
      if (cappedX < rLeft) cappedX = rLeft;
      if (cappedX > rRight) cappedX = rRight;
      if (cappedY < rTop) cappedY = rTop;
      if (cappedY > rBottom) cappedY = rBottom;
      [p moveToWithDouble:cappedX withDouble:cappedY];
      lastX = IOSDoubleArray_Get(f, 0);
      lastY = IOSDoubleArray_Get(f, 1);
    }
    else if (k == GeogebraCommonAwtGPathIterator_SEG_CLOSE) {
      *IOSDoubleArray_GetRef(nil_chk(f), 0) = initialX;
      *IOSDoubleArray_GetRef(f, 1) = initialY;
      k = GeogebraCommonAwtGPathIterator_SEG_LINETO;
      shouldClose = YES;
    }
    xf = nil;
    if (k == GeogebraCommonAwtGPathIterator_SEG_LINETO) {
      [lxf defineWithDouble:lastX withDouble:IOSDoubleArray_Get(nil_chk(f), 0)];
      [lyf defineWithDouble:lastY withDouble:IOSDoubleArray_Get(f, 1)];
      xf = lxf;
      yf = lyf;
    }
    else if (k == GeogebraCommonAwtGPathIterator_SEG_QUADTO) {
      [qxf defineWithDouble:lastX withDouble:IOSDoubleArray_Get(nil_chk(f), 0) withDouble:IOSDoubleArray_Get(f, 2)];
      [qyf defineWithDouble:lastY withDouble:IOSDoubleArray_Get(f, 1) withDouble:IOSDoubleArray_Get(f, 3)];
      xf = qxf;
      yf = qyf;
    }
    else if (k == GeogebraCommonAwtGPathIterator_SEG_CUBICTO) {
      [cxf defineWithDouble:lastX withDouble:IOSDoubleArray_Get(nil_chk(f), 0) withDouble:IOSDoubleArray_Get(f, 2) withDouble:IOSDoubleArray_Get(f, 4)];
      [cyf defineWithDouble:lastY withDouble:IOSDoubleArray_Get(f, 1) withDouble:IOSDoubleArray_Get(f, 3) withDouble:IOSDoubleArray_Get(f, 5)];
      xf = cxf;
      yf = cyf;
    }
    if (xf != nil) {
      tCtr = 0;
      tCtr += [xf evaluateInverseWithDouble:rLeft withDoubleArray:interestingTimes withInt:tCtr];
      tCtr += [xf evaluateInverseWithDouble:rRight withDoubleArray:interestingTimes withInt:tCtr];
      tCtr += [((id<GeogebraCommonEuclidianClippingClipShape_Function>) nil_chk(yf)) evaluateInverseWithDouble:rTop withDoubleArray:interestingTimes withInt:tCtr];
      tCtr += [yf evaluateInverseWithDouble:rBottom withDoubleArray:interestingTimes withInt:tCtr];
      *IOSDoubleArray_GetRef(interestingTimes, tCtr++) = 1;
      *IOSDoubleArray_GetRef(interestingTimes, tCtr++) = 0;
      JavaUtilArrays_sortWithDoubleArray_withInt_withInt_(interestingTimes, 0, tCtr);
      lastValueWasCapped = !(lastX >= rLeft && lastX <= rRight && lastY >= rTop && lastY <= rBottom);
      for (jint a = 0; a < tCtr; a++) {
        if (a > 0 && IOSDoubleArray_Get(interestingTimes, a) == IOSDoubleArray_Get(interestingTimes, a - 1)) {
        }
        else if (IOSDoubleArray_Get(interestingTimes, a) > 0 && IOSDoubleArray_Get(interestingTimes, a) <= 1) {
          x = [xf evaluateWithDouble:IOSDoubleArray_Get(interestingTimes, a)];
          y = [yf evaluateWithDouble:IOSDoubleArray_Get(interestingTimes, a)];
          cappedX = x;
          cappedY = y;
          if (cappedX < rLeft) {
            cappedX = rLeft;
          }
          else if (cappedX > rRight) {
            cappedX = rRight;
          }
          if (cappedY < rTop) {
            cappedY = rTop;
          }
          else if (cappedY > rBottom) {
            cappedY = rBottom;
          }
          thisValueIsCapped = !(JavaLangMath_absWithDouble_(x - cappedX) < GeogebraCommonEuclidianClippingClipShape_TOLERANCE && JavaLangMath_absWithDouble_(y - cappedY) < GeogebraCommonEuclidianClippingClipShape_TOLERANCE);
          x2 = [xf evaluateWithDouble:(IOSDoubleArray_Get(interestingTimes, a) + IOSDoubleArray_Get(interestingTimes, a - 1)) / 2];
          y2 = [yf evaluateWithDouble:(IOSDoubleArray_Get(interestingTimes, a) + IOSDoubleArray_Get(interestingTimes, a - 1)) / 2];
          midValueInvalid = !(rLeft <= x2 && x2 <= rRight && rTop <= y2 && y2 <= rBottom);
          if (([xf isKindOfClass:[GeogebraCommonEuclidianClippingClipShape_LFunction class]]) || thisValueIsCapped || lastValueWasCapped || midValueInvalid) {
            [p lineToWithDouble:cappedX withDouble:cappedY];
          }
          else if (([xf isKindOfClass:[GeogebraCommonEuclidianClippingClipShape_QFunction class]]) || ([xf isKindOfClass:[GeogebraCommonEuclidianClippingClipShape_CFunction class]])) {
            [p curveToWithGeogebraCommonEuclidianClippingClipShape_Function:xf withGeogebraCommonEuclidianClippingClipShape_Function:yf withDouble:IOSDoubleArray_Get(interestingTimes, a - 1) withDouble:IOSDoubleArray_Get(interestingTimes, a)];
          }
          else {
            @throw [new_JavaLangRuntimeException_initWithNSString_(@"Unexpected condition.") autorelease];
          }
          lastValueWasCapped = thisValueIsCapped;
        }
      }
      lastX = [xf evaluateWithDouble:1];
      lastY = [yf evaluateWithDouble:1];
    }
    if (shouldClose) {
      [p closePath];
      shouldClose = NO;
    }
    [i next];
  }
  [p flush];
  [GeogebraCommonEuclidianClippingClipShape_doubleFactory_ putArrayWithDoubleArray:f];
  return p->g_;
}

void GeogebraCommonEuclidianClippingClipShape_init(GeogebraCommonEuclidianClippingClipShape *self) {
  NSObject_init(self);
}

GeogebraCommonEuclidianClippingClipShape *new_GeogebraCommonEuclidianClippingClipShape_init() {
  GeogebraCommonEuclidianClippingClipShape *self = [GeogebraCommonEuclidianClippingClipShape alloc];
  GeogebraCommonEuclidianClippingClipShape_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonEuclidianClippingClipShape)

@implementation GeogebraCommonEuclidianClippingClipShape_ClippedPath

- (instancetype)initWithInt:(jint)windingRule {
  GeogebraCommonEuclidianClippingClipShape_ClippedPath_initWithInt_(self, windingRule);
  return self;
}

- (void)moveToWithDouble:(jdouble)x
              withDouble:(jdouble)y {
  [self flush];
  [((id<GeogebraCommonAwtGGeneralPath>) nil_chk(g_)) moveToWithFloat:(jfloat) x withFloat:(jfloat) y];
  initialX_ = x;
  initialY_ = y;
}

- (void)curveToWithGeogebraCommonEuclidianClippingClipShape_Function:(id<GeogebraCommonEuclidianClippingClipShape_Function>)xf
               withGeogebraCommonEuclidianClippingClipShape_Function:(id<GeogebraCommonEuclidianClippingClipShape_Function>)yf
                                                          withDouble:(jdouble)t0
                                                          withDouble:(jdouble)t1 {
  [self flush];
  jdouble dt = (t1 - t0);
  jdouble dx0 = [((id<GeogebraCommonEuclidianClippingClipShape_Function>) nil_chk(xf)) getDerivativeWithDouble:t0] * dt;
  jdouble dx1 = [xf getDerivativeWithDouble:t1] * dt;
  jdouble dy0 = [((id<GeogebraCommonEuclidianClippingClipShape_Function>) nil_chk(yf)) getDerivativeWithDouble:t0] * dt;
  jdouble dy1 = [yf getDerivativeWithDouble:t1] * dt;
  jdouble x0 = [xf evaluateWithDouble:t0];
  jdouble x1 = [xf evaluateWithDouble:t1];
  jdouble y0 = [yf evaluateWithDouble:t0];
  jdouble y1 = [yf evaluateWithDouble:t1];
  [((id<GeogebraCommonAwtGGeneralPath>) nil_chk(g_)) curveToWithFloat:(jfloat) (x0 + dx0 / 3) withFloat:(jfloat) (y0 + dy0 / 3) withFloat:(jfloat) (x1 - dx1 / 3) withFloat:(jfloat) (y1 - dy1 / 3) withFloat:(jfloat) (x1) withFloat:(jfloat) (y1)];
}

- (void)lineToWithDouble:(jdouble)x
              withDouble:(jdouble)y {
  if ([((JavaUtilStack *) nil_chk(uncommittedPoints_)) size] > 0) {
    IOSDoubleArray *last = [uncommittedPoints_ peek];
    if (JavaLangMath_absWithDouble_(IOSDoubleArray_Get(nil_chk(last), 0) - x) < GeogebraCommonEuclidianClippingClipShape_TOLERANCE && JavaLangMath_absWithDouble_(IOSDoubleArray_Get(last, 1) - y) < GeogebraCommonEuclidianClippingClipShape_TOLERANCE) return;
  }
  IOSDoubleArray *f = [((GeogebraCommonEuclidianClippingDoubleArrayFactory *) nil_chk(GeogebraCommonEuclidianClippingClipShape_get_doubleFactory_())) getArrayWithInt:2];
  *IOSDoubleArray_GetRef(nil_chk(f), 0) = x;
  *IOSDoubleArray_GetRef(f, 1) = y;
  [uncommittedPoints_ pushWithId:f];
}

- (void)closePath {
  [self lineToWithDouble:initialX_ withDouble:initialY_];
  [self flush];
  [((id<GeogebraCommonAwtGGeneralPath>) nil_chk(g_)) closePath];
}

- (void)flush {
  while ([((JavaUtilStack *) nil_chk(uncommittedPoints_)) size] > 0) {
    while ([uncommittedPoints_ size] >= 3) {
      IOSDoubleArray *first = [uncommittedPoints_ getWithInt:0];
      IOSDoubleArray *middle = [uncommittedPoints_ getWithInt:1];
      IOSDoubleArray *last = [uncommittedPoints_ getWithInt:2];
      if (JavaLangMath_absWithDouble_(IOSDoubleArray_Get(nil_chk(first), 0) - IOSDoubleArray_Get(nil_chk(middle), 0)) < GeogebraCommonEuclidianClippingClipShape_TOLERANCE && JavaLangMath_absWithDouble_(IOSDoubleArray_Get(first, 0) - IOSDoubleArray_Get(nil_chk(last), 0)) < GeogebraCommonEuclidianClippingClipShape_TOLERANCE) {
        IOSDoubleArray *array = [uncommittedPoints_ removeWithInt:1];
        [((GeogebraCommonEuclidianClippingDoubleArrayFactory *) nil_chk(GeogebraCommonEuclidianClippingClipShape_get_doubleFactory_())) putArrayWithDoubleArray:array];
      }
      else if (JavaLangMath_absWithDouble_(IOSDoubleArray_Get(first, 1) - IOSDoubleArray_Get(middle, 1)) < GeogebraCommonEuclidianClippingClipShape_TOLERANCE && JavaLangMath_absWithDouble_(IOSDoubleArray_Get(first, 1) - IOSDoubleArray_Get(nil_chk(last), 1)) < GeogebraCommonEuclidianClippingClipShape_TOLERANCE) {
        IOSDoubleArray *array = [uncommittedPoints_ removeWithInt:1];
        [((GeogebraCommonEuclidianClippingDoubleArrayFactory *) nil_chk(GeogebraCommonEuclidianClippingClipShape_get_doubleFactory_())) putArrayWithDoubleArray:array];
      }
      else {
        goto break_identifyLines;
      }
    }
    break_identifyLines: ;
    IOSDoubleArray *point = [uncommittedPoints_ removeWithInt:0];
    [((id<GeogebraCommonAwtGGeneralPath>) nil_chk(g_)) lineToWithFloat:(jfloat) IOSDoubleArray_Get(nil_chk(point), 0) withFloat:(jfloat) IOSDoubleArray_Get(point, 1)];
    [((GeogebraCommonEuclidianClippingDoubleArrayFactory *) nil_chk(GeogebraCommonEuclidianClippingClipShape_get_doubleFactory_())) putArrayWithDoubleArray:point];
  }
}

- (void)dealloc {
  RELEASE_(g_);
  RELEASE_(uncommittedPoints_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithInt:", "ClippedPath", NULL, 0x1, NULL, NULL },
    { "moveToWithDouble:withDouble:", "moveTo", "V", 0x1, NULL, NULL },
    { "curveToWithGeogebraCommonEuclidianClippingClipShape_Function:withGeogebraCommonEuclidianClippingClipShape_Function:withDouble:withDouble:", "curveTo", "V", 0x1, NULL, NULL },
    { "lineToWithDouble:withDouble:", "lineTo", "V", 0x1, NULL, NULL },
    { "closePath", NULL, "V", 0x1, NULL, NULL },
    { "flush", NULL, "V", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "g_", NULL, 0x11, "Lgeogebra.common.awt.GGeneralPath;", NULL, NULL,  },
    { "uncommittedPoints_", NULL, 0x2, "Ljava.util.Stack;", NULL, "Ljava/util/Stack<L[D;>;",  },
    { "initialX_", NULL, 0x2, "D", NULL, NULL,  },
    { "initialY_", NULL, 0x2, "D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonEuclidianClippingClipShape_ClippedPath = { 2, "ClippedPath", "geogebra.common.euclidian.clipping", "ClipShape", 0x8, 6, methods, 4, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonEuclidianClippingClipShape_ClippedPath;
}

@end

void GeogebraCommonEuclidianClippingClipShape_ClippedPath_initWithInt_(GeogebraCommonEuclidianClippingClipShape_ClippedPath *self, jint windingRule) {
  NSObject_init(self);
  GeogebraCommonEuclidianClippingClipShape_ClippedPath_setAndConsume_uncommittedPoints_(self, new_JavaUtilStack_init());
  GeogebraCommonEuclidianClippingClipShape_ClippedPath_set_g_(self, [((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newGeneralPathWithInt:windingRule]);
}

GeogebraCommonEuclidianClippingClipShape_ClippedPath *new_GeogebraCommonEuclidianClippingClipShape_ClippedPath_initWithInt_(jint windingRule) {
  GeogebraCommonEuclidianClippingClipShape_ClippedPath *self = [GeogebraCommonEuclidianClippingClipShape_ClippedPath alloc];
  GeogebraCommonEuclidianClippingClipShape_ClippedPath_initWithInt_(self, windingRule);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonEuclidianClippingClipShape_ClippedPath)

@implementation GeogebraCommonEuclidianClippingClipShape_Function

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "evaluateWithDouble:", "evaluate", "D", 0x401, NULL, NULL },
    { "evaluateInverseWithDouble:withDoubleArray:withInt:", "evaluateInverse", "I", 0x401, NULL, NULL },
    { "getDerivativeWithDouble:", "getDerivative", "D", 0x401, NULL, NULL },
  };
  static const J2ObjcClassInfo _GeogebraCommonEuclidianClippingClipShape_Function = { 2, "Function", "geogebra.common.euclidian.clipping", "ClipShape", 0x608, 3, methods, 0, NULL, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonEuclidianClippingClipShape_Function;
}

@end

J2OBJC_INTERFACE_TYPE_LITERAL_SOURCE(GeogebraCommonEuclidianClippingClipShape_Function)

@implementation GeogebraCommonEuclidianClippingClipShape_LFunction

- (instancetype)init {
  GeogebraCommonEuclidianClippingClipShape_LFunction_init(self);
  return self;
}

- (void)defineWithDouble:(jdouble)x1
              withDouble:(jdouble)x2 {
  slope_ = (x2 - x1);
  intercept_ = x1;
}

- (NSString *)description {
  return JreStrcat("D$D", slope_, @"*t+", intercept_);
}

- (jdouble)evaluateWithDouble:(jdouble)t {
  return slope_ * t + intercept_;
}

- (jint)evaluateInverseWithDouble:(jdouble)x
                  withDoubleArray:(IOSDoubleArray *)dest
                          withInt:(jint)offset {
  *IOSDoubleArray_GetRef(nil_chk(dest), offset) = (x - intercept_) / slope_;
  return 1;
}

- (jdouble)getDerivativeWithDouble:(jdouble)t {
  return slope_;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "LFunction", NULL, 0x1, NULL, NULL },
    { "defineWithDouble:withDouble:", "define", "V", 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "evaluateInverseWithDouble:withDoubleArray:withInt:", "evaluateInverse", "I", 0x1, NULL, NULL },
    { "getDerivativeWithDouble:", "getDerivative", "D", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "slope_", NULL, 0x2, "D", NULL, NULL,  },
    { "intercept_", NULL, 0x2, "D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonEuclidianClippingClipShape_LFunction = { 2, "LFunction", "geogebra.common.euclidian.clipping", "ClipShape", 0x8, 6, methods, 2, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonEuclidianClippingClipShape_LFunction;
}

@end

void GeogebraCommonEuclidianClippingClipShape_LFunction_init(GeogebraCommonEuclidianClippingClipShape_LFunction *self) {
  NSObject_init(self);
}

GeogebraCommonEuclidianClippingClipShape_LFunction *new_GeogebraCommonEuclidianClippingClipShape_LFunction_init() {
  GeogebraCommonEuclidianClippingClipShape_LFunction *self = [GeogebraCommonEuclidianClippingClipShape_LFunction alloc];
  GeogebraCommonEuclidianClippingClipShape_LFunction_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonEuclidianClippingClipShape_LFunction)

@implementation GeogebraCommonEuclidianClippingClipShape_QFunction

- (instancetype)init {
  GeogebraCommonEuclidianClippingClipShape_QFunction_init(self);
  return self;
}

- (NSString *)description {
  return JreStrcat("D$D$D", a_, @"*t*t+", b_, @"*t+", c_);
}

- (void)defineWithDouble:(jdouble)x0
              withDouble:(jdouble)x1
              withDouble:(jdouble)x2 {
  a_ = x0 - 2 * x1 + x2;
  b_ = -2 * x0 + 2 * x1;
  c_ = x0;
}

- (jdouble)evaluateWithDouble:(jdouble)t {
  return a_ * t * t + b_ * t + c_;
}

- (jdouble)getDerivativeWithDouble:(jdouble)t {
  return 2 * a_ * t + b_;
}

- (jint)evaluateInverseWithDouble:(jdouble)x
                  withDoubleArray:(IOSDoubleArray *)dest
                          withInt:(jint)offset {
  jdouble C = c_ - x;
  jdouble det = b_ * b_ - 4 * a_ * C;
  if (det < 0) return 0;
  if (det == 0) {
    *IOSDoubleArray_GetRef(nil_chk(dest), offset) = (-b_) / (2 * a_);
    return 1;
  }
  det = JavaLangMath_sqrtWithDouble_(det);
  *IOSDoubleArray_GetRef(nil_chk(dest), offset) = (-b_ + det) / (2 * a_);
  *IOSDoubleArray_GetRef(dest, offset + 1) = (-b_ - det) / (2 * a_);
  return 2;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "QFunction", NULL, 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "defineWithDouble:withDouble:withDouble:", "define", "V", 0x1, NULL, NULL },
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "getDerivativeWithDouble:", "getDerivative", "D", 0x1, NULL, NULL },
    { "evaluateInverseWithDouble:withDoubleArray:withInt:", "evaluateInverse", "I", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "a_", NULL, 0x2, "D", NULL, NULL,  },
    { "b_", NULL, 0x2, "D", NULL, NULL,  },
    { "c_", NULL, 0x2, "D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonEuclidianClippingClipShape_QFunction = { 2, "QFunction", "geogebra.common.euclidian.clipping", "ClipShape", 0x8, 6, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonEuclidianClippingClipShape_QFunction;
}

@end

void GeogebraCommonEuclidianClippingClipShape_QFunction_init(GeogebraCommonEuclidianClippingClipShape_QFunction *self) {
  NSObject_init(self);
}

GeogebraCommonEuclidianClippingClipShape_QFunction *new_GeogebraCommonEuclidianClippingClipShape_QFunction_init() {
  GeogebraCommonEuclidianClippingClipShape_QFunction *self = [GeogebraCommonEuclidianClippingClipShape_QFunction alloc];
  GeogebraCommonEuclidianClippingClipShape_QFunction_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonEuclidianClippingClipShape_QFunction)

@implementation GeogebraCommonEuclidianClippingClipShape_CFunction

- (instancetype)init {
  GeogebraCommonEuclidianClippingClipShape_CFunction_init(self);
  return self;
}

- (NSString *)description {
  return JreStrcat("D$D$D$D", a_, @"*t*t*t+", b_, @"*t*t+", c_, @"*t+", d_);
}

- (void)defineWithDouble:(jdouble)x0
              withDouble:(jdouble)x1
              withDouble:(jdouble)x2
              withDouble:(jdouble)x3 {
  a_ = -x0 + 3 * x1 - 3 * x2 + x3;
  b_ = 3 * x0 - 6 * x1 + 3 * x2;
  c_ = -3 * x0 + 3 * x1;
  d_ = x0;
}

- (jdouble)evaluateWithDouble:(jdouble)t {
  return a_ * t * t * t + b_ * t * t + c_ * t + d_;
}

- (jdouble)getDerivativeWithDouble:(jdouble)t {
  return 3 * a_ * t * t + 2 * b_ * t + c_;
}

- (jint)evaluateInverseWithDouble:(jdouble)x
                  withDoubleArray:(IOSDoubleArray *)dest
                          withInt:(jint)offset {
  if (eqn_ == nil) GeogebraCommonEuclidianClippingClipShape_CFunction_setAndConsume_eqn_(self, [IOSDoubleArray newArrayWithLength:4]);
  *IOSDoubleArray_GetRef(nil_chk(eqn_), 0) = d_ - x;
  *IOSDoubleArray_GetRef(eqn_, 1) = c_;
  *IOSDoubleArray_GetRef(eqn_, 2) = b_;
  *IOSDoubleArray_GetRef(eqn_, 3) = a_;
  if (offset == 0) {
    jint k = [((id<GeogebraCommonAwtGCubicCurve2D>) nil_chk([((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newCubicCurve2D])) solveCubicWithDoubleArray:eqn_ withDoubleArray:dest];
    if (k < 0) return 0;
    return k;
  }
  if (t2_ == nil) GeogebraCommonEuclidianClippingClipShape_CFunction_setAndConsume_t2_(self, [IOSDoubleArray newArrayWithLength:3]);
  jint k = [((id<GeogebraCommonAwtGCubicCurve2D>) nil_chk([((GeogebraCommonFactoriesAwtFactory *) nil_chk(GeogebraCommonFactoriesAwtFactory_get_prototype_())) newCubicCurve2D])) solveCubicWithDoubleArray:eqn_ withDoubleArray:t2_];
  if (k < 0) return 0;
  for (jint i = 0; i < k; i++) {
    *IOSDoubleArray_GetRef(nil_chk(dest), offset + i) = IOSDoubleArray_Get(nil_chk(t2_), i);
  }
  return k;
}

- (void)dealloc {
  RELEASE_(t2_);
  RELEASE_(eqn_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "CFunction", NULL, 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "defineWithDouble:withDouble:withDouble:withDouble:", "define", "V", 0x1, NULL, NULL },
    { "evaluateWithDouble:", "evaluate", "D", 0x1, NULL, NULL },
    { "getDerivativeWithDouble:", "getDerivative", "D", 0x1, NULL, NULL },
    { "evaluateInverseWithDouble:withDoubleArray:withInt:", "evaluateInverse", "I", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "a_", NULL, 0x2, "D", NULL, NULL,  },
    { "b_", NULL, 0x2, "D", NULL, NULL,  },
    { "c_", NULL, 0x2, "D", NULL, NULL,  },
    { "d_", NULL, 0x2, "D", NULL, NULL,  },
    { "t2_", NULL, 0x0, "[D", NULL, NULL,  },
    { "eqn_", NULL, 0x0, "[D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonEuclidianClippingClipShape_CFunction = { 2, "CFunction", "geogebra.common.euclidian.clipping", "ClipShape", 0x8, 6, methods, 6, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonEuclidianClippingClipShape_CFunction;
}

@end

void GeogebraCommonEuclidianClippingClipShape_CFunction_init(GeogebraCommonEuclidianClippingClipShape_CFunction *self) {
  NSObject_init(self);
}

GeogebraCommonEuclidianClippingClipShape_CFunction *new_GeogebraCommonEuclidianClippingClipShape_CFunction_init() {
  GeogebraCommonEuclidianClippingClipShape_CFunction *self = [GeogebraCommonEuclidianClippingClipShape_CFunction alloc];
  GeogebraCommonEuclidianClippingClipShape_CFunction_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonEuclidianClippingClipShape_CFunction)
