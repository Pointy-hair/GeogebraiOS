//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/algos/AlgoSpline.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/geogebra3D/kernel3D/geos/GeoCurveCartesian3D.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoSpline.h"
#include "geogebra/common/kernel/algos/GetCommand.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionVariable.h"
#include "geogebra/common/kernel/arithmetic/MyList.h"
#include "geogebra/common/kernel/commands/Commands.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoList.h"
#include "geogebra/common/kernel/geos/GeoNumberValue.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/kernelND/GeoCurveCartesianND.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/plugin/Operation.h"
#include "java/lang/Math.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"

@interface GeogebraCommonKernelAlgosAlgoSpline () {
 @public
  GeogebraCommonKernelGeosGeoList *inputList_;
  GeogebraCommonKernelKernelNDGeoCurveCartesianND *spline_;
  id<GeogebraCommonKernelGeosGeoNumberValue> degree_;
  IOSObjectArray *floatPoints_;
  IOSObjectArray *parameters_;
  jint length_;
  IOSFloatArray *cumulativeValueOfParameter_;
  jint degreeValue_;
  IOSFloatArray *parametersValues_;
  IOSFloatArray *parameterIntervalLimits_;
  jint dimension_;
}

- (void)calculateParameterValues;

+ (jfloat)calculateWithFloat:(jfloat)x
              withFloatArray:(IOSFloatArray *)m;

- (IOSFloatArray *)getSystemSolutionWithFloatArray2:(IOSObjectArray *)matrix;

- (IOSObjectArray *)getLinearSystemParametricWithInt:(jint)c;

+ (jfloat)factWithInt:(jint)i;

- (void)calcDerivativeWithFloatArray:(IOSFloatArray *)row
                             withInt:(jint)col
                             withInt:(jint)currentDerivative
                           withFloat:(jfloat)currentValueFromZeroToOne;

- (void)calcExtremesDerivativeWithFloatArray:(IOSFloatArray *)row
                                     withInt:(jint)col
                                     withInt:(jint)currentDerivative;

- (jfloat)calcCoeffWithInt:(jint)col
                   withInt:(jint)currentDerivative
                 withFloat:(jfloat)currentValueFromZeroToOne;

- (jfloat)evalForPointWithFloatArray2:(IOSObjectArray *)matrix
                              withInt:(jint)row
                              withInt:(jint)col
                            withFloat:(jfloat)currentValueFromZeroToOne;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoSpline, inputList_, GeogebraCommonKernelGeosGeoList *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoSpline, spline_, GeogebraCommonKernelKernelNDGeoCurveCartesianND *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoSpline, degree_, id<GeogebraCommonKernelGeosGeoNumberValue>)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoSpline, floatPoints_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoSpline, parameters_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoSpline, cumulativeValueOfParameter_, IOSFloatArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoSpline, parametersValues_, IOSFloatArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoSpline, parameterIntervalLimits_, IOSFloatArray *)

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoSpline_calculateParameterValues(GeogebraCommonKernelAlgosAlgoSpline *self);

__attribute__((unused)) static jfloat GeogebraCommonKernelAlgosAlgoSpline_calculateWithFloat_withFloatArray_(jfloat x, IOSFloatArray *m);

__attribute__((unused)) static IOSFloatArray *GeogebraCommonKernelAlgosAlgoSpline_getSystemSolutionWithFloatArray2_(GeogebraCommonKernelAlgosAlgoSpline *self, IOSObjectArray *matrix);

__attribute__((unused)) static IOSObjectArray *GeogebraCommonKernelAlgosAlgoSpline_getLinearSystemParametricWithInt_(GeogebraCommonKernelAlgosAlgoSpline *self, jint c);

__attribute__((unused)) static jfloat GeogebraCommonKernelAlgosAlgoSpline_factWithInt_(jint i);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoSpline_calcDerivativeWithFloatArray_withInt_withInt_withFloat_(GeogebraCommonKernelAlgosAlgoSpline *self, IOSFloatArray *row, jint col, jint currentDerivative, jfloat currentValueFromZeroToOne);

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoSpline_calcExtremesDerivativeWithFloatArray_withInt_withInt_(GeogebraCommonKernelAlgosAlgoSpline *self, IOSFloatArray *row, jint col, jint currentDerivative);

__attribute__((unused)) static jfloat GeogebraCommonKernelAlgosAlgoSpline_calcCoeffWithInt_withInt_withFloat_(GeogebraCommonKernelAlgosAlgoSpline *self, jint col, jint currentDerivative, jfloat currentValueFromZeroToOne);

__attribute__((unused)) static jfloat GeogebraCommonKernelAlgosAlgoSpline_evalForPointWithFloatArray2_withInt_withInt_withFloat_(GeogebraCommonKernelAlgosAlgoSpline *self, IOSObjectArray *matrix, jint row, jint col, jfloat currentValueFromZeroToOne);

@implementation GeogebraCommonKernelAlgosAlgoSpline

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                                            withNSString:(NSString *)label
                     withGeogebraCommonKernelGeosGeoList:(GeogebraCommonKernelGeosGeoList *)inputList {
  GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_(self, cons, label, inputList);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                                            withNSString:(NSString *)label
                     withGeogebraCommonKernelGeosGeoList:(GeogebraCommonKernelGeosGeoList *)inputList
              withGeogebraCommonKernelGeosGeoNumberValue:(id<GeogebraCommonKernelGeosGeoNumberValue>)degree {
  GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_withGeogebraCommonKernelGeosGeoNumberValue_(self, cons, label, inputList, degree);
  return self;
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_setAndConsume_input_(self, [IOSObjectArray newArrayWithLength:2 type:GeogebraCommonKernelGeosGeoElement_class_()]);
  IOSObjectArray_Set(input_, 0, inputList_);
  IOSObjectArray_Set(input_, 1, [((id<GeogebraCommonKernelGeosGeoNumberValue>) nil_chk(degree_)) toGeoElement]);
  [super setOutputLengthWithInt:1];
  [super setOutputWithInt:0 withGeogebraCommonKernelGeosGeoElement:spline_];
  [self setDependencies];
}

- (id<GeogebraCommonKernelAlgosGetCommand>)getClassName {
  return GeogebraCommonKernelCommandsCommandsEnum_get_Spline();
}

- (GeogebraCommonKernelKernelNDGeoCurveCartesianND *)getSpline {
  return spline_;
}

- (void)calculateParameterValues {
  GeogebraCommonKernelAlgosAlgoSpline_calculateParameterValues(self);
}

+ (jfloat)calculateWithFloat:(jfloat)x
              withFloatArray:(IOSFloatArray *)m {
  return GeogebraCommonKernelAlgosAlgoSpline_calculateWithFloat_withFloatArray_(x, m);
}

- (IOSFloatArray *)getParameterIntervalLimits {
  length_ = ((IOSFloatArray *) nil_chk(cumulativeValueOfParameter_))->size_;
  GeogebraCommonKernelAlgosAlgoSpline_setAndConsume_parameterIntervalLimits_(self, [IOSFloatArray newArrayWithLength:length_]);
  for (jint i = 1; i < length_; i++) {
    *IOSFloatArray_GetRef(parameterIntervalLimits_, i) = IOSFloatArray_Get(cumulativeValueOfParameter_, i) / IOSFloatArray_Get(cumulativeValueOfParameter_, cumulativeValueOfParameter_->size_ - 1);
  }
  return parameterIntervalLimits_;
}

- (void)compute {
  if (![((GeogebraCommonKernelGeosGeoList *) nil_chk(self->inputList_)) isDefined]) {
    [((GeogebraCommonKernelKernelNDGeoCurveCartesianND *) nil_chk(spline_)) setUndefined];
    return;
  }
  degreeValue_ = J2ObjCFpToInt([((id<GeogebraCommonKernelGeosGeoNumberValue>) nil_chk(degree_)) getDouble]) + 1;
  if (degreeValue_ < 4 || degreeValue_ > ((IOSObjectArray *) nil_chk(floatPoints_))->size_ + 1) {
    [((GeogebraCommonKernelKernelNDGeoCurveCartesianND *) nil_chk(spline_)) setUndefined];
    return;
  }
  jint i = 0;
  for (; i < ((IOSObjectArray *) nil_chk(floatPoints_))->size_; i++) {
    id<GeogebraCommonKernelKernelNDGeoPointND> p = (id<GeogebraCommonKernelKernelNDGeoPointND>) check_protocol_cast([self->inputList_ getWithInt:i], @protocol(GeogebraCommonKernelKernelNDGeoPointND));
    for (jint j = 0; j < dimension_; j++) {
      *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(floatPoints_, i)), j) = (jfloat) [((GeogebraCommonKernelMatrixCoords *) nil_chk([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(p)) getInhomCoordsInDWithInt:dimension_])) getWithInt:j + 1];
    }
  }
  for (i = 0; i < dimension_; i++) {
    IOSObjectArray_Set(nil_chk(parameters_), i, GeogebraCommonKernelAlgosAlgoSpline_getSystemSolutionWithFloatArray2_(self, GeogebraCommonKernelAlgosAlgoSpline_getLinearSystemParametricWithInt_(self, i)));
  }
  for (i = 0; i < dimension_; i++) if (IOSObjectArray_Get(nil_chk(parameters_), i) == nil) {
    return;
  }
  GeogebraCommonKernelArithmeticFunctionVariable *fv = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(self->kernel_, @"t") autorelease];
  IOSObjectArray *alt = [IOSObjectArray arrayWithLength:dimension_ type:GeogebraCommonKernelArithmeticMyList_class_()];
  IOSObjectArray *nodes = [IOSObjectArray arrayWithLength:dimension_ type:GeogebraCommonKernelArithmeticExpressionNode_class_()];
  for (i = 0; i < dimension_; i++) {
    IOSObjectArray_SetAndConsume(alt, i, new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel_));
  }
  GeogebraCommonKernelArithmeticMyList *cond = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel_) autorelease];
  GeogebraCommonKernelAlgosAlgoSpline_calculateParameterValues(self);
  jint t = 1;
  for (jint k = 0; k < ((IOSFloatArray *) nil_chk(IOSObjectArray_Get(nil_chk(parameters_), 0)))->size_; k += self->degreeValue_) {
    for (i = 0; i < dimension_; i++) {
      IOSObjectArray_SetAndConsume(nodes, i, new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, 0));
    }
    for (jint j = degreeValue_ - 1; j > -1; j--) {
      for (i = 0; i < dimension_; i++) {
        IOSObjectArray_Set(nodes, i, [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(IOSObjectArray_Get(nodes, i))) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(parameters_, i)), k + degreeValue_ - 1 - j)) autorelease]) multiplyRWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([fv wrap])) powerWithDouble:j]]]);
      }
    }
    for (i = 0; i < dimension_; i++) {
      [((GeogebraCommonKernelArithmeticMyList *) nil_chk(IOSObjectArray_Get(alt, i))) addListElementWithGeogebraCommonKernelArithmeticExpressionValue:IOSObjectArray_Get(nodes, i)];
    }
    if (t < ((IOSFloatArray *) nil_chk(self->parameterIntervalLimits_))->size_) {
      [cond addListElementWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([fv wrap])) lessThanWithDouble:IOSFloatArray_Get(self->parameterIntervalLimits_, t++)]];
    }
  }
  IOSObjectArray *functions = [IOSObjectArray arrayWithLength:dimension_ type:GeogebraCommonKernelArithmeticFunction_class_()];
  for (i = 0; i < dimension_; i++) {
    IOSObjectArray_SetAndConsume(functions, i, new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_([new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, cond, GeogebraCommonPluginOperationEnum_get_IF_LIST(), IOSObjectArray_Get(alt, i)) autorelease], fv));
  }
  [((GeogebraCommonKernelKernelNDGeoCurveCartesianND *) nil_chk(self->spline_)) setFunWithGeogebraCommonKernelArithmeticFunctionArray:functions];
  [self->spline_ setIntervalWithDouble:0 withDouble:1];
}

- (IOSFloatArray *)getSystemSolutionWithFloatArray2:(IOSObjectArray *)matrix {
  return GeogebraCommonKernelAlgosAlgoSpline_getSystemSolutionWithFloatArray2_(self, matrix);
}

- (IOSObjectArray *)getLinearSystemParametricWithInt:(jint)c {
  return GeogebraCommonKernelAlgosAlgoSpline_getLinearSystemParametricWithInt_(self, c);
}

+ (jfloat)factWithInt:(jint)i {
  return GeogebraCommonKernelAlgosAlgoSpline_factWithInt_(i);
}

- (void)calcDerivativeWithFloatArray:(IOSFloatArray *)row
                             withInt:(jint)col
                             withInt:(jint)currentDerivative
                           withFloat:(jfloat)currentValueFromZeroToOne {
  GeogebraCommonKernelAlgosAlgoSpline_calcDerivativeWithFloatArray_withInt_withInt_withFloat_(self, row, col, currentDerivative, currentValueFromZeroToOne);
}

- (void)calcExtremesDerivativeWithFloatArray:(IOSFloatArray *)row
                                     withInt:(jint)col
                                     withInt:(jint)currentDerivative {
  GeogebraCommonKernelAlgosAlgoSpline_calcExtremesDerivativeWithFloatArray_withInt_withInt_(self, row, col, currentDerivative);
}

- (jfloat)calcCoeffWithInt:(jint)col
                   withInt:(jint)currentDerivative
                 withFloat:(jfloat)currentValueFromZeroToOne {
  return GeogebraCommonKernelAlgosAlgoSpline_calcCoeffWithInt_withInt_withFloat_(self, col, currentDerivative, currentValueFromZeroToOne);
}

- (jfloat)evalForPointWithFloatArray2:(IOSObjectArray *)matrix
                              withInt:(jint)row
                              withInt:(jint)col
                            withFloat:(jfloat)currentValueFromZeroToOne {
  return GeogebraCommonKernelAlgosAlgoSpline_evalForPointWithFloatArray2_withInt_withInt_withFloat_(self, matrix, row, col, currentValueFromZeroToOne);
}

- (void)dealloc {
  RELEASE_(inputList_);
  RELEASE_(spline_);
  RELEASE_(degree_);
  RELEASE_(floatPoints_);
  RELEASE_(parameters_);
  RELEASE_(cumulativeValueOfParameter_);
  RELEASE_(parametersValues_);
  RELEASE_(parameterIntervalLimits_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withNSString:withGeogebraCommonKernelGeosGeoList:", "AlgoSpline", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withNSString:withGeogebraCommonKernelGeosGeoList:withGeogebraCommonKernelGeosGeoNumberValue:", "AlgoSpline", NULL, 0x1, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x4, NULL, NULL },
    { "getClassName", NULL, "Lgeogebra.common.kernel.algos.GetCommand;", 0x1, NULL, NULL },
    { "getSpline", NULL, "Lgeogebra.common.kernel.kernelND.GeoCurveCartesianND;", 0x1, NULL, NULL },
    { "calculateParameterValues", NULL, "V", 0x2, NULL, NULL },
    { "calculateWithFloat:withFloatArray:", "calculate", "F", 0xa, NULL, NULL },
    { "getParameterIntervalLimits", NULL, "[F", 0x1, NULL, NULL },
    { "compute", NULL, "V", 0x1, NULL, NULL },
    { "getSystemSolutionWithFloatArray2:", "getSystemSolution", "[F", 0x2, NULL, NULL },
    { "getLinearSystemParametricWithInt:", "getLinearSystemParametric", "[[F", 0x2, NULL, NULL },
    { "factWithInt:", "fact", "F", 0xa, NULL, NULL },
    { "calcDerivativeWithFloatArray:withInt:withInt:withFloat:", "calcDerivative", "V", 0x2, NULL, NULL },
    { "calcExtremesDerivativeWithFloatArray:withInt:withInt:", "calcExtremesDerivative", "V", 0x2, NULL, NULL },
    { "calcCoeffWithInt:withInt:withFloat:", "calcCoeff", "F", 0x2, NULL, NULL },
    { "evalForPointWithFloatArray2:withInt:withInt:withFloat:", "evalForPoint", "F", 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "inputList_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoList;", NULL, NULL,  },
    { "spline_", NULL, 0x2, "Lgeogebra.common.kernel.kernelND.GeoCurveCartesianND;", NULL, NULL,  },
    { "degree_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoNumberValue;", NULL, NULL,  },
    { "floatPoints_", NULL, 0x2, "[[F", NULL, NULL,  },
    { "parameters_", NULL, 0x2, "[[F", NULL, NULL,  },
    { "length_", NULL, 0x2, "I", NULL, NULL,  },
    { "cumulativeValueOfParameter_", NULL, 0x2, "[F", NULL, NULL,  },
    { "degreeValue_", NULL, 0x2, "I", NULL, NULL,  },
    { "parametersValues_", NULL, 0x2, "[F", NULL, NULL,  },
    { "parameterIntervalLimits_", NULL, 0x2, "[F", NULL, NULL,  },
    { "dimension_", NULL, 0x2, "I", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelAlgosAlgoSpline = { 2, "AlgoSpline", "geogebra.common.kernel.algos", NULL, 0x1, 16, methods, 11, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelAlgosAlgoSpline;
}

@end

void GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_(GeogebraCommonKernelAlgosAlgoSpline *self, GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelGeosGeoList *inputList) {
  GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_withGeogebraCommonKernelGeosGeoNumberValue_(self, cons, label, inputList, [new_GeogebraCommonKernelGeosGeoNumeric_initWithGeogebraCommonKernelConstruction_withDouble_(cons, 3) autorelease]);
}

GeogebraCommonKernelAlgosAlgoSpline *new_GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_(GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelGeosGeoList *inputList) {
  GeogebraCommonKernelAlgosAlgoSpline *self = [GeogebraCommonKernelAlgosAlgoSpline alloc];
  GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_(self, cons, label, inputList);
  return self;
}

void GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_withGeogebraCommonKernelGeosGeoNumberValue_(GeogebraCommonKernelAlgosAlgoSpline *self, GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelGeosGeoList *inputList, id<GeogebraCommonKernelGeosGeoNumberValue> degree) {
  GeogebraCommonKernelAlgosAlgoElement_initWithGeogebraCommonKernelConstruction_(self, cons);
  self->dimension_ = 2;
  GeogebraCommonKernelAlgosAlgoSpline_set_degree_(self, degree);
  GeogebraCommonKernelAlgosAlgoSpline_set_inputList_(self, inputList);
  for (jint i = 0; i < [((GeogebraCommonKernelGeosGeoList *) nil_chk(inputList)) size] && self->dimension_ == 2; i++) {
    id<GeogebraCommonKernelKernelNDGeoPointND> p = (id<GeogebraCommonKernelKernelNDGeoPointND>) check_protocol_cast([inputList getWithInt:i], @protocol(GeogebraCommonKernelKernelNDGeoPointND));
    self->dimension_ = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(p)) getDimension];
  }
  GeogebraCommonKernelAlgosAlgoSpline_setAndConsume_parameters_(self, [IOSObjectArray newArrayWithLength:self->dimension_ type:IOSClass_floatArray(1)]);
  GeogebraCommonKernelAlgosAlgoSpline_setAndConsume_floatPoints_(self, [IOSFloatArray newArrayWithDimensions:2 lengths:(jint[]){ [inputList size], self->dimension_ }]);
  if (self->dimension_ == 3) {
    GeogebraCommonKernelAlgosAlgoSpline_setAndConsume_spline_(self, new_GeogebraCommonGeogebra3DKernel3DGeosGeoCurveCartesian3D_initWithGeogebraCommonKernelConstruction_(cons));
  }
  else {
    GeogebraCommonKernelAlgosAlgoSpline_setAndConsume_spline_(self, new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(cons));
  }
  [((GeogebraCommonKernelKernelNDGeoCurveCartesianND *) nil_chk(self->spline_)) setEuclidianVisibleWithBoolean:YES];
  GeogebraCommonKernelAlgosAlgoSpline_setAndConsume_parametersValues_(self, [IOSFloatArray newArrayWithLength:[inputList size]]);
  [self compute];
  [self setInputOutput];
  [self->spline_ setLabelWithNSString:label];
}

GeogebraCommonKernelAlgosAlgoSpline *new_GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_withGeogebraCommonKernelGeosGeoNumberValue_(GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelGeosGeoList *inputList, id<GeogebraCommonKernelGeosGeoNumberValue> degree) {
  GeogebraCommonKernelAlgosAlgoSpline *self = [GeogebraCommonKernelAlgosAlgoSpline alloc];
  GeogebraCommonKernelAlgosAlgoSpline_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoList_withGeogebraCommonKernelGeosGeoNumberValue_(self, cons, label, inputList, degree);
  return self;
}

void GeogebraCommonKernelAlgosAlgoSpline_calculateParameterValues(GeogebraCommonKernelAlgosAlgoSpline *self) {
  jint j = 0;
  jfloat parameterValue = 0;
  IOSFloatArray *lx = [self getParameterIntervalLimits];
  for (jfloat p = 0; p <= 1; p = p + 0.01f) {
    parameterValue = GeogebraCommonKernelAlgosAlgoSpline_calculateWithFloat_withFloatArray_(p, lx);
    if (JavaUtilArrays_binarySearchWithFloatArray_withFloat_(self->parametersValues_, parameterValue) < 0) {
      if (j < ((IOSFloatArray *) nil_chk(self->parametersValues_))->size_) {
        *IOSFloatArray_GetRef(self->parametersValues_, j) = parameterValue;
        j++;
      }
    }
  }
  *IOSFloatArray_GetRef(nil_chk(self->parametersValues_), self->length_ - 1) = 1;
}

jfloat GeogebraCommonKernelAlgosAlgoSpline_calculateWithFloat_withFloatArray_(jfloat x, IOSFloatArray *m) {
  GeogebraCommonKernelAlgosAlgoSpline_initialize();
  for (jint i = ((IOSFloatArray *) nil_chk(m))->size_ - 1; i > -1; i--) {
    if (x > IOSFloatArray_Get(m, i)) {
      return IOSFloatArray_Get(m, i);
    }
  }
  return 0;
}

IOSFloatArray *GeogebraCommonKernelAlgosAlgoSpline_getSystemSolutionWithFloatArray2_(GeogebraCommonKernelAlgosAlgoSpline *self, IOSObjectArray *matrix) {
  jboolean nok = NO;
  self->length_ = ((IOSObjectArray *) nil_chk(matrix))->size_;
  IOSFloatArray *solution = [IOSFloatArray arrayWithLength:self->length_];
  IOSFloatArray *temp = [IOSFloatArray arrayWithLength:((IOSFloatArray *) nil_chk(IOSObjectArray_Get(matrix, 0)))->size_];
  jint column;
  jint row;
  jint i;
  jint j;
  for (column = 0; column < self->length_ - 1; column++) {
    for (i = column; i < self->length_ - 1; i++) {
      for (j = i + 1; j < self->length_; j++) {
        if (JavaLangMath_absWithFloat_(IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, i)), column)) < JavaLangMath_absWithFloat_(IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, j)), column))) {
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(IOSObjectArray_Get(matrix, i), column, temp, column, self->length_ + 1 - column);
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(IOSObjectArray_Get(matrix, j), column, IOSObjectArray_Get(matrix, i), column, self->length_ + 1 - column);
          JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(temp, column, IOSObjectArray_Get(matrix, j), column, self->length_ + 1 - column);
        }
      }
    }
    for (row = column; row < self->length_ && IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, row)), column) == 0; row++) {
    }
    jfloat value;
    if (row != self->length_ - 1) {
      for (i = column; i < self->length_; i++) {
        if (IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, i)), column) != 0 && i != row) {
          value = IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, i)), column) / IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, row)), column);
          for (j = column; j < self->length_ + 1; j++) {
            *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), j) = IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, row)), j) * value;
            *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, i)), j) = IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, i)), j) - IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, row)), j);
          }
        }
      }
    }
  }
  j = 0;
  nok = YES;
  for (; j < self->length_ && nok; j++) {
    if (IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, self->length_ - 1)), j) != 0) {
      nok = NO;
    }
  }
  if (nok) {
    [((GeogebraCommonKernelKernelNDGeoCurveCartesianND *) nil_chk(self->spline_)) setUndefined];
    return nil;
  }
  *IOSFloatArray_GetRef(solution, solution->size_ - 1) = IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, self->length_ - 1)), self->length_) / IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, self->length_ - 1)), self->length_ - 1);
  jfloat buffer;
  jint ii;
  for (i = self->length_ - 2; i > -1; i--) {
    buffer = 0;
    for (ii = self->length_ - 1; ii > i; ii--) {
      buffer = buffer + IOSFloatArray_Get(solution, ii) * IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, i)), ii);
    }
    *IOSFloatArray_GetRef(solution, i) = (IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, i)), self->length_) - buffer) / IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(matrix, i)), i);
  }
  return solution;
}

IOSObjectArray *GeogebraCommonKernelAlgosAlgoSpline_getLinearSystemParametricWithInt_(GeogebraCommonKernelAlgosAlgoSpline *self, jint c) {
  jint row = 0;
  jint col = 0;
  jint pointIndex;
  jfloat currentValueFromZeroToOne;
  self->length_ = ((IOSObjectArray *) nil_chk(self->floatPoints_))->size_;
  GeogebraCommonKernelAlgosAlgoSpline_setAndConsume_cumulativeValueOfParameter_(self, [IOSFloatArray newArrayWithLength:self->length_]);
  jint i;
  for (col = 1; col < self->length_; col++) {
    for (row = 1; row <= col; row++) {
      jfloat value = 0;
      for (i = 0; i < self->dimension_; i++) {
        value += (IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(self->floatPoints_, row)), i) - IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(self->floatPoints_, row - 1)), i)) * (IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(self->floatPoints_, row)), i) - IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(self->floatPoints_, row - 1)), i));
      }
      *IOSFloatArray_GetRef(self->cumulativeValueOfParameter_, col) = IOSFloatArray_Get(self->cumulativeValueOfParameter_, col) + (jfloat) JavaLangMath_sqrtWithDouble_(value);
    }
  }
  IOSObjectArray *matrix = [IOSFloatArray arrayWithDimensions:2 lengths:(jint[]){ (self->length_ - 1) * self->degreeValue_, (self->length_ - 1) * self->degreeValue_ + 1 }];
  row = 0;
  col = 0;
  for (pointIndex = 0; pointIndex < self->length_ - 1; pointIndex++) {
    currentValueFromZeroToOne = IOSFloatArray_Get(self->cumulativeValueOfParameter_, pointIndex) / IOSFloatArray_Get(self->cumulativeValueOfParameter_, self->length_ - 1);
    GeogebraCommonKernelAlgosAlgoSpline_evalForPointWithFloatArray2_withInt_withInt_withFloat_(self, matrix, row, col, currentValueFromZeroToOne);
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), matrix->size_) = IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(self->floatPoints_, pointIndex)), c);
    row++;
    col += self->degreeValue_;
  }
  col = 0;
  for (pointIndex = 1; pointIndex < self->length_; pointIndex++) {
    currentValueFromZeroToOne = IOSFloatArray_Get(self->cumulativeValueOfParameter_, pointIndex) / IOSFloatArray_Get(self->cumulativeValueOfParameter_, self->length_ - 1);
    GeogebraCommonKernelAlgosAlgoSpline_evalForPointWithFloatArray2_withInt_withInt_withFloat_(self, matrix, row, col, currentValueFromZeroToOne);
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), matrix->size_) = IOSFloatArray_Get(nil_chk(IOSObjectArray_Get(self->floatPoints_, pointIndex)), c);
    row++;
    col += self->degreeValue_;
  }
  for (jint currentDerivative = self->degreeValue_ - 2; currentDerivative > 0; currentDerivative--) {
    col = 0;
    for (pointIndex = 1; pointIndex < self->length_ - 1; pointIndex++) {
      currentValueFromZeroToOne = IOSFloatArray_Get(self->cumulativeValueOfParameter_, pointIndex) / IOSFloatArray_Get(self->cumulativeValueOfParameter_, self->length_ - 1);
      GeogebraCommonKernelAlgosAlgoSpline_calcDerivativeWithFloatArray_withInt_withInt_withFloat_(self, IOSObjectArray_Get(matrix, row), col, currentDerivative, currentValueFromZeroToOne);
      row++;
      col += self->degreeValue_;
    }
  }
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk([((GeogebraCommonKernelGeosGeoList *) nil_chk(self->inputList_)) getWithInt:0])) isEqual:[self->inputList_ getWithInt:[self->inputList_ size] - 1]]) {
    for (jint currentDerivative = self->degreeValue_ - 2; currentDerivative > 0; currentDerivative--) {
      col = 0;
      GeogebraCommonKernelAlgosAlgoSpline_calcExtremesDerivativeWithFloatArray_withInt_withInt_(self, IOSObjectArray_Get(matrix, row), col, currentDerivative);
      row++;
      col += self->degreeValue_;
    }
  }
  else {
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), 0) = 0;
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), 1) = GeogebraCommonKernelAlgosAlgoSpline_factWithInt_(self->degreeValue_ - 2);
    row++;
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), matrix->size_ - self->degreeValue_) = GeogebraCommonKernelAlgosAlgoSpline_factWithInt_(self->degreeValue_ - 1);
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), matrix->size_ - self->degreeValue_ + 1) = GeogebraCommonKernelAlgosAlgoSpline_factWithInt_(self->degreeValue_ - 2);
  }
  row++;
  jint num = 2;
  for (; row < matrix->size_; row++) {
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), matrix->size_ - num * self->degreeValue_) = GeogebraCommonKernelAlgosAlgoSpline_factWithInt_(self->degreeValue_ - 1) * IOSFloatArray_Get(self->cumulativeValueOfParameter_, num - 1) / IOSFloatArray_Get(self->cumulativeValueOfParameter_, self->length_ - 1);
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(matrix, row)), matrix->size_ - num * self->degreeValue_ + 1) = GeogebraCommonKernelAlgosAlgoSpline_factWithInt_(self->degreeValue_ - 2);
    num++;
  }
  return matrix;
}

jfloat GeogebraCommonKernelAlgosAlgoSpline_factWithInt_(jint i) {
  GeogebraCommonKernelAlgosAlgoSpline_initialize();
  jint f = 1;
  for (jint j = 2; j <= i; j++) {
    f *= j;
  }
  return f;
}

void GeogebraCommonKernelAlgosAlgoSpline_calcDerivativeWithFloatArray_withInt_withInt_withFloat_(GeogebraCommonKernelAlgosAlgoSpline *self, IOSFloatArray *row, jint col, jint currentDerivative, jfloat currentValueFromZeroToOne) {
  for (jint i = col; i < col + self->degreeValue_; i++) {
    *IOSFloatArray_GetRef(nil_chk(row), i) = GeogebraCommonKernelAlgosAlgoSpline_calcCoeffWithInt_withInt_withFloat_(self, i, currentDerivative, currentValueFromZeroToOne);
    *IOSFloatArray_GetRef(row, i + self->degreeValue_) = -IOSFloatArray_Get(row, i);
  }
}

void GeogebraCommonKernelAlgosAlgoSpline_calcExtremesDerivativeWithFloatArray_withInt_withInt_(GeogebraCommonKernelAlgosAlgoSpline *self, IOSFloatArray *row, jint col, jint currentDerivative) {
  for (jint i = col; i < col + self->degreeValue_; i++) {
    *IOSFloatArray_GetRef(nil_chk(row), i) = GeogebraCommonKernelAlgosAlgoSpline_calcCoeffWithInt_withInt_withFloat_(self, i, currentDerivative, 0);
    *IOSFloatArray_GetRef(row, row->size_ - 1 - self->degreeValue_ + i) = -GeogebraCommonKernelAlgosAlgoSpline_calcCoeffWithInt_withInt_withFloat_(self, i, currentDerivative, 1);
  }
}

jfloat GeogebraCommonKernelAlgosAlgoSpline_calcCoeffWithInt_withInt_withFloat_(GeogebraCommonKernelAlgosAlgoSpline *self, jint col, jint currentDerivative, jfloat currentValueFromZeroToOne) {
  jint exp = col % self->degreeValue_;
  exp = self->degreeValue_ - exp - 1;
  jfloat coeff = (jfloat) JavaLangMath_powWithDouble_withDouble_(currentValueFromZeroToOne, exp - 1);
  if (exp == 0) {
    return 0;
  }
  for (jint i = self->degreeValue_ - 1; i > currentDerivative; i--) {
    coeff *= exp;
    exp--;
  }
  return coeff;
}

jfloat GeogebraCommonKernelAlgosAlgoSpline_evalForPointWithFloatArray2_withInt_withInt_withFloat_(GeogebraCommonKernelAlgosAlgoSpline *self, IOSObjectArray *matrix, jint row, jint col, jfloat currentValueFromZeroToOne) {
  jdouble value = 0;
  for (jint j = self->degreeValue_ - 1; j > -1; j--) {
    *IOSFloatArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(matrix), row)), col + self->degreeValue_ - j - 1) = (jfloat) JavaLangMath_powWithDouble_withDouble_(currentValueFromZeroToOne, j);
  }
  return (jfloat) value;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelAlgosAlgoSpline)
