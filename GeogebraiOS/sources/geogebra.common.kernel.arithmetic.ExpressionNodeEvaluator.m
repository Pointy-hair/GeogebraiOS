//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/arithmetic/ExpressionNodeEvaluator.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/GeoGebraCasInterface.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/arithmetic/BooleanValue.h"
#include "geogebra/common/kernel/arithmetic/Evaluatable.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeEvaluator.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionNVar.h"
#include "geogebra/common/kernel/arithmetic/FunctionalNVar.h"
#include "geogebra/common/kernel/arithmetic/ListValue.h"
#include "geogebra/common/kernel/arithmetic/MyBoolean.h"
#include "geogebra/common/kernel/arithmetic/MyDouble.h"
#include "geogebra/common/kernel/arithmetic/MyList.h"
#include "geogebra/common/kernel/arithmetic/MyStringBuffer.h"
#include "geogebra/common/kernel/arithmetic/MyVecNode.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/arithmetic/Polynomial.h"
#include "geogebra/common/kernel/arithmetic/TextValue.h"
#include "geogebra/common/kernel/arithmetic/Traversing.h"
#include "geogebra/common/kernel/arithmetic/ValidExpression.h"
#include "geogebra/common/kernel/arithmetic/VectorNDValue.h"
#include "geogebra/common/kernel/arithmetic/VectorValue.h"
#include "geogebra/common/kernel/arithmetic3D/Vector3DValue.h"
#include "geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "geogebra/common/kernel/geos/GeoCasCell.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoFunctionable.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/kernel/kernelND/Geo3DVec.h"
#include "geogebra/common/kernel/kernelND/GeoVecInterface.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/main/MyError.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/util/debug/Log.h"
#include "java/lang/Double.h"
#include "java/lang/Math.h"

@interface GeogebraCommonKernelArithmeticExpressionNodeEvaluator () {
 @public
  GeogebraCommonMainLocalization *l10n_;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleSpecialWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                  withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                  withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                                                                  withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)right
                                                                              withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation
                                                                             withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelArithmeticExpressionNodeEvaluator, l10n_, GeogebraCommonMainLocalization *)

static GeogebraCommonKernelStringTemplate *GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_;
J2OBJC_STATIC_FIELD_GETTER(GeogebraCommonKernelArithmeticExpressionNodeEvaluator, errorTemplate_, GeogebraCommonKernelStringTemplate *)

__attribute__((unused)) static id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNodeEvaluator_multiply2DWithGeogebraCommonKernelArithmeticMyList_withInt_withInt_withGeogebraCommonKernelArithmeticVectorValue_(GeogebraCommonKernelArithmeticExpressionNodeEvaluator *self, GeogebraCommonKernelArithmeticMyList *myList, jint rows, jint cols, id<GeogebraCommonKernelArithmeticVectorValue> rt);

__attribute__((unused)) static id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNodeEvaluator_multiply2DWithGeogebraCommonKernelArithmeticMyList_withInt_withInt_withGeogebraCommonKernelArithmeticVectorNDValue_withGeogebraCommonKernelGeosGeoVec2D_(GeogebraCommonKernelArithmeticExpressionNodeEvaluator *self, GeogebraCommonKernelArithmeticMyList *myList, jint rows, jint cols, id<GeogebraCommonKernelArithmeticVectorNDValue> rt, GeogebraCommonKernelGeosGeoVec2D *myVec);

__attribute__((unused)) static id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNodeEvaluator_handleSpecialWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelArithmeticExpressionNodeEvaluator *self, id<GeogebraCommonKernelArithmeticExpressionValue> lt, id<GeogebraCommonKernelArithmeticExpressionValue> rt, id<GeogebraCommonKernelArithmeticExpressionValue> left, id<GeogebraCommonKernelArithmeticExpressionValue> right, GeogebraCommonPluginOperationEnum *operation, GeogebraCommonKernelStringTemplate *tpl);

J2OBJC_INITIALIZED_DEFN(GeogebraCommonKernelArithmeticExpressionNodeEvaluator)

@implementation GeogebraCommonKernelArithmeticExpressionNodeEvaluator

- (instancetype)initWithGeogebraCommonMainLocalization:(GeogebraCommonMainLocalization *)l10n
                        withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  GeogebraCommonKernelArithmeticExpressionNodeEvaluator_initWithGeogebraCommonMainLocalization_withGeogebraCommonKernelKernel_(self, l10n, kernel);
  return self;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)evaluateWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)expressionNode
                                                                       withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  jboolean leaf = ((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(expressionNode))->leaf_;
  id<GeogebraCommonKernelArithmeticExpressionValue> left = [expressionNode getLeft];
  if (leaf) {
    return [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) evaluateWithGeogebraCommonKernelStringTemplate:tpl];
  }
  id<GeogebraCommonKernelArithmeticExpressionValue> right = [expressionNode getRight];
  GeogebraCommonPluginOperationEnum *operation = [expressionNode getOperation];
  jboolean holdsLaTeXtext = expressionNode->holdsLaTeXtext_;
  id<GeogebraCommonKernelArithmeticExpressionValue> lt, rt;
  lt = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) evaluateWithGeogebraCommonKernelStringTemplate:tpl];
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk(operation)) isEqual:GeogebraCommonPluginOperationEnum_get_NO_OPERATION()]) {
    return lt;
  }
  rt = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right)) evaluateWithGeogebraCommonKernelStringTemplate:tpl];
  id<GeogebraCommonKernelArithmeticExpressionValue> special = GeogebraCommonKernelArithmeticExpressionNodeEvaluator_handleSpecialWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelStringTemplate_(self, lt, rt, left, right, operation, tpl);
  if (special != nil) return special;
  return [self handleOpWithGeogebraCommonPluginOperationEnum:operation withGeogebraCommonKernelArithmeticExpressionValue:lt withGeogebraCommonKernelArithmeticExpressionValue:rt withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonKernelStringTemplate:tpl withBoolean:holdsLaTeXtext];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleOpWithGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op
                                                 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                                                 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)right
                                                            withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                                                       withBoolean:(jboolean)holdsLaTeX {
  return [((GeogebraCommonPluginOperationEnum *) nil_chk(op)) handleWithGeogebraCommonKernelArithmeticExpressionNodeEvaluator:self withGeogebraCommonKernelArithmeticExpressionValue:lt withGeogebraCommonKernelArithmeticExpressionValue:rt withGeogebraCommonKernelArithmeticExpressionValue:left withGeogebraCommonKernelArithmeticExpressionValue:right withGeogebraCommonKernelStringTemplate:tpl withBoolean:holdsLaTeX];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)multiplyWithGeogebraCommonKernelArithmeticMyList:(GeogebraCommonKernelArithmeticMyList *)myList
                                                      withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)rt {
  if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    return GeogebraCommonKernelArithmeticExpressionNodeEvaluator_multiply2DWithGeogebraCommonKernelArithmeticMyList_withInt_withInt_withGeogebraCommonKernelArithmeticVectorValue_(self, myList, [((GeogebraCommonKernelArithmeticMyList *) nil_chk(myList)) getMatrixRows], [myList getMatrixCols], (id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue)));
  }
  return nil;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)multiply2DWithGeogebraCommonKernelArithmeticMyList:(GeogebraCommonKernelArithmeticMyList *)myList
                                                                                                withInt:(jint)rows
                                                                                                withInt:(jint)cols
                                                          withGeogebraCommonKernelArithmeticVectorValue:(id<GeogebraCommonKernelArithmeticVectorValue>)rt {
  return GeogebraCommonKernelArithmeticExpressionNodeEvaluator_multiply2DWithGeogebraCommonKernelArithmeticMyList_withInt_withInt_withGeogebraCommonKernelArithmeticVectorValue_(self, myList, rows, cols, rt);
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)multiply2DWithGeogebraCommonKernelArithmeticMyList:(GeogebraCommonKernelArithmeticMyList *)myList
                                                                                                withInt:(jint)rows
                                                                                                withInt:(jint)cols
                                                        withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)rt
                                                                   withGeogebraCommonKernelGeosGeoVec2D:(GeogebraCommonKernelGeosGeoVec2D *)myVec {
  return GeogebraCommonKernelArithmeticExpressionNodeEvaluator_multiply2DWithGeogebraCommonKernelArithmeticMyList_withInt_withInt_withGeogebraCommonKernelArithmeticVectorNDValue_withGeogebraCommonKernelGeosGeoVec2D_(self, myList, rows, cols, rt, myVec);
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleSpecialWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                  withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                  withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                                                                  withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)right
                                                                              withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)operation
                                                                             withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return GeogebraCommonKernelArithmeticExpressionNodeEvaluator_handleSpecialWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelStringTemplate_(self, lt, rt, left, right, operation, tpl);
}

+ (GeogebraCommonKernelArithmeticMyBoolean *)evalEqualsWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
                                    withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                    withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt {
  return GeogebraCommonKernelArithmeticExpressionNodeEvaluator_evalEqualsWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, lt, rt);
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleXcoordWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)arg
                                                                             withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op {
  if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:arg]) {
    return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(arg, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector])) getX]) autorelease];
  }
  else if ([GeogebraCommonKernelArithmetic3DVector3DValue_class_() isInstance:arg]) {
    return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, IOSDoubleArray_Get(nil_chk([((id<GeogebraCommonKernelArithmetic3DVector3DValue>) nil_chk(((id<GeogebraCommonKernelArithmetic3DVector3DValue>) check_protocol_cast(arg, @protocol(GeogebraCommonKernelArithmetic3DVector3DValue))))) getPointAsDouble]), 0)) autorelease];
  }
  else if ([arg isKindOfClass:[GeogebraCommonKernelGeosGeoLine class]]) {
    return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, ((GeogebraCommonKernelGeosGeoLine *) nil_chk(((GeogebraCommonKernelGeosGeoLine *) check_class_cast(arg, [GeogebraCommonKernelGeosGeoLine class]))))->x_) autorelease];
  }
  else return [self polynomialOrDieWithGeogebraCommonKernelArithmeticExpressionValue:arg withGeogebraCommonPluginOperationEnum:op withNSString:op == GeogebraCommonPluginOperationEnum_get_XCOORD() ? @"x(" : @"real("];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleYcoordWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)arg
                                                                             withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op {
  if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:arg]) {
    return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(arg, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector])) getY]) autorelease];
  }
  else if ([GeogebraCommonKernelArithmetic3DVector3DValue_class_() isInstance:arg]) {
    return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, IOSDoubleArray_Get(nil_chk([((id<GeogebraCommonKernelArithmetic3DVector3DValue>) nil_chk(((id<GeogebraCommonKernelArithmetic3DVector3DValue>) check_protocol_cast(arg, @protocol(GeogebraCommonKernelArithmetic3DVector3DValue))))) getPointAsDouble]), 1)) autorelease];
  }
  else if ([arg isKindOfClass:[GeogebraCommonKernelGeosGeoLine class]]) {
    return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, ((GeogebraCommonKernelGeosGeoLine *) nil_chk(((GeogebraCommonKernelGeosGeoLine *) check_class_cast(arg, [GeogebraCommonKernelGeosGeoLine class]))))->y_) autorelease];
  }
  else return [self polynomialOrDieWithGeogebraCommonKernelArithmeticExpressionValue:arg withGeogebraCommonPluginOperationEnum:op withNSString:op == GeogebraCommonPluginOperationEnum_get_YCOORD() ? @"y(" : @"imaginary("];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleMultWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                               withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                          withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                                                                     withBoolean:(jboolean)holdsLaTeXtext {
  GeogebraCommonKernelArithmeticMyDouble *num;
  GeogebraCommonKernelGeosGeoVec2D *vec;
  GeogebraCommonKernelArithmeticMyStringBuffer *msb;
  GeogebraCommonKernelArithmeticPolynomial *poly;
  if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt]) {
    if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
      num = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
      GeogebraCommonKernelArithmeticMyDouble_multWithGeogebraCommonKernelArithmeticMyDouble_withGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelArithmeticMyDouble_(num, (id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue)), num);
      return num;
    }
    else if ([GeogebraCommonKernelArithmeticVectorNDValue_class_() isInstance:rt]) {
      return [self multiplyWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue)) withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue))];
    }
  }
  if ([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:lt]) {
    msb = [((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticTextValue))))) getText];
    if (holdsLaTeXtext) {
      [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toLaTeXStringWithBoolean:NO withGeogebraCommonKernelStringTemplate:tpl]];
    }
    else {
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) isGeoElement]) {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(rt, [GeogebraCommonKernelGeosGeoElement class]);
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[geo toDefinedValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[rt toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    return msb;
  }
  else if ([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:rt]) {
    msb = [((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticTextValue))))) getText];
    if (holdsLaTeXtext) {
      [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toLaTeXStringWithBoolean:NO withGeogebraCommonKernelStringTemplate:tpl]];
    }
    else {
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) isGeoElement]) {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoElement class]);
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[geo toDefinedValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[lt toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    return msb;
  }
  else if ([GeogebraCommonKernelArithmeticBooleanValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    num = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
    GeogebraCommonKernelArithmeticMyDouble_multWithGeogebraCommonKernelArithmeticMyDouble_withDouble_withGeogebraCommonKernelArithmeticMyDouble_(num, [((id<GeogebraCommonKernelArithmeticBooleanValue>) nil_chk(((id<GeogebraCommonKernelArithmeticBooleanValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticBooleanValue))))) getDouble], num);
    return num;
  }
  else if ([GeogebraCommonKernelArithmeticVectorNDValue_class_() isInstance:lt]) {
    if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
      return [self multiplyWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue)) withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue))];
    }
    else if ([GeogebraCommonKernelArithmeticVectorNDValue_class_() isInstance:rt]) {
      if ([((id<GeogebraCommonKernelArithmeticVectorNDValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue))))) getMode] == GeogebraCommonKernelKernel_COORD_COMPLEX || [((id<GeogebraCommonKernelArithmeticVectorNDValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue))))) getMode] == GeogebraCommonKernelKernel_COORD_COMPLEX) {
        return [self complexMultWithGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue)) withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue)) withGeogebraCommonKernelKernel:kernel_];
      }
      return [self innerProductWithGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue)) withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue)) withGeogebraCommonKernelKernel:kernel_];
    }
    return [self illegalBinaryWithGeogebraCommonKernelArithmeticExpressionValue:lt withGeogebraCommonKernelArithmeticExpressionValue:rt withNSString:@"IllegalMultiplication" withNSString:@"*"];
  }
  else if ([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:lt]) {
    msb = [((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticTextValue))))) getText];
    if (holdsLaTeXtext) {
      [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toLaTeXStringWithBoolean:NO withGeogebraCommonKernelStringTemplate:tpl]];
    }
    else {
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) isGeoElement]) {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(rt, [GeogebraCommonKernelGeosGeoElement class]);
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[geo toDefinedValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[rt toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    return msb;
  }
  else if ([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:rt]) {
    msb = [((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticTextValue))))) getText];
    if (holdsLaTeXtext) {
      [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toLaTeXStringWithBoolean:NO withGeogebraCommonKernelStringTemplate:tpl]];
    }
    else {
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) isGeoElement]) {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoElement class]);
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[geo toDefinedValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[lt toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    return msb;
  }
  return [self illegalBinaryWithGeogebraCommonKernelArithmeticExpressionValue:lt withGeogebraCommonKernelArithmeticExpressionValue:rt withNSString:@"IllegalMultiplication" withNSString:@"*"];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)multiplyWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)en
                                                           withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)ev {
  GeogebraCommonKernelGeosGeoVec2D *vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(ev, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
  GeogebraCommonKernelGeosGeoVec2D_multWithGeogebraCommonKernelGeosGeoVec2D_withDouble_withGeogebraCommonKernelGeosGeoVec2D_(vec, [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(en)) getDouble], vec);
  return vec;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)complexMultWithGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)ev1
                                                                withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)ev2
                                                                                 withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  GeogebraCommonKernelGeosGeoVec2D *vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(ev1, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
  GeogebraCommonKernelGeosGeoVec2D_complexMultiplyWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_(vec, [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(ev2, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector], vec);
  return vec;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)innerProductWithGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)ev1
                                                                 withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)ev2
                                                                                  withGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel {
  GeogebraCommonKernelArithmeticMyDouble *num = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_(kernel) autorelease];
  GeogebraCommonKernelGeosGeoVec2D_innerWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticMyDouble_([((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(ev1, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector], [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(ev2, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector], num);
  return num;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handlePlusWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                               withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                          withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                                                                     withBoolean:(jboolean)holdsLaTeXtext {
  IOSObjectArray *str;
  GeogebraCommonKernelArithmeticMyDouble *num;
  GeogebraCommonKernelGeosGeoVec2D *vec;
  GeogebraCommonKernelArithmeticMyStringBuffer *msb;
  GeogebraCommonKernelArithmeticPolynomial *poly;
  if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    num = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
    GeogebraCommonKernelArithmeticMyDouble_addWithGeogebraCommonKernelArithmeticMyDouble_withGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelArithmeticMyDouble_(num, [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber], num);
    return num;
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_addWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_(vec, [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector], vec);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_addWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelGeosGeoVec2D_(vec, ((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))), vec);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_addWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelGeosGeoVec2D_(vec, ((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))), vec);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    GeogebraCommonKernelArithmeticMyList *list = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
    if ([((GeogebraCommonKernelArithmeticMyList *) nil_chk(list)) size] > 0) {
      id<GeogebraCommonKernelArithmeticExpressionValue> ev = [list getListElementWithInt:0];
      if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:ev]) {
        vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
        GeogebraCommonKernelGeosGeoVec2D_addWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticListValue_withGeogebraCommonKernelGeosGeoVec2D_(vec, ((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticListValue))), vec);
        return vec;
      }
    }
    GeogebraCommonKernelArithmeticMyList *myList = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
    [((GeogebraCommonKernelArithmeticMyList *) nil_chk(myList)) applyRightWithGeogebraCommonPluginOperationEnum:GeogebraCommonPluginOperationEnum_get_PLUS() withGeogebraCommonKernelArithmeticExpressionValue:rt withGeogebraCommonKernelStringTemplate:tpl];
    return myList;
  }
  else if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:rt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt]) {
    GeogebraCommonKernelArithmeticMyList *list = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
    if ([((GeogebraCommonKernelArithmeticMyList *) nil_chk(list)) size] > 0) {
      id<GeogebraCommonKernelArithmeticExpressionValue> ev = [list getListElementWithInt:0];
      if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:ev]) {
        vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
        GeogebraCommonKernelGeosGeoVec2D_addWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticListValue_withGeogebraCommonKernelGeosGeoVec2D_(vec, ((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticListValue))), vec);
        return vec;
      }
    }
    GeogebraCommonKernelArithmeticMyList *myList = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
    [((GeogebraCommonKernelArithmeticMyList *) nil_chk(myList)) applyLeftWithGeogebraCommonPluginOperationEnum:GeogebraCommonPluginOperationEnum_get_PLUS() withGeogebraCommonKernelArithmeticExpressionValue:lt withGeogebraCommonKernelStringTemplate:tpl];
    return myList;
  }
  else if ([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:lt]) {
    msb = [((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticTextValue))))) getText];
    if (holdsLaTeXtext) {
      [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toLaTeXStringWithBoolean:NO withGeogebraCommonKernelStringTemplate:tpl]];
    }
    else {
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) isGeoElement]) {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(rt, [GeogebraCommonKernelGeosGeoElement class]);
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[geo toDefinedValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) appendWithNSString:[rt toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    return msb;
  }
  else if ([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:rt]) {
    msb = [((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticTextValue))))) getText];
    if (holdsLaTeXtext) {
      [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toLaTeXStringWithBoolean:NO withGeogebraCommonKernelStringTemplate:tpl]];
    }
    else {
      if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) isGeoElement]) {
        GeogebraCommonKernelGeosGeoElement *geo = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoElement class]);
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[geo toDefinedValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
      else {
        [((GeogebraCommonKernelArithmeticMyStringBuffer *) nil_chk(msb)) insertWithInt:0 withNSString:[lt toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    return msb;
  }
  else {
    str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalAddition", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], @"+", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:4 type:NSString_class_()];
    GeogebraCommonMainApp_errorWithNSString_(JreStrcat("@@", [lt getClass], [rt getClass]));
    @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
  }
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleDivideWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left
                                                                 withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)right {
  IOSObjectArray *str;
  GeogebraCommonKernelArithmeticMyDouble *num;
  GeogebraCommonKernelGeosGeoVec2D *vec;
  GeogebraCommonKernelArithmeticPolynomial *poly;
  if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt]) {
      num = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
      GeogebraCommonKernelArithmeticMyDouble_divWithGeogebraCommonKernelArithmeticMyDouble_withGeogebraCommonKernelArithmeticMyDouble_withGeogebraCommonKernelArithmeticMyDouble_(num, [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber], num);
      return num;
    }
    else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt]) {
      vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
      GeogebraCommonKernelGeosGeoVec2D_divWithGeogebraCommonKernelGeosGeoVec2D_withDouble_withGeogebraCommonKernelGeosGeoVec2D_(vec, [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble], vec);
      return vec;
    }
    else if ([lt isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) {
      return GeogebraCommonKernelGeosGeoFunction_applyNumberSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_(GeogebraCommonPluginOperationEnum_get_DIVIDE(), (GeogebraCommonKernelGeosGeoFunction *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoFunction class]), right, YES);
    }
    else {
      str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalDivision", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], @"/", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:4 type:NSString_class_()];
      @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
    }
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_complexDivideWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_(vec, [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector], vec);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_complexDivideWithGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue)), [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector], vec);
    return vec;
  }
  else if (([rt isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt]) {
    return GeogebraCommonKernelGeosGeoFunction_applyNumberSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_(GeogebraCommonPluginOperationEnum_get_DIVIDE(), (GeogebraCommonKernelGeosGeoFunction *) check_class_cast(rt, [GeogebraCommonKernelGeosGeoFunction class]), left, NO);
  }
  else {
    str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalDivision", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], @"/", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:4 type:NSString_class_()];
    @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
  }
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleMinusWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt {
  IOSObjectArray *str;
  GeogebraCommonKernelArithmeticMyDouble *num;
  GeogebraCommonKernelGeosGeoVec2D *vec;
  GeogebraCommonKernelArithmeticPolynomial *poly;
  if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    num = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
    GeogebraCommonKernelArithmeticMyDouble_subWithGeogebraCommonKernelArithmeticMyDouble_withGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelArithmeticMyDouble_(num, (id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue)), num);
    return num;
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_subWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_(vec, [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector], vec);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_subWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelGeosGeoVec2D_(vec, ((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))), vec);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_subWithGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))), vec, vec);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_subWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticListValue_withGeogebraCommonKernelGeosGeoVec2D_withBoolean_(vec, ((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticListValue))), vec, NO);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:rt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_subWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticListValue_withGeogebraCommonKernelGeosGeoVec2D_withBoolean_(vec, ((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticListValue))), vec, YES);
    return vec;
  }
  else {
    str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalSubtraction", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], @"-", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:4 type:NSString_class_()];
    GeogebraCommonMainApp_debugWithNSString_(JreStrcat("@C@", [lt getClass], ',', [rt getClass]));
    @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
  }
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handlePowerWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)right {
  IOSObjectArray *str;
  GeogebraCommonKernelArithmeticPolynomial *poly;
  GeogebraCommonKernelArithmeticMyDouble *num;
  GeogebraCommonKernelGeosGeoVec2D *vec, *vec2;
  if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    num = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
    jdouble base = [((GeogebraCommonKernelArithmeticMyDouble *) nil_chk(num)) getDouble];
    GeogebraCommonKernelArithmeticMyDouble *exponent = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
    if (base == JavaLangMath_E) {
      return [((GeogebraCommonKernelArithmeticMyDouble *) nil_chk(exponent)) exp];
    }
    if ((base < 0) && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right)) isExpressionNode] && [((GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right, [GeogebraCommonKernelArithmeticExpressionNode class])) getOperation] == GeogebraCommonPluginOperationEnum_get_DIVIDE()) {
      [num setWithDouble:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_negPowerWithDouble_withGeogebraCommonKernelArithmeticExpressionValue_(base, right)];
      return num;
    }
    GeogebraCommonKernelArithmeticMyDouble_powWithGeogebraCommonKernelArithmeticMyDouble_withGeogebraCommonKernelArithmeticMyDouble_withGeogebraCommonKernelArithmeticMyDouble_(num, exponent, num);
    return num;
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    if ([((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(vec)) getMode] == GeogebraCommonKernelKernel_COORD_COMPLEX) {
      GeogebraCommonKernelGeosGeoVec2D_complexPowerWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelGeosGeoVec2D_(vec, ((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))), vec);
      return vec;
    }
    num = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
    if ([((GeogebraCommonKernelArithmeticMyDouble *) nil_chk(num)) getDouble] == 2.0) {
      GeogebraCommonKernelGeosGeoVec2D_innerWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelArithmeticMyDouble_(vec, vec, num);
      return num;
    }
    [num setWithDouble:JavaLangDouble_NaN];
    return num;
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    vec2 = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_complexPowerWithGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_(vec, vec2, vec);
    return vec;
  }
  else if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    num = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber];
    vec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
    GeogebraCommonKernelGeosGeoVec2D_complexPowerWithGeogebraCommonKernelArithmeticNumberValue_withGeogebraCommonKernelGeosGeoVec2D_withGeogebraCommonKernelGeosGeoVec2D_(num, vec, vec);
    return vec;
  }
  else {
    GeogebraCommonMainApp_printStacktraceWithId_(@"ExpressionNodeEvaluator.handlePower()");
    GeogebraCommonMainApp_debugWithNSString_(JreStrcat("$@$@", @"Problem in ExpressionNodeEvaluator.handlePower(): lt :", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) getClass], @", rt: ", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) getClass]));
    str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalExponent", [lt toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], @"^", [rt toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:4 type:NSString_class_()];
    @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
  }
}

+ (jdouble)negPowerWithDouble:(jdouble)base
withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)right {
  return GeogebraCommonKernelArithmeticExpressionNodeEvaluator_negPowerWithDouble_withGeogebraCommonKernelArithmeticExpressionValue_(base, right);
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleFunctionWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                   withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                   withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)left {
  IOSObjectArray *str;
  if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    if ([GeogebraCommonKernelArithmeticEvaluatable_class_() isInstance:lt]) {
      id<GeogebraCommonKernelArithmeticNumberValue> arg = (id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue));
      if (([lt isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) && [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(((GeogebraCommonKernelGeosGeoFunction *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoFunction class])))) isBooleanFunction]) {
        return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel_, [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(((GeogebraCommonKernelGeosGeoFunction *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoFunction class])))) evaluateBooleanWithDouble:[((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(arg)) getDouble]]) autorelease];
      }
      return [((GeogebraCommonKernelArithmeticMyDouble *) nil_chk([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(arg)) getNumber])) applyWithGeogebraCommonKernelArithmeticEvaluatable:(id<GeogebraCommonKernelArithmeticEvaluatable>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticEvaluatable))];
    }
    else if ([lt isKindOfClass:[GeogebraCommonKernelGeosGeoCasCell class]] && [[((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(((GeogebraCommonKernelGeosGeoCasCell *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoCasCell class])))) getOutputValidExpression] isKindOfClass:[GeogebraCommonKernelArithmeticFunction class]]) {
      GeogebraCommonKernelArithmeticExpressionNode *node = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, lt, GeogebraCommonPluginOperationEnum_get_FUNCTION(), rt) autorelease];
      GeogebraCommonKernelArithmeticTraversing_FunctionExpander *fex = GeogebraCommonKernelArithmeticTraversing_FunctionExpander_getCollector();
      node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([node wrap])) getCopyWithGeogebraCommonKernelKernel:kernel_])) traverseWithGeogebraCommonKernelArithmeticTraversing:fex], [GeogebraCommonKernelArithmeticExpressionNode class]);
      NSString *result = [((id<GeogebraCommonKernelGeoGebraCasInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getGeoGebraCAS])) evaluateGeoGebraCASWithGeogebraCommonKernelArithmeticValidExpression:node withGeogebraCommonKernelArithmeticMyArbitraryConstant:nil withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_numericNoLocal_() withGeogebraCommonKernelKernel:kernel_];
      jboolean mode = [kernel_ isSilentMode];
      [kernel_ setSilentModeWithBoolean:YES];
      GeogebraCommonKernelGeosGeoElement *geo = IOSObjectArray_Get(nil_chk([((GeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) processAlgebraCommandWithNSString:result withBoolean:NO]), 0);
      [kernel_ setSilentModeWithBoolean:mode];
      return geo;
    }
    else if ([left isKindOfClass:[GeogebraCommonKernelGeosGeoCasCell class]] && [[((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(((GeogebraCommonKernelGeosGeoCasCell *) check_class_cast(left, [GeogebraCommonKernelGeosGeoCasCell class])))) getTwinGeo] isKindOfClass:[GeogebraCommonKernelGeosGeoLine class]]) {
      return [((GeogebraCommonKernelArithmeticMyDouble *) nil_chk([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getNumber])) applyWithGeogebraCommonKernelArithmeticEvaluatable:(id<GeogebraCommonKernelArithmeticEvaluatable>) check_protocol_cast([((GeogebraCommonKernelGeosGeoCasCell *) nil_chk(((GeogebraCommonKernelGeosGeoCasCell *) check_class_cast(left, [GeogebraCommonKernelGeosGeoCasCell class])))) getTwinGeo], @protocol(GeogebraCommonKernelArithmeticEvaluatable))];
    }
    else {
      GeogebraCommonUtilDebugLog_debugWithId_(lt);
    }
  }
  else if ([rt isKindOfClass:[GeogebraCommonKernelGeosGeoPoint class]]) {
    if ([GeogebraCommonKernelArithmeticEvaluatable_class_() isInstance:lt]) {
      GeogebraCommonKernelGeosGeoPoint *pt = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(rt, [GeogebraCommonKernelGeosGeoPoint class]);
      if ([lt isKindOfClass:[GeogebraCommonKernelGeosGeoFunction class]]) {
        GeogebraCommonKernelArithmeticFunctionNVar *fun = [((GeogebraCommonKernelGeosGeoFunction *) nil_chk(((GeogebraCommonKernelGeosGeoFunction *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoFunction class])))) getFunction];
        if ([((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(fun)) isBooleanFunction]) {
          return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel_, [fun evaluateBooleanWithGeogebraCommonKernelGeosGeoPoint:pt]) autorelease];
        }
        return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [fun evaluateWithGeogebraCommonKernelGeosGeoPoint:pt]) autorelease];
      }
      else if ([GeogebraCommonKernelGeosGeoFunctionable_class_() isInstance:lt]) {
        return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [((GeogebraCommonKernelArithmeticFunction *) nil_chk([((GeogebraCommonKernelGeosGeoFunction *) nil_chk([((id<GeogebraCommonKernelGeosGeoFunctionable>) nil_chk(((id<GeogebraCommonKernelGeosGeoFunctionable>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelGeosGeoFunctionable))))) getGeoFunction])) getFunction])) evaluateWithGeogebraCommonKernelGeosGeoPoint:pt]) autorelease];
      }
      else {
        GeogebraCommonMainApp_errorWithNSString_(@"missing case in ExpressionNodeEvaluator");
      }
    }
  }
  str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalArgument", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:2 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleFunctionNVarWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                       withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt {
  if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:rt] && ([GeogebraCommonKernelArithmeticFunctionalNVar_class_() isInstance:lt])) {
    GeogebraCommonKernelArithmeticFunctionNVar *funN = [((id<GeogebraCommonKernelArithmeticFunctionalNVar>) nil_chk(((id<GeogebraCommonKernelArithmeticFunctionalNVar>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticFunctionalNVar))))) getFunction];
    id<GeogebraCommonKernelArithmeticListValue> list = (id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticListValue));
    if ([((GeogebraCommonKernelArithmeticFunctionNVar *) nil_chk(funN)) getVarNumber] == [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(list)) size]) {
      IOSDoubleArray *args = [list toDouble];
      if (args != nil) {
        if ([funN isBooleanFunction]) {
          return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel_, [funN evaluateBooleanWithDoubleArray:args]) autorelease];
        }
        return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [funN evaluateWithDoubleArray:args]) autorelease];
      }
      return lt;
    }
    else if ([list size] == 1) {
      id<GeogebraCommonKernelArithmeticExpressionValue> ev = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyList *) nil_chk([list getMyList])) getListElementWithInt:0])) evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
      if (([funN getVarNumber] == 2) && ([ev isKindOfClass:[GeogebraCommonKernelGeosGeoPoint class]])) {
        GeogebraCommonKernelGeosGeoPoint *pt = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(ev, [GeogebraCommonKernelGeosGeoPoint class]);
        if ([funN isBooleanFunction]) {
          return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel_, [funN evaluateBooleanWithGeogebraCommonKernelGeosGeoPoint:pt]) autorelease];
        }
        return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [funN evaluateWithGeogebraCommonKernelGeosGeoPoint:pt]) autorelease];
      }
      else if (([funN getVarNumber] == 2) && ([ev isKindOfClass:[GeogebraCommonKernelArithmeticMyVecNode class]])) {
        GeogebraCommonKernelArithmeticMyVecNode *pt = (GeogebraCommonKernelArithmeticMyVecNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticMyVecNode class]);
        IOSDoubleArray *vals = [IOSDoubleArray arrayWithDoubles:(jdouble[]){ [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyVecNode *) nil_chk(pt)) getX])) evaluateDouble], [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([pt getY])) evaluateDouble] } count:2];
        if ([funN isBooleanFunction]) {
          return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel_, [funN evaluateBooleanWithDoubleArray:vals]) autorelease];
        }
        return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [funN evaluateWithDoubleArray:vals]) autorelease];
      }
      else if (([GeogebraCommonKernelArithmeticListValue_class_() isInstance:ev]) && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:[((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyList *) nil_chk([((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(ev, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList])) getListElementWithInt:0])) evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]]) {
        IOSDoubleArray *vals = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(ev, @protocol(GeogebraCommonKernelArithmeticListValue))))) toDouble];
        if (vals != nil) {
          if ([funN isBooleanFunction]) {
            return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel_, [funN evaluateBooleanWithDoubleArray:vals]) autorelease];
          }
          return [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(kernel_, [funN evaluateWithDoubleArray:vals]) autorelease];
        }
      }
      else if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:ev]) {
        GeogebraCommonKernelArithmeticMyList *l = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(ev, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
        GeogebraCommonKernelArithmeticMyList *ret = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel_) autorelease];
        for (jint i = 0; i < [((GeogebraCommonKernelArithmeticMyList *) nil_chk(l)) size]; i++) {
          GeogebraCommonKernelArithmeticMyList *lArg = [new_GeogebraCommonKernelArithmeticMyList_initWithGeogebraCommonKernelKernel_(kernel_) autorelease];
          [lArg addListElementWithGeogebraCommonKernelArithmeticExpressionValue:[l getListElementWithInt:i]];
          [ret addListElementWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, funN, GeogebraCommonPluginOperationEnum_get_FUNCTION_NVAR(), lArg) autorelease]];
        }
        return ret;
      }
      return lt;
    }
  }
  IOSObjectArray *str3 = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalArgument", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:2 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str3) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)illegalBooleanWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)arg
                                                                                                        withNSString:(NSString *)opname {
  IOSObjectArray *str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalBoolean", opname, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(arg)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:3 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)illegalArgumentWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                    withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                                                         withNSString:(NSString *)opname {
  IOSObjectArray *str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalArgument", opname, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], @",", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], @")" } count:6 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)illegalArgumentWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)arg {
  IOSObjectArray *str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalArgument", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(arg)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:2 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)illegalBinaryWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                  withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                                                       withNSString:(NSString *)type
                                                                                                       withNSString:(NSString *)opname {
  IOSObjectArray *str = [IOSObjectArray arrayWithObjects:(id[]){ type, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], opname, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:4 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)illegalComparisonWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                      withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                                                           withNSString:(NSString *)opname {
  IOSObjectArray *str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalComparison", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], opname, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:4 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)illegalListOpWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                  withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                                                       withNSString:(NSString *)opname {
  IOSObjectArray *str = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalListOperation", [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], opname, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_] } count:4 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, str) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)polynomialOrDieWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                                withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op
                                                                                                         withNSString:(NSString *)opname {
  return [self polynomialOrDieWithGeogebraCommonKernelArithmeticExpressionValue:lt withGeogebraCommonPluginOperationEnum:op withNSString:opname withNSString:@")"];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)polynomialOrDieWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                                withGeogebraCommonPluginOperationEnum:(GeogebraCommonPluginOperationEnum *)op
                                                                                                         withNSString:(NSString *)prefix
                                                                                                         withNSString:(NSString *)suffix {
  IOSObjectArray *strings = [IOSObjectArray arrayWithObjects:(id[]){ @"IllegalArgument", prefix, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_], suffix } count:4 type:NSString_class_()];
  @throw [new_GeogebraCommonMainMyError_initWithGeogebraCommonMainLocalization_withNSStringArray_(l10n_, strings) autorelease];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)handleVectorProductWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)lt
                                                                        withGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)rt
                                                                                   withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                                                                              withBoolean:(jboolean)holdsLaTeXtext {
  if ([GeogebraCommonKernelArithmeticVectorNDValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorNDValue_class_() isInstance:rt]) {
    return [self vectorProductWithGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue)) withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue))];
  }
  return [self illegalBinaryWithGeogebraCommonKernelArithmeticExpressionValue:lt withGeogebraCommonKernelArithmeticExpressionValue:rt withNSString:@"IllegalMultiplication" withNSString:GeogebraCommonKernelArithmeticExpressionNodeConstants_get_strVECTORPRODUCT_()];
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)vectorProductWithGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)v1
                                                                  withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>)v2 {
  id<GeogebraCommonKernelKernelNDGeoVecInterface> vec1 = [((id<GeogebraCommonKernelArithmeticVectorNDValue>) nil_chk(v1)) getVector];
  id<GeogebraCommonKernelKernelNDGeoVecInterface> vec2 = [((id<GeogebraCommonKernelArithmeticVectorNDValue>) nil_chk(v2)) getVector];
  GeogebraCommonKernelArithmeticMyDouble *num = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_(kernel_) autorelease];
  GeogebraCommonKernelGeosGeoVec2D_vectorProductWithGeogebraCommonKernelKernelNDGeoVecInterface_withGeogebraCommonKernelKernelNDGeoVecInterface_withGeogebraCommonKernelArithmeticMyDouble_(vec1, vec2, num);
  return num;
}

- (GeogebraCommonKernelKernel *)getKernel {
  return kernel_;
}

- (void)dealloc {
  RELEASE_(l10n_);
  RELEASE_(kernel_);
  [super dealloc];
}

+ (void)initialize {
  if (self == [GeogebraCommonKernelArithmeticExpressionNodeEvaluator class]) {
    JreStrongAssign(&GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_, nil, GeogebraCommonKernelStringTemplate_get_defaultTemplate_());
    J2OBJC_SET_INITIALIZED(GeogebraCommonKernelArithmeticExpressionNodeEvaluator)
  }
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonMainLocalization:withGeogebraCommonKernelKernel:", "ExpressionNodeEvaluator", NULL, 0x1, NULL, NULL },
    { "evaluateWithGeogebraCommonKernelArithmeticExpressionNode:withGeogebraCommonKernelStringTemplate:", "evaluate", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "handleOpWithGeogebraCommonPluginOperationEnum:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelStringTemplate:withBoolean:", "handleOp", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x4, NULL, NULL },
    { "multiplyWithGeogebraCommonKernelArithmeticMyList:withGeogebraCommonKernelArithmeticVectorNDValue:", "multiply", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x4, NULL, NULL },
    { "multiply2DWithGeogebraCommonKernelArithmeticMyList:withInt:withInt:withGeogebraCommonKernelArithmeticVectorValue:", "multiply2D", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x14, NULL, NULL },
    { "multiply2DWithGeogebraCommonKernelArithmeticMyList:withInt:withInt:withGeogebraCommonKernelArithmeticVectorNDValue:withGeogebraCommonKernelGeosGeoVec2D:", "multiply2D", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x14, NULL, NULL },
    { "handleSpecialWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonPluginOperationEnum:withGeogebraCommonKernelStringTemplate:", "handleSpecial", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x2, NULL, NULL },
    { "evalEqualsWithGeogebraCommonKernelKernel:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "evalEquals", "Lgeogebra.common.kernel.arithmetic.MyBoolean;", 0x9, NULL, NULL },
    { "handleXcoordWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonPluginOperationEnum:", "handleXcoord", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "handleYcoordWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonPluginOperationEnum:", "handleYcoord", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "handleMultWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelStringTemplate:withBoolean:", "handleMult", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "multiplyWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelArithmeticVectorNDValue:", "multiply", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x4, NULL, NULL },
    { "complexMultWithGeogebraCommonKernelArithmeticVectorNDValue:withGeogebraCommonKernelArithmeticVectorNDValue:withGeogebraCommonKernelKernel:", "complexMult", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x4, NULL, NULL },
    { "innerProductWithGeogebraCommonKernelArithmeticVectorNDValue:withGeogebraCommonKernelArithmeticVectorNDValue:withGeogebraCommonKernelKernel:", "innerProduct", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x4, NULL, NULL },
    { "handlePlusWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelStringTemplate:withBoolean:", "handlePlus", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "handleDivideWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "handleDivide", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "handleMinusWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "handleMinus", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "handlePowerWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "handlePower", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "negPowerWithDouble:withGeogebraCommonKernelArithmeticExpressionValue:", "negPower", "D", 0x8, NULL, NULL },
    { "handleFunctionWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "handleFunction", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "handleFunctionNVarWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:", "handleFunctionNVar", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "illegalBooleanWithGeogebraCommonKernelArithmeticExpressionValue:withNSString:", "illegalBoolean", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "illegalArgumentWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withNSString:", "illegalArgument", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "illegalArgumentWithGeogebraCommonKernelArithmeticExpressionValue:", "illegalArgument", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "illegalBinaryWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withNSString:withNSString:", "illegalBinary", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "illegalComparisonWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withNSString:", "illegalComparison", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "illegalListOpWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withNSString:", "illegalListOp", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "polynomialOrDieWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonPluginOperationEnum:withNSString:", "polynomialOrDie", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "polynomialOrDieWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonPluginOperationEnum:withNSString:withNSString:", "polynomialOrDie", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "handleVectorProductWithGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelArithmeticExpressionValue:withGeogebraCommonKernelStringTemplate:withBoolean:", "handleVectorProduct", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x1, NULL, NULL },
    { "vectorProductWithGeogebraCommonKernelArithmeticVectorNDValue:withGeogebraCommonKernelArithmeticVectorNDValue:", "vectorProduct", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x4, NULL, NULL },
    { "getKernel", NULL, "Lgeogebra.common.kernel.Kernel;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "errorTemplate_", NULL, 0x1a, "Lgeogebra.common.kernel.StringTemplate;", &GeogebraCommonKernelArithmeticExpressionNodeEvaluator_errorTemplate_, NULL,  },
    { "l10n_", NULL, 0x2, "Lgeogebra.common.main.Localization;", NULL, NULL,  },
    { "kernel_", NULL, 0x4, "Lgeogebra.common.kernel.Kernel;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelArithmeticExpressionNodeEvaluator = { 2, "ExpressionNodeEvaluator", "geogebra.common.kernel.arithmetic", NULL, 0x1, 32, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelArithmeticExpressionNodeEvaluator;
}

@end

void GeogebraCommonKernelArithmeticExpressionNodeEvaluator_initWithGeogebraCommonMainLocalization_withGeogebraCommonKernelKernel_(GeogebraCommonKernelArithmeticExpressionNodeEvaluator *self, GeogebraCommonMainLocalization *l10n, GeogebraCommonKernelKernel *kernel) {
  NSObject_init(self);
  GeogebraCommonKernelArithmeticExpressionNodeEvaluator_set_l10n_(self, l10n);
  GeogebraCommonKernelArithmeticExpressionNodeEvaluator_set_kernel_(self, kernel);
}

GeogebraCommonKernelArithmeticExpressionNodeEvaluator *new_GeogebraCommonKernelArithmeticExpressionNodeEvaluator_initWithGeogebraCommonMainLocalization_withGeogebraCommonKernelKernel_(GeogebraCommonMainLocalization *l10n, GeogebraCommonKernelKernel *kernel) {
  GeogebraCommonKernelArithmeticExpressionNodeEvaluator *self = [GeogebraCommonKernelArithmeticExpressionNodeEvaluator alloc];
  GeogebraCommonKernelArithmeticExpressionNodeEvaluator_initWithGeogebraCommonMainLocalization_withGeogebraCommonKernelKernel_(self, l10n, kernel);
  return self;
}

id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNodeEvaluator_multiply2DWithGeogebraCommonKernelArithmeticMyList_withInt_withInt_withGeogebraCommonKernelArithmeticVectorValue_(GeogebraCommonKernelArithmeticExpressionNodeEvaluator *self, GeogebraCommonKernelArithmeticMyList *myList, jint rows, jint cols, id<GeogebraCommonKernelArithmeticVectorValue> rt) {
  return GeogebraCommonKernelArithmeticExpressionNodeEvaluator_multiply2DWithGeogebraCommonKernelArithmeticMyList_withInt_withInt_withGeogebraCommonKernelArithmeticVectorNDValue_withGeogebraCommonKernelGeosGeoVec2D_(self, myList, rows, cols, rt, [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(rt)) getVector]);
}

id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNodeEvaluator_multiply2DWithGeogebraCommonKernelArithmeticMyList_withInt_withInt_withGeogebraCommonKernelArithmeticVectorNDValue_withGeogebraCommonKernelGeosGeoVec2D_(GeogebraCommonKernelArithmeticExpressionNodeEvaluator *self, GeogebraCommonKernelArithmeticMyList *myList, jint rows, jint cols, id<GeogebraCommonKernelArithmeticVectorNDValue> rt, GeogebraCommonKernelGeosGeoVec2D *myVec) {
  if ((rows == 2) && (cols == 2)) {
    GeogebraCommonKernelGeosGeoVec2D_multiplyMatrixWithGeogebraCommonKernelArithmeticMyList_withGeogebraCommonKernelKernelNDGeoVecInterface_withGeogebraCommonKernelGeosGeoVec2D_(myList, [((id<GeogebraCommonKernelArithmeticVectorNDValue>) nil_chk(rt)) getVector], myVec);
    return myVec;
  }
  else if ((rows == 3) && (cols == 3)) {
    [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(myVec)) multiplyMatrixAffineWithGeogebraCommonKernelArithmeticMyList:myList withGeogebraCommonKernelArithmeticExpressionValue:rt];
    return myVec;
  }
  return nil;
}

id<GeogebraCommonKernelArithmeticExpressionValue> GeogebraCommonKernelArithmeticExpressionNodeEvaluator_handleSpecialWithGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelArithmeticExpressionNodeEvaluator *self, id<GeogebraCommonKernelArithmeticExpressionValue> lt, id<GeogebraCommonKernelArithmeticExpressionValue> rt, id<GeogebraCommonKernelArithmeticExpressionValue> left, id<GeogebraCommonKernelArithmeticExpressionValue> right, GeogebraCommonPluginOperationEnum *operation, GeogebraCommonKernelStringTemplate *tpl) {
  if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:lt]) {
    if ((operation == GeogebraCommonPluginOperationEnum_get_MULTIPLY()) && [GeogebraCommonKernelArithmeticVectorNDValue_class_() isInstance:rt]) {
      GeogebraCommonKernelArithmeticMyList *myList = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
      if ([((GeogebraCommonKernelArithmeticMyList *) nil_chk(myList)) isMatrix]) {
        id<GeogebraCommonKernelArithmeticExpressionValue> ret = [self multiplyWithGeogebraCommonKernelArithmeticMyList:myList withGeogebraCommonKernelArithmeticVectorNDValue:(id<GeogebraCommonKernelArithmeticVectorNDValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorNDValue))];
        if (ret != nil) {
          return ret;
        }
      }
    }
    else if ((operation == GeogebraCommonPluginOperationEnum_get_VECTORPRODUCT()) && [GeogebraCommonKernelArithmeticListValue_class_() isInstance:rt]) {
      GeogebraCommonKernelArithmeticMyList *listL = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) evaluateWithGeogebraCommonKernelStringTemplate:tpl], @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
      GeogebraCommonKernelArithmeticMyList *listR = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) evaluateWithGeogebraCommonKernelStringTemplate:tpl], @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
      if ((([((GeogebraCommonKernelArithmeticMyList *) nil_chk(listL)) size] == 3) && ([((GeogebraCommonKernelArithmeticMyList *) nil_chk(listR)) size] == 3)) || (([listL size] == 2) && ([((GeogebraCommonKernelArithmeticMyList *) nil_chk(listR)) size] == 2))) {
        [listL vectorProductWithGeogebraCommonKernelArithmeticMyList:listR];
        return listL;
      }
    }
    if ((operation != GeogebraCommonPluginOperationEnum_get_IF_LIST()) && (operation != GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()) && (operation != GeogebraCommonPluginOperationEnum_get_NOT_EQUAL()) && (operation != GeogebraCommonPluginOperationEnum_get_IS_SUBSET_OF()) && (operation != GeogebraCommonPluginOperationEnum_get_IS_SUBSET_OF_STRICT()) && (operation != GeogebraCommonPluginOperationEnum_get_SET_DIFFERENCE()) && (operation != GeogebraCommonPluginOperationEnum_get_ELEMENT_OF()) && (operation != GeogebraCommonPluginOperationEnum_get_IS_ELEMENT_OF()) && !([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) && !([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:rt])) {
      GeogebraCommonKernelArithmeticMyList *myList = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
      [((GeogebraCommonKernelArithmeticMyList *) nil_chk(myList)) applyRightWithGeogebraCommonPluginOperationEnum:operation withGeogebraCommonKernelArithmeticExpressionValue:rt withGeogebraCommonKernelStringTemplate:tpl];
      return myList;
    }
  }
  else if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:rt] && ![((GeogebraCommonPluginOperationEnum *) nil_chk(operation)) isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()] && ![operation isEqual:GeogebraCommonPluginOperationEnum_get_NOT_EQUAL()] && ![operation isEqual:GeogebraCommonPluginOperationEnum_get_FUNCTION_NVAR()] && ![operation isEqual:GeogebraCommonPluginOperationEnum_get_FREEHAND()] && !([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [operation isPlusorMinus]) && !([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:lt]) && ![operation isEqual:GeogebraCommonPluginOperationEnum_get_IS_ELEMENT_OF()]) {
    if (operation == GeogebraCommonPluginOperationEnum_get_MULTIPLY() && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt]) {
      GeogebraCommonKernelArithmeticMyList *myList = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
      jboolean isMatrix = [((GeogebraCommonKernelArithmeticMyList *) nil_chk(myList)) isMatrix];
      jint rows = [myList getMatrixRows];
      jint cols = [myList getMatrixCols];
      if (isMatrix && (rows == 2) && (cols == 2)) {
        GeogebraCommonKernelGeosGeoVec2D *myVec = [((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(((id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue))))) getVector];
        [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(myVec)) multiplyMatrixLeftWithGeogebraCommonKernelArithmeticMyList:myList];
        return myVec;
      }
    }
    GeogebraCommonKernelArithmeticMyList *myList = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
    [((GeogebraCommonKernelArithmeticMyList *) nil_chk(myList)) applyLeftWithGeogebraCommonPluginOperationEnum:operation withGeogebraCommonKernelArithmeticExpressionValue:lt withGeogebraCommonKernelStringTemplate:tpl];
    return myList;
  }
  else if (([GeogebraCommonKernelArithmeticFunctionalNVar_class_() isInstance:lt]) && ([GeogebraCommonKernelArithmeticFunctionalNVar_class_() isInstance:rt]) && ![((GeogebraCommonPluginOperationEnum *) nil_chk(operation)) isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()] && ![operation isEqual:GeogebraCommonPluginOperationEnum_get_NOT_EQUAL()]) {
    return GeogebraCommonKernelGeosGeoFunction_operationSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticFunctionalNVar_(operation, (id<GeogebraCommonKernelArithmeticFunctionalNVar>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticFunctionalNVar)), (id<GeogebraCommonKernelArithmeticFunctionalNVar>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticFunctionalNVar)));
  }
  else if (([GeogebraCommonKernelArithmeticFunctionalNVar_class_() isInstance:lt]) && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt] && ([((GeogebraCommonPluginOperationEnum *) nil_chk(operation)) ordinal] < [((GeogebraCommonPluginOperationEnum *) nil_chk(GeogebraCommonPluginOperationEnum_get_FUNCTION())) ordinal])) {
    return GeogebraCommonKernelGeosGeoFunction_applyNumberSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_(operation, (id<GeogebraCommonKernelArithmeticFunctionalNVar>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticFunctionalNVar)), right, YES);
  }
  else if (([GeogebraCommonKernelArithmeticFunctionalNVar_class_() isInstance:rt]) && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt]) {
    return GeogebraCommonKernelGeosGeoFunction_applyNumberSymbWithGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticFunctionalNVar_withGeogebraCommonKernelArithmeticExpressionValue_withBoolean_(operation, (id<GeogebraCommonKernelArithmeticFunctionalNVar>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticFunctionalNVar)), left, NO);
  }
  return nil;
}

GeogebraCommonKernelArithmeticMyBoolean *GeogebraCommonKernelArithmeticExpressionNodeEvaluator_evalEqualsWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(GeogebraCommonKernelKernel *kernel, id<GeogebraCommonKernelArithmeticExpressionValue> lt, id<GeogebraCommonKernelArithmeticExpressionValue> rt) {
  GeogebraCommonKernelArithmeticExpressionNodeEvaluator_initialize();
  GeogebraCommonKernelStringTemplate *tpl = GeogebraCommonKernelStringTemplate_get_defaultTemplate_();
  if ([GeogebraCommonKernelArithmeticBooleanValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticBooleanValue_class_() isInstance:rt]) {
    return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, [((id<GeogebraCommonKernelArithmeticBooleanValue>) nil_chk(((id<GeogebraCommonKernelArithmeticBooleanValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticBooleanValue))))) getBoolean] == [((id<GeogebraCommonKernelArithmeticBooleanValue>) nil_chk(((id<GeogebraCommonKernelArithmeticBooleanValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticBooleanValue))))) getBoolean]) autorelease];
  }
  else if ([GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticNumberValue_class_() isInstance:rt]) {
    return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble], [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(((id<GeogebraCommonKernelArithmeticNumberValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticNumberValue))))) getDouble])) autorelease];
  }
  else if ([GeogebraCommonKernelArithmeticTextValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticTextValue_class_() isInstance:rt]) {
    NSString *strL = [((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticTextValue))))) toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
    NSString *strR = [((id<GeogebraCommonKernelArithmeticTextValue>) nil_chk(((id<GeogebraCommonKernelArithmeticTextValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticTextValue))))) toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
    if ((strL == nil) || (strR == nil)) {
      return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, NO) autorelease];
    }
    return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, [((NSString *) nil_chk(strL)) isEqual:strR]) autorelease];
  }
  else if ([GeogebraCommonKernelArithmeticListValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticListValue_class_() isInstance:rt]) {
    GeogebraCommonKernelArithmeticMyList *list1 = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
    GeogebraCommonKernelArithmeticMyList *list2 = [((id<GeogebraCommonKernelArithmeticListValue>) nil_chk(((id<GeogebraCommonKernelArithmeticListValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticListValue))))) getMyList];
    jint size = [((GeogebraCommonKernelArithmeticMyList *) nil_chk(list1)) size];
    if (size != [((GeogebraCommonKernelArithmeticMyList *) nil_chk(list2)) size]) {
      return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, NO) autorelease];
    }
    for (jint i = 0; i < size; i++) {
      if (![((GeogebraCommonKernelArithmeticMyBoolean *) nil_chk(GeogebraCommonKernelArithmeticExpressionNodeEvaluator_evalEqualsWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonKernelArithmeticExpressionValue_(kernel, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([list1 getListElementWithInt:i])) evaluateWithGeogebraCommonKernelStringTemplate:tpl], [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([list2 getListElementWithInt:i])) evaluateWithGeogebraCommonKernelStringTemplate:tpl]))) getBoolean]) {
        return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, NO) autorelease];
      }
    }
    return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, YES) autorelease];
  }
  else if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(lt)) isGeoElement] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rt)) isGeoElement]) {
    GeogebraCommonKernelGeosGeoElement *geo1 = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(lt, [GeogebraCommonKernelGeosGeoElement class]);
    GeogebraCommonKernelGeosGeoElement *geo2 = (GeogebraCommonKernelGeosGeoElement *) check_class_cast(rt, [GeogebraCommonKernelGeosGeoElement class]);
    return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, [geo1 isEqualWithGeogebraCommonKernelGeosGeoElement:geo2]) autorelease];
  }
  else if ([GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmeticVectorValue_class_() isInstance:rt]) {
    id<GeogebraCommonKernelArithmeticVectorValue> vec1 = (id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmeticVectorValue));
    id<GeogebraCommonKernelArithmeticVectorValue> vec2 = (id<GeogebraCommonKernelArithmeticVectorValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmeticVectorValue));
    return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk([vec1 getVector])) isEqualWithGeogebraCommonKernelGeosGeoVec2D:[((id<GeogebraCommonKernelArithmeticVectorValue>) nil_chk(vec2)) getVector]]) autorelease];
  }
  else if ([GeogebraCommonKernelArithmetic3DVector3DValue_class_() isInstance:lt] && [GeogebraCommonKernelArithmetic3DVector3DValue_class_() isInstance:rt]) {
    id<GeogebraCommonKernelArithmetic3DVector3DValue> vec1 = (id<GeogebraCommonKernelArithmetic3DVector3DValue>) check_protocol_cast(lt, @protocol(GeogebraCommonKernelArithmetic3DVector3DValue));
    id<GeogebraCommonKernelArithmetic3DVector3DValue> vec2 = (id<GeogebraCommonKernelArithmetic3DVector3DValue>) check_protocol_cast(rt, @protocol(GeogebraCommonKernelArithmetic3DVector3DValue));
    return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, [((id<GeogebraCommonKernelKernelNDGeo3DVec>) nil_chk([vec1 getVector])) isEqualWithGeogebraCommonKernelKernelNDGeo3DVec:[((id<GeogebraCommonKernelArithmetic3DVector3DValue>) nil_chk(vec2)) getVector]]) autorelease];
  }
  return [new_GeogebraCommonKernelArithmeticMyBoolean_initWithGeogebraCommonKernelKernel_withBoolean_(kernel, NO) autorelease];
}

jdouble GeogebraCommonKernelArithmeticExpressionNodeEvaluator_negPowerWithDouble_withGeogebraCommonKernelArithmeticExpressionValue_(jdouble base, id<GeogebraCommonKernelArithmeticExpressionValue> right) {
  GeogebraCommonKernelArithmeticExpressionNodeEvaluator_initialize();
  GeogebraCommonKernelArithmeticExpressionNode *node = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right, [GeogebraCommonKernelArithmeticExpressionNode class]);
  jdouble a = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(node)) getLeft])) evaluateDouble];
  jlong al = JavaLangMath_roundWithDouble_(a);
  if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(a, al)) {
    jdouble b = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([node getRight])) evaluateDouble];
    jlong bl = JavaLangMath_roundWithDouble_(b);
    if (b == 0) {
      return (JavaLangDouble_NaN);
    }
    else if (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(b, bl)) {
      jlong gcd = GeogebraCommonKernelKernel_gcdWithLong_withLong_(al, bl);
      al = al / gcd;
      bl = bl / gcd;
      if (al != 1) {
        base = JavaLangMath_powWithDouble_withDouble_(base, al);
      }
      if (base > 0) {
        return JavaLangMath_powWithDouble_withDouble_(base, 1.0 / bl);
      }
      jboolean oddB = (JavaLangMath_absWithLong_(bl) % 2) == 1;
      if (oddB) {
        return (-JavaLangMath_powWithDouble_withDouble_(-base, 1.0 / bl));
      }
      return (JavaLangDouble_NaN);
    }
  }
  return GeogebraCommonKernelArithmeticMyDouble_powWithDouble_withDouble_(base, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right)) evaluateDouble]);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelArithmeticExpressionNodeEvaluator)
