//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/algos/AlgoDependentBoolean.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoDependentBoolean.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/Algos.h"
#include "geogebra/common/kernel/algos/SymbolicParameters.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/MyBoolean.h"
#include "geogebra/common/kernel/geos/GeoBoolean.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/prover/AlgoAreEqual.h"
#include "geogebra/common/kernel/prover/AlgoAreParallel.h"
#include "geogebra/common/kernel/prover/AlgoArePerpendicular.h"
#include "geogebra/common/kernel/prover/NoSymbolicParametersException.h"
#include "geogebra/common/plugin/Operation.h"
#include "java/lang/Exception.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"

@interface GeogebraCommonKernelAlgosAlgoDependentBoolean () {
 @public
  GeogebraCommonKernelArithmeticExpressionNode *root_;
  GeogebraCommonKernelGeosGeoBoolean *bool__;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoDependentBoolean, root_, GeogebraCommonKernelArithmeticExpressionNode *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelAlgosAlgoDependentBoolean, bool__, GeogebraCommonKernelGeosGeoBoolean *)

__attribute__((unused)) static void GeogebraCommonKernelAlgosAlgoDependentBoolean_compute(GeogebraCommonKernelAlgosAlgoDependentBoolean *self);

@implementation GeogebraCommonKernelAlgosAlgoDependentBoolean

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons
                                            withNSString:(NSString *)label
        withGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)root {
  GeogebraCommonKernelAlgosAlgoDependentBoolean_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticExpressionNode_(self, cons, label, root);
  return self;
}

- (GeogebraCommonKernelAlgosAlgosEnum *)getClassName {
  return GeogebraCommonKernelAlgosAlgosEnum_get_Expression();
}

- (void)setInputOutput {
  GeogebraCommonKernelAlgosAlgoElement_set_input_(self, [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(root_)) getGeoElementVariables]);
  [super setOutputLengthWithInt:1];
  [super setOutputWithInt:0 withGeogebraCommonKernelGeosGeoElement:bool__];
  [self setDependencies];
}

- (GeogebraCommonKernelGeosGeoBoolean *)getGeoBoolean {
  return bool__;
}

- (void)compute {
  GeogebraCommonKernelAlgosAlgoDependentBoolean_compute(self);
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(root_)) toStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (GeogebraCommonKernelAlgosSymbolicParameters *)getSymbolicParameters {
  return [new_GeogebraCommonKernelAlgosSymbolicParameters_initWithGeogebraCommonKernelAlgosSymbolicParametersAlgo_(self) autorelease];
}

- (void)getFreeVariablesWithJavaUtilHashSet:(JavaUtilHashSet *)variables {
  if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(root_)) getLeft])) isGeoElement] || ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([root_ getRight])) isGeoElement]) @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  GeogebraCommonKernelGeosGeoElement *left = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getLeft], [GeogebraCommonKernelGeosGeoElement class]);
  GeogebraCommonKernelGeosGeoElement *right = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getRight], [GeogebraCommonKernelGeosGeoElement class]);
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PERPENDICULAR()]) {
    GeogebraCommonKernelProverAlgoArePerpendicular *algo = [new_GeogebraCommonKernelProverAlgoArePerpendicular_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    [algo getFreeVariablesWithJavaUtilHashSet:variables];
    [algo remove];
    return;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PARALLEL()]) {
    GeogebraCommonKernelProverAlgoAreParallel *algo = [new_GeogebraCommonKernelProverAlgoAreParallel_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    [algo getFreeVariablesWithJavaUtilHashSet:variables];
    [algo remove];
    return;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()]) {
    GeogebraCommonKernelProverAlgoAreEqual *algo = [new_GeogebraCommonKernelProverAlgoAreEqual_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", left, right) autorelease];
    [algo getFreeVariablesWithJavaUtilHashSet:variables];
    [algo remove];
    return;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSIntArray *)getDegrees {
  if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(root_)) getLeft])) isGeoElement] || ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([root_ getRight])) isGeoElement]) @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  GeogebraCommonKernelGeosGeoElement *left = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getLeft], [GeogebraCommonKernelGeosGeoElement class]);
  GeogebraCommonKernelGeosGeoElement *right = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getRight], [GeogebraCommonKernelGeosGeoElement class]);
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PERPENDICULAR()]) {
    GeogebraCommonKernelProverAlgoArePerpendicular *algo = [new_GeogebraCommonKernelProverAlgoArePerpendicular_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    IOSIntArray *ret = [algo getDegrees];
    [algo remove];
    return ret;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PARALLEL()]) {
    GeogebraCommonKernelProverAlgoAreParallel *algo = [new_GeogebraCommonKernelProverAlgoAreParallel_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    IOSIntArray *ret = [algo getDegrees];
    [algo remove];
    return ret;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()]) {
    GeogebraCommonKernelProverAlgoAreEqual *algo = [new_GeogebraCommonKernelProverAlgoAreEqual_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", left, right) autorelease];
    IOSIntArray *ret = [algo getDegrees];
    [algo remove];
    return ret;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getExactCoordinatesWithJavaUtilHashMap:(JavaUtilHashMap *)values {
  if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(root_)) getLeft])) isGeoElement] || ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([root_ getRight])) isGeoElement]) @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  GeogebraCommonKernelGeosGeoElement *left = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getLeft], [GeogebraCommonKernelGeosGeoElement class]);
  GeogebraCommonKernelGeosGeoElement *right = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getRight], [GeogebraCommonKernelGeosGeoElement class]);
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PERPENDICULAR()]) {
    GeogebraCommonKernelProverAlgoArePerpendicular *algo = [new_GeogebraCommonKernelProverAlgoArePerpendicular_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    IOSObjectArray *ret = [algo getExactCoordinatesWithJavaUtilHashMap:values];
    [algo remove];
    return ret;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PARALLEL()]) {
    GeogebraCommonKernelProverAlgoAreParallel *algo = [new_GeogebraCommonKernelProverAlgoAreParallel_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    IOSObjectArray *ret = [algo getExactCoordinatesWithJavaUtilHashMap:values];
    [algo remove];
    return ret;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()]) {
    GeogebraCommonKernelProverAlgoAreEqual *algo = [new_GeogebraCommonKernelProverAlgoAreEqual_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", left, right) autorelease];
    IOSObjectArray *ret = [algo getExactCoordinatesWithJavaUtilHashMap:values];
    [algo remove];
    return ret;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getPolynomials {
  if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(root_)) getLeft])) isGeoElement] || ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([root_ getRight])) isGeoElement]) @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  GeogebraCommonKernelGeosGeoElement *left = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getLeft], [GeogebraCommonKernelGeosGeoElement class]);
  GeogebraCommonKernelGeosGeoElement *right = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getRight], [GeogebraCommonKernelGeosGeoElement class]);
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PERPENDICULAR()]) {
    GeogebraCommonKernelProverAlgoArePerpendicular *algo = [new_GeogebraCommonKernelProverAlgoArePerpendicular_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    IOSObjectArray *ret = [algo getPolynomials];
    [algo remove];
    return ret;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PARALLEL()]) {
    GeogebraCommonKernelProverAlgoAreParallel *algo = [new_GeogebraCommonKernelProverAlgoAreParallel_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    IOSObjectArray *ret = [algo getPolynomials];
    [algo remove];
    return ret;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()]) {
    GeogebraCommonKernelProverAlgoAreEqual *algo = [new_GeogebraCommonKernelProverAlgoAreEqual_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", left, right) autorelease];
    IOSObjectArray *ret = [algo getPolynomials];
    [algo remove];
    return ret;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getBotanaPolynomials {
  if (![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(root_)) getLeft])) isGeoElement] || ![((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([root_ getRight])) isGeoElement]) @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
  GeogebraCommonKernelGeosGeoElement *left = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getLeft], [GeogebraCommonKernelGeosGeoElement class]);
  GeogebraCommonKernelGeosGeoElement *right = (GeogebraCommonKernelGeosGeoElement *) check_class_cast([root_ getRight], [GeogebraCommonKernelGeosGeoElement class]);
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PERPENDICULAR()]) {
    GeogebraCommonKernelProverAlgoArePerpendicular *algo = [new_GeogebraCommonKernelProverAlgoArePerpendicular_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    IOSObjectArray *ret = [algo getBotanaPolynomials];
    [algo remove];
    return ret;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_PARALLEL()]) {
    GeogebraCommonKernelProverAlgoAreParallel *algo = [new_GeogebraCommonKernelProverAlgoAreParallel_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", (GeogebraCommonKernelGeosGeoLine *) check_class_cast(left, [GeogebraCommonKernelGeosGeoLine class]), (GeogebraCommonKernelGeosGeoLine *) check_class_cast(right, [GeogebraCommonKernelGeosGeoLine class])) autorelease];
    IOSObjectArray *ret = [algo getBotanaPolynomials];
    [algo remove];
    return ret;
  }
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([root_ getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_EQUAL_BOOLEAN()]) {
    GeogebraCommonKernelProverAlgoAreEqual *algo = [new_GeogebraCommonKernelProverAlgoAreEqual_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelGeosGeoElement_withGeogebraCommonKernelGeosGeoElement_(cons_, @"", left, right) autorelease];
    IOSObjectArray *ret = [algo getBotanaPolynomials];
    [algo remove];
    return ret;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (GeogebraCommonKernelArithmeticExpressionNode *)getExpression {
  return root_;
}

- (void)dealloc {
  RELEASE_(root_);
  RELEASE_(bool__);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withNSString:withGeogebraCommonKernelArithmeticExpressionNode:", "AlgoDependentBoolean", NULL, 0x1, NULL, NULL },
    { "getClassName", NULL, "Lgeogebra.common.kernel.algos.Algos;", 0x1, NULL, NULL },
    { "setInputOutput", NULL, "V", 0x4, NULL, NULL },
    { "getGeoBoolean", NULL, "Lgeogebra.common.kernel.geos.GeoBoolean;", 0x1, NULL, NULL },
    { "compute", NULL, "V", 0x11, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "getSymbolicParameters", NULL, "Lgeogebra.common.kernel.algos.SymbolicParameters;", 0x1, NULL, NULL },
    { "getFreeVariablesWithJavaUtilHashSet:", "getFreeVariables", "V", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getDegrees", NULL, "[I", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getExactCoordinatesWithJavaUtilHashMap:", "getExactCoordinates", "[Ljava.math.BigInteger;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getPolynomials", NULL, "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getBotanaPolynomials", NULL, "[[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getExpression", NULL, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "root_", NULL, 0x2, "Lgeogebra.common.kernel.arithmetic.ExpressionNode;", NULL, NULL,  },
    { "bool__", "bool", 0x2, "Lgeogebra.common.kernel.geos.GeoBoolean;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelAlgosAlgoDependentBoolean = { 2, "AlgoDependentBoolean", "geogebra.common.kernel.algos", NULL, 0x1, 13, methods, 2, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelAlgosAlgoDependentBoolean;
}

@end

void GeogebraCommonKernelAlgosAlgoDependentBoolean_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticExpressionNode_(GeogebraCommonKernelAlgosAlgoDependentBoolean *self, GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelArithmeticExpressionNode *root) {
  GeogebraCommonKernelAlgosAlgoElement_initWithGeogebraCommonKernelConstruction_(self, cons);
  GeogebraCommonKernelAlgosAlgoDependentBoolean_set_root_(self, root);
  GeogebraCommonKernelAlgosAlgoDependentBoolean_setAndConsume_bool__(self, new_GeogebraCommonKernelGeosGeoBoolean_initWithGeogebraCommonKernelConstruction_(cons));
  [self setInputOutput];
  GeogebraCommonKernelAlgosAlgoDependentBoolean_compute(self);
  [self->bool__ setLabelWithNSString:label];
}

GeogebraCommonKernelAlgosAlgoDependentBoolean *new_GeogebraCommonKernelAlgosAlgoDependentBoolean_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticExpressionNode_(GeogebraCommonKernelConstruction *cons, NSString *label, GeogebraCommonKernelArithmeticExpressionNode *root) {
  GeogebraCommonKernelAlgosAlgoDependentBoolean *self = [GeogebraCommonKernelAlgosAlgoDependentBoolean alloc];
  GeogebraCommonKernelAlgosAlgoDependentBoolean_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticExpressionNode_(self, cons, label, root);
  return self;
}

void GeogebraCommonKernelAlgosAlgoDependentBoolean_compute(GeogebraCommonKernelAlgosAlgoDependentBoolean *self) {
  @try {
    jboolean oldLabelStatus = [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) isSuppressLabelsActive];
    [((GeogebraCommonKernelConstruction *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getConstruction])) setSuppressLabelCreationWithBoolean:YES];
    id<GeogebraCommonKernelArithmeticExpressionValue> ev = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(self->root_)) evaluateWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()];
    [((GeogebraCommonKernelConstruction *) nil_chk([self->kernel_ getConstruction])) setSuppressLabelCreationWithBoolean:oldLabelStatus];
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(ev)) isGeoElement]) [((GeogebraCommonKernelGeosGeoBoolean *) nil_chk(self->bool__)) setValueWithBoolean:[((GeogebraCommonKernelGeosGeoBoolean *) check_class_cast(ev, [GeogebraCommonKernelGeosGeoBoolean class])) getBoolean]];
    else [((GeogebraCommonKernelGeosGeoBoolean *) nil_chk(self->bool__)) setValueWithBoolean:[((GeogebraCommonKernelArithmeticMyBoolean *) check_class_cast(ev, [GeogebraCommonKernelArithmeticMyBoolean class])) getBoolean]];
  }
  @catch (JavaLangException *e) {
    [((GeogebraCommonKernelGeosGeoBoolean *) nil_chk(self->bool__)) setUndefined];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelAlgosAlgoDependentBoolean)
