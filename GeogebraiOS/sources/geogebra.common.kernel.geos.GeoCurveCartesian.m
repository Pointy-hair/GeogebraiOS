//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/geos/GeoCurveCartesian.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/DistanceFunction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/ParametricCurveDistanceFunction.h"
#include "geogebra/common/kernel/Path.h"
#include "geogebra/common/kernel/PathMover.h"
#include "geogebra/common/kernel/PathMoverGeneric.h"
#include "geogebra/common/kernel/PathParameter.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoMacroInterface.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionVariable.h"
#include "geogebra/common/kernel/arithmetic/MyDouble.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/geos/GeoConic.h"
#include "geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "geogebra/common/kernel/kernelND/GeoCurveCartesianND.h"
#include "geogebra/common/kernel/kernelND/GeoLineND.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/optimization/ExtremumFinder.h"
#include "geogebra/common/kernel/roots/RealRootFunction.h"
#include "geogebra/common/kernel/roots/RealRootUtil.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/util/MyMath.h"
#include "java/lang/Double.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"

@interface GeogebraCommonKernelGeosGeoCurveCartesian () {
 @public
  jboolean isClosedPath__;
  jboolean trace_;
}

- (void)mirrorWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phi;

- (void)pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P
                                                  withBoolean:(jboolean)changePoint;

- (jdouble)adjustRangeWithDouble:(jdouble)startValResult;

@end

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionXWithGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelGeosGeoCurveCartesian *self, GeogebraCommonKernelArithmeticFunction *funX);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionYWithGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelGeosGeoCurveCartesian *self, GeogebraCommonKernelArithmeticFunction *funY);

__attribute__((unused)) static id<GeogebraCommonKernelRootsRealRootFunction> GeogebraCommonKernelGeosGeoCurveCartesian_getRealRootFunctionX(GeogebraCommonKernelGeosGeoCurveCartesian *self);

__attribute__((unused)) static id<GeogebraCommonKernelRootsRealRootFunction> GeogebraCommonKernelGeosGeoCurveCartesian_getRealRootFunctionY(GeogebraCommonKernelGeosGeoCurveCartesian *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(GeogebraCommonKernelGeosGeoCurveCartesian *self, jdouble vx, jdouble vy);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCurveCartesian_rotateWithGeogebraCommonKernelArithmeticNumberValue_(GeogebraCommonKernelGeosGeoCurveCartesian *self, id<GeogebraCommonKernelArithmeticNumberValue> phi);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCurveCartesian_mirrorWithGeogebraCommonKernelArithmeticNumberValue_(GeogebraCommonKernelGeosGeoCurveCartesian *self, id<GeogebraCommonKernelArithmeticNumberValue> phi);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoCurveCartesian_pathChangedWithGeogebraCommonKernelKernelNDGeoPointND_withBoolean_(GeogebraCommonKernelGeosGeoCurveCartesian *self, id<GeogebraCommonKernelKernelNDGeoPointND> P, jboolean changePoint);

__attribute__((unused)) static jdouble GeogebraCommonKernelGeosGeoCurveCartesian_adjustRangeWithDouble_(GeogebraCommonKernelGeosGeoCurveCartesian *self, jdouble startValResult);

@implementation GeogebraCommonKernelGeosGeoCurveCartesian

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c {
  GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
              withGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)fx
              withGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)fy {
  GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticFunction_(self, c, fx, fy);
  return self;
}

- (NSString *)translatedTypeString {
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Curve"];
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_CURVE_CARTESIAN();
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)f {
  GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelGeosGeoCurveCartesian_(self, f);
  return self;
}

- (GeogebraCommonKernelGeosGeoElement *)copy__ {
  return [new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelGeosGeoCurveCartesian_(self) autorelease];
}

- (void)setFunctionXWithGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)funX {
  GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionXWithGeogebraCommonKernelArithmeticFunction_(self, funX);
}

- (void)setFunctionYWithGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)funY {
  GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionYWithGeogebraCommonKernelArithmeticFunction_(self, funY);
}

- (void)replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([self getFunWithInt:0] != nil) {
    [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:geo];
  }
  if ([self getFunWithInt:1] != nil) {
    [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:geo];
  }
}

- (void)setIntervalWithDouble:(jdouble)startParam
                   withDouble:(jdouble)endParam {
  [super setIntervalWithDouble:startParam withDouble:endParam];
  self->isClosedPath__ = (GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:startParam], [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:endParam], GeogebraCommonKernelKernel_MIN_PRECISION) && GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_withDouble_([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:startParam], [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:endParam], GeogebraCommonKernelKernel_MIN_PRECISION));
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  GeogebraCommonKernelGeosGeoCurveCartesian *geoCurve = (GeogebraCommonKernelGeosGeoCurveCartesian *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoCurveCartesian class]);
  [self setFunWithInt:0 withGeogebraCommonKernelArithmeticFunction:[new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelKernel_(IOSObjectArray_Get(nil_chk(((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(geoCurve))->fun_), 0), self->kernel_) autorelease]];
  [self setFunWithInt:1 withGeogebraCommonKernelArithmeticFunction:[new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelKernel_(IOSObjectArray_Get(geoCurve->fun_, 1), self->kernel_) autorelease]];
  self->startParam_ = geoCurve->startParam_;
  self->endParam_ = geoCurve->endParam_;
  self->isDefined__ = geoCurve->isDefined__;
  if (((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo))->cons_ != self->cons_ && [self isAlgoMacroOutput]) {
    if (![geo isIndependent]) {
      id<GeogebraCommonKernelAlgosAlgoMacroInterface> algoMacro = (id<GeogebraCommonKernelAlgosAlgoMacroInterface>) check_protocol_cast([self getParentAlgorithm], @protocol(GeogebraCommonKernelAlgosAlgoMacroInterface));
      [((id<GeogebraCommonKernelAlgosAlgoMacroInterface>) nil_chk(algoMacro)) initFunctionWithGeogebraCommonKernelArithmeticFunctionNVar:[self getFunWithInt:0]];
      [algoMacro initFunctionWithGeogebraCommonKernelArithmeticFunctionNVar:[self getFunWithInt:1]];
    }
  }
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_set_distFun_(self, nil);
}

- (void)setParametricDerivativeWithGeogebraCommonKernelGeosGeoCurveCartesian:(GeogebraCommonKernelGeosGeoCurveCartesian *)curve {
  if ([((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(curve)) isDefined]) {
    [self setFunWithInt:0 withGeogebraCommonKernelArithmeticFunction:IOSObjectArray_Get(nil_chk(curve->fun_), 0)];
    [self setFunWithInt:1 withGeogebraCommonKernelArithmeticFunction:GeogebraCommonKernelArithmeticFunction_getDerivativeQuotientWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticFunction_(IOSObjectArray_Get(curve->fun_, 0), IOSObjectArray_Get(curve->fun_, 1))];
    self->isDefined__ = !([self getFunWithInt:0] == nil || [self getFunWithInt:1] == nil);
    if (self->isDefined__) [self setIntervalWithDouble:curve->startParam_ withDouble:curve->endParam_];
  }
  else {
    self->isDefined__ = NO;
  }
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_set_distFun_(self, nil);
}

- (NSString *)getFunXWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (NSString *)getFunYWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (id<GeogebraCommonKernelRootsRealRootFunction>)getRealRootFunctionX {
  return GeogebraCommonKernelGeosGeoCurveCartesian_getRealRootFunctionX(self);
}

- (id<GeogebraCommonKernelRootsRealRootFunction>)getRealRootFunctionY {
  return GeogebraCommonKernelGeosGeoCurveCartesian_getRealRootFunctionY(self);
}

- (void)translateWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)v {
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) translateYWithDouble:[((GeogebraCommonKernelMatrixCoords *) nil_chk(v)) getX]];
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) translateYWithDouble:[v getY]];
}

- (jboolean)isTranslateable {
  return YES;
}

- (jboolean)isMatrixTransformable {
  return YES;
}

- (void)translateWithDouble:(jdouble)vx
                 withDouble:(jdouble)vy {
  GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, vx, vy);
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phi
                 withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)point {
  GeogebraCommonKernelMatrixCoords *P = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(point)) getInhomCoords];
  GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, -[((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX], -[P getY]);
  GeogebraCommonKernelGeosGeoCurveCartesian_rotateWithGeogebraCommonKernelArithmeticNumberValue_(self, phi);
  GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, [P getX], [P getY]);
}

- (void)mirrorWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  [self dilateWithGeogebraCommonKernelArithmeticNumberValue:[new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, -1.0) autorelease] withGeogebraCommonKernelMatrixCoords:P];
}

- (void)mirrorWithGeogebraCommonKernelKernelNDGeoLineND:(id<GeogebraCommonKernelKernelNDGeoLineND>)g1 {
  GeogebraCommonKernelGeosGeoLine *g = (GeogebraCommonKernelGeosGeoLine *) check_class_cast(g1, [GeogebraCommonKernelGeosGeoLine class]);
  jdouble qx, qy;
  if (JavaLangMath_absWithDouble_([((GeogebraCommonKernelGeosGeoLine *) nil_chk(g)) getX]) > JavaLangMath_absWithDouble_([g getY])) {
    qx = [g getZ] / [g getX];
    qy = 0.0;
  }
  else {
    qx = 0.0;
    qy = [g getZ] / [g getY];
  }
  GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, qx, qy);
  GeogebraCommonKernelGeosGeoCurveCartesian_mirrorWithGeogebraCommonKernelArithmeticNumberValue_(self, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, 2.0 * JavaLangMath_atan2WithDouble_withDouble_(-[g getX], [g getY])) autorelease]);
  GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, -qx, -qy);
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phi {
  GeogebraCommonKernelGeosGeoCurveCartesian_rotateWithGeogebraCommonKernelArithmeticNumberValue_(self, phi);
}

- (void)dilateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)ratio
                       withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)P {
  GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, -[((GeogebraCommonKernelMatrixCoords *) nil_chk(P)) getX], -[P getY]);
  GeogebraCommonKernelArithmeticExpressionNode *exprX = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_], [GeogebraCommonKernelArithmeticFunction class])))) getExpression];
  GeogebraCommonKernelArithmeticExpressionNode *exprY = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_], [GeogebraCommonKernelArithmeticFunction class])))) getExpression];
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, ratio, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), exprX) autorelease]];
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, ratio, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), exprY) autorelease]];
  GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, [P getX], [P getY]);
}

- (void)mirrorWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phi {
  GeogebraCommonKernelGeosGeoCurveCartesian_mirrorWithGeogebraCommonKernelArithmeticNumberValue_(self, phi);
}

- (JavaUtilArrayList *)getPointsOnCurveWithInt:(jint)n
                                    withDouble:(jdouble)startInterval
                                    withDouble:(jdouble)endInterval {
  JavaUtilArrayList *pointList = [new_JavaUtilArrayList_init() autorelease];
  jdouble step = (endInterval - startInterval) / (n + 1);
  for (jdouble i = 0, v = startInterval; i < n; i++, v += step) {
    IOSDoubleArray *point = [IOSDoubleArray arrayWithLength:2];
    *IOSDoubleArray_GetRef(point, 0) = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:v];
    *IOSDoubleArray_GetRef(point, 1) = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:v];
    [pointList addWithId:[new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_withDouble_withDouble_withDouble_(self->cons_, IOSDoubleArray_Get(point, 0), IOSDoubleArray_Get(point, 1), 1) autorelease]];
  }
  return pointList;
}

- (void)matrixTransformWithDouble:(jdouble)a
                       withDouble:(jdouble)b
                       withDouble:(jdouble)c
                       withDouble:(jdouble)d {
  GeogebraCommonKernelArithmeticMyDouble *ma = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *mb = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, b) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *mc = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, c) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *md = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, d) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *exprX = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_], [GeogebraCommonKernelArithmeticFunction class])))) getExpression];
  GeogebraCommonKernelArithmeticExpressionNode *exprY = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_], [GeogebraCommonKernelArithmeticFunction class])))) getExpression];
  GeogebraCommonKernelArithmeticExpressionNode *transX = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exprX)) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:ma])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exprY)) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:mb]];
  GeogebraCommonKernelArithmeticExpressionNode *transY = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([exprX multiplyWithGeogebraCommonKernelArithmeticExpressionValue:mc])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[exprY multiplyWithGeogebraCommonKernelArithmeticExpressionValue:md]];
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:transX];
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:transY];
}

- (jboolean)showInAlgebraView {
  return YES;
}

- (jboolean)showInEuclidianView {
  return [self isDefined];
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  JavaLangStringBuilder *sbToString = [new_JavaLangStringBuilder_initWithInt_(80) autorelease];
  [sbToString setLengthWithInt:0];
  if ([self isLabelSet]) {
    [sbToString appendWithNSString:self->label_];
    [sbToString appendWithChar:':'];
  }
  [sbToString appendWithNSString:[self toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
  return [sbToString description];
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (self->isDefined__) {
    JavaLangStringBuilder *sbTemp = [new_JavaLangStringBuilder_initWithInt_(80) autorelease];
    if ([((GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum *) nil_chk([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getStringType])) isEqual:GeogebraCommonKernelArithmeticExpressionNodeConstants_StringTypeEnum_get_GIAC()]) {
      [sbTemp appendWithNSString:@"equation(plotparam(["];
      [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      [sbTemp appendWithChar:','];
      [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      [sbTemp appendWithNSString:@"],"];
      [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunctionVariable *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) getFunctionVariable])) toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_giacTemplate_()]];
      [sbTemp appendWithChar:','];
      [sbTemp appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) formatWithDouble:[self getMinParameter] withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_giacTemplate_()]];
      [sbTemp appendWithChar:','];
      [sbTemp appendWithNSString:[self->kernel_ formatWithDouble:[self getMaxParameter] withGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_giacTemplate_()]];
      [sbTemp appendWithNSString:@"))"];
    }
    else {
      [sbTemp appendWithChar:'('];
      [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      [sbTemp appendWithNSString:@", "];
      [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      [sbTemp appendWithChar:')'];
    }
    return [sbTemp description];
  }
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
}

- (NSString *)toSymbolicStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (self->isDefined__) {
    JavaLangStringBuilder *sbTemp = [new_JavaLangStringBuilder_initWithInt_(80) autorelease];
    [sbTemp setLengthWithInt:0];
    [sbTemp appendWithChar:'('];
    [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
    [sbTemp appendWithNSString:@", "];
    [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
    [sbTemp appendWithChar:')'];
    return [sbTemp description];
  }
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
}

- (void)pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  GeogebraCommonKernelPathParameter *pp = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getPathParameter];
  jdouble t = [self getClosestParameterWithGeogebraCommonKernelKernelNDGeoPointND:P withDouble:((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_];
  pp->t_ = t;
  GeogebraCommonKernelGeosGeoCurveCartesian_pathChangedWithGeogebraCommonKernelKernelNDGeoPointND_withBoolean_(self, P, NO);
}

- (jboolean)isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI
                                                    withDouble:(jdouble)eps {
  GeogebraCommonKernelGeosGeoPoint *P = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(PI, [GeogebraCommonKernelGeosGeoPoint class]);
  if ([((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P)) getPath] == self) return YES;
  GeogebraCommonKernelPathParameter *pp = [P getPathParameter];
  jdouble t = [self getClosestParameterWithGeogebraCommonKernelKernelNDGeoPointND:P withDouble:((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_];
  jboolean onPath = JavaLangMath_absWithDouble_([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:t] - [P getInhomX]) <= eps && JavaLangMath_absWithDouble_([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:t] - [P getInhomY]) <= eps;
  return onPath;
}

- (void)pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)PI {
  GeogebraCommonKernelGeosGeoCurveCartesian_pathChangedWithGeogebraCommonKernelKernelNDGeoPointND_withBoolean_(self, PI, ![((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) usePathAndRegionParametersWithGeogebraCommonKernelKernelNDGeoPointND:PI]);
}

- (void)pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P
                                                  withBoolean:(jboolean)changePoint {
  GeogebraCommonKernelGeosGeoCurveCartesian_pathChangedWithGeogebraCommonKernelKernelNDGeoPointND_withBoolean_(self, P, changePoint);
}

- (jdouble)getClosestParameterWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P
                                                              withDouble:(jdouble)startValue {
  jdouble startVal = startValue;
  if (self->distFun_ == nil) GeogebraCommonKernelKernelNDGeoCurveCartesianND_setAndConsume_distFun_(self, new_GeogebraCommonKernelParametricCurveDistanceFunction_initWithGeogebraCommonKernelGeosParametricCurve_(self));
  [((id<GeogebraCommonKernelDistanceFunction>) nil_chk(self->distFun_)) setDistantPointWithGeogebraCommonKernelKernelNDGeoPointND:P];
  if ([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getPath] == self) {
    GeogebraCommonKernelPathParameter *pp = [P getPathParameter];
    jdouble pathParam = ((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_;
    if ([self->distFun_ evaluateWithDouble:pathParam] < GeogebraCommonKernelKernel_MIN_PRECISION * GeogebraCommonKernelKernel_MIN_PRECISION) return pathParam;
    if (JavaLangDouble_isNaNWithDouble_(startVal)) startVal = pathParam;
  }
  jdouble step = (self->endParam_ - self->startParam_) / GeogebraCommonKernelKernelNDGeoCurveCartesianND_CLOSEST_PARAMETER_SAMPLES;
  jdouble minVal = [self->distFun_ evaluateWithDouble:self->startParam_];
  jdouble minParam = self->startParam_;
  jdouble t = self->startParam_;
  for (jint i = 0; i < GeogebraCommonKernelKernelNDGeoCurveCartesianND_CLOSEST_PARAMETER_SAMPLES; i++) {
    t = t + step;
    jdouble ft = [self->distFun_ evaluateWithDouble:t];
    if (ft < minVal) {
      minVal = ft;
      minParam = t;
    }
  }
  if (minParam - step < [self getMinParameter] || minParam + step > [self getMaxParameter]) {
    return minParam;
  }
  jdouble left = minParam - step;
  jdouble right = minParam + step;
  GeogebraCommonKernelOptimizationExtremumFinder *extFinder = [((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getExtremumFinder];
  jdouble sampleResult = [((GeogebraCommonKernelOptimizationExtremumFinder *) nil_chk(extFinder)) findMinimumWithDouble:left withDouble:right withGeogebraCommonKernelRootsRealRootFunction:self->distFun_ withDouble:GeogebraCommonKernelKernel_MIN_PRECISION];
  sampleResult = GeogebraCommonKernelGeosGeoCurveCartesian_adjustRangeWithDouble_(self, sampleResult);
  if (!JavaLangDouble_isNaNWithDouble_(startVal) && (startVal < left || right < startVal)) {
    left = startVal - step;
    right = startVal + step;
    jdouble startValResult = [extFinder findMinimumWithDouble:left withDouble:right withGeogebraCommonKernelRootsRealRootFunction:self->distFun_ withDouble:GeogebraCommonKernelKernel_MIN_PRECISION];
    startValResult = GeogebraCommonKernelGeosGeoCurveCartesian_adjustRangeWithDouble_(self, startValResult);
    if ([self->distFun_ evaluateWithDouble:startValResult] < [self->distFun_ evaluateWithDouble:sampleResult] + GeogebraCommonKernelKernel_MIN_PRECISION / 2) {
      return startValResult;
    }
  }
  return sampleResult;
}

- (jdouble)adjustRangeWithDouble:(jdouble)startValResult {
  return GeogebraCommonKernelGeosGeoCurveCartesian_adjustRangeWithDouble_(self, startValResult);
}

- (id<GeogebraCommonKernelPathMover>)createPathMover {
  return [new_GeogebraCommonKernelPathMoverGeneric_initWithGeogebraCommonKernelPath_(self) autorelease];
}

- (jboolean)isClosedPath {
  return self->isClosedPath__;
}

- (jboolean)isNumberValue {
  return NO;
}

- (jboolean)isTraceable {
  return YES;
}

- (jboolean)getTrace {
  return self->trace_;
}

- (void)setTraceWithBoolean:(jboolean)trace {
  self->trace_ = trace;
}

- (void)evaluateCurveWithDouble:(jdouble)paramVal
                withDoubleArray:(IOSDoubleArray *)outArg {
  *IOSDoubleArray_GetRef(nil_chk(outArg), 0) = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:paramVal];
  *IOSDoubleArray_GetRef(outArg, 1) = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:paramVal];
}

- (GeogebraCommonKernelGeosGeoVec2D *)evaluateCurveWithDouble:(jdouble)t {
  return [new_GeogebraCommonKernelGeosGeoVec2D_initWithGeogebraCommonKernelKernel_withDouble_withDouble_(self->kernel_, [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:t], [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:t]) autorelease];
}

- (jdouble)evaluateCurvatureWithDouble:(jdouble)t {
  GeogebraCommonKernelArithmeticFunction *f1X, *f1Y, *f2X, *f2Y;
  f1X = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) getDerivativeWithInt:1 withBoolean:YES];
  f1Y = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) getDerivativeWithInt:1 withBoolean:YES];
  f2X = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) getDerivativeWithInt:2 withBoolean:YES];
  f2Y = [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) getDerivativeWithInt:2 withBoolean:YES];
  if (f1X == nil || f1Y == nil || f2X == nil || f2Y == nil) return JavaLangDouble_NaN;
  IOSDoubleArray *f1eval = [IOSDoubleArray arrayWithLength:2];
  IOSDoubleArray *f2eval = [IOSDoubleArray arrayWithLength:2];
  *IOSDoubleArray_GetRef(f1eval, 0) = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f1X)) evaluateWithDouble:t];
  *IOSDoubleArray_GetRef(f1eval, 1) = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f1Y)) evaluateWithDouble:t];
  *IOSDoubleArray_GetRef(f2eval, 0) = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f2X)) evaluateWithDouble:t];
  *IOSDoubleArray_GetRef(f2eval, 1) = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(f2Y)) evaluateWithDouble:t];
  jdouble t1 = JavaLangMath_sqrtWithDouble_(IOSDoubleArray_Get(f1eval, 0) * IOSDoubleArray_Get(f1eval, 0) + IOSDoubleArray_Get(f1eval, 1) * IOSDoubleArray_Get(f1eval, 1));
  jdouble t3 = t1 * t1 * t1;
  return (IOSDoubleArray_Get(f1eval, 0) * IOSDoubleArray_Get(f2eval, 1) - IOSDoubleArray_Get(f2eval, 0) * IOSDoubleArray_Get(f1eval, 1)) / t3;
}

- (jboolean)isCasEvaluableObject {
  return YES;
}

- (jboolean)isFunctionInX {
  return NO;
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  return NO;
}

- (jboolean)isFillable {
  return YES;
}

- (jboolean)isInverseFillable {
  return [self isFillable];
}

- (void)mirrorWithGeogebraCommonKernelGeosGeoConic:(GeogebraCommonKernelGeosGeoConic *)c {
  if ([((GeogebraCommonKernelGeosGeoConic *) nil_chk(c)) getType] == GeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE) {
    jdouble r = IOSDoubleArray_Get(nil_chk([c getHalfAxes]), 0);
    GeogebraCommonKernelGeosGeoVec2D *midpoint = [c getTranslationVector];
    jdouble a = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(midpoint)) getX];
    jdouble b = [midpoint getY];
    GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, -a, -b);
    GeogebraCommonKernelArithmeticExpressionNode *exprX = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_], [GeogebraCommonKernelArithmeticFunction class])))) getExpression];
    GeogebraCommonKernelArithmeticExpressionNode *exprY = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_], [GeogebraCommonKernelArithmeticFunction class])))) getExpression];
    GeogebraCommonKernelArithmeticMyDouble *d2 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, 2) autorelease];
    GeogebraCommonKernelArithmeticExpressionNode *sf = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, r * r) autorelease], GeogebraCommonPluginOperationEnum_get_DIVIDE(), [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exprX)) powerWithGeogebraCommonKernelArithmeticExpressionValue:d2])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exprY)) powerWithGeogebraCommonKernelArithmeticExpressionValue:d2]]) autorelease];
    GeogebraCommonKernelArithmeticExpressionNode *transX = [exprX multiplyWithGeogebraCommonKernelArithmeticExpressionValue:sf];
    GeogebraCommonKernelArithmeticExpressionNode *transY = [exprY multiplyWithGeogebraCommonKernelArithmeticExpressionValue:sf];
    [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:transX];
    [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:transY];
    GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(self, a, b);
  }
  else {
    [self setUndefined];
  }
}

- (jdouble)distanceWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *)p {
  jdouble t = [self getClosestParameterWithGeogebraCommonKernelKernelNDGeoPointND:p withDouble:0];
  return GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:t] - [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(p)) getX], [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:t] - [p getY]);
}

- (jdouble)distanceWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p {
  if (![((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(p)) isGeoElement3D]) {
    return [self distanceWithGeogebraCommonKernelGeosGeoPoint:(GeogebraCommonKernelGeosGeoPoint *) check_class_cast(p, [GeogebraCommonKernelGeosGeoPoint class])];
  }
  jdouble t = [self getClosestParameterWithGeogebraCommonKernelKernelNDGeoPointND:p withDouble:0];
  GeogebraCommonKernelMatrixCoords *coords = [p getInhomCoordsInD3];
  return GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_withDouble_([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:t] - [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX], [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:t] - [coords getY], [coords getZ]);
}

- (void)matrixTransformWithDouble:(jdouble)a00
                       withDouble:(jdouble)a01
                       withDouble:(jdouble)a02
                       withDouble:(jdouble)a10
                       withDouble:(jdouble)a11
                       withDouble:(jdouble)a12
                       withDouble:(jdouble)a20
                       withDouble:(jdouble)a21
                       withDouble:(jdouble)a22 {
  GeogebraCommonKernelArithmeticMyDouble *ma00 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a00) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *ma01 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a01) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *ma02 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a02) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *ma10 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a10) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *ma11 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a11) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *ma12 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a12) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *ma20 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a20) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *ma21 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a21) autorelease];
  GeogebraCommonKernelArithmeticMyDouble *ma22 = [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, a22) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *exprX = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_], [GeogebraCommonKernelArithmeticFunction class])))) getExpression];
  GeogebraCommonKernelArithmeticExpressionNode *exprY = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(((GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_], [GeogebraCommonKernelArithmeticFunction class])))) getExpression];
  GeogebraCommonKernelArithmeticExpressionNode *transX = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exprX)) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:ma00])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(exprY)) multiplyWithGeogebraCommonKernelArithmeticExpressionValue:ma01]])) plusWithGeogebraCommonKernelArithmeticExpressionValue:ma02];
  GeogebraCommonKernelArithmeticExpressionNode *transY = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([exprX multiplyWithGeogebraCommonKernelArithmeticExpressionValue:ma10])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[exprY multiplyWithGeogebraCommonKernelArithmeticExpressionValue:ma11]])) plusWithGeogebraCommonKernelArithmeticExpressionValue:ma12];
  GeogebraCommonKernelArithmeticExpressionNode *transZ = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([exprX multiplyWithGeogebraCommonKernelArithmeticExpressionValue:ma20])) plusWithGeogebraCommonKernelArithmeticExpressionValue:[exprY multiplyWithGeogebraCommonKernelArithmeticExpressionValue:ma21]])) plusWithGeogebraCommonKernelArithmeticExpressionValue:ma22];
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, transX, GeogebraCommonPluginOperationEnum_get_DIVIDE(), transZ) autorelease]];
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, transY, GeogebraCommonPluginOperationEnum_get_DIVIDE(), transZ) autorelease]];
}

- (void)setFromPolyLineWithGeogebraCommonKernelKernelNDGeoPointNDArray:(IOSObjectArray *)points
                                                           withBoolean:(jboolean)repeatLast {
  jdouble coef = 0, coefY = 0;
  jdouble cumulative = 0, cumulativeY = 0;
  GeogebraCommonKernelArithmeticExpressionNode *enx = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, [((GeogebraCommonKernelMatrixCoords *) nil_chk([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(nil_chk(points), 0))) getInhomCoordsInD2])) getX]) autorelease]) autorelease];
  GeogebraCommonKernelArithmeticExpressionNode *eny = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, [((GeogebraCommonKernelMatrixCoords *) nil_chk([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(points, 0))) getInhomCoordsInD2])) getY]) autorelease]) autorelease];
  GeogebraCommonKernelArithmeticFunctionVariable *fv = [new_GeogebraCommonKernelArithmeticFunctionVariable_initWithGeogebraCommonKernelKernel_withNSString_(self->kernel_, @"t") autorelease];
  jdouble sum = 0;
  jdouble sumY = 0;
  jint limit = repeatLast ? points->size_ + 1 : points->size_;
  jint nonzeroSegments = 0;
  for (jint i = 1; i < limit; i++) {
    jint pointIndex = i >= points->size_ ? 0 : i;
    GeogebraCommonKernelArithmeticExpressionNode *greater = [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, fv, GeogebraCommonPluginOperationEnum_get_MINUS(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, nonzeroSegments) autorelease]) autorelease], GeogebraCommonPluginOperationEnum_get_ABS(), nil) autorelease];
    GeogebraCommonKernelMatrixCoords *c1 = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(points, pointIndex))) getInhomCoordsInD2];
    GeogebraCommonKernelMatrixCoords *c2 = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(points, i - 1))) getInhomCoordsInD2];
    if ([((GeogebraCommonKernelMatrixCoords *) nil_chk(c1)) isEqualWithGeogebraCommonKernelMatrixCoords:c2]) continue;
    coef = 0.5 * [c1 getX] - 0.5 * [((GeogebraCommonKernelMatrixCoords *) nil_chk(c2)) getX] - cumulative;
    coefY = 0.5 * [c1 getY] - 0.5 * [c2 getY] - cumulativeY;
    sum += coef * nonzeroSegments;
    sumY += coefY * nonzeroSegments;
    nonzeroSegments++;
    cumulative += coef;
    cumulativeY += coefY;
    enx = [enx plusWithGeogebraCommonKernelArithmeticExpressionValue:[greater multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, coef) autorelease]]];
    eny = [eny plusWithGeogebraCommonKernelArithmeticExpressionValue:[greater multiplyWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, coefY) autorelease]]];
  }
  enx = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(enx)) plusWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, fv, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, cumulative) autorelease]) autorelease]];
  eny = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(eny)) plusWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(self->kernel_, fv, GeogebraCommonPluginOperationEnum_get_MULTIPLY(), [new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, cumulativeY) autorelease]) autorelease]];
  enx = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(enx)) plusWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, -sum) autorelease]];
  eny = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(eny)) plusWithGeogebraCommonKernelArithmeticExpressionValue:[new_GeogebraCommonKernelArithmeticMyDouble_initWithGeogebraCommonKernelKernel_withDouble_(self->kernel_, -sumY) autorelease]];
  GeogebraCommonKernelArithmeticFunction *xFun = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(enx, fv) autorelease];
  GeogebraCommonKernelArithmeticFunction *yFun = [new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticExpressionNode_withGeogebraCommonKernelArithmeticFunctionVariable_(eny, fv) autorelease];
  GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionYWithGeogebraCommonKernelArithmeticFunction_(self, yFun);
  GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionXWithGeogebraCommonKernelArithmeticFunction_(self, xFun);
  [self setIntervalWithDouble:0 withDouble:nonzeroSegments];
}

- (jboolean)isLaTeXDrawableGeo {
  return YES;
}

- (GeogebraCommonKernelArithmeticFunction *)getFunX {
  return [self getFunWithInt:0];
}

- (GeogebraCommonKernelArithmeticFunction *)getFunY {
  return [self getFunWithInt:1];
}

- (jboolean)hasDrawable3D {
  return YES;
}

- (IOSDoubleArray *)newDoubleArray {
  return [IOSDoubleArray arrayWithLength:2];
}

- (IOSDoubleArray *)getDefinedIntervalWithDouble:(jdouble)a
                                      withDouble:(jdouble)b {
  IOSDoubleArray *intervalX = GeogebraCommonKernelRootsRealRootUtil_getDefinedIntervalWithGeogebraCommonKernelRootsRealRootFunction_withDouble_withDouble_(GeogebraCommonKernelGeosGeoCurveCartesian_getRealRootFunctionX(self), a, b);
  IOSDoubleArray *intervalY = GeogebraCommonKernelRootsRealRootUtil_getDefinedIntervalWithGeogebraCommonKernelRootsRealRootFunction_withDouble_withDouble_(GeogebraCommonKernelGeosGeoCurveCartesian_getRealRootFunctionY(self), a, b);
  if (IOSDoubleArray_Get(nil_chk(intervalX), 0) < IOSDoubleArray_Get(nil_chk(intervalY), 0)) {
    *IOSDoubleArray_GetRef(intervalX, 0) = IOSDoubleArray_Get(intervalY, 0);
  }
  if (IOSDoubleArray_Get(intervalX, 1) > IOSDoubleArray_Get(intervalY, 1)) {
    *IOSDoubleArray_GetRef(intervalX, 1) = IOSDoubleArray_Get(intervalY, 1);
  }
  return intervalX;
}

- (jdouble)distanceMaxWithDoubleArray:(IOSDoubleArray *)p1
                      withDoubleArray:(IOSDoubleArray *)p2 {
  return JavaLangMath_maxWithDouble_withDouble_(JavaLangMath_absWithDouble_(IOSDoubleArray_Get(nil_chk(p1), 0) - IOSDoubleArray_Get(nil_chk(p2), 0)), JavaLangMath_absWithDouble_(IOSDoubleArray_Get(p1, 1) - IOSDoubleArray_Get(p2, 1)));
}

- (GeogebraCommonKernelKernelNDGeoCurveCartesianND *)newGeoCurveCartesianWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons {
  return [new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(cons) autorelease];
}

- (GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)getLastHitType {
  return GeogebraCommonKernelGeosGeoElement_HitTypeEnum_get_ON_BOUNDARY();
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:", "GeoCurveCartesian", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelArithmeticFunction:withGeogebraCommonKernelArithmeticFunction:", "GeoCurveCartesian", NULL, 0x1, NULL, NULL },
    { "translatedTypeString", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoCurveCartesian:", "GeoCurveCartesian", NULL, 0x1, NULL, NULL },
    { "copy__", "copy", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "setFunctionXWithGeogebraCommonKernelArithmeticFunction:", "setFunctionX", "V", 0x11, NULL, NULL },
    { "setFunctionYWithGeogebraCommonKernelArithmeticFunction:", "setFunctionY", "V", 0x11, NULL, NULL },
    { "replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:", "replaceChildrenByValues", "V", 0x1, NULL, NULL },
    { "setIntervalWithDouble:withDouble:", "setInterval", "V", 0x1, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "setParametricDerivativeWithGeogebraCommonKernelGeosGeoCurveCartesian:", "setParametricDerivative", "V", 0x1, NULL, NULL },
    { "getFunXWithGeogebraCommonKernelStringTemplate:", "getFunX", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "getFunYWithGeogebraCommonKernelStringTemplate:", "getFunY", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "getRealRootFunctionX", NULL, "Lgeogebra.common.kernel.roots.RealRootFunction;", 0x11, NULL, NULL },
    { "getRealRootFunctionY", NULL, "Lgeogebra.common.kernel.roots.RealRootFunction;", 0x11, NULL, NULL },
    { "translateWithGeogebraCommonKernelMatrixCoords:", "translate", "V", 0x11, NULL, NULL },
    { "isTranslateable", NULL, "Z", 0x11, NULL, NULL },
    { "isMatrixTransformable", NULL, "Z", 0x11, NULL, NULL },
    { "translateWithDouble:withDouble:", "translate", "V", 0x11, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelKernelNDGeoPointND:", "rotate", "V", 0x11, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelMatrixCoords:", "mirror", "V", 0x11, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelKernelNDGeoLineND:", "mirror", "V", 0x11, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:", "rotate", "V", 0x11, NULL, NULL },
    { "dilateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelMatrixCoords:", "dilate", "V", 0x1, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelArithmeticNumberValue:", "mirror", "V", 0x2, NULL, NULL },
    { "getPointsOnCurveWithInt:withDouble:withDouble:", "getPointsOnCurve", "Ljava.util.ArrayList;", 0x1, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "showInAlgebraView", NULL, "Z", 0x1, NULL, NULL },
    { "showInEuclidianView", NULL, "Z", 0x4, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toSymbolicStringWithGeogebraCommonKernelStringTemplate:", "toSymbolicString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChanged", "V", 0x1, NULL, NULL },
    { "isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "isOnPath", "Z", 0x1, NULL, NULL },
    { "pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pathChanged", "V", 0x1, NULL, NULL },
    { "pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:withBoolean:", "pathChanged", "V", 0x2, NULL, NULL },
    { "getClosestParameterWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "getClosestParameter", "D", 0x1, NULL, NULL },
    { "adjustRangeWithDouble:", "adjustRange", "D", 0x2, NULL, NULL },
    { "createPathMover", NULL, "Lgeogebra.common.kernel.PathMover;", 0x1, NULL, NULL },
    { "isClosedPath", NULL, "Z", 0x1, NULL, NULL },
    { "isNumberValue", NULL, "Z", 0x1, NULL, NULL },
    { "isTraceable", NULL, "Z", 0x11, NULL, NULL },
    { "getTrace", NULL, "Z", 0x11, NULL, NULL },
    { "setTraceWithBoolean:", "setTrace", "V", 0x1, NULL, NULL },
    { "evaluateCurveWithDouble:withDoubleArray:", "evaluateCurve", "V", 0x1, NULL, NULL },
    { "evaluateCurveWithDouble:", "evaluateCurve", "Lgeogebra.common.kernel.geos.GeoVec2D;", 0x1, NULL, NULL },
    { "evaluateCurvatureWithDouble:", "evaluateCurvature", "D", 0x1, NULL, NULL },
    { "isCasEvaluableObject", NULL, "Z", 0x1, NULL, NULL },
    { "isFunctionInX", NULL, "Z", 0x11, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x11, NULL, NULL },
    { "isFillable", NULL, "Z", 0x1, NULL, NULL },
    { "isInverseFillable", NULL, "Z", 0x1, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelGeosGeoConic:", "mirror", "V", 0x11, NULL, NULL },
    { "distanceWithGeogebraCommonKernelGeosGeoPoint:", "distance", "D", 0x1, NULL, NULL },
    { "distanceWithGeogebraCommonKernelKernelNDGeoPointND:", "distance", "D", 0x1, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "setFromPolyLineWithGeogebraCommonKernelKernelNDGeoPointNDArray:withBoolean:", "setFromPolyLine", "V", 0x1, NULL, NULL },
    { "isLaTeXDrawableGeo", NULL, "Z", 0x1, NULL, NULL },
    { "getFunX", NULL, "Lgeogebra.common.kernel.arithmetic.Function;", 0x1, NULL, NULL },
    { "getFunY", NULL, "Lgeogebra.common.kernel.arithmetic.Function;", 0x1, NULL, NULL },
    { "hasDrawable3D", NULL, "Z", 0x1, NULL, NULL },
    { "newDoubleArray", NULL, "[D", 0x1, NULL, NULL },
    { "getDefinedIntervalWithDouble:withDouble:", "getDefinedInterval", "[D", 0x1, NULL, NULL },
    { "distanceMaxWithDoubleArray:withDoubleArray:", "distanceMax", "D", 0x1, NULL, NULL },
    { "newGeoCurveCartesianWithGeogebraCommonKernelConstruction:", "newGeoCurveCartesian", "Lgeogebra.common.kernel.kernelND.GeoCurveCartesianND;", 0x4, NULL, NULL },
    { "getLastHitType", NULL, "Lgeogebra.common.kernel.geos.GeoElement$HitType;", 0x11, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "isClosedPath__", "isClosedPath", 0x2, "Z", NULL, NULL,  },
    { "trace_", NULL, 0x2, "Z", NULL, NULL,  },
    { "CURVATURE_COLOR_", NULL, 0x0, "D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoCurveCartesian = { 2, "GeoCurveCartesian", "geogebra.common.kernel.geos", NULL, 0x1, 67, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoCurveCartesian;
}

@end

void GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelGeosGeoCurveCartesian *self, GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_initWithGeogebraCommonKernelConstruction_withInt_(self, c, 2);
  self->trace_ = NO;
  self->CURVATURE_COLOR_ = 15;
}

GeogebraCommonKernelGeosGeoCurveCartesian *new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoCurveCartesian *self = [GeogebraCommonKernelGeosGeoCurveCartesian alloc];
  GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

void GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelGeosGeoCurveCartesian *self, GeogebraCommonKernelConstruction *c, GeogebraCommonKernelArithmeticFunction *fx, GeogebraCommonKernelArithmeticFunction *fy) {
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_initWithGeogebraCommonKernelConstruction_withInt_(self, c, 2);
  self->trace_ = NO;
  self->CURVATURE_COLOR_ = 15;
  GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionXWithGeogebraCommonKernelArithmeticFunction_(self, fx);
  GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionYWithGeogebraCommonKernelArithmeticFunction_(self, fy);
}

GeogebraCommonKernelGeosGeoCurveCartesian *new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelConstruction *c, GeogebraCommonKernelArithmeticFunction *fx, GeogebraCommonKernelArithmeticFunction *fy) {
  GeogebraCommonKernelGeosGeoCurveCartesian *self = [GeogebraCommonKernelGeosGeoCurveCartesian alloc];
  GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelArithmeticFunction_(self, c, fx, fy);
  return self;
}

void GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelGeosGeoCurveCartesian_(GeogebraCommonKernelGeosGeoCurveCartesian *self, GeogebraCommonKernelGeosGeoCurveCartesian *f) {
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_initWithGeogebraCommonKernelConstruction_withInt_(self, ((GeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(f))->cons_, 2);
  self->trace_ = NO;
  self->CURVATURE_COLOR_ = 15;
  [self setWithGeogebraCommonKernelGeosGeoElement:f];
}

GeogebraCommonKernelGeosGeoCurveCartesian *new_GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelGeosGeoCurveCartesian_(GeogebraCommonKernelGeosGeoCurveCartesian *f) {
  GeogebraCommonKernelGeosGeoCurveCartesian *self = [GeogebraCommonKernelGeosGeoCurveCartesian alloc];
  GeogebraCommonKernelGeosGeoCurveCartesian_initWithGeogebraCommonKernelGeosGeoCurveCartesian_(self, f);
  return self;
}

void GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionXWithGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelGeosGeoCurveCartesian *self, GeogebraCommonKernelArithmeticFunction *funX) {
  [self setFunWithInt:0 withGeogebraCommonKernelArithmeticFunction:funX];
}

void GeogebraCommonKernelGeosGeoCurveCartesian_setFunctionYWithGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelGeosGeoCurveCartesian *self, GeogebraCommonKernelArithmeticFunction *funY) {
  [self setFunWithInt:1 withGeogebraCommonKernelArithmeticFunction:funY];
}

id<GeogebraCommonKernelRootsRealRootFunction> GeogebraCommonKernelGeosGeoCurveCartesian_getRealRootFunctionX(GeogebraCommonKernelGeosGeoCurveCartesian *self) {
  return [self getFunWithInt:0];
}

id<GeogebraCommonKernelRootsRealRootFunction> GeogebraCommonKernelGeosGeoCurveCartesian_getRealRootFunctionY(GeogebraCommonKernelGeosGeoCurveCartesian *self) {
  return [self getFunWithInt:1];
}

void GeogebraCommonKernelGeosGeoCurveCartesian_translateWithDouble_withDouble_(GeogebraCommonKernelGeosGeoCurveCartesian *self, jdouble vx, jdouble vy) {
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) translateYWithDouble:vx];
  [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) translateYWithDouble:vy];
}

void GeogebraCommonKernelGeosGeoCurveCartesian_rotateWithGeogebraCommonKernelArithmeticNumberValue_(GeogebraCommonKernelGeosGeoCurveCartesian *self, id<GeogebraCommonKernelArithmeticNumberValue> phi) {
  jdouble cosPhi = JavaLangMath_cosWithDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(phi)) getDouble]);
  jdouble sinPhi = JavaLangMath_sinWithDouble_([phi getDouble]);
  [self matrixTransformWithDouble:cosPhi withDouble:-sinPhi withDouble:sinPhi withDouble:cosPhi];
}

void GeogebraCommonKernelGeosGeoCurveCartesian_mirrorWithGeogebraCommonKernelArithmeticNumberValue_(GeogebraCommonKernelGeosGeoCurveCartesian *self, id<GeogebraCommonKernelArithmeticNumberValue> phi) {
  jdouble cosPhi = JavaLangMath_cosWithDouble_([((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(phi)) getDouble]);
  jdouble sinPhi = JavaLangMath_sinWithDouble_([phi getDouble]);
  [self matrixTransformWithDouble:cosPhi withDouble:sinPhi withDouble:sinPhi withDouble:-cosPhi];
}

void GeogebraCommonKernelGeosGeoCurveCartesian_pathChangedWithGeogebraCommonKernelKernelNDGeoPointND_withBoolean_(GeogebraCommonKernelGeosGeoCurveCartesian *self, id<GeogebraCommonKernelKernelNDGeoPointND> P, jboolean changePoint) {
  if (changePoint) {
    [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
    return;
  }
  GeogebraCommonKernelPathParameter *pp = [((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(P)) getPathParameter];
  if (((GeogebraCommonKernelPathParameter *) nil_chk(pp))->t_ < self->startParam_) pp->t_ = self->startParam_;
  else if (pp->t_ > self->endParam_) pp->t_ = self->endParam_;
  [P setCoords2DWithDouble:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) evaluateWithDouble:pp->t_] withDouble:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:1])) evaluateWithDouble:pp->t_] withDouble:1];
  [P updateCoordsFrom2DWithBoolean:NO withGeogebraCommonKernelMatrixCoordSys:nil];
}

jdouble GeogebraCommonKernelGeosGeoCurveCartesian_adjustRangeWithDouble_(GeogebraCommonKernelGeosGeoCurveCartesian *self, jdouble startValResult) {
  if (startValResult < self->startParam_) {
    return startValResult + (self->endParam_ - self->startParam_);
  }
  if (startValResult > self->endParam_) {
    return startValResult - (self->endParam_ - self->startParam_);
  }
  return startValResult;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoCurveCartesian)
