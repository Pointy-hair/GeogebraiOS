//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/org/apache/commons/math/estimation/GaussNewtonEstimator.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Deprecated.h"
#include "java/lang/Double.h"
#include "org/apache/commons/math/estimation/AbstractEstimator.h"
#include "org/apache/commons/math/estimation/EstimatedParameter.h"
#include "org/apache/commons/math/estimation/EstimationException.h"
#include "org/apache/commons/math/estimation/EstimationProblem.h"
#include "org/apache/commons/math/estimation/GaussNewtonEstimator.h"
#include "org/apache/commons/math/estimation/WeightedMeasurement.h"
#include "org/apache/commons/math/exception/util/LocalizedFormats.h"
#include "org/apache/commons/math/linear/ArrayRealVector.h"
#include "org/apache/commons/math/linear/DecompositionSolver.h"
#include "org/apache/commons/math/linear/InvalidMatrixException.h"
#include "org/apache/commons/math/linear/LUDecompositionImpl.h"
#include "org/apache/commons/math/linear/MatrixUtils.h"
#include "org/apache/commons/math/linear/RealMatrix.h"
#include "org/apache/commons/math/linear/RealVector.h"
#include "org/apache/commons/math/util/FastMath.h"

#define OrgApacheCommonsMathEstimationGaussNewtonEstimator_serialVersionUID 5485001826076289109LL
#define OrgApacheCommonsMathEstimationGaussNewtonEstimator_DEFAULT_STEADY_STATE_THRESHOLD 1.0E-6
#define OrgApacheCommonsMathEstimationGaussNewtonEstimator_DEFAULT_CONVERGENCE 1.0E-6

@interface OrgApacheCommonsMathEstimationGaussNewtonEstimator () {
 @public
  jdouble steadyStateThreshold_;
  jdouble convergence_;
}

@end

J2OBJC_STATIC_FIELD_GETTER(OrgApacheCommonsMathEstimationGaussNewtonEstimator, serialVersionUID, jlong)

J2OBJC_STATIC_FIELD_GETTER(OrgApacheCommonsMathEstimationGaussNewtonEstimator, DEFAULT_STEADY_STATE_THRESHOLD, jdouble)

J2OBJC_STATIC_FIELD_GETTER(OrgApacheCommonsMathEstimationGaussNewtonEstimator, DEFAULT_CONVERGENCE, jdouble)

@implementation OrgApacheCommonsMathEstimationGaussNewtonEstimator

- (instancetype)init {
  OrgApacheCommonsMathEstimationGaussNewtonEstimator_init(self);
  return self;
}

- (instancetype)initWithInt:(jint)maxCostEval
                 withDouble:(jdouble)convergence
                 withDouble:(jdouble)steadyStateThreshold {
  OrgApacheCommonsMathEstimationGaussNewtonEstimator_initWithInt_withDouble_withDouble_(self, maxCostEval, convergence, steadyStateThreshold);
  return self;
}

- (void)setConvergenceWithDouble:(jdouble)convergence {
  self->convergence_ = convergence;
}

- (void)setSteadyStateThresholdWithDouble:(jdouble)steadyStateThreshold {
  self->steadyStateThreshold_ = steadyStateThreshold;
}

- (void)estimateWithOrgApacheCommonsMathEstimationEstimationProblem:(id<OrgApacheCommonsMathEstimationEstimationProblem>)problem {
  [self initializeEstimateWithOrgApacheCommonsMathEstimationEstimationProblem:problem];
  IOSDoubleArray *grad = [IOSDoubleArray arrayWithLength:((IOSObjectArray *) nil_chk(parameters_))->size_];
  OrgApacheCommonsMathLinearArrayRealVector *bDecrement = [new_OrgApacheCommonsMathLinearArrayRealVector_initWithInt_(parameters_->size_) autorelease];
  IOSDoubleArray *bDecrementData = [bDecrement getDataRef];
  id<OrgApacheCommonsMathLinearRealMatrix> wGradGradT = OrgApacheCommonsMathLinearMatrixUtils_createRealMatrixWithInt_withInt_(parameters_->size_, parameters_->size_);
  jdouble previous = JavaLangDouble_POSITIVE_INFINITY;
  do {
    [self incrementJacobianEvaluationsCounter];
    id<OrgApacheCommonsMathLinearRealVector> b = [new_OrgApacheCommonsMathLinearArrayRealVector_initWithInt_(parameters_->size_) autorelease];
    id<OrgApacheCommonsMathLinearRealMatrix> a = OrgApacheCommonsMathLinearMatrixUtils_createRealMatrixWithInt_withInt_(parameters_->size_, parameters_->size_);
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(measurements_))->size_; ++i) {
      if (![((OrgApacheCommonsMathEstimationWeightedMeasurement *) nil_chk(IOSObjectArray_Get(measurements_, i))) isIgnored]) {
        jdouble weight = [((OrgApacheCommonsMathEstimationWeightedMeasurement *) nil_chk(IOSObjectArray_Get(measurements_, i))) getWeight];
        jdouble residual = [((OrgApacheCommonsMathEstimationWeightedMeasurement *) nil_chk(IOSObjectArray_Get(measurements_, i))) getResidual];
        for (jint j = 0; j < parameters_->size_; ++j) {
          *IOSDoubleArray_GetRef(grad, j) = [((OrgApacheCommonsMathEstimationWeightedMeasurement *) nil_chk(IOSObjectArray_Get(measurements_, i))) getPartialWithOrgApacheCommonsMathEstimationEstimatedParameter:IOSObjectArray_Get(parameters_, j)];
          *IOSDoubleArray_GetRef(nil_chk(bDecrementData), j) = weight * residual * IOSDoubleArray_Get(grad, j);
        }
        for (jint k = 0; k < parameters_->size_; ++k) {
          jdouble gk = IOSDoubleArray_Get(grad, k);
          for (jint l = 0; l < parameters_->size_; ++l) {
            [((id<OrgApacheCommonsMathLinearRealMatrix>) nil_chk(wGradGradT)) setEntryWithInt:k withInt:l withDouble:weight * gk * IOSDoubleArray_Get(grad, l)];
          }
        }
        a = [((id<OrgApacheCommonsMathLinearRealMatrix>) nil_chk(a)) addWithOrgApacheCommonsMathLinearRealMatrix:wGradGradT];
        b = [b addWithOrgApacheCommonsMathLinearRealVector:bDecrement];
      }
    }
    @try {
      id<OrgApacheCommonsMathLinearRealVector> dX = [((id<OrgApacheCommonsMathLinearDecompositionSolver>) nil_chk([((OrgApacheCommonsMathLinearLUDecompositionImpl *) [new_OrgApacheCommonsMathLinearLUDecompositionImpl_initWithOrgApacheCommonsMathLinearRealMatrix_(a) autorelease]) getSolver])) solveWithOrgApacheCommonsMathLinearRealVector:b];
      for (jint i = 0; i < parameters_->size_; ++i) {
        [((OrgApacheCommonsMathEstimationEstimatedParameter *) nil_chk(IOSObjectArray_Get(parameters_, i))) setEstimateWithDouble:[((OrgApacheCommonsMathEstimationEstimatedParameter *) nil_chk(IOSObjectArray_Get(parameters_, i))) getEstimate] + [((id<OrgApacheCommonsMathLinearRealVector>) nil_chk(dX)) getEntryWithInt:i]];
      }
    }
    @catch (OrgApacheCommonsMathLinearInvalidMatrixException *e) {
      @throw [new_OrgApacheCommonsMathEstimationEstimationException_initWithOrgApacheCommonsMathExceptionUtilLocalizable_withNSObjectArray_(OrgApacheCommonsMathExceptionUtilLocalizedFormatsEnum_get_UNABLE_TO_SOLVE_SINGULAR_PROBLEM(), [IOSObjectArray arrayWithLength:0 type:NSObject_class_()]) autorelease];
    }
    previous = cost_;
    [self updateResidualsAndCost];
  }
  while (([self getCostEvaluations] < 2) || (OrgApacheCommonsMathUtilFastMath_absWithDouble_(previous - cost_) > (cost_ * steadyStateThreshold_) && (OrgApacheCommonsMathUtilFastMath_absWithDouble_(cost_) > convergence_)));
}

+ (IOSObjectArray *)__annotations {
  return [IOSObjectArray arrayWithObjects:(id[]) { [[[JavaLangDeprecated alloc] init] autorelease] } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "GaussNewtonEstimator", NULL, 0x1, NULL, NULL },
    { "initWithInt:withDouble:withDouble:", "GaussNewtonEstimator", NULL, 0x1, NULL, NULL },
    { "setConvergenceWithDouble:", "setConvergence", "V", 0x1, NULL, NULL },
    { "setSteadyStateThresholdWithDouble:", "setSteadyStateThreshold", "V", 0x1, NULL, NULL },
    { "estimateWithOrgApacheCommonsMathEstimationEstimationProblem:", "estimate", "V", 0x1, "Lorg.apache.commons.math.estimation.EstimationException;", NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID_", NULL, 0x1a, "J", NULL, NULL, .constantValue.asLong = OrgApacheCommonsMathEstimationGaussNewtonEstimator_serialVersionUID },
    { "DEFAULT_STEADY_STATE_THRESHOLD_", NULL, 0x1a, "D", NULL, NULL, .constantValue.asDouble = OrgApacheCommonsMathEstimationGaussNewtonEstimator_DEFAULT_STEADY_STATE_THRESHOLD },
    { "DEFAULT_CONVERGENCE_", NULL, 0x1a, "D", NULL, NULL, .constantValue.asDouble = OrgApacheCommonsMathEstimationGaussNewtonEstimator_DEFAULT_CONVERGENCE },
    { "steadyStateThreshold_", NULL, 0x2, "D", NULL, NULL,  },
    { "convergence_", NULL, 0x2, "D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _OrgApacheCommonsMathEstimationGaussNewtonEstimator = { 2, "GaussNewtonEstimator", "org.apache.commons.math.estimation", NULL, 0x1, 5, methods, 5, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgApacheCommonsMathEstimationGaussNewtonEstimator;
}

@end

void OrgApacheCommonsMathEstimationGaussNewtonEstimator_init(OrgApacheCommonsMathEstimationGaussNewtonEstimator *self) {
  OrgApacheCommonsMathEstimationAbstractEstimator_init(self);
  self->steadyStateThreshold_ = OrgApacheCommonsMathEstimationGaussNewtonEstimator_DEFAULT_STEADY_STATE_THRESHOLD;
  self->convergence_ = OrgApacheCommonsMathEstimationGaussNewtonEstimator_DEFAULT_CONVERGENCE;
}

OrgApacheCommonsMathEstimationGaussNewtonEstimator *new_OrgApacheCommonsMathEstimationGaussNewtonEstimator_init() {
  OrgApacheCommonsMathEstimationGaussNewtonEstimator *self = [OrgApacheCommonsMathEstimationGaussNewtonEstimator alloc];
  OrgApacheCommonsMathEstimationGaussNewtonEstimator_init(self);
  return self;
}

void OrgApacheCommonsMathEstimationGaussNewtonEstimator_initWithInt_withDouble_withDouble_(OrgApacheCommonsMathEstimationGaussNewtonEstimator *self, jint maxCostEval, jdouble convergence, jdouble steadyStateThreshold) {
  OrgApacheCommonsMathEstimationAbstractEstimator_init(self);
  [self setMaxCostEvalWithInt:maxCostEval];
  self->steadyStateThreshold_ = steadyStateThreshold;
  self->convergence_ = convergence;
}

OrgApacheCommonsMathEstimationGaussNewtonEstimator *new_OrgApacheCommonsMathEstimationGaussNewtonEstimator_initWithInt_withDouble_withDouble_(jint maxCostEval, jdouble convergence, jdouble steadyStateThreshold) {
  OrgApacheCommonsMathEstimationGaussNewtonEstimator *self = [OrgApacheCommonsMathEstimationGaussNewtonEstimator alloc];
  OrgApacheCommonsMathEstimationGaussNewtonEstimator_initWithInt_withDouble_withDouble_(self, maxCostEval, convergence, steadyStateThreshold);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheCommonsMathEstimationGaussNewtonEstimator)
