//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/geos/GeoVector.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/CircularDefinitionException.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/LocateableList.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/PathMover.h"
#include "geogebra/common/kernel/PathMoverGeneric.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoDependentVector.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/algos/DependentAlgo.h"
#include "geogebra/common/kernel/algos/SymbolicParameters.h"
#include "geogebra/common/kernel/algos/SymbolicParametersAlgo.h"
#include "geogebra/common/kernel/algos/SymbolicParametersBotanaAlgo.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNodeConstants.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/MyStringBuffer.h"
#include "geogebra/common/kernel/arithmetic/MyVecNode.h"
#include "geogebra/common/kernel/arithmetic/NumberValue.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoLine.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/geos/GeoPoint.h"
#include "geogebra/common/kernel/geos/GeoSegment.h"
#include "geogebra/common/kernel/geos/GeoText.h"
#include "geogebra/common/kernel/geos/GeoVec2D.h"
#include "geogebra/common/kernel/geos/GeoVec3D.h"
#include "geogebra/common/kernel/geos/GeoVector.h"
#include "geogebra/common/kernel/kernelND/GeoLineND.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/kernel/kernelND/GeoVectorND.h"
#include "geogebra/common/kernel/prover/NoSymbolicParametersException.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/util/MyMath.h"
#include "geogebra/common/util/Unicode.h"
#include "java/lang/Double.h"
#include "java/lang/Exception.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"

@interface GeogebraCommonKernelGeosGeoVector () {
 @public
  id<GeogebraCommonKernelKernelNDGeoPointND> startPoint_;
  GeogebraCommonKernelGeosGeoSegment *pathSegment_;
  GeogebraCommonKernelGeosGeoPoint *pathStartPoint_, *pathEndPoint_;
  jboolean waitingForStartPoint_;
  JavaUtilHashSet *waitingPointSet_;
  JavaLangStringBuilder *sbToString_GeoVector_;
  JavaLangStringBuilder *sbBuildValueString_;
  JavaLangStringBuilder *sb_;
}

- (JavaLangStringBuilder *)buildValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl;

- (void)initPathSegment OBJC_METHOD_FAMILY_NONE;

- (void)updatePathSegment;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoVector, startPoint_, id<GeogebraCommonKernelKernelNDGeoPointND>)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoVector, pathSegment_, GeogebraCommonKernelGeosGeoSegment *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoVector, pathStartPoint_, GeogebraCommonKernelGeosGeoPoint *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoVector, pathEndPoint_, GeogebraCommonKernelGeosGeoPoint *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoVector, waitingPointSet_, JavaUtilHashSet *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoVector, sbToString_GeoVector_, JavaLangStringBuilder *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoVector, sbBuildValueString_, JavaLangStringBuilder *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoVector, sb_, JavaLangStringBuilder *)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(GeogebraCommonKernelGeosGeoVector *self, jdouble x, jdouble y, jdouble z);

__attribute__((unused)) static GeogebraCommonKernelGeosGeoVec2D *GeogebraCommonKernelGeosGeoVector_getInhomVec(GeogebraCommonKernelGeosGeoVector *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoVector_isFinite(GeogebraCommonKernelGeosGeoVector *self);

__attribute__((unused)) static jboolean GeogebraCommonKernelGeosGeoVector_isInfinite(GeogebraCommonKernelGeosGeoVector *self);

__attribute__((unused)) static JavaLangStringBuilder *GeogebraCommonKernelGeosGeoVector_buildValueStringWithGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelGeosGeoVector *self, GeogebraCommonKernelStringTemplate *tpl);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoVector_initPathSegment(GeogebraCommonKernelGeosGeoVector *self);

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoVector_updatePathSegment(GeogebraCommonKernelGeosGeoVector *self);

@implementation GeogebraCommonKernelGeosGeoVector

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c {
  GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_VECTOR();
}

- (jboolean)isCasEvaluableObject {
  return YES;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                                            withNSString:(NSString *)label
                                              withDouble:(jdouble)x
                                              withDouble:(jdouble)y
                                              withDouble:(jdouble)z {
  GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_withNSString_withDouble_withDouble_withDouble_(self, c, label, x, y, z);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoVector:(GeogebraCommonKernelGeosGeoVector *)vector {
  GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelGeosGeoVector_(self, vector);
  return self;
}

- (void)setCoordsWithDouble:(jdouble)x
                 withDouble:(jdouble)y
                 withDouble:(jdouble)z {
  GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(self, x, y, z);
}

- (void)setCoordsWithDoubleArray:(IOSDoubleArray *)c {
  GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(self, IOSDoubleArray_Get(nil_chk(c), 0), IOSDoubleArray_Get(c, 1), IOSDoubleArray_Get(c, 2));
}

- (void)setCoordsWithGeogebraCommonKernelGeosGeoVec3D:(GeogebraCommonKernelGeosGeoVec3D *)v {
  x_ = ((GeogebraCommonKernelGeosGeoVec3D *) nil_chk(v))->x_;
  y_ = v->y_;
  z_ = v->z_;
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if ([((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoPoint]) {
    GeogebraCommonKernelGeosGeoPoint *p = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoPoint class]);
    GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(self, [p getX] / [p getZ], [p getY] / [p getZ], 0.0);
  }
  else {
    [super setWithGeogebraCommonKernelGeosGeoElement:geo];
  }
  if (![geo isGeoVector]) return;
  GeogebraCommonKernelGeosGeoVector *vec = (GeogebraCommonKernelGeosGeoVector *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoVector class]);
  if (geo->cons_ != cons_ && [self isAlgoMacroOutput]) return;
  @try {
    if (vec->startPoint_ != nil) {
      if ([vec hasAbsoluteLocation]) {
        [self setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:[vec->startPoint_ copy__]];
      }
      else {
        [self setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:vec->startPoint_];
      }
    }
  }
  @catch (GeogebraCommonKernelCircularDefinitionException *e) {
    GeogebraCommonMainApp_debugWithNSString_(@"set GeoVector: CircularDefinitionException");
  }
}

- (GeogebraCommonKernelGeosGeoElement *)copy__ {
  return [new_GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelGeosGeoVector_(self) autorelease];
}

- (void)setPolarCoordsWithDouble:(jdouble)r
                      withDouble:(jdouble)phi {
  x_ = r * JavaLangMath_cosWithDouble_(phi);
  y_ = r * JavaLangMath_sinWithDouble_(phi);
  z_ = 0.0;
}

- (void)setCoordsWithGeogebraCommonKernelGeosGeoVec2D:(GeogebraCommonKernelGeosGeoVec2D *)v {
  x_ = [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(v)) getX];
  y_ = [v getY];
  z_ = 0.0;
}

- (GeogebraCommonKernelGeosGeoVec2D *)getInhomVec {
  return GeogebraCommonKernelGeosGeoVector_getInhomVec(self);
}

- (id<GeogebraCommonKernelKernelNDGeoPointND>)getStartPoint {
  return startPoint_;
}

- (IOSObjectArray *)getStartPoints {
  if (startPoint_ == nil) return nil;
  IOSObjectArray *ret = [IOSObjectArray arrayWithLength:1 type:GeogebraCommonKernelKernelNDGeoPointND_class_()];
  IOSObjectArray_Set(ret, 0, startPoint_);
  return ret;
}

- (jboolean)hasAbsoluteLocation {
  return startPoint_ == nil || [startPoint_ isAbsoluteStartPoint];
}

- (void)setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p
                                                        withInt:(jint)number {
  [self setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:p];
}

- (void)initStartPointWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p
                                                         withInt:(jint)number {
  GeogebraCommonKernelGeosGeoVector_set_startPoint_(self, p);
}

- (void)removeStartPointWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p {
  if (startPoint_ == p) {
    @try {
      [self setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:nil];
    }
    @catch (JavaLangException *e) {
    }
  }
}

- (void)setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)p {
  if (startPoint_ == p) return;
  if ([self isAlgoMacroOutput]) return;
  if ([self isParentOfWithGeogebraCommonKernelKernelNDGeoElementND:p]) {
    GeogebraCommonMainApp_debugWithNSString_(JreStrcat("@$@", self, @" startpoint ", p));
  }
  if (startPoint_ != nil) [((GeogebraCommonKernelLocateableList *) nil_chk([startPoint_ getLocateableList])) unregisterLocateableWithGeogebraCommonKernelLocateable:self];
  GeogebraCommonKernelGeosGeoVector_set_startPoint_(self, p);
  if (startPoint_ != nil) [((GeogebraCommonKernelLocateableList *) nil_chk([startPoint_ getLocateableList])) registerLocateableWithGeogebraCommonKernelLocateable:self];
  if (pathSegment_ != nil) {
    GeogebraCommonKernelGeosGeoVector_initPathSegment(self);
  }
  if (waitingForStartPoint_) {
    waitingForStartPoint_ = NO;
    if (waitingPointSet_ != nil) {
      GeogebraCommonKernelGeosGeoVector_updatePathSegment(self);
      GeogebraCommonKernelGeosGeoPoint *P;
      id<JavaUtilIterator> it = [waitingPointSet_ iterator];
      while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
        P = (GeogebraCommonKernelGeosGeoPoint *) check_class_cast([it next], [GeogebraCommonKernelGeosGeoPoint class]);
        [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(pathSegment_)) pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
        [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(P)) updateCoords];
      }
    }
    GeogebraCommonKernelGeosGeoVector_set_waitingPointSet_(self, nil);
  }
}

- (void)setWaitForStartPoint {
  waitingForStartPoint_ = YES;
}

- (void)doRemove {
  [super doRemove];
  if (startPoint_ != nil) [((GeogebraCommonKernelLocateableList *) nil_chk([startPoint_ getLocateableList])) unregisterLocateableWithGeogebraCommonKernelLocateable:self];
}

- (jboolean)isFinite {
  return GeogebraCommonKernelGeosGeoVector_isFinite(self);
}

- (jboolean)isInfinite {
  return GeogebraCommonKernelGeosGeoVector_isInfinite(self);
}

- (jboolean)showInEuclidianView {
  return [self isDefined] && !GeogebraCommonKernelGeosGeoVector_isInfinite(self);
}

- (jboolean)showInAlgebraView {
  return YES;
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (![((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isGeoVector]) return NO;
  GeogebraCommonKernelGeosGeoVector *v = (GeogebraCommonKernelGeosGeoVector *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoVector class]);
  if (!(GeogebraCommonKernelGeosGeoVector_isFinite(self) && GeogebraCommonKernelGeosGeoVector_isFinite(v))) return NO;
  return GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(x_, v->x_) && GeogebraCommonKernelKernel_isEqualWithDouble_withDouble_(y_, v->y_);
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)phi {
  [self rotateXYWithGeogebraCommonKernelArithmeticNumberValue:phi];
}

- (void)translateWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)v {
}

- (void)rotateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)r
                 withGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)S {
  [self rotateXYWithGeogebraCommonKernelArithmeticNumberValue:r];
}

- (void)mirrorWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)Q {
  GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(self, -x_, -y_, z_);
}

- (void)mirrorWithGeogebraCommonKernelKernelNDGeoLineND:(id<GeogebraCommonKernelKernelNDGeoLineND>)g1 {
  GeogebraCommonKernelGeosGeoLine *g = (GeogebraCommonKernelGeosGeoLine *) check_class_cast(g1, [GeogebraCommonKernelGeosGeoLine class]);
  [self mirrorXYWithDouble:2.0 * JavaLangMath_atan2WithDouble_withDouble_(-[((GeogebraCommonKernelGeosGeoLine *) nil_chk(g)) getX], [g getY])];
}

- (void)dilateWithGeogebraCommonKernelArithmeticNumberValue:(id<GeogebraCommonKernelArithmeticNumberValue>)rval
                       withGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)S {
  jdouble r = [((id<GeogebraCommonKernelArithmeticNumberValue>) nil_chk(rval)) getDouble];
  GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(self, r * x_, r * y_, z_);
}

- (void)matrixTransformWithDouble:(jdouble)a
                       withDouble:(jdouble)b
                       withDouble:(jdouble)c
                       withDouble:(jdouble)d {
  JavaLangDouble *x1 = JavaLangDouble_valueOfWithDouble_(a * x_ + b * y_);
  JavaLangDouble *y1 = JavaLangDouble_valueOfWithDouble_(c * x_ + d * y_);
  GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(self, [x1 doubleValue], [y1 doubleValue], z_);
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  [((JavaLangStringBuilder *) nil_chk(sbToString_GeoVector_)) setLengthWithInt:0];
  [sbToString_GeoVector_ appendWithNSString:label_];
  switch ([((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getCoordStyleWithInt:[((GeogebraCommonKernelKernel *) nil_chk(kernel_)) getCoordStyle]]) {
    case GeogebraCommonKernelKernel_COORD_STYLE_FRENCH:
    [sbToString_GeoVector_ appendWithNSString:@": "];
    case GeogebraCommonKernelKernel_COORD_STYLE_AUSTRIAN:
    break;
    default:
    [sbToString_GeoVector_ appendWithNSString:@" = "];
  }
  NSString *str = [((JavaLangStringBuilder *) nil_chk(GeogebraCommonKernelGeosGeoVector_buildValueStringWithGeogebraCommonKernelStringTemplate_(self, tpl))) description];
  [sbToString_GeoVector_ appendWithNSString:str];
  return [sbToString_GeoVector_ description];
}

- (NSString *)toStringMinimalWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  [((JavaLangStringBuilder *) nil_chk(sbToString_GeoVector_)) setLengthWithInt:0];
  [sbToString_GeoVector_ appendWithNSString:JreStrcat("$C$", [self regrFormatWithDouble:x_], ' ', [self regrFormatWithDouble:y_])];
  return [sbToString_GeoVector_ description];
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [((JavaLangStringBuilder *) nil_chk(GeogebraCommonKernelGeosGeoVector_buildValueStringWithGeogebraCommonKernelStringTemplate_(self, tpl))) description];
}

- (JavaLangStringBuilder *)buildValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return GeogebraCommonKernelGeosGeoVector_buildValueStringWithGeogebraCommonKernelStringTemplate_(self, tpl);
}

- (GeogebraCommonKernelGeosGeoVec2D *)getVector {
  GeogebraCommonKernelGeosGeoVec2D *ret = [new_GeogebraCommonKernelGeosGeoVec2D_initWithGeogebraCommonKernelKernel_withDouble_withDouble_(kernel_, x_, y_) autorelease];
  [ret setModeWithInt:toStringMode_];
  return ret;
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)xmlsb {
  [super getXMLtagsWithJavaLangStringBuilder:xmlsb];
  [self getLineStyleXMLWithJavaLangStringBuilder:xmlsb];
  switch (toStringMode_) {
    case GeogebraCommonKernelKernel_COORD_POLAR:
    [((JavaLangStringBuilder *) nil_chk(xmlsb)) appendWithNSString:@"\t<coordStyle style=\"polar\"/>\n"];
    break;
    case GeogebraCommonKernelKernel_COORD_COMPLEX:
    [((JavaLangStringBuilder *) nil_chk(xmlsb)) appendWithNSString:@"\t<coordStyle style=\"complex\"/>\n"];
    break;
    case GeogebraCommonKernelKernel_COORD_CARTESIAN_3D:
    [((JavaLangStringBuilder *) nil_chk(xmlsb)) appendWithNSString:@"\t<coordStyle style=\"cartesian3d\"/>\n"];
    break;
    case GeogebraCommonKernelKernel_COORD_SPHERICAL:
    [((JavaLangStringBuilder *) nil_chk(xmlsb)) appendWithNSString:@"\t<coordStyle style=\"spherical\"/>\n"];
    break;
    default:
    [((JavaLangStringBuilder *) nil_chk(xmlsb)) appendWithNSString:@"\t<coordStyle style=\"cartesian\"/>\n"];
  }
  if (startPoint_ != nil) {
    [((JavaLangStringBuilder *) nil_chk(xmlsb)) appendWithNSString:[startPoint_ getStartPointXML]];
  }
}

- (jboolean)isNumberValue {
  return NO;
}

- (jboolean)evaluatesToNonComplex2DVector {
  return [self getMode] != GeogebraCommonKernelKernel_COORD_COMPLEX;
}

- (jboolean)evaluatesToVectorNotPoint {
  return [self getMode] != GeogebraCommonKernelKernel_COORD_COMPLEX;
}

- (jboolean)isClosedPath {
  return NO;
}

- (void)pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  if (startPoint_ == nil && waitingForStartPoint_) {
    if (waitingPointSet_ == nil) GeogebraCommonKernelGeosGeoVector_setAndConsume_waitingPointSet_(self, new_JavaUtilHashSet_init());
    [((JavaUtilHashSet *) nil_chk(waitingPointSet_)) addWithId:P];
    return;
  }
  if (pathSegment_ == nil) GeogebraCommonKernelGeosGeoVector_updatePathSegment(self);
  [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(pathSegment_)) pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
}

- (void)pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P {
  if (![((GeogebraCommonKernelKernel *) nil_chk([self getKernel])) usePathAndRegionParametersWithGeogebraCommonKernelKernelNDGeoPointND:P]) {
    [self pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
    return;
  }
  GeogebraCommonKernelGeosGeoVector_updatePathSegment(self);
  [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(pathSegment_)) pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:P];
}

- (jboolean)isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)P
                                                    withDouble:(jdouble)eps {
  GeogebraCommonKernelGeosGeoVector_updatePathSegment(self);
  return [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(pathSegment_)) isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:P withDouble:eps];
}

- (jboolean)isPath {
  return YES;
}

- (jdouble)getMinParameter {
  return 0;
}

- (jdouble)getMaxParameter {
  return 1;
}

- (id<GeogebraCommonKernelPathMover>)createPathMover {
  return [new_GeogebraCommonKernelPathMoverGeneric_initWithGeogebraCommonKernelPath_(self) autorelease];
}

- (void)initPathSegment {
  GeogebraCommonKernelGeosGeoVector_initPathSegment(self);
}

- (void)updatePathSegment {
  GeogebraCommonKernelGeosGeoVector_updatePathSegment(self);
}

- (jboolean)isGeoVector {
  return YES;
}

- (jboolean)isAlwaysFixed {
  return NO;
}

- (jboolean)isMatrixTransformable {
  return YES;
}

+ (void)buildLatexValueStringCoordCartesian3DWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
                                     withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                                 withDouble:(jdouble)x
                                                                 withDouble:(jdouble)y
                                                                 withDouble:(jdouble)z
                                                  withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                withGeogebraCommonKernelKernelNDGeoVectorND:(id<GeogebraCommonKernelKernelNDGeoVectorND>)vector
                                                                withBoolean:(jboolean)symbolic {
  GeogebraCommonKernelGeosGeoVector_buildLatexValueStringCoordCartesian3DWithGeogebraCommonKernelKernel_withGeogebraCommonKernelStringTemplate_withDouble_withDouble_withDouble_withJavaLangStringBuilder_withGeogebraCommonKernelKernelNDGeoVectorND_withBoolean_(kernel, tpl, x, y, z, sb, vector, symbolic);
}

- (NSString *)toLaTeXStringWithBoolean:(jboolean)symbolic
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (sb_ == nil) GeogebraCommonKernelGeosGeoVector_setAndConsume_sb_(self, new_JavaLangStringBuilder_init());
  else [sb_ setLengthWithInt:0];
  return GeogebraCommonKernelGeosGeoVector_buildLatexStringWithGeogebraCommonKernelKernel_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelStringTemplate_withInt_withDouble_withDouble_withGeogebraCommonKernelKernelNDGeoVectorND_(kernel_, sb_, symbolic, tpl, toStringMode_, x_, y_, self);
}

+ (NSString *)buildLatexStringWithGeogebraCommonKernelKernel:(GeogebraCommonKernelKernel *)kernel
                                   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                                 withBoolean:(jboolean)symbolic
                      withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl
                                                     withInt:(jint)toStringMode
                                                  withDouble:(jdouble)x
                                                  withDouble:(jdouble)y
                 withGeogebraCommonKernelKernelNDGeoVectorND:(id<GeogebraCommonKernelKernelNDGeoVectorND>)vector {
  return GeogebraCommonKernelGeosGeoVector_buildLatexStringWithGeogebraCommonKernelKernel_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelStringTemplate_withInt_withDouble_withDouble_withGeogebraCommonKernelKernelNDGeoVectorND_(kernel, sb, symbolic, tpl, toStringMode, x, y, vector);
}

- (GeogebraCommonKernelMatrixCoords *)getCoordsInD2 {
  GeogebraCommonKernelMatrixCoords *ret = [new_GeogebraCommonKernelMatrixCoords_initWithInt_(3) autorelease];
  [ret setXWithDouble:[self getX]];
  [ret setYWithDouble:[self getY]];
  [ret setZWithDouble:[self getZ]];
  return ret;
}

- (GeogebraCommonKernelMatrixCoords *)getCoordsInD3 {
  GeogebraCommonKernelMatrixCoords *ret = [new_GeogebraCommonKernelMatrixCoords_initWithInt_(4) autorelease];
  [ret setXWithDouble:[self getX]];
  [ret setYWithDouble:[self getY]];
  [ret setZWithDouble:[self getZ]];
  return ret;
}

- (jboolean)hasDrawable3D {
  return YES;
}

- (void)updateStartPointPosition {
}

- (GeogebraCommonKernelMatrixCoords *)getDirectionInD3 {
  return [self getCoordsInD3];
}

- (void)matrixTransformWithDouble:(jdouble)a00
                       withDouble:(jdouble)a01
                       withDouble:(jdouble)a02
                       withDouble:(jdouble)a10
                       withDouble:(jdouble)a11
                       withDouble:(jdouble)a12
                       withDouble:(jdouble)a20
                       withDouble:(jdouble)a21
                       withDouble:(jdouble)a22 {
  jdouble x1 = a00 * x_ + a01 * y_ + a02 * 1;
  jdouble y1 = a10 * x_ + a11 * y_ + a12 * 1;
  jdouble z1 = a20 * x_ + a21 * y_ + a22 * 1;
  GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(self, x1 / z1, y1 / z1, 0);
}

- (jboolean)isLaTeXDrawableGeo {
  return YES;
}

- (void)updateColumnHeadingsForTraceValues {
  [self resetSpreadsheetColumnHeadings];
  [((JavaUtilArrayList *) nil_chk(spreadsheetColumnHeadings_)) addWithId:[self getColumnHeadingTextWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [self getXBracket], GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [self getNameGeo], GeogebraCommonPluginOperationEnum_get_PLUS(), [self getCloseBracket]) autorelease]) autorelease]]];
  [spreadsheetColumnHeadings_ addWithId:[self getColumnHeadingTextWithGeogebraCommonKernelArithmeticExpressionNode:[new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [self getYBracket], GeogebraCommonPluginOperationEnum_get_PLUS(), [new_GeogebraCommonKernelArithmeticExpressionNode_initWithGeogebraCommonKernelKernel_withGeogebraCommonKernelArithmeticExpressionValue_withGeogebraCommonPluginOperationEnum_withGeogebraCommonKernelArithmeticExpressionValue_(kernel_, [self getNameGeo], GeogebraCommonPluginOperationEnum_get_PLUS(), [self getCloseBracket]) autorelease]) autorelease]]];
}

- (GeogebraCommonKernelGeosGeoElement_TraceModesEnumEnum *)getTraceModes {
  return GeogebraCommonKernelGeosGeoElement_TraceModesEnumEnum_get_SEVERAL_VALUES_OR_COPY();
}

- (NSString *)getTraceDialogAsValues {
  NSString *name = [self getLabelTextOrHTMLWithBoolean:NO];
  JavaLangStringBuilder *sbTrace = [new_JavaLangStringBuilder_init() autorelease];
  [sbTrace appendWithNSString:@"x("];
  [sbTrace appendWithNSString:name];
  [sbTrace appendWithNSString:@"), y("];
  [sbTrace appendWithNSString:name];
  [sbTrace appendWithNSString:@")"];
  return [sbTrace description];
}

- (void)addToSpreadsheetTraceListWithJavaUtilArrayList:(JavaUtilArrayList *)spreadsheetTraceList {
  GeogebraCommonKernelGeosGeoNumeric *xx = [new_GeogebraCommonKernelGeosGeoNumeric_initWithGeogebraCommonKernelConstruction_withDouble_(cons_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(GeogebraCommonKernelGeosGeoVector_getInhomVec(self))) getX]) autorelease];
  [((JavaUtilArrayList *) nil_chk(spreadsheetTraceList)) addWithId:xx];
  GeogebraCommonKernelGeosGeoNumeric *yy = [new_GeogebraCommonKernelGeosGeoNumeric_initWithGeogebraCommonKernelConstruction_withDouble_(cons_, [((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(GeogebraCommonKernelGeosGeoVector_getInhomVec(self))) getY]) autorelease];
  [spreadsheetTraceList addWithId:yy];
}

- (GeogebraCommonKernelAlgosSymbolicParameters *)getSymbolicParameters {
  if (algoParent_ != nil && ([GeogebraCommonKernelAlgosSymbolicParametersAlgo_class_() isInstance:algoParent_])) {
    return [new_GeogebraCommonKernelAlgosSymbolicParameters_initWithGeogebraCommonKernelAlgosSymbolicParametersAlgo_((id<GeogebraCommonKernelAlgosSymbolicParametersAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosSymbolicParametersAlgo))) autorelease];
  }
  return nil;
}

- (void)getFreeVariablesWithJavaUtilHashSet:(JavaUtilHashSet *)variables {
  if (algoParent_ != nil && ([GeogebraCommonKernelAlgosSymbolicParametersAlgo_class_() isInstance:algoParent_])) {
    [((id<GeogebraCommonKernelAlgosSymbolicParametersAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosSymbolicParametersAlgo))) getFreeVariablesWithJavaUtilHashSet:variables];
    return;
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSIntArray *)getDegrees {
  if (algoParent_ != nil && ([GeogebraCommonKernelAlgosSymbolicParametersAlgo_class_() isInstance:algoParent_])) {
    return [((id<GeogebraCommonKernelAlgosSymbolicParametersAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosSymbolicParametersAlgo))) getDegrees];
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getExactCoordinatesWithJavaUtilHashMap:(JavaUtilHashMap *)values {
  if (algoParent_ != nil && ([GeogebraCommonKernelAlgosSymbolicParametersAlgo_class_() isInstance:algoParent_])) {
    return [((id<GeogebraCommonKernelAlgosSymbolicParametersAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosSymbolicParametersAlgo))) getExactCoordinatesWithJavaUtilHashMap:values];
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getPolynomials {
  if (algoParent_ != nil && [GeogebraCommonKernelAlgosSymbolicParametersAlgo_class_() isInstance:algoParent_]) {
    return [((id<GeogebraCommonKernelAlgosSymbolicParametersAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosSymbolicParametersAlgo))) getPolynomials];
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSObjectArray *)getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (algoParent_ != nil && [GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo_class_() isInstance:algoParent_]) {
    return [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))) getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:self];
  }
  return nil;
}

- (IOSObjectArray *)getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  if (algoParent_ != nil && [GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo_class_() isInstance:algoParent_]) {
    return [((id<GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo>) check_protocol_cast(algoParent_, @protocol(GeogebraCommonKernelAlgosSymbolicParametersBotanaAlgo))) getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:self];
  }
  @throw [new_GeogebraCommonKernelProverNoSymbolicParametersException_init() autorelease];
}

- (IOSDoubleArray *)getInhomCoords {
  IOSDoubleArray *ret = [IOSDoubleArray arrayWithLength:2];
  *IOSDoubleArray_GetRef(ret, 0) = [self getX];
  *IOSDoubleArray_GetRef(ret, 1) = [self getY];
  return ret;
}

- (void)updateLocation {
  [self updateGeo];
  [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) notifyUpdateLocationWithGeogebraCommonKernelGeosGeoElement:self];
}

- (GeogebraCommonKernelGeosGeoElement_HitTypeEnum *)getLastHitType {
  return GeogebraCommonKernelGeosGeoElement_HitTypeEnum_get_ON_BOUNDARY();
}

- (void)dealloc {
  RELEASE_(startPoint_);
  RELEASE_(pathSegment_);
  RELEASE_(pathStartPoint_);
  RELEASE_(pathEndPoint_);
  RELEASE_(waitingPointSet_);
  RELEASE_(sbToString_GeoVector_);
  RELEASE_(sbBuildValueString_);
  RELEASE_(sb_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:", "GeoVector", NULL, 0x1, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "isCasEvaluableObject", NULL, "Z", 0x11, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withNSString:withDouble:withDouble:withDouble:", "GeoVector", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoVector:", "GeoVector", NULL, 0x1, NULL, NULL },
    { "setCoordsWithDouble:withDouble:withDouble:", "setCoords", "V", 0x11, NULL, NULL },
    { "setCoordsWithDoubleArray:", "setCoords", "V", 0x11, NULL, NULL },
    { "setCoordsWithGeogebraCommonKernelGeosGeoVec3D:", "setCoords", "V", 0x11, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "copy__", "copy", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "setPolarCoordsWithDouble:withDouble:", "setPolarCoords", "V", 0x11, NULL, NULL },
    { "setCoordsWithGeogebraCommonKernelGeosGeoVec2D:", "setCoords", "V", 0x11, NULL, NULL },
    { "getInhomVec", NULL, "Lgeogebra.common.kernel.geos.GeoVec2D;", 0x11, NULL, NULL },
    { "getStartPoint", NULL, "Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x11, NULL, NULL },
    { "getStartPoints", NULL, "[Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x1, NULL, NULL },
    { "hasAbsoluteLocation", NULL, "Z", 0x1, NULL, NULL },
    { "setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:withInt:", "setStartPoint", "V", 0x1, "Lgeogebra.common.kernel.CircularDefinitionException;", NULL },
    { "initStartPointWithGeogebraCommonKernelKernelNDGeoPointND:withInt:", "initStartPoint", "V", 0x1, NULL, NULL },
    { "removeStartPointWithGeogebraCommonKernelKernelNDGeoPointND:", "removeStartPoint", "V", 0x1, NULL, NULL },
    { "setStartPointWithGeogebraCommonKernelKernelNDGeoPointND:", "setStartPoint", "V", 0x1, "Lgeogebra.common.kernel.CircularDefinitionException;", NULL },
    { "setWaitForStartPoint", NULL, "V", 0x1, NULL, NULL },
    { "doRemove", NULL, "V", 0x1, NULL, NULL },
    { "isFinite", NULL, "Z", 0x11, NULL, NULL },
    { "isInfinite", NULL, "Z", 0x11, NULL, NULL },
    { "showInEuclidianView", NULL, "Z", 0x14, NULL, NULL },
    { "showInAlgebraView", NULL, "Z", 0x11, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x11, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:", "rotate", "V", 0x11, NULL, NULL },
    { "translateWithGeogebraCommonKernelMatrixCoords:", "translate", "V", 0x1, NULL, NULL },
    { "rotateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelKernelNDGeoPointND:", "rotate", "V", 0x1, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelMatrixCoords:", "mirror", "V", 0x1, NULL, NULL },
    { "mirrorWithGeogebraCommonKernelKernelNDGeoLineND:", "mirror", "V", 0x1, NULL, NULL },
    { "dilateWithGeogebraCommonKernelArithmeticNumberValue:withGeogebraCommonKernelMatrixCoords:", "dilate", "V", 0x1, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "toStringMinimalWithGeogebraCommonKernelStringTemplate:", "toStringMinimal", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "buildValueStringWithGeogebraCommonKernelStringTemplate:", "buildValueString", "Ljava.lang.StringBuilder;", 0x2, NULL, NULL },
    { "getVector", NULL, "Lgeogebra.common.kernel.geos.GeoVec2D;", 0x1, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "isNumberValue", NULL, "Z", 0x1, NULL, NULL },
    { "evaluatesToNonComplex2DVector", NULL, "Z", 0x1, NULL, NULL },
    { "evaluatesToVectorNotPoint", NULL, "Z", 0x1, NULL, NULL },
    { "isClosedPath", NULL, "Z", 0x1, NULL, NULL },
    { "pointChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pointChanged", "V", 0x1, NULL, NULL },
    { "pathChangedWithGeogebraCommonKernelKernelNDGeoPointND:", "pathChanged", "V", 0x1, NULL, NULL },
    { "isOnPathWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "isOnPath", "Z", 0x1, NULL, NULL },
    { "isPath", NULL, "Z", 0x1, NULL, NULL },
    { "getMinParameter", NULL, "D", 0x1, NULL, NULL },
    { "getMaxParameter", NULL, "D", 0x1, NULL, NULL },
    { "createPathMover", NULL, "Lgeogebra.common.kernel.PathMover;", 0x1, NULL, NULL },
    { "initPathSegment", NULL, "V", 0x2, NULL, NULL },
    { "updatePathSegment", NULL, "V", 0x2, NULL, NULL },
    { "isGeoVector", NULL, "Z", 0x1, NULL, NULL },
    { "isAlwaysFixed", NULL, "Z", 0x1, NULL, NULL },
    { "isMatrixTransformable", NULL, "Z", 0x1, NULL, NULL },
    { "buildLatexValueStringCoordCartesian3DWithGeogebraCommonKernelKernel:withGeogebraCommonKernelStringTemplate:withDouble:withDouble:withDouble:withJavaLangStringBuilder:withGeogebraCommonKernelKernelNDGeoVectorND:withBoolean:", "buildLatexValueStringCoordCartesian3D", "V", 0x19, NULL, NULL },
    { "toLaTeXStringWithBoolean:withGeogebraCommonKernelStringTemplate:", "toLaTeXString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "buildLatexStringWithGeogebraCommonKernelKernel:withJavaLangStringBuilder:withBoolean:withGeogebraCommonKernelStringTemplate:withInt:withDouble:withDouble:withGeogebraCommonKernelKernelNDGeoVectorND:", "buildLatexString", "Ljava.lang.String;", 0x19, NULL, NULL },
    { "getCoordsInD2", NULL, "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "getCoordsInD3", NULL, "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "hasDrawable3D", NULL, "Z", 0x1, NULL, NULL },
    { "updateStartPointPosition", NULL, "V", 0x1, NULL, NULL },
    { "getDirectionInD3", NULL, "Lgeogebra.common.kernel.Matrix.Coords;", 0x1, NULL, NULL },
    { "matrixTransformWithDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:withDouble:", "matrixTransform", "V", 0x1, NULL, NULL },
    { "isLaTeXDrawableGeo", NULL, "Z", 0x1, NULL, NULL },
    { "updateColumnHeadingsForTraceValues", NULL, "V", 0x1, NULL, NULL },
    { "getTraceModes", NULL, "Lgeogebra.common.kernel.geos.GeoElement$TraceModesEnum;", 0x1, NULL, NULL },
    { "getTraceDialogAsValues", NULL, "Ljava.lang.String;", 0x1, NULL, NULL },
    { "addToSpreadsheetTraceListWithJavaUtilArrayList:", "addToSpreadsheetTraceList", "V", 0x1, NULL, NULL },
    { "getSymbolicParameters", NULL, "Lgeogebra.common.kernel.algos.SymbolicParameters;", 0x1, NULL, NULL },
    { "getFreeVariablesWithJavaUtilHashSet:", "getFreeVariables", "V", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getDegrees", NULL, "[I", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getExactCoordinatesWithJavaUtilHashMap:", "getExactCoordinates", "[Ljava.math.BigInteger;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getPolynomials", NULL, "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getBotanaVarsWithGeogebraCommonKernelGeosGeoElement:", "getBotanaVars", "[Lgeogebra.common.kernel.prover.polynomial.Variable;", 0x1, NULL, NULL },
    { "getBotanaPolynomialsWithGeogebraCommonKernelGeosGeoElement:", "getBotanaPolynomials", "[Lgeogebra.common.kernel.prover.polynomial.Polynomial;", 0x1, "Lgeogebra.common.kernel.prover.NoSymbolicParametersException;", NULL },
    { "getInhomCoords", NULL, "[D", 0x1, NULL, NULL },
    { "updateLocation", NULL, "V", 0x1, NULL, NULL },
    { "getLastHitType", NULL, "Lgeogebra.common.kernel.geos.GeoElement$HitType;", 0x11, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "startPoint_", NULL, 0x2, "Lgeogebra.common.kernel.kernelND.GeoPointND;", NULL, NULL,  },
    { "pathSegment_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoSegment;", NULL, NULL,  },
    { "pathStartPoint_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "pathEndPoint_", NULL, 0x2, "Lgeogebra.common.kernel.geos.GeoPoint;", NULL, NULL,  },
    { "waitingForStartPoint_", NULL, 0x2, "Z", NULL, NULL,  },
    { "waitingPointSet_", NULL, 0x2, "Ljava.util.HashSet;", NULL, "Ljava/util/HashSet<Lgeogebra/common/kernel/kernelND/GeoPointND;>;",  },
    { "sbToString_GeoVector_", "sbToString", 0x2, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "sbBuildValueString_", NULL, 0x2, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "sb_", NULL, 0x2, "Ljava.lang.StringBuilder;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoVector = { 2, "GeoVector", "geogebra.common.kernel.geos", NULL, 0x11, 80, methods, 9, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoVector;
}

@end

void GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelGeosGeoVector *self, GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoVec3D_initWithGeogebraCommonKernelConstruction_(self, c);
  self->waitingForStartPoint_ = NO;
  GeogebraCommonKernelGeosGeoVector_setAndConsume_sbToString_GeoVector_(self, new_JavaLangStringBuilder_initWithInt_(50));
  GeogebraCommonKernelGeosGeoVector_setAndConsume_sbBuildValueString_(self, new_JavaLangStringBuilder_initWithInt_(50));
  [self setConstructionDefaults];
}

GeogebraCommonKernelGeosGeoVector *new_GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *c) {
  GeogebraCommonKernelGeosGeoVector *self = [GeogebraCommonKernelGeosGeoVector alloc];
  GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_(self, c);
  return self;
}

void GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_withNSString_withDouble_withDouble_withDouble_(GeogebraCommonKernelGeosGeoVector *self, GeogebraCommonKernelConstruction *c, NSString *label, jdouble x, jdouble y, jdouble z) {
  GeogebraCommonKernelGeosGeoVec3D_initWithGeogebraCommonKernelConstruction_withDouble_withDouble_withDouble_(self, c, x, y, z);
  self->waitingForStartPoint_ = NO;
  GeogebraCommonKernelGeosGeoVector_setAndConsume_sbToString_GeoVector_(self, new_JavaLangStringBuilder_initWithInt_(50));
  GeogebraCommonKernelGeosGeoVector_setAndConsume_sbBuildValueString_(self, new_JavaLangStringBuilder_initWithInt_(50));
  [self setConstructionDefaults];
  [self setLabelWithNSString:label];
}

GeogebraCommonKernelGeosGeoVector *new_GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_withNSString_withDouble_withDouble_withDouble_(GeogebraCommonKernelConstruction *c, NSString *label, jdouble x, jdouble y, jdouble z) {
  GeogebraCommonKernelGeosGeoVector *self = [GeogebraCommonKernelGeosGeoVector alloc];
  GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_withNSString_withDouble_withDouble_withDouble_(self, c, label, x, y, z);
  return self;
}

void GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelGeosGeoVector_(GeogebraCommonKernelGeosGeoVector *self, GeogebraCommonKernelGeosGeoVector *vector) {
  GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelConstruction_(self, ((GeogebraCommonKernelGeosGeoVector *) nil_chk(vector))->cons_);
  [self setWithGeogebraCommonKernelGeosGeoElement:vector];
}

GeogebraCommonKernelGeosGeoVector *new_GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelGeosGeoVector_(GeogebraCommonKernelGeosGeoVector *vector) {
  GeogebraCommonKernelGeosGeoVector *self = [GeogebraCommonKernelGeosGeoVector alloc];
  GeogebraCommonKernelGeosGeoVector_initWithGeogebraCommonKernelGeosGeoVector_(self, vector);
  return self;
}

void GeogebraCommonKernelGeosGeoVector_setCoordsWithDouble_withDouble_withDouble_(GeogebraCommonKernelGeosGeoVector *self, jdouble x, jdouble y, jdouble z) {
  self->x_ = x;
  self->y_ = y;
  self->z_ = z;
}

GeogebraCommonKernelGeosGeoVec2D *GeogebraCommonKernelGeosGeoVector_getInhomVec(GeogebraCommonKernelGeosGeoVector *self) {
  return [new_GeogebraCommonKernelGeosGeoVec2D_initWithGeogebraCommonKernelKernel_withDouble_withDouble_(self->kernel_, self->x_, self->y_) autorelease];
}

jboolean GeogebraCommonKernelGeosGeoVector_isFinite(GeogebraCommonKernelGeosGeoVector *self) {
  return !GeogebraCommonKernelGeosGeoVector_isInfinite(self);
}

jboolean GeogebraCommonKernelGeosGeoVector_isInfinite(GeogebraCommonKernelGeosGeoVector *self) {
  return JavaLangDouble_isInfiniteWithDouble_(self->x_) || JavaLangDouble_isInfiniteWithDouble_(self->y_);
}

JavaLangStringBuilder *GeogebraCommonKernelGeosGeoVector_buildValueStringWithGeogebraCommonKernelStringTemplate_(GeogebraCommonKernelGeosGeoVector *self, GeogebraCommonKernelStringTemplate *tpl) {
  [((JavaLangStringBuilder *) nil_chk(self->sbBuildValueString_)) setLengthWithInt:0];
  switch ([[((GeogebraCommonKernelStringTemplate *) nil_chk(tpl)) getStringType] ordinal]) {
    case GeogebraCommonKernelArithmeticExpressionNodeConstants_StringType_GIAC:
    [self->sbBuildValueString_ appendWithNSString:@"ggbvect["];
    [self->sbBuildValueString_ appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) formatWithDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(GeogebraCommonKernelGeosGeoVector_getInhomVec(self))) getX] withGeogebraCommonKernelStringTemplate:tpl]];
    [self->sbBuildValueString_ appendWithChar:','];
    [self->sbBuildValueString_ appendWithNSString:[self->kernel_ formatWithDouble:[((GeogebraCommonKernelGeosGeoVec2D *) nil_chk(GeogebraCommonKernelGeosGeoVector_getInhomVec(self))) getY] withGeogebraCommonKernelStringTemplate:tpl]];
    [self->sbBuildValueString_ appendWithNSString:@"]"];
    return self->sbBuildValueString_;
    default:
    ;
  }
  switch (self->toStringMode_) {
    case GeogebraCommonKernelKernel_COORD_POLAR:
    [self->sbBuildValueString_ appendWithNSString:@"("];
    [self->sbBuildValueString_ appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) formatWithDouble:GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_(self->x_, self->y_) withGeogebraCommonKernelStringTemplate:tpl]];
    [self->sbBuildValueString_ appendWithNSString:@"; "];
    [self->sbBuildValueString_ appendWithJavaLangCharSequence:[self->kernel_ formatAngleWithDouble:JavaLangMath_atan2WithDouble_withDouble_(self->y_, self->x_) withGeogebraCommonKernelStringTemplate:tpl withBoolean:NO]];
    [self->sbBuildValueString_ appendWithNSString:@")"];
    break;
    case GeogebraCommonKernelKernel_COORD_COMPLEX:
    [self->sbBuildValueString_ appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) formatWithDouble:self->x_ withGeogebraCommonKernelStringTemplate:tpl]];
    [self->sbBuildValueString_ appendWithNSString:@" "];
    [self->kernel_ formatSignedWithDouble:self->y_ withJavaLangStringBuilder:self->sbBuildValueString_ withGeogebraCommonKernelStringTemplate:tpl];
    [self->sbBuildValueString_ appendWithNSString:GeogebraCommonUtilUnicode_get_IMAGINARY_()];
    break;
    case GeogebraCommonKernelKernel_COORD_CARTESIAN_3D:
    GeogebraCommonKernelGeosGeoPoint_buildValueStringCoordCartesian3DWithGeogebraCommonKernelKernel_withGeogebraCommonKernelStringTemplate_withDouble_withDouble_withDouble_withJavaLangStringBuilder_(self->kernel_, tpl, self->x_, self->y_, 0, self->sbBuildValueString_);
    break;
    case GeogebraCommonKernelKernel_COORD_SPHERICAL:
    GeogebraCommonKernelGeosGeoPoint_buildValueStringCoordSphericalWithGeogebraCommonKernelKernel_withGeogebraCommonKernelStringTemplate_withDouble_withDouble_withDouble_withJavaLangStringBuilder_(self->kernel_, tpl, self->x_, self->y_, 0, self->sbBuildValueString_);
    break;
    default:
    [self->sbBuildValueString_ appendWithNSString:@"("];
    [self->sbBuildValueString_ appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) formatWithDouble:self->x_ withGeogebraCommonKernelStringTemplate:tpl]];
    switch ([tpl getCoordStyleWithInt:[self->kernel_ getCoordStyle]]) {
      case GeogebraCommonKernelKernel_COORD_STYLE_AUSTRIAN:
      [self->sbBuildValueString_ appendWithNSString:@" | "];
      break;
      default:
      [self->sbBuildValueString_ appendWithNSString:@", "];
    }
    [self->sbBuildValueString_ appendWithNSString:[self->kernel_ formatWithDouble:self->y_ withGeogebraCommonKernelStringTemplate:tpl]];
    [self->sbBuildValueString_ appendWithNSString:@")"];
    break;
  }
  return self->sbBuildValueString_;
}

void GeogebraCommonKernelGeosGeoVector_initPathSegment(GeogebraCommonKernelGeosGeoVector *self) {
  if (self->startPoint_ != nil && ![self->startPoint_ isGeoElement3D]) {
    GeogebraCommonKernelGeosGeoVector_set_pathStartPoint_(self, (GeogebraCommonKernelGeosGeoPoint *) check_class_cast(self->startPoint_, [GeogebraCommonKernelGeosGeoPoint class]));
  }
  else {
    GeogebraCommonKernelGeosGeoVector_setAndConsume_pathStartPoint_(self, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(self->cons_));
    [self->pathStartPoint_ setCoordsWithDouble:0 withDouble:0 withDouble:1];
  }
  GeogebraCommonKernelGeosGeoVector_setAndConsume_pathEndPoint_(self, new_GeogebraCommonKernelGeosGeoPoint_initWithGeogebraCommonKernelConstruction_(self->cons_));
  GeogebraCommonKernelGeosGeoVector_setAndConsume_pathSegment_(self, new_GeogebraCommonKernelGeosGeoSegment_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_(self->cons_, self->pathStartPoint_, self->pathEndPoint_));
}

void GeogebraCommonKernelGeosGeoVector_updatePathSegment(GeogebraCommonKernelGeosGeoVector *self) {
  if (self->pathSegment_ == nil) GeogebraCommonKernelGeosGeoVector_initPathSegment(self);
  [((GeogebraCommonKernelGeosGeoPoint *) nil_chk(self->pathEndPoint_)) setCoordsWithDouble:((GeogebraCommonKernelGeosGeoPoint *) nil_chk(self->pathStartPoint_))->inhomX_ + self->x_ withDouble:self->pathStartPoint_->inhomY_ + self->y_ withDouble:1.0];
  GeogebraCommonKernelGeosGeoVec3D_lineThroughPointsWithGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoPoint_withGeogebraCommonKernelGeosGeoLine_(self->pathStartPoint_, self->pathEndPoint_, self->pathSegment_);
  [((GeogebraCommonKernelGeosGeoSegment *) nil_chk(self->pathSegment_)) calcLength];
}

void GeogebraCommonKernelGeosGeoVector_buildLatexValueStringCoordCartesian3DWithGeogebraCommonKernelKernel_withGeogebraCommonKernelStringTemplate_withDouble_withDouble_withDouble_withJavaLangStringBuilder_withGeogebraCommonKernelKernelNDGeoVectorND_withBoolean_(GeogebraCommonKernelKernel *kernel, GeogebraCommonKernelStringTemplate *tpl, jdouble x, jdouble y, jdouble z, JavaLangStringBuilder *sb, id<GeogebraCommonKernelKernelNDGeoVectorND> vector, jboolean symbolic) {
  GeogebraCommonKernelGeosGeoVector_initialize();
  IOSObjectArray *inputs;
  if (symbolic && [GeogebraCommonKernelAlgosDependentAlgo_class_() isInstance:[((id<GeogebraCommonKernelKernelNDGeoVectorND>) nil_chk(vector)) getParentAlgorithm]]) {
    GeogebraCommonKernelAlgosAlgoElement *algo = [vector getParentAlgorithm];
    NSString *symbolicStr = [((GeogebraCommonKernelAlgosAlgoElement *) nil_chk(algo)) toStringWithGeogebraCommonKernelStringTemplate:tpl];
    jint firstIndex = [((NSString *) nil_chk(symbolicStr)) indexOfString:@"\\left("];
    jint lastIndex = [symbolicStr lastIndexOfString:@"\\right)"];
    inputs = [((NSString *) nil_chk([symbolicStr substring:firstIndex + 6 endIndex:lastIndex])) split:@","];
  }
  else {
    inputs = [IOSObjectArray arrayWithLength:3 type:NSString_class_()];
    IOSObjectArray_Set(inputs, 0, [((GeogebraCommonKernelKernel *) nil_chk(kernel)) formatWithDouble:x withGeogebraCommonKernelStringTemplate:tpl]);
    IOSObjectArray_Set(inputs, 1, [kernel formatWithDouble:y withGeogebraCommonKernelStringTemplate:tpl]);
    IOSObjectArray_Set(inputs, 2, [kernel formatWithDouble:z withGeogebraCommonKernelStringTemplate:tpl]);
  }
  if (((IOSObjectArray *) nil_chk(inputs))->size_ == 3 && [((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel)) getApplication])) isHTML5Applet]) {
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\openparenonly{\\closeparenonly{\\ggbtable{\\ggbtr{\\ggbtd{"];
    [sb appendWithNSString:IOSObjectArray_Get(inputs, 0)];
    [sb appendWithNSString:@"}}\\ggbtr{\\ggbtd{"];
    [sb appendWithNSString:IOSObjectArray_Get(inputs, 1)];
    [sb appendWithNSString:@"}}\\ggbtr{\\ggbtd{"];
    [sb appendWithNSString:IOSObjectArray_Get(inputs, 2)];
    [sb appendWithNSString:@"}}}}}"];
    return;
  }
  jboolean alignOnDecimalPoint = YES;
  for (jint i = 0; i < inputs->size_; i++) {
    if ([((NSString *) nil_chk(IOSObjectArray_Get(inputs, i))) indexOf:'.'] == -1) {
      alignOnDecimalPoint = NO;
      continue;
    }
  }
  if (alignOnDecimalPoint) {
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\left( \\begin{tabular}{r@{.}l}"];
    for (jint i = 0; i < inputs->size_; i++) {
      IOSObjectArray_Set(inputs, i, [((NSString *) nil_chk(IOSObjectArray_Get(inputs, i))) replace:'.' withChar:'&']);
    }
  }
  else {
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\left( \\begin{tabular}{r}"];
  }
  for (jint i = 0; i < inputs->size_; i++) {
    [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:IOSObjectArray_Get(inputs, i)];
    [sb appendWithNSString:@" \\\\ "];
  }
  [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\end{tabular} \\right)"];
}

NSString *GeogebraCommonKernelGeosGeoVector_buildLatexStringWithGeogebraCommonKernelKernel_withJavaLangStringBuilder_withBoolean_withGeogebraCommonKernelStringTemplate_withInt_withDouble_withDouble_withGeogebraCommonKernelKernelNDGeoVectorND_(GeogebraCommonKernelKernel *kernel, JavaLangStringBuilder *sb, jboolean symbolic, GeogebraCommonKernelStringTemplate *tpl, jint toStringMode, jdouble x, jdouble y, id<GeogebraCommonKernelKernelNDGeoVectorND> vector) {
  GeogebraCommonKernelGeosGeoVector_initialize();
  {
    IOSObjectArray *inputs;
    switch (toStringMode) {
      case GeogebraCommonKernelKernel_COORD_POLAR:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"("];
      [sb appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(kernel)) formatWithDouble:GeogebraCommonUtilMyMath_lengthWithDouble_withDouble_(x, y) withGeogebraCommonKernelStringTemplate:tpl]];
      [sb appendWithNSString:@"; "];
      [sb appendWithJavaLangCharSequence:[kernel formatAngleWithDouble:JavaLangMath_atan2WithDouble_withDouble_(y, x) withGeogebraCommonKernelStringTemplate:tpl withBoolean:NO]];
      [sb appendWithNSString:@")"];
      break;
      case GeogebraCommonKernelKernel_COORD_COMPLEX:
      [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:[((GeogebraCommonKernelKernel *) nil_chk(kernel)) formatWithDouble:x withGeogebraCommonKernelStringTemplate:tpl]];
      [sb appendWithNSString:@" "];
      [kernel formatSignedWithDouble:y withJavaLangStringBuilder:sb withGeogebraCommonKernelStringTemplate:tpl];
      [sb appendWithNSString:GeogebraCommonUtilUnicode_get_IMAGINARY_()];
      break;
      case GeogebraCommonKernelKernel_COORD_CARTESIAN_3D:
      GeogebraCommonKernelGeosGeoVector_buildLatexValueStringCoordCartesian3DWithGeogebraCommonKernelKernel_withGeogebraCommonKernelStringTemplate_withDouble_withDouble_withDouble_withJavaLangStringBuilder_withGeogebraCommonKernelKernelNDGeoVectorND_withBoolean_(kernel, tpl, x, y, 0, sb, vector, symbolic);
      break;
      case GeogebraCommonKernelKernel_COORD_SPHERICAL:
      GeogebraCommonKernelGeosGeoPoint_buildValueStringCoordSphericalWithGeogebraCommonKernelKernel_withGeogebraCommonKernelStringTemplate_withDouble_withDouble_withDouble_withJavaLangStringBuilder_(kernel, tpl, x, y, 0, sb);
      break;
      default:
      if (symbolic && [[((id<GeogebraCommonKernelKernelNDGeoVectorND>) nil_chk(vector)) getParentAlgorithm] isKindOfClass:[GeogebraCommonKernelAlgosAlgoDependentVector class]]) {
        GeogebraCommonKernelAlgosAlgoDependentVector *algo = (GeogebraCommonKernelAlgosAlgoDependentVector *) check_class_cast([vector getParentAlgorithm], [GeogebraCommonKernelAlgosAlgoDependentVector class]);
        GeogebraCommonKernelArithmeticExpressionNode *en = [((GeogebraCommonKernelAlgosAlgoDependentVector *) nil_chk(algo)) getExpression];
        id<GeogebraCommonKernelArithmeticExpressionValue> ev = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en)) unwrap];
        if ([ev isKindOfClass:[GeogebraCommonKernelArithmeticMyVecNode class]]) {
          GeogebraCommonKernelArithmeticMyVecNode *vn = (GeogebraCommonKernelArithmeticMyVecNode *) check_class_cast(ev, [GeogebraCommonKernelArithmeticMyVecNode class]);
          inputs = [IOSObjectArray arrayWithLength:2 type:NSString_class_()];
          IOSObjectArray_Set(inputs, 0, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([((GeogebraCommonKernelArithmeticMyVecNode *) nil_chk(vn)) getX])) toStringWithGeogebraCommonKernelStringTemplate:tpl]);
          IOSObjectArray_Set(inputs, 1, [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk([vn getY])) toStringWithGeogebraCommonKernelStringTemplate:tpl]);
        }
        else {
          return [algo toStringWithGeogebraCommonKernelStringTemplate:tpl];
        }
      }
      else {
        inputs = [IOSObjectArray arrayWithLength:2 type:NSString_class_()];
        IOSObjectArray_Set(inputs, 0, [((GeogebraCommonKernelKernel *) nil_chk(kernel)) formatWithDouble:x withGeogebraCommonKernelStringTemplate:tpl]);
        IOSObjectArray_Set(inputs, 1, [kernel formatWithDouble:y withGeogebraCommonKernelStringTemplate:tpl]);
      }
      if (((IOSObjectArray *) nil_chk(inputs))->size_ == 2 && [((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(kernel)) getApplication])) isHTML5Applet]) {
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@" \\binom{ "];
        [sb appendWithNSString:IOSObjectArray_Get(inputs, 0)];
        [sb appendWithNSString:@" }{ "];
        [sb appendWithNSString:IOSObjectArray_Get(inputs, 1)];
        [sb appendWithNSString:@" }"];
      }
      else {
        jboolean alignOnDecimalPoint = YES;
        for (jint i = 0; i < inputs->size_; i++) {
          if ([((NSString *) nil_chk(IOSObjectArray_Get(inputs, i))) indexOf:'.'] == -1) {
            alignOnDecimalPoint = NO;
            continue;
          }
        }
        if (alignOnDecimalPoint) {
          [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\left( \\begin{tabular}{r@{.}l}"];
          for (jint i = 0; i < inputs->size_; i++) {
            IOSObjectArray_Set(inputs, i, [((NSString *) nil_chk(IOSObjectArray_Get(inputs, i))) replace:'.' withChar:'&']);
          }
        }
        else {
          [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\left( \\begin{tabular}{r}"];
        }
        for (jint i = 0; i < inputs->size_; i++) {
          [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:IOSObjectArray_Get(inputs, i)];
          [sb appendWithNSString:@" \\\\ "];
        }
        [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"\\end{tabular} \\right)"];
      }
      break;
    }
  }
  return [((JavaLangStringBuilder *) nil_chk(sb)) description];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoVector)
