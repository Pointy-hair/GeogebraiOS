//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/kernelND/GeoCurveCartesianND.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/DistanceFunction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoDependentFunction.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionNVar.h"
#include "geogebra/common/kernel/arithmetic/MyArbitraryConstant.h"
#include "geogebra/common/kernel/geos/CasEvaluableFunction.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoNumeric.h"
#include "geogebra/common/kernel/kernelND/GeoCurveCartesianND.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/main/App.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/util/debug/Log.h"
#include "java/lang/StringBuilder.h"

#pragma clang diagnostic ignored "-Wprotocol"

@interface GeogebraCommonKernelKernelNDGeoCurveCartesianND () {
 @public
  jboolean hideRangeInFormula_;
}

@end

__attribute__((unused)) static jboolean GeogebraCommonKernelKernelNDGeoCurveCartesianND_isDefined(GeogebraCommonKernelKernelNDGeoCurveCartesianND *self);

@implementation GeogebraCommonKernelKernelNDGeoCurveCartesianND

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                                                 withInt:(jint)dimension {
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_initWithGeogebraCommonKernelConstruction_withInt_(self, c, dimension);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
         withGeogebraCommonKernelArithmeticFunctionArray:(IOSObjectArray *)fun {
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunctionArray_(self, c, fun);
  return self;
}

- (void)setFunWithGeogebraCommonKernelArithmeticFunctionArray:(IOSObjectArray *)fun {
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(fun))->size_; i++) {
    IOSObjectArray_Set(nil_chk(self->fun_), i, IOSObjectArray_Get(fun, i));
  }
}

- (jboolean)isGeoCurveCartesian {
  return YES;
}

- (void)replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(fun_))->size_; i++) if (IOSObjectArray_Get(fun_, i) != nil) {
    [((GeogebraCommonKernelArithmeticFunction *) nil_chk(IOSObjectArray_Get(fun_, i))) replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:geo];
  }
}

- (void)setIntervalWithDouble:(jdouble)startParam
                   withDouble:(jdouble)endParam {
  self->startParam_ = startParam;
  self->endParam_ = endParam;
  isDefined__ = (startParam <= endParam);
}

- (jdouble)getMinParameter {
  return startParam_;
}

- (jdouble)getMaxParameter {
  return endParam_;
}

- (void)getXMLtagsWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  [super getXMLtagsWithJavaLangStringBuilder:sb];
  [self getLineStyleXMLWithJavaLangStringBuilder:sb];
}

- (jboolean)isPath {
  return YES;
}

- (jboolean)isDefined {
  return GeogebraCommonKernelKernelNDGeoCurveCartesianND_isDefined(self);
}

- (void)setDefinedWithBoolean:(jboolean)defined {
  isDefined__ = defined;
}

- (void)setUndefined {
  isDefined__ = NO;
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  JavaLangStringBuilder *sbToString = [new_JavaLangStringBuilder_initWithInt_(80) autorelease];
  [sbToString setLengthWithInt:0];
  if ([self isLabelSet]) {
    [sbToString appendWithNSString:label_];
    [sbToString appendWithChar:':'];
  }
  [sbToString appendWithNSString:[self toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
  return [sbToString description];
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (isDefined__) {
    JavaLangStringBuilder *sbTemp = [new_JavaLangStringBuilder_initWithInt_(80) autorelease];
    [sbTemp setLengthWithInt:0];
    [sbTemp appendWithChar:'('];
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(fun_))->size_; i++) {
      [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk(IOSObjectArray_Get(fun_, i))) toValueStringWithGeogebraCommonKernelStringTemplate:tpl]];
      if (i < fun_->size_ - 1) [sbTemp appendWithNSString:@", "];
    }
    [sbTemp appendWithChar:')'];
    return [sbTemp description];
  }
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
}

- (NSString *)toSymbolicStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  JavaLangStringBuilder *sbTemp = nil;
  if (isDefined__) {
    sbTemp = [new_JavaLangStringBuilder_initWithInt_(80) autorelease];
    [sbTemp setLengthWithInt:0];
    [sbTemp appendWithChar:'('];
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(fun_))->size_; i++) {
      [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk(IOSObjectArray_Get(fun_, i))) toStringWithGeogebraCommonKernelStringTemplate:tpl]];
      if (i < fun_->size_ - 1) [sbTemp appendWithNSString:@", "];
    }
    [sbTemp appendWithChar:')'];
    return [sbTemp description];
  }
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
}

- (GeogebraCommonKernelArithmeticFunction *)getFunWithInt:(jint)i {
  return IOSObjectArray_Get(nil_chk(fun_), i);
}

- (void)update {
  [super update];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->funExpanded_))->size_; i++) {
    IOSObjectArray_Set(self->funExpanded_, i, nil);
  }
}

- (IOSObjectArray *)getFunctionVariables {
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) getFunctionVariables];
}

- (NSString *)getVarStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) getVarStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (void)setUsingCasCommandWithNSString:(NSString *)ggbCasCmd
withGeogebraCommonKernelGeosCasEvaluableFunction:(id<GeogebraCommonKernelGeosCasEvaluableFunction>)f
                           withBoolean:(jboolean)symbolic
withGeogebraCommonKernelArithmeticMyArbitraryConstant:(GeogebraCommonKernelArithmeticMyArbitraryConstant *)arbconst {
  GeogebraCommonKernelKernelNDGeoCurveCartesianND *c = (GeogebraCommonKernelKernelNDGeoCurveCartesianND *) check_class_cast(f, [GeogebraCommonKernelKernelNDGeoCurveCartesianND class]);
  if (GeogebraCommonKernelKernelNDGeoCurveCartesianND_isDefined(nil_chk(c))) {
    GeogebraCommonKernelGeosGeoNumeric *geo = [new_GeogebraCommonKernelGeosGeoNumeric_initWithGeogebraCommonKernelConstruction_(self->cons_) autorelease];
    [((GeogebraCommonKernelConstruction *) nil_chk(self->cons_)) addLocalVariableWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) getVarStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()] withGeogebraCommonKernelGeosGeoElement:geo];
    self->isDefined__ = YES;
    for (jint k = 0; k < [self getDimension]; k++) {
      [self setFunWithInt:k withGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *) check_class_cast([((GeogebraCommonKernelArithmeticFunction *) nil_chk([c getFunExpandedWithInt:k])) evalCasCommandWithNSString:ggbCasCmd withBoolean:symbolic withGeogebraCommonKernelArithmeticMyArbitraryConstant:arbconst], [GeogebraCommonKernelArithmeticFunction class])];
      self->isDefined__ = (self->isDefined__ && [self getFunWithInt:k] != nil);
    }
    [self->cons_ removeLocalVariableWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:0])) getVarStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]];
    if (self->isDefined__) [self setIntervalWithDouble:c->startParam_ withDouble:c->endParam_];
  }
  else {
    self->isDefined__ = NO;
  }
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_set_distFun_(self, nil);
}

- (void)clearCasEvalMapWithNSString:(NSString *)key {
  for (jint k = 0; k < [self getDimension]; k++) {
    [((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:k])) clearCasEvalMapWithNSString:key];
  }
}

- (void)setFunWithInt:(jint)i
withGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)f {
  IOSObjectArray_Set(nil_chk(self->fun_), i, f);
  IOSObjectArray_Set(nil_chk(self->funExpanded_), i, nil);
  *IOSBooleanArray_GetRef(nil_chk(self->containsFunctions_), i) = GeogebraCommonKernelAlgosAlgoDependentFunction_containsFunctionsWithGeogebraCommonKernelArithmeticExpressionValue_([((GeogebraCommonKernelArithmeticFunction *) nil_chk(IOSObjectArray_Get(self->fun_, i))) getExpression]);
}

- (GeogebraCommonKernelArithmeticFunction *)getFunExpandedWithInt:(jint)i {
  if (!IOSBooleanArray_Get(nil_chk(self->containsFunctions_), i)) {
    return [self getFunWithInt:i];
  }
  if (IOSObjectArray_Get(nil_chk(self->funExpanded_), i) == nil) {
    IOSObjectArray_SetAndConsume(self->funExpanded_, i, new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelKernel_([self getFunWithInt:i], self->kernel_));
    GeogebraCommonKernelArithmeticExpressionNode *expr = [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(GeogebraCommonKernelAlgosAlgoDependentFunction_expandFunctionDerivativeNodesWithGeogebraCommonKernelArithmeticExpressionValue_([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk([((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:i])) getExpression])) deepCopyWithGeogebraCommonKernelKernel:self->kernel_]))) wrap];
    [((GeogebraCommonKernelArithmeticFunction *) nil_chk(IOSObjectArray_Get(self->funExpanded_, i))) setExpressionWithGeogebraCommonKernelArithmeticExpressionNode:expr];
  }
  return IOSObjectArray_Get(self->funExpanded_, i);
}

- (void)setDerivativeWithGeogebraCommonKernelKernelNDGeoCurveCartesianND:(GeogebraCommonKernelKernelNDGeoCurveCartesianND *)curve
                                                                 withInt:(jint)n {
  if (GeogebraCommonKernelKernelNDGeoCurveCartesianND_isDefined(nil_chk(curve))) {
    self->isDefined__ = YES;
    for (jint k = 0; k < [self getDimension]; k++) {
      [self setFunWithInt:k withGeogebraCommonKernelArithmeticFunction:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([curve getFunWithInt:k])) getDerivativeWithInt:n withBoolean:YES]];
      self->isDefined__ = (self->isDefined__ && [self getFunWithInt:k] != nil);
    }
    if (self->isDefined__) [self setIntervalWithDouble:curve->startParam_ withDouble:curve->endParam_];
  }
  else {
    self->isDefined__ = NO;
  }
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_set_distFun_(self, nil);
}

- (jint)getDimension {
  return ((IOSObjectArray *) nil_chk(self->fun_))->size_;
}

- (NSString *)getVariableWithInt:(jint)n {
  if (n < [self getDimension] && n >= 0) {
    switch (n) {
      case 0:
      return @"x";
      case 1:
      return @"y";
      case 2:
      return @"z";
    }
  }
  GeogebraCommonUtilDebugLog_debugWithNSString_(@"problem with variable number");
  return @"";
}

- (jdouble)getClosestParameterWithGeogebraCommonKernelKernelNDGeoPointND:(id<GeogebraCommonKernelKernelNDGeoPointND>)a
                                                              withDouble:(jdouble)minParameter {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jdouble)evaluateCurvatureWithDouble:(jdouble)t {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jboolean)isHiddenRange {
  return self->hideRangeInFormula_;
}

- (void)setHideRangeInFormulaWithBoolean:(jboolean)b {
  self->hideRangeInFormula_ = b;
}

- (jboolean)isLaTeXDrawableGeo {
  return YES;
}

- (NSString *)toLaTeXStringWithBoolean:(jboolean)symbolic
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (self->isDefined__) {
    JavaLangStringBuilder *sbTemp = [new_JavaLangStringBuilder_initWithInt_(80) autorelease];
    NSString *param = [self getVarStringWithGeogebraCommonKernelStringTemplate:tpl];
    if ([((GeogebraCommonMainApp *) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getApplication])) isHTML5Applet]) {
      if (!hideRangeInFormula_) {
        [sbTemp appendWithNSString:@"\\closebraceonly{ "];
      }
      [sbTemp appendWithNSString:@"\\ggbtable{"];
      for (jint i = 0; i < [self getDimension]; i++) {
        [sbTemp appendWithNSString:@"\\ggbtr{ \\ggbtdL{  "];
        [sbTemp appendWithNSString:[self getVariableWithInt:i]];
        [sbTemp appendWithNSString:@" = "];
        [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:i])) toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl]];
        [sbTemp appendWithNSString:@"} }"];
      }
      [sbTemp appendWithNSString:@"}"];
      if (!hideRangeInFormula_) {
        [sbTemp appendWithNSString:@"}"];
        [sbTemp appendWithNSString:[self->kernel_ formatWithDouble:self->startParam_ withGeogebraCommonKernelStringTemplate:tpl]];
        [sbTemp appendWithNSString:@" \\le "];
        [sbTemp appendWithNSString:param];
        [sbTemp appendWithNSString:@" \\le "];
        [sbTemp appendWithNSString:[self->kernel_ formatWithDouble:self->endParam_ withGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    else {
      if (!hideRangeInFormula_) {
        [sbTemp appendWithNSString:@"\\left."];
      }
      [sbTemp appendWithNSString:@"\\begin{array}{lll}"];
      for (jint i = 0; i < [self getDimension]; i++) {
        if (i > 0) {
          [sbTemp appendWithNSString:@"\\\\ "];
        }
        [sbTemp appendWithNSString:[self getVariableWithInt:i]];
        [sbTemp appendWithNSString:@" = "];
        [sbTemp appendWithNSString:[((GeogebraCommonKernelArithmeticFunction *) nil_chk([self getFunWithInt:i])) toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl]];
      }
      [sbTemp appendWithNSString:@" \\end{array}"];
      if (!hideRangeInFormula_) {
        [sbTemp appendWithNSString:@"\\right\\} \\; "];
        [sbTemp appendWithNSString:[self->kernel_ formatWithDouble:self->startParam_ withGeogebraCommonKernelStringTemplate:tpl]];
        [sbTemp appendWithNSString:@" \\le "];
        [sbTemp appendWithNSString:param];
        [sbTemp appendWithNSString:@" \\le "];
        [sbTemp appendWithNSString:[self->kernel_ formatWithDouble:self->endParam_ withGeogebraCommonKernelStringTemplate:tpl]];
      }
    }
    return [sbTemp description];
  }
  return JreStrcat("$$$", @" \\text{", [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"], @"} ");
}

- (GeogebraCommonKernelKernelNDGeoCurveCartesianND *)getGeoDerivativeWithInt:(jint)order {
  if (self->derivGeoFun_ == nil) {
    GeogebraCommonKernelKernelNDGeoCurveCartesianND_set_derivGeoFun_(self, [self newGeoCurveCartesianWithGeogebraCommonKernelConstruction:self->cons_]);
  }
  [((GeogebraCommonKernelKernelNDGeoCurveCartesianND *) nil_chk(self->derivGeoFun_)) setDerivativeWithGeogebraCommonKernelKernelNDGeoCurveCartesianND:self withInt:order];
  return self->derivGeoFun_;
}

- (GeogebraCommonKernelKernelNDGeoCurveCartesianND *)newGeoCurveCartesianWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id<GeogebraCommonKernelArithmeticExpressionValue>)evaluateCurveWithDouble:(jdouble)double1 {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (void)dealloc {
  RELEASE_(fun_);
  RELEASE_(funExpanded_);
  RELEASE_(containsFunctions_);
  RELEASE_(funD1_);
  RELEASE_(funD2_);
  RELEASE_(distFun_);
  RELEASE_(derivGeoFun_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withInt:", "GeoCurveCartesianND", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:withGeogebraCommonKernelArithmeticFunctionArray:", "GeoCurveCartesianND", NULL, 0x1, NULL, NULL },
    { "setFunWithGeogebraCommonKernelArithmeticFunctionArray:", "setFun", "V", 0x1, NULL, NULL },
    { "isGeoCurveCartesian", NULL, "Z", 0x1, NULL, NULL },
    { "replaceChildrenByValuesWithGeogebraCommonKernelGeosGeoElement:", "replaceChildrenByValues", "V", 0x1, NULL, NULL },
    { "setIntervalWithDouble:withDouble:", "setInterval", "V", 0x1, NULL, NULL },
    { "getMinParameter", NULL, "D", 0x1, NULL, NULL },
    { "getMaxParameter", NULL, "D", 0x1, NULL, NULL },
    { "getXMLtagsWithJavaLangStringBuilder:", "getXMLtags", "V", 0x4, NULL, NULL },
    { "isPath", NULL, "Z", 0x1, NULL, NULL },
    { "isDefined", NULL, "Z", 0x11, NULL, NULL },
    { "setDefinedWithBoolean:", "setDefined", "V", 0x1, NULL, NULL },
    { "setUndefined", NULL, "V", 0x1, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toSymbolicStringWithGeogebraCommonKernelStringTemplate:", "toSymbolicString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getFunWithInt:", "getFun", "Lgeogebra.common.kernel.arithmetic.Function;", 0x1, NULL, NULL },
    { "update", NULL, "V", 0x11, NULL, NULL },
    { "getFunctionVariables", NULL, "[Lgeogebra.common.kernel.arithmetic.FunctionVariable;", 0x1, NULL, NULL },
    { "getVarStringWithGeogebraCommonKernelStringTemplate:", "getVarString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "setUsingCasCommandWithNSString:withGeogebraCommonKernelGeosCasEvaluableFunction:withBoolean:withGeogebraCommonKernelArithmeticMyArbitraryConstant:", "setUsingCasCommand", "V", 0x1, NULL, NULL },
    { "clearCasEvalMapWithNSString:", "clearCasEvalMap", "V", 0x1, NULL, NULL },
    { "setFunWithInt:withGeogebraCommonKernelArithmeticFunction:", "setFun", "V", 0x4, NULL, NULL },
    { "getFunExpandedWithInt:", "getFunExpanded", "Lgeogebra.common.kernel.arithmetic.Function;", 0x4, NULL, NULL },
    { "setDerivativeWithGeogebraCommonKernelKernelNDGeoCurveCartesianND:withInt:", "setDerivative", "V", 0x1, NULL, NULL },
    { "getDimension", NULL, "I", 0x1, NULL, NULL },
    { "getVariableWithInt:", "getVariable", "Ljava.lang.String;", 0x4, NULL, NULL },
    { "getClosestParameterWithGeogebraCommonKernelKernelNDGeoPointND:withDouble:", "getClosestParameter", "D", 0x401, NULL, NULL },
    { "evaluateCurvatureWithDouble:", "evaluateCurvature", "D", 0x401, NULL, NULL },
    { "isHiddenRange", NULL, "Z", 0x1, NULL, NULL },
    { "setHideRangeInFormulaWithBoolean:", "setHideRangeInFormula", "V", 0x1, NULL, NULL },
    { "isLaTeXDrawableGeo", NULL, "Z", 0x1, NULL, NULL },
    { "toLaTeXStringWithBoolean:withGeogebraCommonKernelStringTemplate:", "toLaTeXString", "Ljava.lang.String;", 0x11, NULL, NULL },
    { "getGeoDerivativeWithInt:", "getGeoDerivative", "Lgeogebra.common.kernel.kernelND.GeoCurveCartesianND;", 0x1, NULL, NULL },
    { "newGeoCurveCartesianWithGeogebraCommonKernelConstruction:", "newGeoCurveCartesian", "Lgeogebra.common.kernel.kernelND.GeoCurveCartesianND;", 0x404, NULL, NULL },
    { "evaluateCurveWithDouble:", "evaluateCurve", "Lgeogebra.common.kernel.arithmetic.ExpressionValue;", 0x401, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "CLOSEST_PARAMETER_SAMPLES_", NULL, 0x1c, "I", NULL, NULL, .constantValue.asInt = GeogebraCommonKernelKernelNDGeoCurveCartesianND_CLOSEST_PARAMETER_SAMPLES },
    { "fun_", NULL, 0x14, "[Lgeogebra.common.kernel.arithmetic.Function;", NULL, NULL,  },
    { "funExpanded_", NULL, 0x14, "[Lgeogebra.common.kernel.arithmetic.Function;", NULL, NULL,  },
    { "containsFunctions_", NULL, 0x14, "[Z", NULL, NULL,  },
    { "funD1_", NULL, 0x4, "[Lgeogebra.common.kernel.arithmetic.Function;", NULL, NULL,  },
    { "funD2_", NULL, 0x4, "[Lgeogebra.common.kernel.arithmetic.Function;", NULL, NULL,  },
    { "startParam_", NULL, 0x4, "D", NULL, NULL,  },
    { "endParam_", NULL, 0x4, "D", NULL, NULL,  },
    { "isDefined__", "isDefined", 0x4, "Z", NULL, NULL,  },
    { "distFun_", NULL, 0x4, "Lgeogebra.common.kernel.DistanceFunction;", NULL, NULL,  },
    { "hideRangeInFormula_", NULL, 0x2, "Z", NULL, NULL,  },
    { "derivGeoFun_", NULL, 0x4, "Lgeogebra.common.kernel.kernelND.GeoCurveCartesianND;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelKernelNDGeoCurveCartesianND = { 2, "GeoCurveCartesianND", "geogebra.common.kernel.kernelND", NULL, 0x401, 36, methods, 12, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelKernelNDGeoCurveCartesianND;
}

@end

void GeogebraCommonKernelKernelNDGeoCurveCartesianND_initWithGeogebraCommonKernelConstruction_withInt_(GeogebraCommonKernelKernelNDGeoCurveCartesianND *self, GeogebraCommonKernelConstruction *c, jint dimension) {
  GeogebraCommonKernelGeosGeoElement_initWithGeogebraCommonKernelConstruction_(self, c);
  self->isDefined__ = YES;
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_setAndConsume_fun_(self, [IOSObjectArray newArrayWithLength:dimension type:GeogebraCommonKernelArithmeticFunction_class_()]);
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_setAndConsume_funExpanded_(self, [IOSObjectArray newArrayWithLength:dimension type:GeogebraCommonKernelArithmeticFunction_class_()]);
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_setAndConsume_containsFunctions_(self, [IOSBooleanArray newArrayWithLength:dimension]);
  [self setConstructionDefaults];
}

void GeogebraCommonKernelKernelNDGeoCurveCartesianND_initWithGeogebraCommonKernelConstruction_withGeogebraCommonKernelArithmeticFunctionArray_(GeogebraCommonKernelKernelNDGeoCurveCartesianND *self, GeogebraCommonKernelConstruction *c, IOSObjectArray *fun) {
  GeogebraCommonKernelGeosGeoElement_initWithGeogebraCommonKernelConstruction_(self, c);
  self->isDefined__ = YES;
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_set_fun_(self, fun);
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_setAndConsume_funExpanded_(self, [IOSObjectArray newArrayWithLength:((IOSObjectArray *) nil_chk(fun))->size_ type:GeogebraCommonKernelArithmeticFunction_class_()]);
  GeogebraCommonKernelKernelNDGeoCurveCartesianND_setAndConsume_containsFunctions_(self, [IOSBooleanArray newArrayWithLength:fun->size_]);
  [self setConstructionDefaults];
}

jboolean GeogebraCommonKernelKernelNDGeoCurveCartesianND_isDefined(GeogebraCommonKernelKernelNDGeoCurveCartesianND *self) {
  return self->isDefined__;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelKernelNDGeoCurveCartesianND)
