//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/kernel/geos/GeoInterval.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/kernel/Construction.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/StringTemplate.h"
#include "geogebra/common/kernel/algos/AlgoElement.h"
#include "geogebra/common/kernel/algos/AlgoMacroInterface.h"
#include "geogebra/common/kernel/algos/ConstructionElement.h"
#include "geogebra/common/kernel/arithmetic/ExpressionNode.h"
#include "geogebra/common/kernel/arithmetic/ExpressionValue.h"
#include "geogebra/common/kernel/arithmetic/Function.h"
#include "geogebra/common/kernel/arithmetic/FunctionVariable.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/geos/GeoFunction.h"
#include "geogebra/common/kernel/geos/GeoInterval.h"
#include "geogebra/common/main/Localization.h"
#include "geogebra/common/plugin/GeoClass.h"
#include "geogebra/common/plugin/Operation.h"
#include "geogebra/common/util/Unicode.h"
#include "java/lang/Double.h"
#include "java/lang/StringBuilder.h"

@interface GeogebraCommonKernelGeosGeoInterval () {
 @public
  JavaLangStringBuilder *sbToString2_;
  IOSDoubleArray *leftRightBoundsField_;
  IOSObjectArray *leftRightStrField_;
  IOSCharArray *leftRightInequalityField_;
}

- (NSString *)toStringWithBoolean:(jboolean)symbolic
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl;

- (void)updateBoundaries;

+ (jdouble)setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)nv
                                                       withNSStringArray:(IOSObjectArray *)leftRightStr;

+ (jdouble)setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)nv
                                                        withNSStringArray:(IOSObjectArray *)leftRightStr;

@end

J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoInterval, sbToString2_, JavaLangStringBuilder *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoInterval, leftRightBoundsField_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoInterval, leftRightStrField_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(GeogebraCommonKernelGeosGeoInterval, leftRightInequalityField_, IOSCharArray *)

__attribute__((unused)) static void GeogebraCommonKernelGeosGeoInterval_updateBoundaries(GeogebraCommonKernelGeosGeoInterval *self);

__attribute__((unused)) static jdouble GeogebraCommonKernelGeosGeoInterval_setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(id<GeogebraCommonKernelArithmeticExpressionValue> nv, IOSObjectArray *leftRightStr);

__attribute__((unused)) static jdouble GeogebraCommonKernelGeosGeoInterval_setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(id<GeogebraCommonKernelArithmeticExpressionValue> nv, IOSObjectArray *leftRightStr);

@implementation GeogebraCommonKernelGeosGeoInterval

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)c
                                            withNSString:(NSString *)label
              withGeogebraCommonKernelArithmeticFunction:(GeogebraCommonKernelArithmeticFunction *)f {
  GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(self, c, label, f);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelGeosGeoInterval:(GeogebraCommonKernelGeosGeoInterval *)geoInterval {
  GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelGeosGeoInterval_(self, geoInterval);
  return self;
}

- (instancetype)initWithGeogebraCommonKernelConstruction:(GeogebraCommonKernelConstruction *)cons {
  GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelConstruction_(self, cons);
  return self;
}

- (GeogebraCommonKernelGeosGeoElement *)copy__ {
  return [new_GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelGeosGeoInterval_(self) autorelease];
}

- (void)setWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  GeogebraCommonKernelGeosGeoInterval *geoFun = (GeogebraCommonKernelGeosGeoInterval *) check_class_cast(geo, [GeogebraCommonKernelGeosGeoInterval class]);
  if (geo == nil || ((GeogebraCommonKernelGeosGeoInterval *) nil_chk(geoFun))->fun_ == nil) {
    GeogebraCommonKernelGeosGeoFunction_set_fun_(self, nil);
    isDefined__ = NO;
    return;
  }
  isDefined__ = ((GeogebraCommonKernelGeosGeoInterval *) nil_chk(geoFun))->isDefined__;
  GeogebraCommonKernelGeosGeoFunction_setAndConsume_fun_(self, new_GeogebraCommonKernelArithmeticFunction_initWithGeogebraCommonKernelArithmeticFunction_withGeogebraCommonKernelKernel_(geoFun->fun_, kernel_));
  if (((GeogebraCommonKernelGeosGeoElement *) nil_chk(geo))->cons_ != cons_ && [self isAlgoMacroOutput]) {
    if (![geoFun isIndependent]) {
      id<GeogebraCommonKernelAlgosAlgoMacroInterface> algoMacro = (id<GeogebraCommonKernelAlgosAlgoMacroInterface>) check_protocol_cast([self getParentAlgorithm], @protocol(GeogebraCommonKernelAlgosAlgoMacroInterface));
      [((id<GeogebraCommonKernelAlgosAlgoMacroInterface>) nil_chk(algoMacro)) initFunctionWithGeogebraCommonKernelArithmeticFunctionNVar:self->fun_];
    }
  }
}

- (GeogebraCommonPluginGeoClassEnum *)getGeoClassType {
  return GeogebraCommonPluginGeoClassEnum_get_INTERVAL();
}

- (NSString *)toStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (sbToString2_ == nil) GeogebraCommonKernelGeosGeoInterval_setAndConsume_sbToString2_(self, new_JavaLangStringBuilder_init());
  else [sbToString2_ setLengthWithInt:0];
  if ([self isLabelSet]) {
    [((JavaLangStringBuilder *) nil_chk(sbToString2_)) appendWithNSString:label_];
    [sbToString2_ appendWithNSString:@": "];
  }
  [((JavaLangStringBuilder *) nil_chk(sbToString2_)) appendWithNSString:[self toSymbolicStringWithGeogebraCommonKernelStringTemplate:tpl]];
  return [sbToString2_ description];
}

- (NSString *)toValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [self toStringWithBoolean:NO withGeogebraCommonKernelStringTemplate:tpl];
}

- (NSString *)toStringWithBoolean:(jboolean)symbolic
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if (![self isDefined]) {
    return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
  }
  GeogebraCommonKernelArithmeticExpressionNode *en = [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) getExpression];
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en)) getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_AND()] || [((GeogebraCommonPluginOperationEnum *) nil_chk([en getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_AND_INTERVAL()]) {
    id<GeogebraCommonKernelArithmeticExpressionValue> left = [en getLeft];
    id<GeogebraCommonKernelArithmeticExpressionValue> right = [en getRight];
    if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(left)) isExpressionNode] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(right)) isExpressionNode]) {
      GeogebraCommonKernelGeosGeoInterval_updateBoundaries(self);
      if (!JavaLangDouble_isNaNWithDouble_(IOSDoubleArray_Get(nil_chk(leftRightBoundsField_), 1)) && !JavaLangDouble_isNaNWithDouble_(IOSDoubleArray_Get(leftRightBoundsField_, 0)) && IOSDoubleArray_Get(leftRightBoundsField_, 0) <= IOSDoubleArray_Get(leftRightBoundsField_, 1)) {
        [((JavaLangStringBuilder *) nil_chk(sbToString_)) setLengthWithInt:0];
        [sbToString_ appendWithNSString:symbolic ? IOSObjectArray_Get(nil_chk(leftRightStrField_), 0) : [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatWithDouble:IOSDoubleArray_Get(leftRightBoundsField_, 0) withGeogebraCommonKernelStringTemplate:tpl]];
        [sbToString_ appendWithChar:' '];
        [sbToString_ appendWithChar:IOSCharArray_Get(nil_chk(leftRightInequalityField_), 0)];
        [sbToString_ appendWithChar:' '];
        [sbToString_ appendWithNSString:[self getVarStringWithGeogebraCommonKernelStringTemplate:tpl]];
        [sbToString_ appendWithChar:' '];
        [sbToString_ appendWithChar:IOSCharArray_Get(leftRightInequalityField_, 1)];
        [sbToString_ appendWithChar:' '];
        [sbToString_ appendWithNSString:symbolic ? IOSObjectArray_Get(nil_chk(leftRightStrField_), 1) : [((GeogebraCommonKernelKernel *) nil_chk(kernel_)) formatWithDouble:IOSDoubleArray_Get(leftRightBoundsField_, 1) withGeogebraCommonKernelStringTemplate:tpl]];
        return [sbToString_ description];
      }
    }
  }
  return symbolic ? [super toSymbolicStringWithGeogebraCommonKernelStringTemplate:tpl] : [super toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (void)updateBoundaries {
  GeogebraCommonKernelGeosGeoInterval_updateBoundaries(self);
}

- (NSString *)toSymbolicStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if ([self isDefined]) {
    return [self toStringWithBoolean:YES withGeogebraCommonKernelStringTemplate:tpl];
  }
  return [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"];
}

- (NSString *)toLaTeXStringWithBoolean:(jboolean)symbolic
withGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  if ([self isDefined]) {
    return [((GeogebraCommonKernelArithmeticFunction *) nil_chk(fun_)) toLaTeXStringWithBoolean:symbolic withGeogebraCommonKernelStringTemplate:tpl];
  }
  return JreStrcat("$$$", @" \\text{", [((GeogebraCommonMainLocalization *) nil_chk([self getLoc])) getPlainWithNSString:@"Undefined"], @"} ");
}

- (jboolean)isEqualWithGeogebraCommonKernelGeosGeoElement:(GeogebraCommonKernelGeosGeoElement *)geo {
  return NO;
}

+ (void)updateBoundariesWithGeogebraCommonKernelArithmeticExpressionNode:(GeogebraCommonKernelArithmeticExpressionNode *)en
                                                         withDoubleArray:(IOSDoubleArray *)leftRightDouble
                                                       withNSStringArray:(IOSObjectArray *)leftRightStr
                                                           withCharArray:(IOSCharArray *)leftRightInequalityChar {
  GeogebraCommonKernelGeosGeoInterval_updateBoundariesWithGeogebraCommonKernelArithmeticExpressionNode_withDoubleArray_withNSStringArray_withCharArray_(en, leftRightDouble, leftRightStr, leftRightInequalityChar);
}

+ (jdouble)setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)nv
                                                       withNSStringArray:(IOSObjectArray *)leftRightStr {
  return GeogebraCommonKernelGeosGeoInterval_setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(nv, leftRightStr);
}

+ (jdouble)setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue:(id<GeogebraCommonKernelArithmeticExpressionValue>)nv
                                                        withNSStringArray:(IOSObjectArray *)leftRightStr {
  return GeogebraCommonKernelGeosGeoInterval_setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(nv, leftRightStr);
}

- (jdouble)getMin {
  GeogebraCommonKernelGeosGeoInterval_updateBoundaries(self);
  return IOSDoubleArray_Get(nil_chk(leftRightBoundsField_), 0);
}

- (jdouble)getMax {
  GeogebraCommonKernelGeosGeoInterval_updateBoundaries(self);
  return IOSDoubleArray_Get(nil_chk(leftRightBoundsField_), 1);
}

- (jdouble)getMidPoint {
  GeogebraCommonKernelGeosGeoInterval_updateBoundaries(self);
  return (IOSDoubleArray_Get(nil_chk(leftRightBoundsField_), 1) + IOSDoubleArray_Get(leftRightBoundsField_, 0)) / 2;
}

- (jboolean)isGeoInterval {
  return YES;
}

- (NSString *)toOutputValueStringWithGeogebraCommonKernelStringTemplate:(GeogebraCommonKernelStringTemplate *)tpl {
  return [self toValueStringWithGeogebraCommonKernelStringTemplate:tpl];
}

- (jint)getMinimumLineThickness {
  return 0;
}

- (void)dealloc {
  RELEASE_(sbToString2_);
  RELEASE_(leftRightBoundsField_);
  RELEASE_(leftRightStrField_);
  RELEASE_(leftRightInequalityField_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonKernelConstruction:withNSString:withGeogebraCommonKernelArithmeticFunction:", "GeoInterval", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelGeosGeoInterval:", "GeoInterval", NULL, 0x1, NULL, NULL },
    { "initWithGeogebraCommonKernelConstruction:", "GeoInterval", NULL, 0x1, NULL, NULL },
    { "copy__", "copy", "Lgeogebra.common.kernel.geos.GeoElement;", 0x1, NULL, NULL },
    { "setWithGeogebraCommonKernelGeosGeoElement:", "set", "V", 0x1, NULL, NULL },
    { "getGeoClassType", NULL, "Lgeogebra.common.plugin.GeoClass;", 0x1, NULL, NULL },
    { "toStringWithGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toValueStringWithGeogebraCommonKernelStringTemplate:", "toValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toStringWithBoolean:withGeogebraCommonKernelStringTemplate:", "toString", "Ljava.lang.String;", 0x2, NULL, NULL },
    { "updateBoundaries", NULL, "V", 0x2, NULL, NULL },
    { "toSymbolicStringWithGeogebraCommonKernelStringTemplate:", "toSymbolicString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "toLaTeXStringWithBoolean:withGeogebraCommonKernelStringTemplate:", "toLaTeXString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "isEqualWithGeogebraCommonKernelGeosGeoElement:", "isEqual", "Z", 0x1, NULL, NULL },
    { "updateBoundariesWithGeogebraCommonKernelArithmeticExpressionNode:withDoubleArray:withNSStringArray:withCharArray:", "updateBoundaries", "V", 0x9, NULL, NULL },
    { "setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue:withNSStringArray:", "setLeftBound", "D", 0xa, NULL, NULL },
    { "setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue:withNSStringArray:", "setRightBound", "D", 0xa, NULL, NULL },
    { "getMin", NULL, "D", 0x1, NULL, NULL },
    { "getMax", NULL, "D", 0x1, NULL, NULL },
    { "getMidPoint", NULL, "D", 0x1, NULL, NULL },
    { "isGeoInterval", NULL, "Z", 0x1, NULL, NULL },
    { "toOutputValueStringWithGeogebraCommonKernelStringTemplate:", "toOutputValueString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "getMinimumLineThickness", NULL, "I", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "sbToString2_", NULL, 0x2, "Ljava.lang.StringBuilder;", NULL, NULL,  },
    { "leftRightBoundsField_", NULL, 0x2, "[D", NULL, NULL,  },
    { "leftRightStrField_", NULL, 0x2, "[Ljava.lang.String;", NULL, NULL,  },
    { "leftRightInequalityField_", NULL, 0x2, "[C", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonKernelGeosGeoInterval = { 2, "GeoInterval", "geogebra.common.kernel.geos", NULL, 0x1, 22, methods, 4, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonKernelGeosGeoInterval;
}

@end

void GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelGeosGeoInterval *self, GeogebraCommonKernelConstruction *c, NSString *label, GeogebraCommonKernelArithmeticFunction *f) {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(self, c, label, f);
}

GeogebraCommonKernelGeosGeoInterval *new_GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(GeogebraCommonKernelConstruction *c, NSString *label, GeogebraCommonKernelArithmeticFunction *f) {
  GeogebraCommonKernelGeosGeoInterval *self = [GeogebraCommonKernelGeosGeoInterval alloc];
  GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelConstruction_withNSString_withGeogebraCommonKernelArithmeticFunction_(self, c, label, f);
  return self;
}

void GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelGeosGeoInterval_(GeogebraCommonKernelGeosGeoInterval *self, GeogebraCommonKernelGeosGeoInterval *geoInterval) {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(self, ((GeogebraCommonKernelGeosGeoInterval *) nil_chk(geoInterval))->cons_);
  [self setWithGeogebraCommonKernelGeosGeoElement:geoInterval];
}

GeogebraCommonKernelGeosGeoInterval *new_GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelGeosGeoInterval_(GeogebraCommonKernelGeosGeoInterval *geoInterval) {
  GeogebraCommonKernelGeosGeoInterval *self = [GeogebraCommonKernelGeosGeoInterval alloc];
  GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelGeosGeoInterval_(self, geoInterval);
  return self;
}

void GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelGeosGeoInterval *self, GeogebraCommonKernelConstruction *cons) {
  GeogebraCommonKernelGeosGeoFunction_initWithGeogebraCommonKernelConstruction_(self, cons);
}

GeogebraCommonKernelGeosGeoInterval *new_GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelConstruction_(GeogebraCommonKernelConstruction *cons) {
  GeogebraCommonKernelGeosGeoInterval *self = [GeogebraCommonKernelGeosGeoInterval alloc];
  GeogebraCommonKernelGeosGeoInterval_initWithGeogebraCommonKernelConstruction_(self, cons);
  return self;
}

void GeogebraCommonKernelGeosGeoInterval_updateBoundaries(GeogebraCommonKernelGeosGeoInterval *self) {
  if (self->leftRightBoundsField_ == nil) {
    GeogebraCommonKernelGeosGeoInterval_setAndConsume_leftRightBoundsField_(self, [IOSDoubleArray newArrayWithLength:2]);
    *IOSDoubleArray_GetRef(self->leftRightBoundsField_, 0) = JavaLangDouble_NaN;
    *IOSDoubleArray_GetRef(self->leftRightBoundsField_, 1) = JavaLangDouble_NaN;
  }
  if (self->leftRightStrField_ == nil) {
    GeogebraCommonKernelGeosGeoInterval_setAndConsume_leftRightStrField_(self, [IOSObjectArray newArrayWithLength:2 type:NSString_class_()]);
  }
  if (self->leftRightInequalityField_ == nil) {
    GeogebraCommonKernelGeosGeoInterval_setAndConsume_leftRightInequalityField_(self, [IOSCharArray newArrayWithLength:2]);
  }
  GeogebraCommonKernelGeosGeoInterval_updateBoundariesWithGeogebraCommonKernelArithmeticExpressionNode_withDoubleArray_withNSStringArray_withCharArray_([((GeogebraCommonKernelArithmeticFunction *) nil_chk(self->fun_)) getExpression], self->leftRightBoundsField_, self->leftRightStrField_, self->leftRightInequalityField_);
}

void GeogebraCommonKernelGeosGeoInterval_updateBoundariesWithGeogebraCommonKernelArithmeticExpressionNode_withDoubleArray_withNSStringArray_withCharArray_(GeogebraCommonKernelArithmeticExpressionNode *en, IOSDoubleArray *leftRightDouble, IOSObjectArray *leftRightStr, IOSCharArray *leftRightInequalityChar) {
  GeogebraCommonKernelGeosGeoInterval_initialize();
  jchar leftInequality, rightInequality;
  jdouble leftBound, rightBound;
  leftBound = IOSDoubleArray_Get(nil_chk(leftRightDouble), 0);
  rightBound = IOSDoubleArray_Get(leftRightDouble, 1);
  leftInequality = IOSCharArray_Get(nil_chk(leftRightInequalityChar), 0);
  rightInequality = IOSCharArray_Get(leftRightInequalityChar, 1);
  if ([((GeogebraCommonPluginOperationEnum *) nil_chk([((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(en)) getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_AND()] || [((GeogebraCommonPluginOperationEnum *) nil_chk([en getOperation])) isEqual:GeogebraCommonPluginOperationEnum_get_AND_INTERVAL()]) {
    id<GeogebraCommonKernelArithmeticExpressionValue> left = [en getLeft];
    id<GeogebraCommonKernelArithmeticExpressionValue> right = [en getRight];
    GeogebraCommonKernelArithmeticExpressionNode *enLeft = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(left, [GeogebraCommonKernelArithmeticExpressionNode class]);
    GeogebraCommonKernelArithmeticExpressionNode *enRight = (GeogebraCommonKernelArithmeticExpressionNode *) check_class_cast(right, [GeogebraCommonKernelArithmeticExpressionNode class]);
    GeogebraCommonPluginOperationEnum *opLeft = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(enLeft)) getOperation];
    GeogebraCommonPluginOperationEnum *opRight = [((GeogebraCommonKernelArithmeticExpressionNode *) nil_chk(enRight)) getOperation];
    id<GeogebraCommonKernelArithmeticExpressionValue> leftLeft = [enLeft getLeft];
    id<GeogebraCommonKernelArithmeticExpressionValue> leftRight = [enLeft getRight];
    id<GeogebraCommonKernelArithmeticExpressionValue> rightLeft = [enRight getLeft];
    id<GeogebraCommonKernelArithmeticExpressionValue> rightRight = [enRight getRight];
    if (([((GeogebraCommonPluginOperationEnum *) nil_chk(opLeft)) isEqual:GeogebraCommonPluginOperationEnum_get_LESS()] || [opLeft isEqual:GeogebraCommonPluginOperationEnum_get_LESS_EQUAL()])) {
      if ([leftLeft isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(leftRight)) isNumberValue]) {
        rightInequality = [opLeft isEqual:GeogebraCommonPluginOperationEnum_get_LESS()] ? '<' : GeogebraCommonUtilUnicode_LESS_EQUAL;
        rightBound = GeogebraCommonKernelGeosGeoInterval_setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(leftRight, leftRightStr);
      }
      else if ([leftRight isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(leftLeft)) isNumberValue]) {
        leftInequality = [opLeft isEqual:GeogebraCommonPluginOperationEnum_get_LESS()] ? '<' : GeogebraCommonUtilUnicode_LESS_EQUAL;
        leftBound = GeogebraCommonKernelGeosGeoInterval_setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(leftLeft, leftRightStr);
      }
    }
    else if (([opLeft isEqual:GeogebraCommonPluginOperationEnum_get_GREATER()] || [opLeft isEqual:GeogebraCommonPluginOperationEnum_get_GREATER_EQUAL()])) {
      if ([leftLeft isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(leftRight)) isNumberValue]) {
        leftInequality = [opLeft isEqual:GeogebraCommonPluginOperationEnum_get_GREATER()] ? '<' : GeogebraCommonUtilUnicode_LESS_EQUAL;
        leftBound = GeogebraCommonKernelGeosGeoInterval_setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(leftRight, leftRightStr);
      }
      else if ([leftRight isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(leftLeft)) isNumberValue]) {
        rightInequality = [opLeft isEqual:GeogebraCommonPluginOperationEnum_get_GREATER()] ? '<' : GeogebraCommonUtilUnicode_LESS_EQUAL;
        rightBound = GeogebraCommonKernelGeosGeoInterval_setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(leftLeft, leftRightStr);
      }
    }
    if (([((GeogebraCommonPluginOperationEnum *) nil_chk(opRight)) isEqual:GeogebraCommonPluginOperationEnum_get_LESS()] || [opRight isEqual:GeogebraCommonPluginOperationEnum_get_LESS_EQUAL()])) {
      if ([rightLeft isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rightRight)) isNumberValue]) {
        rightInequality = [opRight isEqual:GeogebraCommonPluginOperationEnum_get_LESS()] ? '<' : GeogebraCommonUtilUnicode_LESS_EQUAL;
        rightBound = GeogebraCommonKernelGeosGeoInterval_setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(rightRight, leftRightStr);
      }
      else if ([rightRight isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rightLeft)) isNumberValue]) {
        leftInequality = [opRight isEqual:GeogebraCommonPluginOperationEnum_get_LESS()] ? '<' : GeogebraCommonUtilUnicode_LESS_EQUAL;
        leftBound = GeogebraCommonKernelGeosGeoInterval_setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(rightLeft, leftRightStr);
      }
    }
    else if (([opRight isEqual:GeogebraCommonPluginOperationEnum_get_GREATER()] || [opRight isEqual:GeogebraCommonPluginOperationEnum_get_GREATER_EQUAL()])) {
      if ([rightLeft isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rightRight)) isNumberValue]) {
        leftInequality = [opRight isEqual:GeogebraCommonPluginOperationEnum_get_GREATER()] ? '<' : GeogebraCommonUtilUnicode_LESS_EQUAL;
        leftBound = GeogebraCommonKernelGeosGeoInterval_setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(rightRight, leftRightStr);
      }
      else if ([rightRight isKindOfClass:[GeogebraCommonKernelArithmeticFunctionVariable class]] && [((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(rightLeft)) isNumberValue]) {
        rightInequality = [opRight isEqual:GeogebraCommonPluginOperationEnum_get_GREATER()] ? '<' : GeogebraCommonUtilUnicode_LESS_EQUAL;
        rightBound = GeogebraCommonKernelGeosGeoInterval_setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(rightLeft, leftRightStr);
      }
    }
  }
  else {
    rightBound = JavaLangDouble_NaN;
    leftBound = JavaLangDouble_NaN;
  }
  if (rightBound < leftBound) {
    rightBound = JavaLangDouble_NaN;
    leftBound = JavaLangDouble_NaN;
  }
  *IOSDoubleArray_GetRef(leftRightDouble, 0) = leftBound;
  *IOSDoubleArray_GetRef(leftRightDouble, 1) = rightBound;
  *IOSCharArray_GetRef(leftRightInequalityChar, 0) = leftInequality;
  *IOSCharArray_GetRef(leftRightInequalityChar, 1) = rightInequality;
}

jdouble GeogebraCommonKernelGeosGeoInterval_setLeftBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(id<GeogebraCommonKernelArithmeticExpressionValue> nv, IOSObjectArray *leftRightStr) {
  GeogebraCommonKernelGeosGeoInterval_initialize();
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(nv)) isGeoElement]) {
    IOSObjectArray_Set(nil_chk(leftRightStr), 0, [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(nv, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
  }
  else {
    IOSObjectArray_Set(nil_chk(leftRightStr), 0, [nv toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
  }
  return [nv evaluateDouble];
}

jdouble GeogebraCommonKernelGeosGeoInterval_setRightBoundWithGeogebraCommonKernelArithmeticExpressionValue_withNSStringArray_(id<GeogebraCommonKernelArithmeticExpressionValue> nv, IOSObjectArray *leftRightStr) {
  GeogebraCommonKernelGeosGeoInterval_initialize();
  if ([((id<GeogebraCommonKernelArithmeticExpressionValue>) nil_chk(nv)) isGeoElement]) {
    IOSObjectArray_Set(nil_chk(leftRightStr), 1, [((GeogebraCommonKernelGeosGeoElement *) check_class_cast(nv, [GeogebraCommonKernelGeosGeoElement class])) getLabelWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
  }
  else {
    IOSObjectArray_Set(nil_chk(leftRightStr), 1, [nv toStringWithGeogebraCommonKernelStringTemplate:GeogebraCommonKernelStringTemplate_get_defaultTemplate_()]);
  }
  return [nv evaluateDouble];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonKernelGeosGeoInterval)
