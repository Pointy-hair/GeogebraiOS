//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/geogebra_iOS/geogebra/geogebra/common/src/geogebra/common/geogebra3D/euclidian3D/EuclidianController3DCompanion.java
//


#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "geogebra/common/awt/GPoint.h"
#include "geogebra/common/euclidian/EuclidianController.h"
#include "geogebra/common/euclidian/EuclidianView.h"
#include "geogebra/common/euclidian/Previewable.h"
#include "geogebra/common/euclidian/event/AbstractEvent.h"
#include "geogebra/common/geogebra3D/euclidian3D/EuclidianController3D.h"
#include "geogebra/common/geogebra3D/euclidian3D/EuclidianController3DCompanion.h"
#include "geogebra/common/geogebra3D/euclidian3D/EuclidianView3D.h"
#include "geogebra/common/geogebra3D/euclidianFor3D/EuclidianControllerFor3DCompanion.h"
#include "geogebra/common/geogebra3D/kernel3D/geos/GeoPlane3D.h"
#include "geogebra/common/geogebra3D/kernel3D/geos/GeoPoint3D.h"
#include "geogebra/common/kernel/Kernel.h"
#include "geogebra/common/kernel/Manager3DInterface.h"
#include "geogebra/common/kernel/Matrix/CoordMatrix4x4.h"
#include "geogebra/common/kernel/Matrix/Coords.h"
#include "geogebra/common/kernel/Path.h"
#include "geogebra/common/kernel/Region.h"
#include "geogebra/common/kernel/RegionParameters.h"
#include "geogebra/common/kernel/geos/GeoElement.h"
#include "geogebra/common/kernel/kernelND/GeoCoordSys2D.h"
#include "geogebra/common/kernel/kernelND/GeoPointND.h"
#include "geogebra/common/plugin/EuclidianStyleConstants.h"
#include "java/lang/Math.h"

@interface GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion () {
 @public
  GeogebraCommonKernelMatrixCoords *tmpCoords1_, *tmpCoords2_;
  GeogebraCommonKernelMatrixCoords *captureCoords_;
}

@end

J2OBJC_FIELD_SETTER(GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion, tmpCoords1_, GeogebraCommonKernelMatrixCoords *)
J2OBJC_FIELD_SETTER(GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion, tmpCoords2_, GeogebraCommonKernelMatrixCoords *)
J2OBJC_FIELD_SETTER(GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion, captureCoords_, GeogebraCommonKernelMatrixCoords *)

@implementation GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion

- (instancetype)initWithGeogebraCommonEuclidianEuclidianController:(GeogebraCommonEuclidianEuclidianController *)ec {
  GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion_initWithGeogebraCommonEuclidianEuclidianController_(self, ec);
  return self;
}

- (void)movePointWithBoolean:(jboolean)repaint
withGeogebraCommonEuclidianEventAbstractEvent:(GeogebraCommonEuclidianEventAbstractEvent *)event {
  if ([((GeogebraCommonEuclidianEuclidianController *) nil_chk(ec_))->movedGeoPoint_ isKindOfClass:[GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D class]]) {
    GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *movedGeoPoint3D = (GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) check_class_cast(ec_->movedGeoPoint_, [GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D class]);
    if ([((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk(movedGeoPoint3D)) hasPath]) {
      [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])) setMouseInformationWithGeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D:movedGeoPoint3D];
      [movedGeoPoint3D doPath];
      GeogebraCommonKernelMatrixCoords *coords = [movedGeoPoint3D getInhomCoordsInDWithInt:3];
      if ([self checkPointCapturingXYThenZWithGeogebraCommonKernelMatrixCoords:coords]) {
        [movedGeoPoint3D setWillingCoordsWithGeogebraCommonKernelMatrixCoords:coords];
        [movedGeoPoint3D setWillingDirectionUndefined];
        [movedGeoPoint3D doPath];
      }
    }
    else if ([movedGeoPoint3D hasRegion]) {
      [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])) setMouseInformationWithGeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D:movedGeoPoint3D];
      [movedGeoPoint3D doRegion];
      jboolean changed = NO;
      GeogebraCommonKernelMatrixCoords *coords = [movedGeoPoint3D getCoords];
      if ([movedGeoPoint3D getRegion] == [((GeogebraCommonKernelKernel *) nil_chk([ec_ getKernel])) getXOYPlane]) {
        changed = [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])) checkXYMinMaxWithGeogebraCommonKernelMatrixCoords:coords];
      }
      if ([self checkPointCapturingXYThenZWithGeogebraCommonKernelMatrixCoords:coords] || changed) {
        [movedGeoPoint3D setWillingCoordsWithGeogebraCommonKernelMatrixCoords:coords];
        [movedGeoPoint3D setWillingDirectionUndefined];
        [movedGeoPoint3D doRegion];
      }
      [((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk([((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_)) getCursor3D])) setMoveNormalDirectionWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelRegionParameters *) nil_chk([movedGeoPoint3D getRegionParameters])) getNormal]];
    }
    else {
      if ([((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(ec_->movedGeoPoint_)) getMoveMode] == GeogebraCommonKernelKernelNDGeoPointND_MOVE_MODE_Z || ([ec_->movedGeoPoint_ getMoveMode] == GeogebraCommonKernelKernelNDGeoPointND_MOVE_MODE_TOOL_DEFAULT && [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])) getPointMoveMode] == GeogebraCommonKernelKernelNDGeoPointND_MOVE_MODE_Z)) {
        GeogebraCommonKernelMatrixCoords *o = [((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_)) getPickPointWithGeogebraCommonAwtGPoint:ec_->mouseLoc_];
        [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_ toSceneCoords3DWithGeogebraCommonKernelMatrixCoords:o];
        [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])) addOffsetForTranslationWithGeogebraCommonKernelMatrixCoords:o];
        [((GeogebraCommonKernelMatrixCoords *) nil_chk([movedGeoPoint3D getCoords])) projectNearLineWithGeogebraCommonKernelMatrixCoords:o withGeogebraCommonKernelMatrixCoords:[((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_ getViewDirection] withGeogebraCommonKernelMatrixCoords:[((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])) getNormalTranslateDirection] withGeogebraCommonKernelMatrixCoords:tmpCoords1_];
        if ([ec_ getMoveMode] == GeogebraCommonEuclidianEuclidianController_MOVE_POINT) {
          if ([((GeogebraCommonKernelMatrixCoords *) nil_chk(tmpCoords1_)) getZ] > IOSDoubleArray_Get(nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->zMinMax_), 1)) [tmpCoords1_ setZWithDouble:IOSDoubleArray_Get(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->zMinMax_, 1)];
          else if ([tmpCoords1_ getZ] < IOSDoubleArray_Get(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->zMinMax_, 0)) [tmpCoords1_ setZWithDouble:IOSDoubleArray_Get(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->zMinMax_, 0)];
        }
        {
          jdouble z0;
          jdouble gz;
          jdouble z;
          switch ([((GeogebraCommonEuclidianEuclidianView *) nil_chk(ec_->view_)) getPointCapturingMode]) {
            case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_STICKY_POINTS:
            case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_AUTOMATIC:
            if (![ec_->view_ isGridOrAxesShown]) {
              break;
            }
            case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON:
            case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID:
            z0 = [((GeogebraCommonKernelMatrixCoords *) nil_chk(tmpCoords1_)) getZ];
            gz = [ec_->view_ getGridDistancesWithInt:2];
            z = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(z0, gz);
            if ([ec_->view_ getPointCapturingMode] == GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID || JavaLangMath_absWithDouble_(z - z0) < gz * [ec_ getPointCapturingPercentage]) {
              [tmpCoords1_ setZWithDouble:z];
            }
          }
        }
        [movedGeoPoint3D setCoordsWithGeogebraCommonKernelMatrixCoords:tmpCoords1_];
        [((GeogebraCommonKernelMatrixCoordMatrix4x4 *) nil_chk([((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])) getCurrentPlane])) setWithGeogebraCommonKernelMatrixCoords:[movedGeoPoint3D getCoords] withInt:4];
      }
      else {
        [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])) movePointOnCurrentPlaneWithGeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D:movedGeoPoint3D withBoolean:NO];
      }
      if ([ec_ getMoveMode] == GeogebraCommonEuclidianEuclidianController_MOVE_POINT) {
        [((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_)) updatePointDecorationsWithGeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D:movedGeoPoint3D];
      }
    }
    [((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk([((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_)) getCursor3D])) setCoordsWithGeogebraCommonKernelMatrixCoords:[movedGeoPoint3D getCoords] withBoolean:NO];
    [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_ updateMatrixForCursor3D];
    if (repaint) {
      [movedGeoPoint3D updateRepaint];
    }
    else {
      [movedGeoPoint3D updateCascade];
    }
    if ([((GeogebraCommonEuclidianEuclidianView *) nil_chk(ec_->view_)) getPreviewDrawable] != nil) [ec_->view_ updatePreviewable];
    ec_->movedGeoPointDragged_ = YES;
  }
  else {
    GeogebraCommonKernelMatrixCoords *o = [((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_)) getPickPointWithGeogebraCommonAwtGPoint:ec_->mouseLoc_];
    [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_ toSceneCoords3DWithGeogebraCommonKernelMatrixCoords:o];
    [((GeogebraCommonKernelMatrixCoords *) nil_chk(o)) projectPlaneThruVIfPossibleWithGeogebraCommonKernelMatrixCoordMatrix:GeogebraCommonKernelMatrixCoordMatrix4x4_get_IDENTITY_() withGeogebraCommonKernelMatrixCoords:[((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_ getViewDirection] withGeogebraCommonKernelMatrixCoords:tmpCoords1_ withGeogebraCommonKernelMatrixCoords:tmpCoords2_];
    [self checkPointCapturingXYWithGeogebraCommonKernelMatrixCoords:tmpCoords2_];
    ec_->xRW_ = [((GeogebraCommonKernelMatrixCoords *) nil_chk(tmpCoords2_)) getX];
    ec_->yRW_ = [tmpCoords2_ getY];
    [super movePointWithBoolean:repaint withGeogebraCommonEuclidianEventAbstractEvent:((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->mouseEvent_];
    [((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk([((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_ getCursor3D])) setCoordsWithGeogebraCommonKernelMatrixCoords:[((id<GeogebraCommonKernelKernelNDGeoPointND>) nil_chk(ec_->movedGeoPoint_)) getCoordsInD3] withBoolean:NO];
  }
}

- (jboolean)checkPointCapturingXYWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)coords {
  {
    jdouble x0;
    jdouble y0;
    jdouble gx;
    jdouble gy;
    jdouble x;
    jdouble y;
    switch ([((GeogebraCommonEuclidianEuclidianView *) nil_chk(((GeogebraCommonEuclidianEuclidianController *) nil_chk(ec_))->view_)) getPointCapturingMode]) {
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_STICKY_POINTS:
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_AUTOMATIC:
      if (![ec_->view_ isGridOrAxesShown]) {
        return NO;
      }
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON:
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID:
      x0 = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX];
      y0 = [coords getY];
      gx = [ec_->view_ getGridDistancesWithInt:0];
      gy = [ec_->view_ getGridDistancesWithInt:1];
      x = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(x0, gx);
      y = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(y0, gy);
      if ([ec_->view_ getPointCapturingMode] == GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID || (JavaLangMath_absWithDouble_(x - x0) < gx * [ec_ getPointCapturingPercentage] && JavaLangMath_absWithDouble_(y - y0) < gy * [ec_ getPointCapturingPercentage])) {
        [coords setXWithDouble:x];
        [coords setYWithDouble:y];
        return YES;
      }
      return NO;
    }
  }
  return NO;
}

- (jboolean)checkPointCapturingXYZWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)coords {
  {
    jdouble x0;
    jdouble y0;
    jdouble z0;
    jdouble gx;
    jdouble gy;
    jdouble gz;
    jdouble x;
    jdouble y;
    jdouble z;
    switch ([((GeogebraCommonEuclidianEuclidianView *) nil_chk(((GeogebraCommonEuclidianEuclidianController *) nil_chk(ec_))->view_)) getPointCapturingMode]) {
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_STICKY_POINTS:
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_AUTOMATIC:
      if (![ec_->view_ isGridOrAxesShown]) {
        return NO;
      }
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON:
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID:
      x0 = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX];
      y0 = [coords getY];
      z0 = [coords getZ];
      gx = [ec_->view_ getGridDistancesWithInt:0];
      gy = [ec_->view_ getGridDistancesWithInt:1];
      gz = [ec_->view_ getGridDistancesWithInt:2];
      x = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(x0, gx);
      y = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(y0, gy);
      z = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(z0, gz);
      if ([ec_->view_ getPointCapturingMode] == GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID || (JavaLangMath_absWithDouble_(x - x0) < gx * [ec_ getPointCapturingPercentage] && JavaLangMath_absWithDouble_(y - y0) < gy * [ec_ getPointCapturingPercentage] && JavaLangMath_absWithDouble_(z - z0) < gz * [ec_ getPointCapturingPercentage])) {
        [coords setXWithDouble:x];
        [coords setYWithDouble:y];
        [coords setZWithDouble:z];
        return YES;
      }
      return NO;
    }
  }
  return NO;
}

- (jboolean)checkPointCapturingXYThenZWithGeogebraCommonKernelMatrixCoords:(GeogebraCommonKernelMatrixCoords *)coords {
  {
    jdouble x0;
    jdouble y0;
    jdouble z0;
    jdouble gx;
    jdouble gy;
    jdouble gz;
    jdouble x;
    jdouble y;
    jdouble z;
    switch ([((GeogebraCommonEuclidianEuclidianView *) nil_chk(((GeogebraCommonEuclidianEuclidianController *) nil_chk(ec_))->view_)) getPointCapturingMode]) {
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_STICKY_POINTS:
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_AUTOMATIC:
      if (![ec_->view_ isGridOrAxesShown]) {
        return NO;
      }
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON:
      case GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID:
      x0 = [((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX];
      y0 = [coords getY];
      z0 = [coords getZ];
      gx = [ec_->view_ getGridDistancesWithInt:0];
      gy = [ec_->view_ getGridDistancesWithInt:1];
      gz = [ec_->view_ getGridDistancesWithInt:2];
      x = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(x0, gx);
      y = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(y0, gy);
      z = GeogebraCommonKernelKernel_roundToScaleWithDouble_withDouble_(z0, gz);
      if ([ec_->view_ getPointCapturingMode] == GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID || (JavaLangMath_absWithDouble_(x - x0) < gx * [ec_ getPointCapturingPercentage] && JavaLangMath_absWithDouble_(y - y0) < gy * [ec_ getPointCapturingPercentage])) {
        [coords setXWithDouble:x];
        [coords setYWithDouble:y];
        if ([ec_->view_ getPointCapturingMode] == GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID || JavaLangMath_absWithDouble_(z - z0) < gz * [ec_ getPointCapturingPercentage]) {
          [coords setZWithDouble:z];
        }
        return YES;
      }
      else if ([ec_->view_ getPointCapturingMode] == GeogebraCommonPluginEuclidianStyleConstants_POINT_CAPTURING_ON_GRID || JavaLangMath_absWithDouble_(z - z0) < gz * [ec_ getPointCapturingPercentage]) {
        [coords setZWithDouble:z];
        return YES;
      }
      return NO;
    }
  }
  return NO;
}

- (id<GeogebraCommonKernelKernelNDGeoPointND>)createNewPointWithBoolean:(jboolean)forPreviewable
                                                            withBoolean:(jboolean)complex {
  GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *point3D;
  if (!forPreviewable) {
    if ([((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))))->view3D_)) getCursor3DType] == GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_PREVIEW_POINT_NONE) return nil;
    point3D = (GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) check_class_cast([((id<GeogebraCommonKernelManager3DInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk(((GeogebraCommonEuclidianEuclidianController *) nil_chk(ec_))->kernel_)) getManager3D])) Point3DWithNSString:nil withDouble:0 withDouble:0 withDouble:0 withBoolean:NO], [GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D class]);
  }
  else {
    point3D = [self createNewFreePointWithBoolean:complex];
    if (point3D == nil) return nil;
    [((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk(point3D)) setPathWithGeogebraCommonKernelPath:nil];
    [point3D setRegionWithGeogebraCommonKernelRegion:nil];
    [((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))))->view3D_)) setCursor3DTypeWithInt:GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_PREVIEW_POINT_FREE];
    return point3D;
  }
  GeogebraCommonKernelMatrixCoordMatrix4x4_IdentityWithGeogebraCommonKernelMatrixCoordMatrix4x4_([((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])))) getCurrentPlane]);
  [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])))) movePointOnCurrentPlaneWithGeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D:point3D withBoolean:NO];
  return point3D;
}

- (id<GeogebraCommonKernelKernelNDGeoPointND>)createNewPointWithBoolean:(jboolean)forPreviewable
                                           withGeogebraCommonKernelPath:(id<GeogebraCommonKernelPath>)path
                                                            withBoolean:(jboolean)complex {
  GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *point3D;
  if (!forPreviewable) point3D = (GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) check_class_cast([((id<GeogebraCommonKernelManager3DInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonEuclidianEuclidianController *) nil_chk(ec_)) getKernel])) getManager3D])) Point3DWithNSString:nil withGeogebraCommonKernelPath:path withBoolean:NO], [GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D class]);
  else {
    point3D = [((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))))->view3D_)) getCursor3D];
    [((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk(point3D)) setPathWithGeogebraCommonKernelPath:path];
    [point3D setRegionWithGeogebraCommonKernelRegion:nil];
    [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))))->view3D_ setCursor3DTypeWithInt:GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_PREVIEW_POINT_PATH];
  }
  [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])))) setMouseInformationWithGeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D:point3D];
  [((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk(point3D)) doPath];
  [((GeogebraCommonKernelMatrixCoords *) nil_chk(tmpCoords1_)) setWithGeogebraCommonKernelMatrixCoords:[point3D getInhomCoordsInD3]];
  if ([self checkPointCapturingXYThenZWithGeogebraCommonKernelMatrixCoords:tmpCoords1_]) {
    [point3D setWillingCoordsWithGeogebraCommonKernelMatrixCoords:tmpCoords1_];
    [point3D doPath];
  }
  return point3D;
}

- (id<GeogebraCommonKernelKernelNDGeoPointND>)createNewPointWithBoolean:(jboolean)forPreviewable
                                         withGeogebraCommonKernelRegion:(id<GeogebraCommonKernelRegion>)region
                                                            withBoolean:(jboolean)complex {
  GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *point3D = [((GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))))->view3D_)) getCursor3D];
  [((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk(point3D)) setPathWithGeogebraCommonKernelPath:nil];
  [point3D setRegionWithGeogebraCommonKernelRegion:region];
  [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) nil_chk(((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class])))) setMouseInformationWithGeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D:point3D];
  [point3D doRegion];
  [point3D setMoveNormalDirectionWithGeogebraCommonKernelMatrixCoords:[((GeogebraCommonKernelRegionParameters *) nil_chk([point3D getRegionParameters])) getNormal]];
  if (region == [((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonEuclidianEuclidianController *) nil_chk(ec_)) getKernel])) getXOYPlane]) {
    GeogebraCommonKernelMatrixCoords *coords = [point3D getInhomCoords];
    GeogebraCommonGeogebra3DKernel3DGeosGeoPlane3D *plane = (GeogebraCommonGeogebra3DKernel3DGeosGeoPlane3D *) check_class_cast(region, [GeogebraCommonGeogebra3DKernel3DGeosGeoPlane3D class]);
    if ([((GeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] < [((GeogebraCommonGeogebra3DKernel3DGeosGeoPlane3D *) nil_chk(plane)) getXmin] || [coords getX] > [plane getXmax] || [coords getY] < [plane getYmin] || [coords getY] > [plane getYmax]) {
      [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_ setCursor3DTypeWithInt:GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_PREVIEW_POINT_NONE];
      return nil;
    }
    [((GeogebraCommonKernelMatrixCoords *) nil_chk(captureCoords_)) setValuesWithGeogebraCommonKernelMatrixCoords:coords withInt:2];
    if ([self checkPointCapturingXYWithGeogebraCommonKernelMatrixCoords:captureCoords_]) {
      [point3D setCoordsWithGeogebraCommonKernelMatrixCoords:captureCoords_ withBoolean:NO];
    }
  }
  else {
    [((GeogebraCommonKernelMatrixCoords *) nil_chk(tmpCoords1_)) setWithGeogebraCommonKernelMatrixCoords:[point3D getInhomCoordsInD3]];
    if ([self checkPointCapturingXYThenZWithGeogebraCommonKernelMatrixCoords:tmpCoords1_]) {
      [point3D setWillingCoordsWithGeogebraCommonKernelMatrixCoords:tmpCoords1_];
      [point3D doRegion];
    }
  }
  [((GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D *) check_class_cast(ec_, [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3D class]))->view3D_ setCursor3DTypeWithInt:GeogebraCommonGeogebra3DEuclidian3DEuclidianView3D_PREVIEW_POINT_REGION];
  if (!forPreviewable) {
    GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *ret = (GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) check_class_cast([((id<GeogebraCommonKernelManager3DInterface>) nil_chk([((GeogebraCommonKernelKernel *) nil_chk([ec_ getKernel])) getManager3D])) Point3DInWithNSString:nil withGeogebraCommonKernelRegion:region withBoolean:NO], [GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D class]);
    [((GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) nil_chk(ret)) setWithGeogebraCommonKernelGeosGeoElement:point3D];
    [ret doRegion];
    return ret;
  }
  return point3D;
}

- (GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *)createNewFreePointWithBoolean:(jboolean)complex {
  return (GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D *) check_class_cast([self createNewPointWithBoolean:YES withGeogebraCommonKernelRegion:[((GeogebraCommonKernelKernel *) nil_chk([((GeogebraCommonEuclidianEuclidianController *) nil_chk(ec_)) getKernel])) getXOYPlane] withBoolean:complex], [GeogebraCommonGeogebra3DKernel3DGeosGeoPoint3D class]);
}

- (void)dealloc {
  RELEASE_(tmpCoords1_);
  RELEASE_(tmpCoords2_);
  RELEASE_(captureCoords_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithGeogebraCommonEuclidianEuclidianController:", "EuclidianController3DCompanion", NULL, 0x1, NULL, NULL },
    { "movePointWithBoolean:withGeogebraCommonEuclidianEventAbstractEvent:", "movePoint", "V", 0x1, NULL, NULL },
    { "checkPointCapturingXYWithGeogebraCommonKernelMatrixCoords:", "checkPointCapturingXY", "Z", 0x1, NULL, NULL },
    { "checkPointCapturingXYZWithGeogebraCommonKernelMatrixCoords:", "checkPointCapturingXYZ", "Z", 0x1, NULL, NULL },
    { "checkPointCapturingXYThenZWithGeogebraCommonKernelMatrixCoords:", "checkPointCapturingXYThenZ", "Z", 0x1, NULL, NULL },
    { "createNewPointWithBoolean:withBoolean:", "createNewPoint", "Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x4, NULL, NULL },
    { "createNewPointWithBoolean:withGeogebraCommonKernelPath:withBoolean:", "createNewPoint", "Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x4, NULL, NULL },
    { "createNewPointWithBoolean:withGeogebraCommonKernelRegion:withBoolean:", "createNewPoint", "Lgeogebra.common.kernel.kernelND.GeoPointND;", 0x4, NULL, NULL },
    { "createNewFreePointWithBoolean:", "createNewFreePoint", "Lgeogebra.common.geogebra3D.kernel3D.geos.GeoPoint3D;", 0x4, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "tmpCoords1_", NULL, 0x2, "Lgeogebra.common.kernel.Matrix.Coords;", NULL, NULL,  },
    { "tmpCoords2_", NULL, 0x2, "Lgeogebra.common.kernel.Matrix.Coords;", NULL, NULL,  },
    { "captureCoords_", NULL, 0x2, "Lgeogebra.common.kernel.Matrix.Coords;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion = { 2, "EuclidianController3DCompanion", "geogebra.common.geogebra3D.euclidian3D", NULL, 0x1, 9, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion;
}

@end

void GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion_initWithGeogebraCommonEuclidianEuclidianController_(GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion *self, GeogebraCommonEuclidianEuclidianController *ec) {
  GeogebraCommonGeogebra3DEuclidianFor3DEuclidianControllerFor3DCompanion_initWithGeogebraCommonEuclidianEuclidianController_(self, ec);
  GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion_setAndConsume_tmpCoords1_(self, new_GeogebraCommonKernelMatrixCoords_initWithInt_(4));
  GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion_setAndConsume_tmpCoords2_(self, new_GeogebraCommonKernelMatrixCoords_initWithInt_(4));
  GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion_set_captureCoords_(self, GeogebraCommonKernelMatrixCoords_createInhomCoorsInD3());
}

GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion *new_GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion_initWithGeogebraCommonEuclidianEuclidianController_(GeogebraCommonEuclidianEuclidianController *ec) {
  GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion *self = [GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion alloc];
  GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion_initWithGeogebraCommonEuclidianEuclidianController_(self, ec);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(GeogebraCommonGeogebra3DEuclidian3DEuclidianController3DCompanion)
