//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeoGebraiOSARC/GeoGebraiOSARC/javasources/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Deprecated.h"
#include "java/lang/Double.h"
#include "java/lang/Integer.h"
#include "java/util/Arrays.h"
#include "org/apache/commons/math/estimation/AbstractEstimator.h"
#include "org/apache/commons/math/estimation/EstimatedParameter.h"
#include "org/apache/commons/math/estimation/EstimationException.h"
#include "org/apache/commons/math/estimation/EstimationProblem.h"
#include "org/apache/commons/math/estimation/LevenbergMarquardtEstimator.h"
#include "org/apache/commons/math/exception/util/LocalizedFormats.h"
#include "org/apache/commons/math/util/FastMath.h"

#define OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_serialVersionUID -5705952631533171019LL

@interface OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator () {
 @public
  jint solvedCols_;
  IOSDoubleArray *diagR_;
  IOSDoubleArray *jacNorm_;
  IOSDoubleArray *beta_;
  IOSIntArray *permutation_;
  jint rank_;
  jdouble lmPar_;
  IOSDoubleArray *lmDir_;
  jdouble initialStepBoundFactor_;
  jdouble costRelativeTolerance_;
  jdouble parRelativeTolerance_;
  jdouble orthoTolerance_;
}

- (void)determineLMParameterWithDoubleArray:(IOSDoubleArray *)qy
                                 withDouble:(jdouble)delta
                            withDoubleArray:(IOSDoubleArray *)diag
                            withDoubleArray:(IOSDoubleArray *)work1
                            withDoubleArray:(IOSDoubleArray *)work2
                            withDoubleArray:(IOSDoubleArray *)work3;

- (void)determineLMDirectionWithDoubleArray:(IOSDoubleArray *)qy
                            withDoubleArray:(IOSDoubleArray *)diag
                            withDoubleArray:(IOSDoubleArray *)lmDiag
                            withDoubleArray:(IOSDoubleArray *)work;

- (void)qrDecomposition;

- (void)qTyWithDoubleArray:(IOSDoubleArray *)y;

@end

J2OBJC_FIELD_SETTER(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator, diagR_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator, jacNorm_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator, beta_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator, permutation_, IOSIntArray *)
J2OBJC_FIELD_SETTER(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator, lmDir_, IOSDoubleArray *)

J2OBJC_STATIC_FIELD_GETTER(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator, serialVersionUID, jlong)

__attribute__((unused)) static void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_determineLMParameterWithDoubleArray_withDouble_withDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self, IOSDoubleArray *qy, jdouble delta, IOSDoubleArray *diag, IOSDoubleArray *work1, IOSDoubleArray *work2, IOSDoubleArray *work3);

__attribute__((unused)) static void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_determineLMDirectionWithDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self, IOSDoubleArray *qy, IOSDoubleArray *diag, IOSDoubleArray *lmDiag, IOSDoubleArray *work);

__attribute__((unused)) static void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_qrDecomposition(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self);

__attribute__((unused)) static void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_qTyWithDoubleArray_(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self, IOSDoubleArray *y);

@implementation OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator

- (instancetype)init {
  OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_init(self);
  return self;
}

- (void)setInitialStepBoundFactorWithDouble:(jdouble)initialStepBoundFactor {
  self->initialStepBoundFactor_ = initialStepBoundFactor;
}

- (void)setCostRelativeToleranceWithDouble:(jdouble)costRelativeTolerance {
  self->costRelativeTolerance_ = costRelativeTolerance;
}

- (void)setParRelativeToleranceWithDouble:(jdouble)parRelativeTolerance {
  self->parRelativeTolerance_ = parRelativeTolerance;
}

- (void)setOrthoToleranceWithDouble:(jdouble)orthoTolerance {
  self->orthoTolerance_ = orthoTolerance;
}

- (void)estimateWithOrgApacheCommonsMathEstimationEstimationProblem:(id<OrgApacheCommonsMathEstimationEstimationProblem>)problem {
  [self initializeEstimateWithOrgApacheCommonsMathEstimationEstimationProblem:problem];
  solvedCols_ = OrgApacheCommonsMathUtilFastMath_minWithInt_withInt_(rows_, cols_);
  diagR_ = [IOSDoubleArray newArrayWithLength:cols_];
  jacNorm_ = [IOSDoubleArray newArrayWithLength:cols_];
  beta_ = [IOSDoubleArray newArrayWithLength:cols_];
  permutation_ = [IOSIntArray newArrayWithLength:cols_];
  lmDir_ = [IOSDoubleArray newArrayWithLength:cols_];
  jdouble delta = 0;
  jdouble xNorm = 0;
  IOSDoubleArray *diag = [IOSDoubleArray newArrayWithLength:cols_];
  IOSDoubleArray *oldX = [IOSDoubleArray newArrayWithLength:cols_];
  IOSDoubleArray *oldRes = [IOSDoubleArray newArrayWithLength:rows_];
  IOSDoubleArray *work1 = [IOSDoubleArray newArrayWithLength:cols_];
  IOSDoubleArray *work2 = [IOSDoubleArray newArrayWithLength:cols_];
  IOSDoubleArray *work3 = [IOSDoubleArray newArrayWithLength:cols_];
  [self updateResidualsAndCost];
  lmPar_ = 0;
  jboolean firstIteration = YES;
  while (YES) {
    [self updateJacobian];
    OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_qrDecomposition(self);
    OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_qTyWithDoubleArray_(self, residuals_);
    for (jint k = 0; k < solvedCols_; ++k) {
      jint pk = IOSIntArray_Get(permutation_, k);
      *IOSDoubleArray_GetRef(nil_chk(jacobian_), k * cols_ + pk) = IOSDoubleArray_Get(diagR_, pk);
    }
    if (firstIteration) {
      xNorm = 0;
      for (jint k = 0; k < cols_; ++k) {
        jdouble dk = IOSDoubleArray_Get(jacNorm_, k);
        if (dk == 0) {
          dk = 1.0;
        }
        jdouble xk = dk * [((OrgApacheCommonsMathEstimationEstimatedParameter *) nil_chk(IOSObjectArray_Get(nil_chk(parameters_), k))) getEstimate];
        xNorm += xk * xk;
        *IOSDoubleArray_GetRef(diag, k) = dk;
      }
      xNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(xNorm);
      delta = (xNorm == 0) ? initialStepBoundFactor_ : (initialStepBoundFactor_ * xNorm);
    }
    jdouble maxCosine = 0;
    if (cost_ != 0) {
      for (jint j = 0; j < solvedCols_; ++j) {
        jint pj = IOSIntArray_Get(permutation_, j);
        jdouble s = IOSDoubleArray_Get(jacNorm_, pj);
        if (s != 0) {
          jdouble sum = 0;
          jint index = pj;
          for (jint i = 0; i <= j; ++i) {
            sum += IOSDoubleArray_Get(nil_chk(jacobian_), index) * IOSDoubleArray_Get(nil_chk(residuals_), i);
            index += cols_;
          }
          maxCosine = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(maxCosine, OrgApacheCommonsMathUtilFastMath_absWithDouble_(sum) / (s * cost_));
        }
      }
    }
    if (maxCosine <= orthoTolerance_) {
      return;
    }
    for (jint j = 0; j < cols_; ++j) {
      *IOSDoubleArray_GetRef(diag, j) = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(IOSDoubleArray_Get(diag, j), IOSDoubleArray_Get(jacNorm_, j));
    }
    for (jdouble ratio = 0; ratio < 1.0e-4; ) {
      for (jint j = 0; j < solvedCols_; ++j) {
        jint pj = IOSIntArray_Get(permutation_, j);
        *IOSDoubleArray_GetRef(oldX, pj) = [((OrgApacheCommonsMathEstimationEstimatedParameter *) nil_chk(IOSObjectArray_Get(nil_chk(parameters_), pj))) getEstimate];
      }
      jdouble previousCost = cost_;
      IOSDoubleArray *tmpVec = residuals_;
      residuals_ = oldRes;
      oldRes = tmpVec;
      OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_determineLMParameterWithDoubleArray_withDouble_withDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(self, oldRes, delta, diag, work1, work2, work3);
      jdouble lmNorm = 0;
      for (jint j = 0; j < solvedCols_; ++j) {
        jint pj = IOSIntArray_Get(permutation_, j);
        *IOSDoubleArray_GetRef(lmDir_, pj) = -IOSDoubleArray_Get(lmDir_, pj);
        [((OrgApacheCommonsMathEstimationEstimatedParameter *) nil_chk(IOSObjectArray_Get(nil_chk(parameters_), pj))) setEstimateWithDouble:IOSDoubleArray_Get(oldX, pj) + IOSDoubleArray_Get(lmDir_, pj)];
        jdouble s = IOSDoubleArray_Get(diag, pj) * IOSDoubleArray_Get(lmDir_, pj);
        lmNorm += s * s;
      }
      lmNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(lmNorm);
      if (firstIteration) {
        delta = OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(delta, lmNorm);
      }
      [self updateResidualsAndCost];
      jdouble actRed = -1.0;
      if (0.1 * cost_ < previousCost) {
        jdouble r = cost_ / previousCost;
        actRed = 1.0 - r * r;
      }
      for (jint j = 0; j < solvedCols_; ++j) {
        jint pj = IOSIntArray_Get(permutation_, j);
        jdouble dirJ = IOSDoubleArray_Get(lmDir_, pj);
        *IOSDoubleArray_GetRef(work1, j) = 0;
        jint index = pj;
        for (jint i = 0; i <= j; ++i) {
          *IOSDoubleArray_GetRef(work1, i) += IOSDoubleArray_Get(nil_chk(jacobian_), index) * dirJ;
          index += cols_;
        }
      }
      jdouble coeff1 = 0;
      for (jint j = 0; j < solvedCols_; ++j) {
        coeff1 += IOSDoubleArray_Get(work1, j) * IOSDoubleArray_Get(work1, j);
      }
      jdouble pc2 = previousCost * previousCost;
      coeff1 = coeff1 / pc2;
      jdouble coeff2 = lmPar_ * lmNorm * lmNorm / pc2;
      jdouble preRed = coeff1 + 2 * coeff2;
      jdouble dirDer = -(coeff1 + coeff2);
      ratio = (preRed == 0) ? 0 : (actRed / preRed);
      if (ratio <= 0.25) {
        jdouble tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
        if ((0.1 * cost_ >= previousCost) || (tmp < 0.1)) {
          tmp = 0.1;
        }
        delta = tmp * OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(delta, 10.0 * lmNorm);
        lmPar_ /= tmp;
      }
      else if ((lmPar_ == 0) || (ratio >= 0.75)) {
        delta = 2 * lmNorm;
        lmPar_ *= 0.5;
      }
      if (ratio >= 1.0e-4) {
        firstIteration = NO;
        xNorm = 0;
        for (jint k = 0; k < cols_; ++k) {
          jdouble xK = IOSDoubleArray_Get(diag, k) * [((OrgApacheCommonsMathEstimationEstimatedParameter *) nil_chk(IOSObjectArray_Get(nil_chk(parameters_), k))) getEstimate];
          xNorm += xK * xK;
        }
        xNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(xNorm);
      }
      else {
        cost_ = previousCost;
        for (jint j = 0; j < solvedCols_; ++j) {
          jint pj = IOSIntArray_Get(permutation_, j);
          [((OrgApacheCommonsMathEstimationEstimatedParameter *) nil_chk(IOSObjectArray_Get(nil_chk(parameters_), pj))) setEstimateWithDouble:IOSDoubleArray_Get(oldX, pj)];
        }
        tmpVec = residuals_;
        residuals_ = oldRes;
        oldRes = tmpVec;
      }
      if (((OrgApacheCommonsMathUtilFastMath_absWithDouble_(actRed) <= costRelativeTolerance_) && (preRed <= costRelativeTolerance_) && (ratio <= 2.0)) || (delta <= parRelativeTolerance_ * xNorm)) {
        return;
      }
      if ((OrgApacheCommonsMathUtilFastMath_absWithDouble_(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
        @throw new_OrgApacheCommonsMathEstimationEstimationException_initWithNSString_withNSObjectArray_(@"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangDouble_valueOfWithDouble_(costRelativeTolerance_) } count:1 type:NSObject_class_()]);
      }
      else if (delta <= 2.2204e-16 * xNorm) {
        @throw new_OrgApacheCommonsMathEstimationEstimationException_initWithNSString_withNSObjectArray_(@"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangDouble_valueOfWithDouble_(parRelativeTolerance_) } count:1 type:NSObject_class_()]);
      }
      else if (maxCosine <= 2.2204e-16) {
        @throw new_OrgApacheCommonsMathEstimationEstimationException_initWithNSString_withNSObjectArray_(@"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian", [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangDouble_valueOfWithDouble_(orthoTolerance_) } count:1 type:NSObject_class_()]);
      }
    }
  }
}

- (void)determineLMParameterWithDoubleArray:(IOSDoubleArray *)qy
                                 withDouble:(jdouble)delta
                            withDoubleArray:(IOSDoubleArray *)diag
                            withDoubleArray:(IOSDoubleArray *)work1
                            withDoubleArray:(IOSDoubleArray *)work2
                            withDoubleArray:(IOSDoubleArray *)work3 {
  OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_determineLMParameterWithDoubleArray_withDouble_withDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(self, qy, delta, diag, work1, work2, work3);
}

- (void)determineLMDirectionWithDoubleArray:(IOSDoubleArray *)qy
                            withDoubleArray:(IOSDoubleArray *)diag
                            withDoubleArray:(IOSDoubleArray *)lmDiag
                            withDoubleArray:(IOSDoubleArray *)work {
  OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_determineLMDirectionWithDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(self, qy, diag, lmDiag, work);
}

- (void)qrDecomposition {
  OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_qrDecomposition(self);
}

- (void)qTyWithDoubleArray:(IOSDoubleArray *)y {
  OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_qTyWithDoubleArray_(self, y);
}

+ (IOSObjectArray *)__annotations {
  return [IOSObjectArray arrayWithObjects:(id[]) { [[JavaLangDeprecated alloc] init] } count:1 type:JavaLangAnnotationAnnotation_class_()];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "LevenbergMarquardtEstimator", NULL, 0x1, NULL, NULL },
    { "setInitialStepBoundFactorWithDouble:", "setInitialStepBoundFactor", "V", 0x1, NULL, NULL },
    { "setCostRelativeToleranceWithDouble:", "setCostRelativeTolerance", "V", 0x1, NULL, NULL },
    { "setParRelativeToleranceWithDouble:", "setParRelativeTolerance", "V", 0x1, NULL, NULL },
    { "setOrthoToleranceWithDouble:", "setOrthoTolerance", "V", 0x1, NULL, NULL },
    { "estimateWithOrgApacheCommonsMathEstimationEstimationProblem:", "estimate", "V", 0x1, "Lorg.apache.commons.math.estimation.EstimationException;", NULL },
    { "determineLMParameterWithDoubleArray:withDouble:withDoubleArray:withDoubleArray:withDoubleArray:withDoubleArray:", "determineLMParameter", "V", 0x2, NULL, NULL },
    { "determineLMDirectionWithDoubleArray:withDoubleArray:withDoubleArray:withDoubleArray:", "determineLMDirection", "V", 0x2, NULL, NULL },
    { "qrDecomposition", NULL, "V", 0x2, "Lorg.apache.commons.math.estimation.EstimationException;", NULL },
    { "qTyWithDoubleArray:", "qTy", "V", 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "serialVersionUID_", NULL, 0x1a, "J", NULL, NULL, .constantValue.asLong = OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_serialVersionUID },
    { "solvedCols_", NULL, 0x2, "I", NULL, NULL,  },
    { "diagR_", NULL, 0x2, "[D", NULL, NULL,  },
    { "jacNorm_", NULL, 0x2, "[D", NULL, NULL,  },
    { "beta_", NULL, 0x2, "[D", NULL, NULL,  },
    { "permutation_", NULL, 0x2, "[I", NULL, NULL,  },
    { "rank_", NULL, 0x2, "I", NULL, NULL,  },
    { "lmPar_", NULL, 0x2, "D", NULL, NULL,  },
    { "lmDir_", NULL, 0x2, "[D", NULL, NULL,  },
    { "initialStepBoundFactor_", NULL, 0x2, "D", NULL, NULL,  },
    { "costRelativeTolerance_", NULL, 0x2, "D", NULL, NULL,  },
    { "parRelativeTolerance_", NULL, 0x2, "D", NULL, NULL,  },
    { "orthoTolerance_", NULL, 0x2, "D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator = { 2, "LevenbergMarquardtEstimator", "org.apache.commons.math.estimation", NULL, 0x1, 10, methods, 13, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator;
}

@end

void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_init(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self) {
  (void) OrgApacheCommonsMathEstimationAbstractEstimator_init(self);
  [self setMaxCostEvalWithInt:1000];
  [self setInitialStepBoundFactorWithDouble:100.0];
  [self setCostRelativeToleranceWithDouble:1.0e-10];
  [self setParRelativeToleranceWithDouble:1.0e-10];
  [self setOrthoToleranceWithDouble:1.0e-10];
}

OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *new_OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_init() {
  OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self = [OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator alloc];
  OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_init(self);
  return self;
}

void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_determineLMParameterWithDoubleArray_withDouble_withDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self, IOSDoubleArray *qy, jdouble delta, IOSDoubleArray *diag, IOSDoubleArray *work1, IOSDoubleArray *work2, IOSDoubleArray *work3) {
  for (jint j = 0; j < self->rank_; ++j) {
    *IOSDoubleArray_GetRef(nil_chk(self->lmDir_), IOSIntArray_Get(nil_chk(self->permutation_), j)) = IOSDoubleArray_Get(nil_chk(qy), j);
  }
  for (jint j = self->rank_; j < self->cols_; ++j) {
    *IOSDoubleArray_GetRef(nil_chk(self->lmDir_), IOSIntArray_Get(nil_chk(self->permutation_), j)) = 0;
  }
  for (jint k = self->rank_ - 1; k >= 0; --k) {
    jint pk = IOSIntArray_Get(nil_chk(self->permutation_), k);
    jdouble ypk = IOSDoubleArray_Get(nil_chk(self->lmDir_), pk) / IOSDoubleArray_Get(nil_chk(self->diagR_), pk);
    jint index = pk;
    for (jint i = 0; i < k; ++i) {
      *IOSDoubleArray_GetRef(self->lmDir_, IOSIntArray_Get(self->permutation_, i)) -= ypk * IOSDoubleArray_Get(nil_chk(self->jacobian_), index);
      index += self->cols_;
    }
    *IOSDoubleArray_GetRef(self->lmDir_, pk) = ypk;
  }
  jdouble dxNorm = 0;
  for (jint j = 0; j < self->solvedCols_; ++j) {
    jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
    jdouble s = IOSDoubleArray_Get(nil_chk(diag), pj) * IOSDoubleArray_Get(nil_chk(self->lmDir_), pj);
    *IOSDoubleArray_GetRef(nil_chk(work1), pj) = s;
    dxNorm += s * s;
  }
  dxNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(dxNorm);
  jdouble fp = dxNorm - delta;
  if (fp <= 0.1 * delta) {
    self->lmPar_ = 0;
    return;
  }
  jdouble sum2;
  jdouble parl = 0;
  if (self->rank_ == self->solvedCols_) {
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      *IOSDoubleArray_GetRef(nil_chk(work1), pj) *= IOSDoubleArray_Get(nil_chk(diag), pj) / dxNorm;
    }
    sum2 = 0;
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      jdouble sum = 0;
      jint index = pj;
      for (jint i = 0; i < j; ++i) {
        sum += IOSDoubleArray_Get(nil_chk(self->jacobian_), index) * IOSDoubleArray_Get(nil_chk(work1), IOSIntArray_Get(self->permutation_, i));
        index += self->cols_;
      }
      jdouble s = (IOSDoubleArray_Get(nil_chk(work1), pj) - sum) / IOSDoubleArray_Get(nil_chk(self->diagR_), pj);
      *IOSDoubleArray_GetRef(work1, pj) = s;
      sum2 += s * s;
    }
    parl = fp / (delta * sum2);
  }
  sum2 = 0;
  for (jint j = 0; j < self->solvedCols_; ++j) {
    jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
    jdouble sum = 0;
    jint index = pj;
    for (jint i = 0; i <= j; ++i) {
      sum += IOSDoubleArray_Get(nil_chk(self->jacobian_), index) * IOSDoubleArray_Get(nil_chk(qy), i);
      index += self->cols_;
    }
    sum /= IOSDoubleArray_Get(nil_chk(diag), pj);
    sum2 += sum * sum;
  }
  jdouble gNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(sum2);
  jdouble paru = gNorm / delta;
  if (paru == 0) {
    paru = 2.2251e-308 / OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(delta, 0.1);
  }
  self->lmPar_ = OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(paru, OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(self->lmPar_, parl));
  if (self->lmPar_ == 0) {
    self->lmPar_ = gNorm / dxNorm;
  }
  for (jint countdown = 10; countdown >= 0; --countdown) {
    if (self->lmPar_ == 0) {
      self->lmPar_ = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(2.2251e-308, 0.001 * paru);
    }
    jdouble sPar = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(self->lmPar_);
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      *IOSDoubleArray_GetRef(nil_chk(work1), pj) = sPar * IOSDoubleArray_Get(nil_chk(diag), pj);
    }
    OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_determineLMDirectionWithDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(self, qy, work1, work2, work3);
    dxNorm = 0;
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      jdouble s = IOSDoubleArray_Get(nil_chk(diag), pj) * IOSDoubleArray_Get(nil_chk(self->lmDir_), pj);
      *IOSDoubleArray_GetRef(nil_chk(work3), pj) = s;
      dxNorm += s * s;
    }
    dxNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(dxNorm);
    jdouble previousFP = fp;
    fp = dxNorm - delta;
    if ((OrgApacheCommonsMathUtilFastMath_absWithDouble_(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {
      return;
    }
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      *IOSDoubleArray_GetRef(nil_chk(work1), pj) = IOSDoubleArray_Get(nil_chk(work3), pj) * IOSDoubleArray_Get(nil_chk(diag), pj) / dxNorm;
    }
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      *IOSDoubleArray_GetRef(nil_chk(work1), pj) /= IOSDoubleArray_Get(nil_chk(work2), j);
      jdouble tmp = IOSDoubleArray_Get(work1, pj);
      for (jint i = j + 1; i < self->solvedCols_; ++i) {
        *IOSDoubleArray_GetRef(work1, IOSIntArray_Get(self->permutation_, i)) -= IOSDoubleArray_Get(nil_chk(self->jacobian_), i * self->cols_ + pj) * tmp;
      }
    }
    sum2 = 0;
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jdouble s = IOSDoubleArray_Get(nil_chk(work1), IOSIntArray_Get(nil_chk(self->permutation_), j));
      sum2 += s * s;
    }
    jdouble correction = fp / (delta * sum2);
    if (fp > 0) {
      parl = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(parl, self->lmPar_);
    }
    else if (fp < 0) {
      paru = OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(paru, self->lmPar_);
    }
    self->lmPar_ = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(parl, self->lmPar_ + correction);
  }
}

void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_determineLMDirectionWithDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self, IOSDoubleArray *qy, IOSDoubleArray *diag, IOSDoubleArray *lmDiag, IOSDoubleArray *work) {
  for (jint j = 0; j < self->solvedCols_; ++j) {
    jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
    for (jint i = j + 1; i < self->solvedCols_; ++i) {
      *IOSDoubleArray_GetRef(nil_chk(self->jacobian_), i * self->cols_ + pj) = IOSDoubleArray_Get(self->jacobian_, j * self->cols_ + IOSIntArray_Get(self->permutation_, i));
    }
    *IOSDoubleArray_GetRef(nil_chk(self->lmDir_), j) = IOSDoubleArray_Get(nil_chk(self->diagR_), pj);
    *IOSDoubleArray_GetRef(nil_chk(work), j) = IOSDoubleArray_Get(nil_chk(qy), j);
  }
  for (jint j = 0; j < self->solvedCols_; ++j) {
    jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
    jdouble dpj = IOSDoubleArray_Get(nil_chk(diag), pj);
    if (dpj != 0) {
      JavaUtilArrays_fillWithDoubleArray_withInt_withInt_withDouble_(lmDiag, j + 1, ((IOSDoubleArray *) nil_chk(lmDiag))->size_, 0);
    }
    *IOSDoubleArray_GetRef(nil_chk(lmDiag), j) = dpj;
    jdouble qtbpj = 0;
    for (jint k = j; k < self->solvedCols_; ++k) {
      jint pk = IOSIntArray_Get(self->permutation_, k);
      if (IOSDoubleArray_Get(lmDiag, k) != 0) {
        jdouble sin;
        jdouble cos;
        jdouble rkk = IOSDoubleArray_Get(nil_chk(self->jacobian_), k * self->cols_ + pk);
        if (OrgApacheCommonsMathUtilFastMath_absWithDouble_(rkk) < OrgApacheCommonsMathUtilFastMath_absWithDouble_(IOSDoubleArray_Get(lmDiag, k))) {
          jdouble cotan = rkk / IOSDoubleArray_Get(lmDiag, k);
          sin = 1.0 / OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(1.0 + cotan * cotan);
          cos = sin * cotan;
        }
        else {
          jdouble tan = IOSDoubleArray_Get(lmDiag, k) / rkk;
          cos = 1.0 / OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(1.0 + tan * tan);
          sin = cos * tan;
        }
        *IOSDoubleArray_GetRef(self->jacobian_, k * self->cols_ + pk) = cos * rkk + sin * IOSDoubleArray_Get(lmDiag, k);
        jdouble temp = cos * IOSDoubleArray_Get(nil_chk(work), k) + sin * qtbpj;
        qtbpj = -sin * IOSDoubleArray_Get(work, k) + cos * qtbpj;
        *IOSDoubleArray_GetRef(work, k) = temp;
        for (jint i = k + 1; i < self->solvedCols_; ++i) {
          jdouble rik = IOSDoubleArray_Get(self->jacobian_, i * self->cols_ + pk);
          jdouble temp2 = cos * rik + sin * IOSDoubleArray_Get(lmDiag, i);
          *IOSDoubleArray_GetRef(lmDiag, i) = -sin * rik + cos * IOSDoubleArray_Get(lmDiag, i);
          *IOSDoubleArray_GetRef(self->jacobian_, i * self->cols_ + pk) = temp2;
        }
      }
    }
    jint index = j * self->cols_ + IOSIntArray_Get(self->permutation_, j);
    *IOSDoubleArray_GetRef(lmDiag, j) = IOSDoubleArray_Get(nil_chk(self->jacobian_), index);
    *IOSDoubleArray_GetRef(self->jacobian_, index) = IOSDoubleArray_Get(nil_chk(self->lmDir_), j);
  }
  jint nSing = self->solvedCols_;
  for (jint j = 0; j < self->solvedCols_; ++j) {
    if ((IOSDoubleArray_Get(nil_chk(lmDiag), j) == 0) && (nSing == self->solvedCols_)) {
      nSing = j;
    }
    if (nSing < self->solvedCols_) {
      *IOSDoubleArray_GetRef(nil_chk(work), j) = 0;
    }
  }
  if (nSing > 0) {
    for (jint j = nSing - 1; j >= 0; --j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      jdouble sum = 0;
      for (jint i = j + 1; i < nSing; ++i) {
        sum += IOSDoubleArray_Get(nil_chk(self->jacobian_), i * self->cols_ + pj) * IOSDoubleArray_Get(nil_chk(work), i);
      }
      *IOSDoubleArray_GetRef(nil_chk(work), j) = (IOSDoubleArray_Get(work, j) - sum) / IOSDoubleArray_Get(nil_chk(lmDiag), j);
    }
  }
  for (jint j = 0; j < ((IOSDoubleArray *) nil_chk(self->lmDir_))->size_; ++j) {
    *IOSDoubleArray_GetRef(self->lmDir_, IOSIntArray_Get(nil_chk(self->permutation_), j)) = IOSDoubleArray_Get(nil_chk(work), j);
  }
}

void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_qrDecomposition(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self) {
  for (jint k = 0; k < self->cols_; ++k) {
    *IOSIntArray_GetRef(nil_chk(self->permutation_), k) = k;
    jdouble norm2 = 0;
    for (jint index = k; index < ((IOSDoubleArray *) nil_chk(self->jacobian_))->size_; index += self->cols_) {
      jdouble akk = IOSDoubleArray_Get(self->jacobian_, index);
      norm2 += akk * akk;
    }
    *IOSDoubleArray_GetRef(nil_chk(self->jacNorm_), k) = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(norm2);
  }
  for (jint k = 0; k < self->cols_; ++k) {
    jint nextColumn = -1;
    jdouble ak2 = JavaLangDouble_NEGATIVE_INFINITY;
    for (jint i = k; i < self->cols_; ++i) {
      jdouble norm2 = 0;
      jint iDiag = k * self->cols_ + IOSIntArray_Get(nil_chk(self->permutation_), i);
      for (jint index = iDiag; index < ((IOSDoubleArray *) nil_chk(self->jacobian_))->size_; index += self->cols_) {
        jdouble aki = IOSDoubleArray_Get(self->jacobian_, index);
        norm2 += aki * aki;
      }
      if (JavaLangDouble_isInfiniteWithDouble_(norm2) || JavaLangDouble_isNaNWithDouble_(norm2)) {
        @throw new_OrgApacheCommonsMathEstimationEstimationException_initWithOrgApacheCommonsMathExceptionUtilLocalizable_withNSObjectArray_(OrgApacheCommonsMathExceptionUtilLocalizedFormatsEnum_get_UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN(), [IOSObjectArray newArrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(self->rows_), JavaLangInteger_valueOfWithInt_(self->cols_) } count:2 type:NSObject_class_()]);
      }
      if (norm2 > ak2) {
        nextColumn = i;
        ak2 = norm2;
      }
    }
    if (ak2 == 0) {
      self->rank_ = k;
      return;
    }
    jint pk = IOSIntArray_Get(nil_chk(self->permutation_), nextColumn);
    *IOSIntArray_GetRef(self->permutation_, nextColumn) = IOSIntArray_Get(self->permutation_, k);
    *IOSIntArray_GetRef(self->permutation_, k) = pk;
    jint kDiag = k * self->cols_ + pk;
    jdouble akk = IOSDoubleArray_Get(nil_chk(self->jacobian_), kDiag);
    jdouble alpha = (akk > 0) ? -OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(ak2) : OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(ak2);
    jdouble betak = 1.0 / (ak2 - akk * alpha);
    *IOSDoubleArray_GetRef(nil_chk(self->beta_), pk) = betak;
    *IOSDoubleArray_GetRef(nil_chk(self->diagR_), pk) = alpha;
    *IOSDoubleArray_GetRef(self->jacobian_, kDiag) -= alpha;
    for (jint dk = self->cols_ - 1 - k; dk > 0; --dk) {
      jint dkp = IOSIntArray_Get(self->permutation_, k + dk) - pk;
      jdouble gamma = 0;
      for (jint index = kDiag; index < self->jacobian_->size_; index += self->cols_) {
        gamma += IOSDoubleArray_Get(self->jacobian_, index) * IOSDoubleArray_Get(self->jacobian_, index + dkp);
      }
      gamma *= betak;
      for (jint index = kDiag; index < self->jacobian_->size_; index += self->cols_) {
        *IOSDoubleArray_GetRef(self->jacobian_, index + dkp) -= gamma * IOSDoubleArray_Get(self->jacobian_, index);
      }
    }
  }
  self->rank_ = self->solvedCols_;
}

void OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator_qTyWithDoubleArray_(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator *self, IOSDoubleArray *y) {
  for (jint k = 0; k < self->cols_; ++k) {
    jint pk = IOSIntArray_Get(nil_chk(self->permutation_), k);
    jint kDiag = k * self->cols_ + pk;
    jdouble gamma = 0;
    jint index = kDiag;
    for (jint i = k; i < self->rows_; ++i) {
      gamma += IOSDoubleArray_Get(nil_chk(self->jacobian_), index) * IOSDoubleArray_Get(nil_chk(y), i);
      index += self->cols_;
    }
    gamma *= IOSDoubleArray_Get(nil_chk(self->beta_), pk);
    index = kDiag;
    for (jint i = k; i < self->rows_; ++i) {
      *IOSDoubleArray_GetRef(nil_chk(y), i) -= gamma * IOSDoubleArray_Get(nil_chk(self->jacobian_), index);
      index += self->cols_;
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheCommonsMathEstimationLevenbergMarquardtEstimator)
