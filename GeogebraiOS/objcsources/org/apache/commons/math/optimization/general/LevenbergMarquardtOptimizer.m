//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeogebraiOS/GeogebraiOS/sources/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Double.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/util/Arrays.h"
#include "org/apache/commons/math/FunctionEvaluationException.h"
#include "org/apache/commons/math/exception/util/LocalizedFormats.h"
#include "org/apache/commons/math/optimization/OptimizationException.h"
#include "org/apache/commons/math/optimization/VectorialConvergenceChecker.h"
#include "org/apache/commons/math/optimization/VectorialPointValuePair.h"
#include "org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.h"
#include "org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.h"
#include "org/apache/commons/math/util/FastMath.h"
#include "org/apache/commons/math/util/MathUtils.h"

@interface OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer () {
 @public
  jint solvedCols_;
  IOSDoubleArray *diagR_;
  IOSDoubleArray *jacNorm_;
  IOSDoubleArray *beta_;
  IOSIntArray *permutation_;
  jint rank_;
  jdouble lmPar_;
  IOSDoubleArray *lmDir_;
  jdouble initialStepBoundFactor_;
  jdouble costRelativeTolerance_;
  jdouble parRelativeTolerance_;
  jdouble orthoTolerance_;
  jdouble qrRankingThreshold_;
}

- (void)determineLMParameterWithDoubleArray:(IOSDoubleArray *)qy
                                 withDouble:(jdouble)delta
                            withDoubleArray:(IOSDoubleArray *)diag
                            withDoubleArray:(IOSDoubleArray *)work1
                            withDoubleArray:(IOSDoubleArray *)work2
                            withDoubleArray:(IOSDoubleArray *)work3;

- (void)determineLMDirectionWithDoubleArray:(IOSDoubleArray *)qy
                            withDoubleArray:(IOSDoubleArray *)diag
                            withDoubleArray:(IOSDoubleArray *)lmDiag
                            withDoubleArray:(IOSDoubleArray *)work;

- (void)qrDecomposition;

- (void)qTyWithDoubleArray:(IOSDoubleArray *)y;

@end

J2OBJC_FIELD_SETTER(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer, diagR_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer, jacNorm_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer, beta_, IOSDoubleArray *)
J2OBJC_FIELD_SETTER(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer, permutation_, IOSIntArray *)
J2OBJC_FIELD_SETTER(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer, lmDir_, IOSDoubleArray *)

__attribute__((unused)) static void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_determineLMParameterWithDoubleArray_withDouble_withDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self, IOSDoubleArray *qy, jdouble delta, IOSDoubleArray *diag, IOSDoubleArray *work1, IOSDoubleArray *work2, IOSDoubleArray *work3);

__attribute__((unused)) static void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_determineLMDirectionWithDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self, IOSDoubleArray *qy, IOSDoubleArray *diag, IOSDoubleArray *lmDiag, IOSDoubleArray *work);

__attribute__((unused)) static void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_qrDecomposition(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self);

__attribute__((unused)) static void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_qTyWithDoubleArray_(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self, IOSDoubleArray *y);

@implementation OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer

- (instancetype)init {
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_init(self);
  return self;
}

- (void)setInitialStepBoundFactorWithDouble:(jdouble)initialStepBoundFactor {
  self->initialStepBoundFactor_ = initialStepBoundFactor;
}

- (void)setCostRelativeToleranceWithDouble:(jdouble)costRelativeTolerance {
  self->costRelativeTolerance_ = costRelativeTolerance;
}

- (void)setParRelativeToleranceWithDouble:(jdouble)parRelativeTolerance {
  self->parRelativeTolerance_ = parRelativeTolerance;
}

- (void)setOrthoToleranceWithDouble:(jdouble)orthoTolerance {
  self->orthoTolerance_ = orthoTolerance;
}

- (void)setQRRankingThresholdWithDouble:(jdouble)threshold {
  self->qrRankingThreshold_ = threshold;
}

- (OrgApacheCommonsMathOptimizationVectorialPointValuePair *)doOptimize {
  solvedCols_ = JavaLangMath_minWithInt_withInt_(rows_, cols_);
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_setAndConsume_diagR_(self, [IOSDoubleArray newArrayWithLength:cols_]);
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_setAndConsume_jacNorm_(self, [IOSDoubleArray newArrayWithLength:cols_]);
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_setAndConsume_beta_(self, [IOSDoubleArray newArrayWithLength:cols_]);
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_setAndConsume_permutation_(self, [IOSIntArray newArrayWithLength:cols_]);
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_setAndConsume_lmDir_(self, [IOSDoubleArray newArrayWithLength:cols_]);
  jdouble delta = 0;
  jdouble xNorm = 0;
  IOSDoubleArray *diag = [IOSDoubleArray arrayWithLength:cols_];
  IOSDoubleArray *oldX = [IOSDoubleArray arrayWithLength:cols_];
  IOSDoubleArray *oldRes = [IOSDoubleArray arrayWithLength:rows_];
  IOSDoubleArray *oldObj = [IOSDoubleArray arrayWithLength:rows_];
  IOSDoubleArray *qtf = [IOSDoubleArray arrayWithLength:rows_];
  IOSDoubleArray *work1 = [IOSDoubleArray arrayWithLength:cols_];
  IOSDoubleArray *work2 = [IOSDoubleArray arrayWithLength:cols_];
  IOSDoubleArray *work3 = [IOSDoubleArray arrayWithLength:cols_];
  [self updateResidualsAndCost];
  lmPar_ = 0;
  jboolean firstIteration = YES;
  OrgApacheCommonsMathOptimizationVectorialPointValuePair *current = [new_OrgApacheCommonsMathOptimizationVectorialPointValuePair_initWithDoubleArray_withDoubleArray_(point_, objective_) autorelease];
  while (YES) {
    for (jint i = 0; i < rows_; i++) {
      *IOSDoubleArray_GetRef(qtf, i) = IOSDoubleArray_Get(nil_chk(wresiduals_), i);
    }
    [self incrementIterationsCounter];
    OrgApacheCommonsMathOptimizationVectorialPointValuePair *previous = current;
    [self updateJacobian];
    OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_qrDecomposition(self);
    OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_qTyWithDoubleArray_(self, qtf);
    for (jint k = 0; k < solvedCols_; ++k) {
      jint pk = IOSIntArray_Get(permutation_, k);
      *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(wjacobian_), k)), pk) = IOSDoubleArray_Get(diagR_, pk);
    }
    if (firstIteration) {
      xNorm = 0;
      for (jint k = 0; k < cols_; ++k) {
        jdouble dk = IOSDoubleArray_Get(jacNorm_, k);
        if (dk == 0) {
          dk = 1.0;
        }
        jdouble xk = dk * IOSDoubleArray_Get(nil_chk(point_), k);
        xNorm += xk * xk;
        *IOSDoubleArray_GetRef(diag, k) = dk;
      }
      xNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(xNorm);
      delta = (xNorm == 0) ? initialStepBoundFactor_ : (initialStepBoundFactor_ * xNorm);
    }
    jdouble maxCosine = 0;
    if (cost_ != 0) {
      for (jint j = 0; j < solvedCols_; ++j) {
        jint pj = IOSIntArray_Get(permutation_, j);
        jdouble s = IOSDoubleArray_Get(jacNorm_, pj);
        if (s != 0) {
          jdouble sum = 0;
          for (jint i = 0; i <= j; ++i) {
            sum += IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(wjacobian_), i)), pj) * IOSDoubleArray_Get(qtf, i);
          }
          maxCosine = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(maxCosine, OrgApacheCommonsMathUtilFastMath_absWithDouble_(sum) / (s * cost_));
        }
      }
    }
    if (maxCosine <= orthoTolerance_) {
      [self updateResidualsAndCost];
      current = [new_OrgApacheCommonsMathOptimizationVectorialPointValuePair_initWithDoubleArray_withDoubleArray_(point_, objective_) autorelease];
      return current;
    }
    for (jint j = 0; j < cols_; ++j) {
      *IOSDoubleArray_GetRef(diag, j) = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(IOSDoubleArray_Get(diag, j), IOSDoubleArray_Get(jacNorm_, j));
    }
    for (jdouble ratio = 0; ratio < 1.0e-4; ) {
      for (jint j = 0; j < solvedCols_; ++j) {
        jint pj = IOSIntArray_Get(permutation_, j);
        *IOSDoubleArray_GetRef(oldX, pj) = IOSDoubleArray_Get(nil_chk(point_), pj);
      }
      jdouble previousCost = cost_;
      IOSDoubleArray *tmpVec = residuals_;
      OrgApacheCommonsMathOptimizationGeneralAbstractLeastSquaresOptimizer_set_residuals_(self, oldRes);
      oldRes = tmpVec;
      tmpVec = objective_;
      OrgApacheCommonsMathOptimizationGeneralAbstractLeastSquaresOptimizer_set_objective_(self, oldObj);
      oldObj = tmpVec;
      OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_determineLMParameterWithDoubleArray_withDouble_withDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(self, qtf, delta, diag, work1, work2, work3);
      jdouble lmNorm = 0;
      for (jint j = 0; j < solvedCols_; ++j) {
        jint pj = IOSIntArray_Get(permutation_, j);
        *IOSDoubleArray_GetRef(lmDir_, pj) = -IOSDoubleArray_Get(lmDir_, pj);
        *IOSDoubleArray_GetRef(nil_chk(point_), pj) = IOSDoubleArray_Get(oldX, pj) + IOSDoubleArray_Get(lmDir_, pj);
        jdouble s = IOSDoubleArray_Get(diag, pj) * IOSDoubleArray_Get(lmDir_, pj);
        lmNorm += s * s;
      }
      lmNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(lmNorm);
      if (firstIteration) {
        delta = OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(delta, lmNorm);
      }
      [self updateResidualsAndCost];
      jdouble actRed = -1.0;
      if (0.1 * cost_ < previousCost) {
        jdouble r = cost_ / previousCost;
        actRed = 1.0 - r * r;
      }
      for (jint j = 0; j < solvedCols_; ++j) {
        jint pj = IOSIntArray_Get(permutation_, j);
        jdouble dirJ = IOSDoubleArray_Get(lmDir_, pj);
        *IOSDoubleArray_GetRef(work1, j) = 0;
        for (jint i = 0; i <= j; ++i) {
          *IOSDoubleArray_GetRef(work1, i) += IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(wjacobian_), i)), pj) * dirJ;
        }
      }
      jdouble coeff1 = 0;
      for (jint j = 0; j < solvedCols_; ++j) {
        coeff1 += IOSDoubleArray_Get(work1, j) * IOSDoubleArray_Get(work1, j);
      }
      jdouble pc2 = previousCost * previousCost;
      coeff1 = coeff1 / pc2;
      jdouble coeff2 = lmPar_ * lmNorm * lmNorm / pc2;
      jdouble preRed = coeff1 + 2 * coeff2;
      jdouble dirDer = -(coeff1 + coeff2);
      ratio = (preRed == 0) ? 0 : (actRed / preRed);
      if (ratio <= 0.25) {
        jdouble tmp = (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;
        if ((0.1 * cost_ >= previousCost) || (tmp < 0.1)) {
          tmp = 0.1;
        }
        delta = tmp * OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(delta, 10.0 * lmNorm);
        lmPar_ /= tmp;
      }
      else if ((lmPar_ == 0) || (ratio >= 0.75)) {
        delta = 2 * lmNorm;
        lmPar_ *= 0.5;
      }
      if (ratio >= 1.0e-4) {
        firstIteration = NO;
        xNorm = 0;
        for (jint k = 0; k < cols_; ++k) {
          jdouble xK = IOSDoubleArray_Get(diag, k) * IOSDoubleArray_Get(nil_chk(point_), k);
          xNorm += xK * xK;
        }
        xNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(xNorm);
        current = [new_OrgApacheCommonsMathOptimizationVectorialPointValuePair_initWithDoubleArray_withDoubleArray_(point_, objective_) autorelease];
        if (checker_ != nil) {
          if ([checker_ convergedWithInt:[self getIterations] withOrgApacheCommonsMathOptimizationVectorialPointValuePair:previous withOrgApacheCommonsMathOptimizationVectorialPointValuePair:current]) {
            return current;
          }
        }
      }
      else {
        cost_ = previousCost;
        for (jint j = 0; j < solvedCols_; ++j) {
          jint pj = IOSIntArray_Get(permutation_, j);
          *IOSDoubleArray_GetRef(nil_chk(point_), pj) = IOSDoubleArray_Get(oldX, pj);
        }
        tmpVec = residuals_;
        OrgApacheCommonsMathOptimizationGeneralAbstractLeastSquaresOptimizer_set_residuals_(self, oldRes);
        oldRes = tmpVec;
        tmpVec = objective_;
        OrgApacheCommonsMathOptimizationGeneralAbstractLeastSquaresOptimizer_set_objective_(self, oldObj);
        oldObj = tmpVec;
      }
      if (checker_ == nil) {
        if (((OrgApacheCommonsMathUtilFastMath_absWithDouble_(actRed) <= costRelativeTolerance_) && (preRed <= costRelativeTolerance_) && (ratio <= 2.0)) || (delta <= parRelativeTolerance_ * xNorm)) {
          return current;
        }
      }
      if ((OrgApacheCommonsMathUtilFastMath_absWithDouble_(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {
        @throw [new_OrgApacheCommonsMathOptimizationOptimizationException_initWithOrgApacheCommonsMathExceptionUtilLocalizable_withNSObjectArray_(OrgApacheCommonsMathExceptionUtilLocalizedFormatsEnum_get_TOO_SMALL_COST_RELATIVE_TOLERANCE(), [IOSObjectArray arrayWithObjects:(id[]){ JavaLangDouble_valueOfWithDouble_(costRelativeTolerance_) } count:1 type:NSObject_class_()]) autorelease];
      }
      else if (delta <= 2.2204e-16 * xNorm) {
        @throw [new_OrgApacheCommonsMathOptimizationOptimizationException_initWithOrgApacheCommonsMathExceptionUtilLocalizable_withNSObjectArray_(OrgApacheCommonsMathExceptionUtilLocalizedFormatsEnum_get_TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE(), [IOSObjectArray arrayWithObjects:(id[]){ JavaLangDouble_valueOfWithDouble_(parRelativeTolerance_) } count:1 type:NSObject_class_()]) autorelease];
      }
      else if (maxCosine <= 2.2204e-16) {
        @throw [new_OrgApacheCommonsMathOptimizationOptimizationException_initWithOrgApacheCommonsMathExceptionUtilLocalizable_withNSObjectArray_(OrgApacheCommonsMathExceptionUtilLocalizedFormatsEnum_get_TOO_SMALL_ORTHOGONALITY_TOLERANCE(), [IOSObjectArray arrayWithObjects:(id[]){ JavaLangDouble_valueOfWithDouble_(orthoTolerance_) } count:1 type:NSObject_class_()]) autorelease];
      }
    }
  }
}

- (void)determineLMParameterWithDoubleArray:(IOSDoubleArray *)qy
                                 withDouble:(jdouble)delta
                            withDoubleArray:(IOSDoubleArray *)diag
                            withDoubleArray:(IOSDoubleArray *)work1
                            withDoubleArray:(IOSDoubleArray *)work2
                            withDoubleArray:(IOSDoubleArray *)work3 {
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_determineLMParameterWithDoubleArray_withDouble_withDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(self, qy, delta, diag, work1, work2, work3);
}

- (void)determineLMDirectionWithDoubleArray:(IOSDoubleArray *)qy
                            withDoubleArray:(IOSDoubleArray *)diag
                            withDoubleArray:(IOSDoubleArray *)lmDiag
                            withDoubleArray:(IOSDoubleArray *)work {
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_determineLMDirectionWithDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(self, qy, diag, lmDiag, work);
}

- (void)qrDecomposition {
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_qrDecomposition(self);
}

- (void)qTyWithDoubleArray:(IOSDoubleArray *)y {
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_qTyWithDoubleArray_(self, y);
}

- (void)dealloc {
  RELEASE_(diagR_);
  RELEASE_(jacNorm_);
  RELEASE_(beta_);
  RELEASE_(permutation_);
  RELEASE_(lmDir_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "LevenbergMarquardtOptimizer", NULL, 0x1, NULL, NULL },
    { "setInitialStepBoundFactorWithDouble:", "setInitialStepBoundFactor", "V", 0x1, NULL, NULL },
    { "setCostRelativeToleranceWithDouble:", "setCostRelativeTolerance", "V", 0x1, NULL, NULL },
    { "setParRelativeToleranceWithDouble:", "setParRelativeTolerance", "V", 0x1, NULL, NULL },
    { "setOrthoToleranceWithDouble:", "setOrthoTolerance", "V", 0x1, NULL, NULL },
    { "setQRRankingThresholdWithDouble:", "setQRRankingThreshold", "V", 0x1, NULL, NULL },
    { "doOptimize", NULL, "Lorg.apache.commons.math.optimization.VectorialPointValuePair;", 0x4, "Lorg.apache.commons.math.FunctionEvaluationException;Lorg.apache.commons.math.optimization.OptimizationException;Ljava.lang.IllegalArgumentException;", NULL },
    { "determineLMParameterWithDoubleArray:withDouble:withDoubleArray:withDoubleArray:withDoubleArray:withDoubleArray:", "determineLMParameter", "V", 0x2, NULL, NULL },
    { "determineLMDirectionWithDoubleArray:withDoubleArray:withDoubleArray:withDoubleArray:", "determineLMDirection", "V", 0x2, NULL, NULL },
    { "qrDecomposition", NULL, "V", 0x2, "Lorg.apache.commons.math.optimization.OptimizationException;", NULL },
    { "qTyWithDoubleArray:", "qTy", "V", 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "solvedCols_", NULL, 0x2, "I", NULL, NULL,  },
    { "diagR_", NULL, 0x2, "[D", NULL, NULL,  },
    { "jacNorm_", NULL, 0x2, "[D", NULL, NULL,  },
    { "beta_", NULL, 0x2, "[D", NULL, NULL,  },
    { "permutation_", NULL, 0x2, "[I", NULL, NULL,  },
    { "rank_", NULL, 0x2, "I", NULL, NULL,  },
    { "lmPar_", NULL, 0x2, "D", NULL, NULL,  },
    { "lmDir_", NULL, 0x2, "[D", NULL, NULL,  },
    { "initialStepBoundFactor_", NULL, 0x2, "D", NULL, NULL,  },
    { "costRelativeTolerance_", NULL, 0x2, "D", NULL, NULL,  },
    { "parRelativeTolerance_", NULL, 0x2, "D", NULL, NULL,  },
    { "orthoTolerance_", NULL, 0x2, "D", NULL, NULL,  },
    { "qrRankingThreshold_", NULL, 0x2, "D", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer = { 2, "LevenbergMarquardtOptimizer", "org.apache.commons.math.optimization.general", NULL, 0x1, 11, methods, 13, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer;
}

@end

void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_init(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self) {
  OrgApacheCommonsMathOptimizationGeneralAbstractLeastSquaresOptimizer_init(self);
  [self setMaxIterationsWithInt:1000];
  [self setConvergenceCheckerWithOrgApacheCommonsMathOptimizationVectorialConvergenceChecker:nil];
  [self setInitialStepBoundFactorWithDouble:100.0];
  [self setCostRelativeToleranceWithDouble:1.0e-10];
  [self setParRelativeToleranceWithDouble:1.0e-10];
  [self setOrthoToleranceWithDouble:1.0e-10];
  [self setQRRankingThresholdWithDouble:OrgApacheCommonsMathUtilMathUtils_SAFE_MIN];
}

OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *new_OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_init() {
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self = [OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer alloc];
  OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_init(self);
  return self;
}

void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_determineLMParameterWithDoubleArray_withDouble_withDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self, IOSDoubleArray *qy, jdouble delta, IOSDoubleArray *diag, IOSDoubleArray *work1, IOSDoubleArray *work2, IOSDoubleArray *work3) {
  for (jint j = 0; j < self->rank_; ++j) {
    *IOSDoubleArray_GetRef(nil_chk(self->lmDir_), IOSIntArray_Get(nil_chk(self->permutation_), j)) = IOSDoubleArray_Get(nil_chk(qy), j);
  }
  for (jint j = self->rank_; j < self->cols_; ++j) {
    *IOSDoubleArray_GetRef(nil_chk(self->lmDir_), IOSIntArray_Get(nil_chk(self->permutation_), j)) = 0;
  }
  for (jint k = self->rank_ - 1; k >= 0; --k) {
    jint pk = IOSIntArray_Get(nil_chk(self->permutation_), k);
    jdouble ypk = IOSDoubleArray_Get(nil_chk(self->lmDir_), pk) / IOSDoubleArray_Get(nil_chk(self->diagR_), pk);
    for (jint i = 0; i < k; ++i) {
      *IOSDoubleArray_GetRef(self->lmDir_, IOSIntArray_Get(self->permutation_, i)) -= ypk * IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), i)), pk);
    }
    *IOSDoubleArray_GetRef(self->lmDir_, pk) = ypk;
  }
  jdouble dxNorm = 0;
  for (jint j = 0; j < self->solvedCols_; ++j) {
    jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
    jdouble s = IOSDoubleArray_Get(nil_chk(diag), pj) * IOSDoubleArray_Get(nil_chk(self->lmDir_), pj);
    *IOSDoubleArray_GetRef(nil_chk(work1), pj) = s;
    dxNorm += s * s;
  }
  dxNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(dxNorm);
  jdouble fp = dxNorm - delta;
  if (fp <= 0.1 * delta) {
    self->lmPar_ = 0;
    return;
  }
  jdouble sum2;
  jdouble parl = 0;
  if (self->rank_ == self->solvedCols_) {
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      *IOSDoubleArray_GetRef(nil_chk(work1), pj) *= IOSDoubleArray_Get(nil_chk(diag), pj) / dxNorm;
    }
    sum2 = 0;
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      jdouble sum = 0;
      for (jint i = 0; i < j; ++i) {
        sum += IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), i)), pj) * IOSDoubleArray_Get(nil_chk(work1), IOSIntArray_Get(self->permutation_, i));
      }
      jdouble s = (IOSDoubleArray_Get(nil_chk(work1), pj) - sum) / IOSDoubleArray_Get(nil_chk(self->diagR_), pj);
      *IOSDoubleArray_GetRef(work1, pj) = s;
      sum2 += s * s;
    }
    parl = fp / (delta * sum2);
  }
  sum2 = 0;
  for (jint j = 0; j < self->solvedCols_; ++j) {
    jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
    jdouble sum = 0;
    for (jint i = 0; i <= j; ++i) {
      sum += IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), i)), pj) * IOSDoubleArray_Get(nil_chk(qy), i);
    }
    sum /= IOSDoubleArray_Get(nil_chk(diag), pj);
    sum2 += sum * sum;
  }
  jdouble gNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(sum2);
  jdouble paru = gNorm / delta;
  if (paru == 0) {
    paru = 2.2251e-308 / OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(delta, 0.1);
  }
  self->lmPar_ = OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(paru, OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(self->lmPar_, parl));
  if (self->lmPar_ == 0) {
    self->lmPar_ = gNorm / dxNorm;
  }
  for (jint countdown = 10; countdown >= 0; --countdown) {
    if (self->lmPar_ == 0) {
      self->lmPar_ = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(2.2251e-308, 0.001 * paru);
    }
    jdouble sPar = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(self->lmPar_);
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      *IOSDoubleArray_GetRef(nil_chk(work1), pj) = sPar * IOSDoubleArray_Get(nil_chk(diag), pj);
    }
    OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_determineLMDirectionWithDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(self, qy, work1, work2, work3);
    dxNorm = 0;
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      jdouble s = IOSDoubleArray_Get(nil_chk(diag), pj) * IOSDoubleArray_Get(nil_chk(self->lmDir_), pj);
      *IOSDoubleArray_GetRef(nil_chk(work3), pj) = s;
      dxNorm += s * s;
    }
    dxNorm = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(dxNorm);
    jdouble previousFP = fp;
    fp = dxNorm - delta;
    if ((OrgApacheCommonsMathUtilFastMath_absWithDouble_(fp) <= 0.1 * delta) || ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {
      return;
    }
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      *IOSDoubleArray_GetRef(nil_chk(work1), pj) = IOSDoubleArray_Get(nil_chk(work3), pj) * IOSDoubleArray_Get(nil_chk(diag), pj) / dxNorm;
    }
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      *IOSDoubleArray_GetRef(nil_chk(work1), pj) /= IOSDoubleArray_Get(nil_chk(work2), j);
      jdouble tmp = IOSDoubleArray_Get(work1, pj);
      for (jint i = j + 1; i < self->solvedCols_; ++i) {
        *IOSDoubleArray_GetRef(work1, IOSIntArray_Get(self->permutation_, i)) -= IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), i)), pj) * tmp;
      }
    }
    sum2 = 0;
    for (jint j = 0; j < self->solvedCols_; ++j) {
      jdouble s = IOSDoubleArray_Get(nil_chk(work1), IOSIntArray_Get(nil_chk(self->permutation_), j));
      sum2 += s * s;
    }
    jdouble correction = fp / (delta * sum2);
    if (fp > 0) {
      parl = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(parl, self->lmPar_);
    }
    else if (fp < 0) {
      paru = OrgApacheCommonsMathUtilFastMath_minWithDouble_withDouble_(paru, self->lmPar_);
    }
    self->lmPar_ = OrgApacheCommonsMathUtilFastMath_maxWithDouble_withDouble_(parl, self->lmPar_ + correction);
  }
}

void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_determineLMDirectionWithDoubleArray_withDoubleArray_withDoubleArray_withDoubleArray_(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self, IOSDoubleArray *qy, IOSDoubleArray *diag, IOSDoubleArray *lmDiag, IOSDoubleArray *work) {
  for (jint j = 0; j < self->solvedCols_; ++j) {
    jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
    for (jint i = j + 1; i < self->solvedCols_; ++i) {
      *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), i)), pj) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(self->wjacobian_, j)), IOSIntArray_Get(self->permutation_, i));
    }
    *IOSDoubleArray_GetRef(nil_chk(self->lmDir_), j) = IOSDoubleArray_Get(nil_chk(self->diagR_), pj);
    *IOSDoubleArray_GetRef(nil_chk(work), j) = IOSDoubleArray_Get(nil_chk(qy), j);
  }
  for (jint j = 0; j < self->solvedCols_; ++j) {
    jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
    jdouble dpj = IOSDoubleArray_Get(nil_chk(diag), pj);
    if (dpj != 0) {
      JavaUtilArrays_fillWithDoubleArray_withInt_withInt_withDouble_(lmDiag, j + 1, ((IOSDoubleArray *) nil_chk(lmDiag))->size_, 0);
    }
    *IOSDoubleArray_GetRef(nil_chk(lmDiag), j) = dpj;
    jdouble qtbpj = 0;
    for (jint k = j; k < self->solvedCols_; ++k) {
      jint pk = IOSIntArray_Get(self->permutation_, k);
      if (IOSDoubleArray_Get(lmDiag, k) != 0) {
        jdouble sin;
        jdouble cos;
        jdouble rkk = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), k)), pk);
        if (OrgApacheCommonsMathUtilFastMath_absWithDouble_(rkk) < OrgApacheCommonsMathUtilFastMath_absWithDouble_(IOSDoubleArray_Get(lmDiag, k))) {
          jdouble cotan = rkk / IOSDoubleArray_Get(lmDiag, k);
          sin = 1.0 / OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(1.0 + cotan * cotan);
          cos = sin * cotan;
        }
        else {
          jdouble tan = IOSDoubleArray_Get(lmDiag, k) / rkk;
          cos = 1.0 / OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(1.0 + tan * tan);
          sin = cos * tan;
        }
        *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(self->wjacobian_, k)), pk) = cos * rkk + sin * IOSDoubleArray_Get(lmDiag, k);
        jdouble temp = cos * IOSDoubleArray_Get(nil_chk(work), k) + sin * qtbpj;
        qtbpj = -sin * IOSDoubleArray_Get(work, k) + cos * qtbpj;
        *IOSDoubleArray_GetRef(work, k) = temp;
        for (jint i = k + 1; i < self->solvedCols_; ++i) {
          jdouble rik = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(self->wjacobian_, i)), pk);
          jdouble temp2 = cos * rik + sin * IOSDoubleArray_Get(lmDiag, i);
          *IOSDoubleArray_GetRef(lmDiag, i) = -sin * rik + cos * IOSDoubleArray_Get(lmDiag, i);
          *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(self->wjacobian_, i)), pk) = temp2;
        }
      }
    }
    *IOSDoubleArray_GetRef(lmDiag, j) = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), j)), IOSIntArray_Get(self->permutation_, j));
    *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(self->wjacobian_, j)), IOSIntArray_Get(self->permutation_, j)) = IOSDoubleArray_Get(nil_chk(self->lmDir_), j);
  }
  jint nSing = self->solvedCols_;
  for (jint j = 0; j < self->solvedCols_; ++j) {
    if ((IOSDoubleArray_Get(nil_chk(lmDiag), j) == 0) && (nSing == self->solvedCols_)) {
      nSing = j;
    }
    if (nSing < self->solvedCols_) {
      *IOSDoubleArray_GetRef(nil_chk(work), j) = 0;
    }
  }
  if (nSing > 0) {
    for (jint j = nSing - 1; j >= 0; --j) {
      jint pj = IOSIntArray_Get(nil_chk(self->permutation_), j);
      jdouble sum = 0;
      for (jint i = j + 1; i < nSing; ++i) {
        sum += IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), i)), pj) * IOSDoubleArray_Get(nil_chk(work), i);
      }
      *IOSDoubleArray_GetRef(nil_chk(work), j) = (IOSDoubleArray_Get(work, j) - sum) / IOSDoubleArray_Get(nil_chk(lmDiag), j);
    }
  }
  for (jint j = 0; j < ((IOSDoubleArray *) nil_chk(self->lmDir_))->size_; ++j) {
    *IOSDoubleArray_GetRef(self->lmDir_, IOSIntArray_Get(nil_chk(self->permutation_), j)) = IOSDoubleArray_Get(nil_chk(work), j);
  }
}

void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_qrDecomposition(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self) {
  for (jint k = 0; k < self->cols_; ++k) {
    *IOSIntArray_GetRef(nil_chk(self->permutation_), k) = k;
    jdouble norm2 = 0;
    for (jint i = 0; i < ((IOSObjectArray *) nil_chk(self->wjacobian_))->size_; ++i) {
      jdouble akk = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(self->wjacobian_, i)), k);
      norm2 += akk * akk;
    }
    *IOSDoubleArray_GetRef(nil_chk(self->jacNorm_), k) = OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(norm2);
  }
  for (jint k = 0; k < self->cols_; ++k) {
    jint nextColumn = -1;
    jdouble ak2 = JavaLangDouble_NEGATIVE_INFINITY;
    for (jint i = k; i < self->cols_; ++i) {
      jdouble norm2 = 0;
      for (jint j = k; j < ((IOSObjectArray *) nil_chk(self->wjacobian_))->size_; ++j) {
        jdouble aki = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(self->wjacobian_, j)), IOSIntArray_Get(nil_chk(self->permutation_), i));
        norm2 += aki * aki;
      }
      if (JavaLangDouble_isInfiniteWithDouble_(norm2) || JavaLangDouble_isNaNWithDouble_(norm2)) {
        @throw [new_OrgApacheCommonsMathOptimizationOptimizationException_initWithOrgApacheCommonsMathExceptionUtilLocalizable_withNSObjectArray_(OrgApacheCommonsMathExceptionUtilLocalizedFormatsEnum_get_UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN(), [IOSObjectArray arrayWithObjects:(id[]){ JavaLangInteger_valueOfWithInt_(self->rows_), JavaLangInteger_valueOfWithInt_(self->cols_) } count:2 type:NSObject_class_()]) autorelease];
      }
      if (norm2 > ak2) {
        nextColumn = i;
        ak2 = norm2;
      }
    }
    if (ak2 <= self->qrRankingThreshold_) {
      self->rank_ = k;
      return;
    }
    jint pk = IOSIntArray_Get(nil_chk(self->permutation_), nextColumn);
    *IOSIntArray_GetRef(self->permutation_, nextColumn) = IOSIntArray_Get(self->permutation_, k);
    *IOSIntArray_GetRef(self->permutation_, k) = pk;
    jdouble akk = IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), k)), pk);
    jdouble alpha = (akk > 0) ? -OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(ak2) : OrgApacheCommonsMathUtilFastMath_sqrtWithDouble_(ak2);
    jdouble betak = 1.0 / (ak2 - akk * alpha);
    *IOSDoubleArray_GetRef(nil_chk(self->beta_), pk) = betak;
    *IOSDoubleArray_GetRef(nil_chk(self->diagR_), pk) = alpha;
    *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(self->wjacobian_, k)), pk) -= alpha;
    for (jint dk = self->cols_ - 1 - k; dk > 0; --dk) {
      jdouble gamma = 0;
      for (jint j = k; j < self->wjacobian_->size_; ++j) {
        gamma += IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(self->wjacobian_, j)), pk) * IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(self->wjacobian_, j)), IOSIntArray_Get(self->permutation_, k + dk));
      }
      gamma *= betak;
      for (jint j = k; j < self->wjacobian_->size_; ++j) {
        *IOSDoubleArray_GetRef(nil_chk(IOSObjectArray_Get(self->wjacobian_, j)), IOSIntArray_Get(self->permutation_, k + dk)) -= gamma * IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(self->wjacobian_, j)), pk);
      }
    }
  }
  self->rank_ = self->solvedCols_;
}

void OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer_qTyWithDoubleArray_(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer *self, IOSDoubleArray *y) {
  for (jint k = 0; k < self->cols_; ++k) {
    jint pk = IOSIntArray_Get(nil_chk(self->permutation_), k);
    jdouble gamma = 0;
    for (jint i = k; i < self->rows_; ++i) {
      gamma += IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), i)), pk) * IOSDoubleArray_Get(nil_chk(y), i);
    }
    gamma *= IOSDoubleArray_Get(nil_chk(self->beta_), pk);
    for (jint i = k; i < self->rows_; ++i) {
      *IOSDoubleArray_GetRef(nil_chk(y), i) -= gamma * IOSDoubleArray_Get(nil_chk(IOSObjectArray_Get(nil_chk(self->wjacobian_), i)), pk);
    }
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgApacheCommonsMathOptimizationGeneralLevenbergMarquardtOptimizer)
