//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeoGebraiOSARC/GeoGebraiOSARC/javasources/org/geogebra/common/gui/inputfield/MyTextField.java
//


#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "org/geogebra/common/gui/inputfield/MyTextField.h"
#include "org/geogebra/common/gui/inputfield/ValidateAutocompletionResult.h"
#include "org/geogebra/common/util/StringUtil.h"

@implementation OrgGeogebraCommonGuiInputfieldMyTextField

+ (IOSIntArray *)getBracketPositionsWithNSString:(NSString *)inputText
                                         withInt:(jint)caret {
  return OrgGeogebraCommonGuiInputfieldMyTextField_getBracketPositionsWithNSString_withInt_(inputText, caret);
}

+ (jboolean)isCloseBracketOrWhitespaceWithChar:(jchar)c {
  return OrgGeogebraCommonGuiInputfieldMyTextField_isCloseBracketOrWhitespaceWithChar_(c);
}

+ (OrgGeogebraCommonGuiInputfieldValidateAutocompletionResult *)commonValidateAutocompletionWithInt:(jint)index
                                                                                   withJavaUtilList:(id<JavaUtilList>)completions
                                                                                       withNSString:(NSString *)text
                                                                                            withInt:(jint)curWordStart {
  return OrgGeogebraCommonGuiInputfieldMyTextField_commonValidateAutocompletionWithInt_withJavaUtilList_withNSString_withInt_(index, completions, text, curWordStart);
}

- (void)setShowSymbolTableIconWithBoolean:(jboolean)showSymbolTableIcon {
}

- (instancetype)init {
  OrgGeogebraCommonGuiInputfieldMyTextField_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getBracketPositionsWithNSString:withInt:", "getBracketPositions", "[I", 0x9, NULL, NULL },
    { "isCloseBracketOrWhitespaceWithChar:", "isCloseBracketOrWhitespace", "Z", 0x9, NULL, NULL },
    { "commonValidateAutocompletionWithInt:withJavaUtilList:withNSString:withInt:", "commonValidateAutocompletion", "Lorg.geogebra.common.gui.inputfield.ValidateAutocompletionResult;", 0x9, NULL, NULL },
    { "setShowSymbolTableIconWithBoolean:", "setShowSymbolTableIcon", "V", 0x1, NULL, NULL },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcClassInfo _OrgGeogebraCommonGuiInputfieldMyTextField = { 2, "MyTextField", "org.geogebra.common.gui.inputfield", NULL, 0x401, 5, methods, 0, NULL, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgGeogebraCommonGuiInputfieldMyTextField;
}

@end

IOSIntArray *OrgGeogebraCommonGuiInputfieldMyTextField_getBracketPositionsWithNSString_withInt_(NSString *inputText, jint caret) {
  OrgGeogebraCommonGuiInputfieldMyTextField_initialize();
  NSString *text = inputText;
  jint bracketPos0 = -1;
  jint bracketPos1 = -1;
  jint searchDirection = 0;
  jint searchEnd = 0;
  jchar bracketToMatch = ' ';
  jchar oppositeBracketToMatch = ' ';
  if (caret > 0 && caret <= ((jint) [((NSString *) nil_chk(text)) length])) {
    jchar c = [text charAtWithInt:caret - 1];
    bracketPos0 = caret - 1;
    switch (c) {
      case '(':
      searchDirection = +1;
      searchEnd = ((jint) [text length]);
      oppositeBracketToMatch = '(';
      bracketToMatch = ')';
      break;
      case '{':
      searchDirection = +1;
      searchEnd = ((jint) [text length]);
      oppositeBracketToMatch = '{';
      bracketToMatch = '}';
      break;
      case '[':
      searchDirection = +1;
      searchEnd = ((jint) [text length]);
      oppositeBracketToMatch = '[';
      bracketToMatch = ']';
      break;
      case ')':
      searchDirection = -1;
      searchEnd = -1;
      oppositeBracketToMatch = ')';
      bracketToMatch = '(';
      break;
      case '}':
      searchDirection = -1;
      searchEnd = -1;
      oppositeBracketToMatch = '}';
      bracketToMatch = '{';
      break;
      case ']':
      searchDirection = -1;
      searchEnd = -1;
      oppositeBracketToMatch = ']';
      bracketToMatch = '[';
      break;
      default:
      searchDirection = 0;
      bracketPos0 = -1;
      bracketPos1 = -1;
      break;
    }
  }
  jboolean textMode = NO;
  if (searchDirection != 0) {
    jint count = 0;
    for (jint i = caret - 1; i != searchEnd; i += searchDirection) {
      if ([((NSString *) nil_chk(text)) charAtWithInt:i] == '"') {
        textMode = !textMode;
      }
      if (!textMode && [text charAtWithInt:i] == bracketToMatch) {
        count++;
      }
      else if (!textMode && [text charAtWithInt:i] == oppositeBracketToMatch) {
        count--;
      }
      if (count == 0) {
        bracketPos1 = i;
        break;
      }
    }
  }
  IOSIntArray *result = [IOSIntArray newArrayWithInts:(jint[]){ bracketPos0, bracketPos1 } count:2];
  return result;
}

jboolean OrgGeogebraCommonGuiInputfieldMyTextField_isCloseBracketOrWhitespaceWithChar_(jchar c) {
  OrgGeogebraCommonGuiInputfieldMyTextField_initialize();
  return OrgGeogebraCommonUtilStringUtil_isWhitespaceWithChar_(c) || c == ')' || c == ']' || c == '}';
}

OrgGeogebraCommonGuiInputfieldValidateAutocompletionResult *OrgGeogebraCommonGuiInputfieldMyTextField_commonValidateAutocompletionWithInt_withJavaUtilList_withNSString_withInt_(jint index, id<JavaUtilList> completions, NSString *text, jint curWordStart) {
  OrgGeogebraCommonGuiInputfieldMyTextField_initialize();
  OrgGeogebraCommonGuiInputfieldValidateAutocompletionResult *ret = new_OrgGeogebraCommonGuiInputfieldValidateAutocompletionResult_init();
  if (completions == nil || index < 0 || index >= [completions size]) {
    ret->returnval_ = NO;
  }
  NSString *command = [((id<JavaUtilList>) nil_chk(completions)) getWithInt:index];
  JavaLangStringBuilder *sb = new_JavaLangStringBuilder_init();
  jint carPos = 0;
  IOSCharArray *tArray = [((NSString *) nil_chk(text)) toCharArray];
  JavaUtilArrayList *textTokens = new_JavaUtilArrayList_init();
  jint textBLPos = -1;
  jint textBRPos = -1;
  jint textFirstComma = -1;
  jint textBLCount = 0;
  jint textParams = 0;
  sb = new_JavaLangStringBuilder_init();
  NSString *lastToken = @"";
  for (jint i = 0; i < ((IOSCharArray *) nil_chk(tArray))->size_; i++) {
    switch (IOSCharArray_Get(tArray, i)) {
      case '[':
      [textTokens addWithId:[sb description]];
      sb = new_JavaLangStringBuilder_init();
      [textTokens addWithId:@"["];
      lastToken = @"[";
      if (textBLPos == -1) {
        textBLPos = [textTokens size] - 1;
      }
      textBLCount++;
      break;
      case ']':
      if (![lastToken isEqual:@"["] || ([lastToken isEqual:@"["] && ((jint) [((NSString *) nil_chk([((NSString *) nil_chk([sb description])) trim])) length]) != 0)) {
        textParams++;
      }
      if ([sb length] > 0) {
        [textTokens addWithId:[sb description]];
        sb = new_JavaLangStringBuilder_init();
      }
      [textTokens addWithId:@"]"];
      lastToken = @"]";
      if (textBRPos == -1) {
        textBRPos = [textTokens size] - 1;
      }
      break;
      case ',':
      [textTokens addWithId:[sb description]];
      sb = new_JavaLangStringBuilder_init();
      [textTokens addWithId:@","];
      lastToken = @",";
      if (textFirstComma == -1) {
        textFirstComma = [textTokens size] - 1;
      }
      textParams++;
      break;
      case '=':
      [textTokens addWithId:[sb description]];
      sb = new_JavaLangStringBuilder_init();
      [textTokens addWithId:@"="];
      lastToken = @"=";
      break;
      default:
      (void) [sb appendWithChar:IOSCharArray_Get(tArray, i)];
    }
    if (i == tArray->size_ - 1 && [sb length] != 0) {
      [textTokens addWithId:[sb description]];
      sb = new_JavaLangStringBuilder_init();
    }
  }
  sb = new_JavaLangStringBuilder_init();
  IOSCharArray *cArray = [((NSString *) nil_chk(command)) toCharArray];
  JavaUtilArrayList *commandTokens = new_JavaUtilArrayList_init();
  sb = new_JavaLangStringBuilder_init();
  jint commandBLPos = -1;
  jint commandParams = 0;
  for (jint i = 0; i < ((IOSCharArray *) nil_chk(cArray))->size_; i++) {
    switch (IOSCharArray_Get(cArray, i)) {
      case '[':
      [commandTokens addWithId:[sb description]];
      sb = new_JavaLangStringBuilder_init();
      [commandTokens addWithId:@"["];
      lastToken = @"[";
      commandBLPos = [commandTokens size] - 1;
      break;
      case ']':
      if (![lastToken isEqual:@"["] || ([lastToken isEqual:@"["] && ((jint) [((NSString *) nil_chk([((NSString *) nil_chk([sb description])) trim])) length]) != 0)) {
        commandParams++;
      }
      if ([sb length] > 0) {
        [commandTokens addWithId:[sb description]];
        sb = new_JavaLangStringBuilder_init();
      }
      [commandTokens addWithId:@"]"];
      lastToken = @"]";
      break;
      case ',':
      [commandTokens addWithId:[sb description]];
      sb = new_JavaLangStringBuilder_init();
      commandParams++;
      [commandTokens addWithId:@","];
      lastToken = @",";
      break;
      default:
      if (!OrgGeogebraCommonUtilStringUtil_isWhitespaceWithChar_(IOSCharArray_Get(cArray, i))) {
        (void) [sb appendWithChar:IOSCharArray_Get(cArray, i)];
      }
    }
    if (i == cArray->size_ - 1 && [sb length] != 0) {
      [commandTokens addWithId:[sb description]];
      sb = new_JavaLangStringBuilder_init();
    }
  }
  sb = new_JavaLangStringBuilder_init();
  jint startPos = 0;
  jint length = 0;
  id<JavaUtilIterator> iterator = [textTokens iterator];
  while ([((id<JavaUtilIterator>) nil_chk(iterator)) hasNext]) {
    length += ((jint) [((NSString *) nil_chk([iterator next])) length]);
    if (length > curWordStart) {
      break;
    }
    startPos++;
  }
  iterator = nil;
  NSString *current;
  for (jint i = 0; i < startPos; i++) {
    current = [((NSString *) nil_chk([textTokens getWithInt:i])) trim];
    if ([((NSString *) nil_chk(current)) isEqual:@"["]) {
      (void) [sb appendWithChar:'['];
      if (i + 1 < [textTokens size] && ![((NSString *) nil_chk([textTokens getWithInt:i + 1])) isEqual:@"]"]) {
        (void) [sb appendWithChar:' '];
      }
    }
    else if ([current isEqual:@"]"]) {
      if (i - 1 >= 0 && ![((NSString *) nil_chk([textTokens getWithInt:i - 1])) isEqual:@"["]) {
        (void) [sb appendWithChar:' '];
      }
      (void) [sb appendWithChar:']'];
    }
    else if ([current isEqual:@","]) {
      (void) [sb appendWithNSString:@", "];
    }
    else {
      (void) [sb appendWithNSString:current];
    }
  }
  (void) [sb appendWithNSString:[commandTokens getWithInt:0]];
  if (textBLCount == 0) {
    if (commandParams == 0) {
      (void) [sb appendWithNSString:@"[]"];
      carPos = [sb length];
    }
    else {
      carPos = [sb length];
      (void) [sb appendWithNSString:@"[ "];
      for (jint i = commandBLPos + 1; i < [commandTokens size]; i++) {
        current = [commandTokens getWithInt:i];
        if ([((NSString *) nil_chk(current)) isEqual:@"["]) {
          (void) [sb appendWithNSString:@"[ "];
        }
        else if ([current isEqual:@"]"]) {
          (void) [sb appendWithNSString:@" ]"];
        }
        else if ([current isEqual:@","]) {
          (void) [sb appendWithNSString:@", "];
        }
        else {
          (void) [sb appendWithNSString:current];
        }
      }
    }
  }
  else {
    if (startPos + 1 < [textTokens size]) {
      if ([((NSString *) nil_chk([((NSString *) nil_chk([textTokens getWithInt:startPos + 1])) trim])) isEqual:@","] || [((NSString *) nil_chk([((NSString *) nil_chk([textTokens getWithInt:startPos + 1])) trim])) isEqual:@"]"]) {
        if (commandParams == 0) {
          (void) [sb appendWithNSString:@"[]"];
        }
        else {
          for (jint i = 1; i < [commandTokens size]; i++) {
            current = [((NSString *) nil_chk([commandTokens getWithInt:i])) trim];
            if ([((NSString *) nil_chk(current)) isEqual:@"["]) {
              carPos = [sb length];
              (void) [sb appendWithNSString:@"[ "];
            }
            else if ([current isEqual:@"]"]) {
              (void) [sb appendWithNSString:@" ]"];
            }
            else if ([current isEqual:@","]) {
              (void) [sb appendWithNSString:@", "];
            }
            else {
              (void) [sb appendWithNSString:current];
            }
          }
        }
        for (jint i = startPos + 1; i < [textTokens size]; i++) {
          current = [((NSString *) nil_chk([textTokens getWithInt:i])) trim];
          if ([((NSString *) nil_chk(current)) isEqual:@"["]) {
            (void) [sb appendWithChar:'['];
            if (i + 1 < [textTokens size] && ![((NSString *) nil_chk([textTokens getWithInt:i + 1])) isEqual:@"]"]) {
              (void) [sb appendWithChar:' '];
            }
          }
          else if ([current isEqual:@"]"]) {
            if (i - 1 >= 0 && ![((NSString *) nil_chk([textTokens getWithInt:i - 1])) isEqual:@"["]) {
              (void) [sb appendWithChar:' '];
            }
            (void) [sb appendWithChar:']'];
          }
          else if ([current isEqual:@","]) {
            (void) [sb appendWithNSString:@", "];
          }
          else {
            (void) [sb appendWithNSString:current];
          }
        }
      }
      else if ([((NSString *) nil_chk([((NSString *) nil_chk([textTokens getWithInt:startPos + 1])) trim])) isEqual:@"["]) {
        jint openBrackets = 0;
        jint params = 0;
        jint lastIndex = 0;
        carPos = [sb length];
        for (jint i = startPos + 1; i < [textTokens size]; i++) {
          current = [((NSString *) nil_chk([textTokens getWithInt:i])) trim];
          if ([((NSString *) nil_chk(current)) isEqual:@"["]) {
            openBrackets++;
            (void) [sb appendWithChar:'['];
            if (i + 1 < [textTokens size] && ![((NSString *) nil_chk([textTokens getWithInt:i + 1])) isEqual:@"]"]) {
              (void) [sb appendWithChar:' '];
            }
          }
          else if ([current isEqual:@"]"]) {
            if (openBrackets == 1) {
              params++;
            }
            else {
              if (i - 1 >= 0 && ![((NSString *) nil_chk([textTokens getWithInt:i - 1])) isEqual:@"["]) {
                (void) [sb appendWithChar:' '];
              }
              (void) [sb appendWithChar:']'];
            }
            openBrackets--;
            if (openBrackets == 0) {
              lastIndex = i + 1;
              break;
            }
          }
          else if ([current isEqual:@","]) {
            (void) [sb appendWithNSString:@", "];
            if (openBrackets == 1) {
              params++;
            }
          }
          else {
            (void) [sb appendWithNSString:current];
          }
        }
        if (params < commandParams) {
          (void) [sb appendWithNSString:@", "];
          carPos = [sb length];
          for (jint i = 2 + 2 * params; i < [commandTokens size]; i++) {
            current = [commandTokens getWithInt:i];
            if ([((NSString *) nil_chk(current)) isEqual:@"["]) {
              carPos = [sb length];
              (void) [sb appendWithNSString:@"[ "];
            }
            else if ([current isEqual:@"]"]) {
              (void) [sb appendWithNSString:@" ]"];
            }
            else if ([current isEqual:@","]) {
              (void) [sb appendWithNSString:@", "];
            }
            else {
              (void) [sb appendWithNSString:current];
            }
          }
        }
        else {
          if (commandParams == 0) {
            (void) [sb appendWithChar:']'];
          }
          else {
            (void) [sb appendWithNSString:@" ]"];
          }
        }
        for (jint i = lastIndex; i < [textTokens size]; i++) {
          current = [((NSString *) nil_chk([textTokens getWithInt:i])) trim];
          if ([((NSString *) nil_chk(current)) isEqual:@"["]) {
            carPos = [sb length];
            (void) [sb appendWithChar:'['];
            if (i + 1 < [textTokens size] && ![((NSString *) nil_chk([textTokens getWithInt:i + 1])) isEqual:@"]"]) {
              (void) [sb appendWithChar:' '];
            }
          }
          else if ([current isEqual:@"]"]) {
            if (i - 1 >= 0 && ![((NSString *) nil_chk([textTokens getWithInt:i - 1])) isEqual:@"["]) {
              (void) [sb appendWithChar:' '];
            }
            (void) [sb appendWithChar:']'];
          }
          else if ([current isEqual:@","]) {
            (void) [sb appendWithNSString:@", "];
          }
          else {
            (void) [sb appendWithNSString:current];
          }
        }
      }
    }
    else {
    }
  }
  if (textParams + commandParams == 0) {
    carPos = [sb length];
  }
  ret->carPos_ = carPos;
  ret->sb_ = [sb description];
  return ret;
}

void OrgGeogebraCommonGuiInputfieldMyTextField_init(OrgGeogebraCommonGuiInputfieldMyTextField *self) {
  (void) NSObject_init(self);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgGeogebraCommonGuiInputfieldMyTextField)
