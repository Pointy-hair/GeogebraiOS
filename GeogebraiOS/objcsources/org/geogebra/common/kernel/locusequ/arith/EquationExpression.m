//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeogebraiOS/GeogebraiOS/sources/org/geogebra/common/kernel/locusequ/arith/EquationExpression.java
//


#include "IOSClass.h"
#include "J2ObjC_source.h"
#include "java/lang/Boolean.h"
#include "java/lang/Double.h"
#include "org/geogebra/common/kernel/locusequ/EquationTranslator.h"
#include "org/geogebra/common/kernel/locusequ/arith/EquationExpression.h"
#include "org/geogebra/common/kernel/locusequ/arith/EquationInverseOperator.h"
#include "org/geogebra/common/kernel/locusequ/arith/EquationOppositeOperator.h"

@interface OrgGeogebraCommonKernelLocusequArithEquationExpression () {
 @public
  JavaLangBoolean *containsSymbolicValues__;
}

@end

J2OBJC_FIELD_SETTER(OrgGeogebraCommonKernelLocusequArithEquationExpression, containsSymbolicValues__, JavaLangBoolean *)

@implementation OrgGeogebraCommonKernelLocusequArithEquationExpression

- (OrgGeogebraCommonKernelLocusequArithEquationExpression *)getOpposite {
  if (self->opposite_ == nil) {
    OrgGeogebraCommonKernelLocusequArithEquationExpression_setAndConsume_opposite_(self, new_OrgGeogebraCommonKernelLocusequArithEquationOppositeOperator_initWithOrgGeogebraCommonKernelLocusequArithEquationExpression_(self));
  }
  return self->opposite_;
}

- (OrgGeogebraCommonKernelLocusequArithEquationExpression *)getInverse {
  if (self->inverse_ == nil) {
    OrgGeogebraCommonKernelLocusequArithEquationExpression_setAndConsume_inverse_(self, new_OrgGeogebraCommonKernelLocusequArithEquationInverseOperator_initWithOrgGeogebraCommonKernelLocusequArithEquationExpression_(self));
  }
  return self->inverse_;
}

- (jboolean)isTerm {
  return NO;
}

- (jboolean)isNumericValue {
  return NO;
}

- (jboolean)isAuxiliarSymbolicValue {
  return NO;
}

- (jboolean)isSymbolicValue {
  return NO;
}

- (jboolean)isSpecialSymbolicValue {
  return NO;
}

- (jboolean)isAnySymbolicValue {
  return [self isAuxiliarSymbolicValue] || [self isSymbolicValue] || [self isSpecialSymbolicValue];
}

- (jboolean)isOperator {
  return NO;
}

- (jboolean)isSum {
  return NO;
}

- (jboolean)isDiff {
  return NO;
}

- (jboolean)isProduct {
  return NO;
}

- (jboolean)isDiv {
  return NO;
}

- (jboolean)isExp {
  return NO;
}

- (jboolean)isSqrt {
  return NO;
}

- (jboolean)isOpposite {
  return NO;
}

- (jboolean)isInverse {
  return NO;
}

- (jboolean)isAbs {
  return NO;
}

- (jboolean)containsSymbolicValues {
  if (self->containsSymbolicValues__ == nil) {
    OrgGeogebraCommonKernelLocusequArithEquationExpression_set_containsSymbolicValues__(self, JavaLangBoolean_valueOfWithBoolean_([self containsSymbolicValuesImpl]));
  }
  return [((JavaLangBoolean *) nil_chk(self->containsSymbolicValues__)) booleanValue];
}

- (jboolean)containsSymbolicValuesImpl {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jdouble)computeValue {
  if ([self containsSymbolicValuesImpl]) {
    return JavaLangDouble_NaN;
  }
  return [self computeValueImpl];
}

- (jdouble)computeValueImpl {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)translateImplWithOrgGeogebraCommonKernelLocusequEquationTranslator:(OrgGeogebraCommonKernelLocusequEquationTranslator *)translator {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id)translateWithOrgGeogebraCommonKernelLocusequEquationTranslator:(OrgGeogebraCommonKernelLocusequEquationTranslator *)translator {
  return [self translateImplWithOrgGeogebraCommonKernelLocusequEquationTranslator:translator];
}

- (jlong)toLong {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (jboolean)isSimplifiable {
  return ![self containsSymbolicValues] && !JavaLangDouble_isNaNWithDouble_([self computeValue]);
}

- (NSString *)description {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (instancetype)init {
  OrgGeogebraCommonKernelLocusequArithEquationExpression_init(self);
  return self;
}

- (void)dealloc {
  RELEASE_(opposite_);
  RELEASE_(inverse_);
  RELEASE_(containsSymbolicValues__);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getOpposite", NULL, "Lorg.geogebra.common.kernel.locusequ.arith.EquationExpression;", 0x1, NULL, NULL },
    { "getInverse", NULL, "Lorg.geogebra.common.kernel.locusequ.arith.EquationExpression;", 0x1, NULL, NULL },
    { "isTerm", NULL, "Z", 0x1, NULL, NULL },
    { "isNumericValue", NULL, "Z", 0x1, NULL, NULL },
    { "isAuxiliarSymbolicValue", NULL, "Z", 0x1, NULL, NULL },
    { "isSymbolicValue", NULL, "Z", 0x1, NULL, NULL },
    { "isSpecialSymbolicValue", NULL, "Z", 0x1, NULL, NULL },
    { "isAnySymbolicValue", NULL, "Z", 0x1, NULL, NULL },
    { "isOperator", NULL, "Z", 0x1, NULL, NULL },
    { "isSum", NULL, "Z", 0x1, NULL, NULL },
    { "isDiff", NULL, "Z", 0x1, NULL, NULL },
    { "isProduct", NULL, "Z", 0x1, NULL, NULL },
    { "isDiv", NULL, "Z", 0x1, NULL, NULL },
    { "isExp", NULL, "Z", 0x1, NULL, NULL },
    { "isSqrt", NULL, "Z", 0x1, NULL, NULL },
    { "isOpposite", NULL, "Z", 0x1, NULL, NULL },
    { "isInverse", NULL, "Z", 0x1, NULL, NULL },
    { "isAbs", NULL, "Z", 0x1, NULL, NULL },
    { "containsSymbolicValues", NULL, "Z", 0x1, NULL, NULL },
    { "containsSymbolicValuesImpl", NULL, "Z", 0x404, NULL, NULL },
    { "computeValue", NULL, "D", 0x1, NULL, NULL },
    { "computeValueImpl", NULL, "D", 0x404, NULL, NULL },
    { "translateImplWithOrgGeogebraCommonKernelLocusequEquationTranslator:", "translateImpl", "TT;", 0x404, NULL, "<T:Ljava/lang/Object;>(Lorg/geogebra/common/kernel/locusequ/EquationTranslator<TT;>;)TT;" },
    { "translateWithOrgGeogebraCommonKernelLocusequEquationTranslator:", "translate", "TT;", 0x1, NULL, "<T:Ljava/lang/Object;>(Lorg/geogebra/common/kernel/locusequ/EquationTranslator<TT;>;)TT;" },
    { "toLong", NULL, "J", 0x401, NULL, NULL },
    { "isSimplifiable", NULL, "Z", 0x1, NULL, NULL },
    { "description", "toString", "Ljava.lang.String;", 0x401, NULL, NULL },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "opposite_", NULL, 0x4, "Lorg.geogebra.common.kernel.locusequ.arith.EquationExpression;", NULL, NULL,  },
    { "inverse_", NULL, 0x4, "Lorg.geogebra.common.kernel.locusequ.arith.EquationExpression;", NULL, NULL,  },
    { "containsSymbolicValues__", "containsSymbolicValues", 0x2, "Ljava.lang.Boolean;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _OrgGeogebraCommonKernelLocusequArithEquationExpression = { 2, "EquationExpression", "org.geogebra.common.kernel.locusequ.arith", NULL, 0x401, 28, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgGeogebraCommonKernelLocusequArithEquationExpression;
}

@end

void OrgGeogebraCommonKernelLocusequArithEquationExpression_init(OrgGeogebraCommonKernelLocusequArithEquationExpression *self) {
  NSObject_init(self);
  OrgGeogebraCommonKernelLocusequArithEquationExpression_set_opposite_(self, nil);
  OrgGeogebraCommonKernelLocusequArithEquationExpression_set_inverse_(self, nil);
  OrgGeogebraCommonKernelLocusequArithEquationExpression_set_containsSymbolicValues__(self, nil);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgGeogebraCommonKernelLocusequArithEquationExpression)
