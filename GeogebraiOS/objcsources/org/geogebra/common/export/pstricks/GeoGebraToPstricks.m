//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeoGebraiOSARC/GeoGebraiOSARC/javasources/org/geogebra/common/export/pstricks/GeoGebraToPstricks.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Double.h"
#include "java/lang/Float.h"
#include "java/lang/Math.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringBuilder.h"
#include "java/util/ArrayList.h"
#include "java/util/HashMap.h"
#include "java/util/Iterator.h"
#include "org/geogebra/common/awt/GAffineTransform.h"
#include "org/geogebra/common/awt/GColor.h"
#include "org/geogebra/common/awt/GFont.h"
#include "org/geogebra/common/euclidian/DrawableND.h"
#include "org/geogebra/common/euclidian/EuclidianView.h"
#include "org/geogebra/common/euclidian/draw/DrawPoint.h"
#include "org/geogebra/common/export/pstricks/ExportSettings.h"
#include "org/geogebra/common/export/pstricks/GeoGebraExport.h"
#include "org/geogebra/common/export/pstricks/GeoGebraToPstricks.h"
#include "org/geogebra/common/export/pstricks/UnicodeTeX.h"
#include "org/geogebra/common/factories/AwtFactory.h"
#include "org/geogebra/common/kernel/Construction.h"
#include "org/geogebra/common/kernel/Kernel.h"
#include "org/geogebra/common/kernel/Matrix/Coords.h"
#include "org/geogebra/common/kernel/MyPoint.h"
#include "org/geogebra/common/kernel/StringTemplate.h"
#include "org/geogebra/common/kernel/algos/AlgoAngleLines.h"
#include "org/geogebra/common/kernel/algos/AlgoAnglePoints.h"
#include "org/geogebra/common/kernel/algos/AlgoAngleVector.h"
#include "org/geogebra/common/kernel/algos/AlgoAngleVectors.h"
#include "org/geogebra/common/kernel/algos/AlgoBoxPlot.h"
#include "org/geogebra/common/kernel/algos/AlgoElement.h"
#include "org/geogebra/common/kernel/algos/AlgoFunctionAreaSums.h"
#include "org/geogebra/common/kernel/algos/AlgoIntersectAbstract.h"
#include "org/geogebra/common/kernel/algos/AlgoSlope.h"
#include "org/geogebra/common/kernel/arithmetic/Function.h"
#include "org/geogebra/common/kernel/arithmetic/NumberValue.h"
#include "org/geogebra/common/kernel/cas/AlgoIntegralDefinite.h"
#include "org/geogebra/common/kernel/cas/AlgoIntegralFunctions.h"
#include "org/geogebra/common/kernel/commands/AlgebraProcessor.h"
#include "org/geogebra/common/kernel/geos/GeoAngle.h"
#include "org/geogebra/common/kernel/geos/GeoConic.h"
#include "org/geogebra/common/kernel/geos/GeoConicPart.h"
#include "org/geogebra/common/kernel/geos/GeoCurveCartesian.h"
#include "org/geogebra/common/kernel/geos/GeoElement.h"
#include "org/geogebra/common/kernel/geos/GeoFunction.h"
#include "org/geogebra/common/kernel/geos/GeoLine.h"
#include "org/geogebra/common/kernel/geos/GeoLocus.h"
#include "org/geogebra/common/kernel/geos/GeoNumeric.h"
#include "org/geogebra/common/kernel/geos/GeoPoint.h"
#include "org/geogebra/common/kernel/geos/GeoPolyLine.h"
#include "org/geogebra/common/kernel/geos/GeoPolygon.h"
#include "org/geogebra/common/kernel/geos/GeoRay.h"
#include "org/geogebra/common/kernel/geos/GeoSegment.h"
#include "org/geogebra/common/kernel/geos/GeoText.h"
#include "org/geogebra/common/kernel/geos/GeoTransferFunction.h"
#include "org/geogebra/common/kernel/geos/GeoVec2D.h"
#include "org/geogebra/common/kernel/geos/GeoVec3D.h"
#include "org/geogebra/common/kernel/geos/GeoVector.h"
#include "org/geogebra/common/kernel/implicit/GeoImplicitPoly.h"
#include "org/geogebra/common/kernel/kernelND/GeoConicNDConstants.h"
#include "org/geogebra/common/kernel/kernelND/GeoPointND.h"
#include "org/geogebra/common/kernel/kernelND/GeoVectorND.h"
#include "org/geogebra/common/main/App.h"
#include "org/geogebra/common/plugin/EuclidianStyleConstants.h"
#include "org/geogebra/common/util/GStringTokenizer.h"
#include "org/geogebra/common/util/StringUtil.h"
#include "org/geogebra/common/util/Unicode.h"

#define OrgGeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER 1

@interface OrgGeogebraCommonExportPstricksGeoGebraToPstricks () {
 @public
  jboolean eurosym_;
  JavaLangStringBuilder *codeBeginPic_;
}

+ (NSString *)killSpaceWithNSString:(NSString *)name;

+ (void)renameFuncWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                               withNSString:(NSString *)nameFunc
                               withNSString:(NSString *)nameNew;

- (jdouble)maxDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction:(OrgGeogebraCommonKernelGeosGeoFunction *)f
                                                          withDouble:(jdouble)a
                                                          withDouble:(jdouble)b;

- (jdouble)firstDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction:(OrgGeogebraCommonKernelGeosGeoFunction *)f
                                                            withDouble:(jdouble)a
                                                            withDouble:(jdouble)b;

- (void)drawCircleWithOrgGeogebraCommonKernelGeosGeoConic:(OrgGeogebraCommonKernelGeosGeoConic *)geo;

- (void)initUnitAndVariable OBJC_METHOD_FAMILY_NONE;

- (void)drawGrid;

- (void)drawAxis;

- (void)PointOptionCodeWithOrgGeogebraCommonKernelGeosGeoPoint:(OrgGeogebraCommonKernelGeosGeoPoint *)geo;

- (void)LinestyleCodeWithInt:(jint)linestyle
   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb;

- (void)addTextWithNSString:(NSString *)st
                withBoolean:(jboolean)isLatex
                    withInt:(jint)style
withOrgGeogebraCommonAwtGColor:(OrgGeogebraCommonAwtGColor *)geocolor;

@end

J2OBJC_FIELD_SETTER(OrgGeogebraCommonExportPstricksGeoGebraToPstricks, codeBeginPic_, JavaLangStringBuilder *)

J2OBJC_STATIC_FIELD_GETTER(OrgGeogebraCommonExportPstricksGeoGebraToPstricks, FORMAT_BEAMER, jint)

__attribute__((unused)) static NSString *OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(NSString *name);

__attribute__((unused)) static void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(JavaLangStringBuilder *sb, NSString *nameFunc, NSString *nameNew);

__attribute__((unused)) static jdouble OrgGeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b);

__attribute__((unused)) static jdouble OrgGeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b);

__attribute__((unused)) static void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawCircleWithOrgGeogebraCommonKernelGeosGeoConic_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonKernelGeosGeoConic *geo);

__attribute__((unused)) static void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_initUnitAndVariable(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self);

__attribute__((unused)) static void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawGrid(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self);

__attribute__((unused)) static void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawAxis(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self);

__attribute__((unused)) static void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_PointOptionCodeWithOrgGeogebraCommonKernelGeosGeoPoint_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonKernelGeosGeoPoint *geo);

__attribute__((unused)) static void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_LinestyleCodeWithInt_withJavaLangStringBuilder_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, jint linestyle, JavaLangStringBuilder *sb);

__attribute__((unused)) static void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withOrgGeogebraCommonAwtGColor_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, NSString *st, jboolean isLatex, jint style, OrgGeogebraCommonAwtGColor *geocolor);

@implementation OrgGeogebraCommonExportPstricksGeoGebraToPstricks

- (instancetype)initWithOrgGeogebraCommonMainApp:(OrgGeogebraCommonMainApp *)app {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_initWithOrgGeogebraCommonMainApp_(self, app);
  return self;
}

- (void)generateAllCode {
  format__ = [((id<OrgGeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) getFormat];
  @try {
    xunit_ = [frame_ getXUnit];
    yunit_ = [frame_ getYUnit];
  }
  @catch (JavaLangNullPointerException *e2) {
    xunit_ = 1;
    yunit_ = 1;
  }
  code_ = new_JavaLangStringBuilder_init();
  codePoint_ = new_JavaLangStringBuilder_init();
  codePreamble_ = new_JavaLangStringBuilder_init();
  codeFilledObject_ = new_JavaLangStringBuilder_init();
  codeBeginDoc_ = new_JavaLangStringBuilder_init();
  codeBeginPic_ = new_JavaLangStringBuilder_init();
  CustomColor_ = new_JavaUtilHashMap_init();
  if (format__ == OrgGeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER) {
    (void) [codePreamble_ appendWithNSString:JreStrcat("$I$", @"\\documentclass[", [frame_ getFontSize], @"pt]{beamer}\n")];
  }
  else {
    (void) [codePreamble_ appendWithNSString:JreStrcat("$I$", @"\\documentclass[", [frame_ getFontSize], @"pt]{article}\n")];
  }
  (void) [codePreamble_ appendWithNSString:@"\\usepackage{pstricks-add}\n\\pagestyle{empty}\n"];
  (void) [codeBeginDoc_ appendWithNSString:@"\\begin{document}\n"];
  if (format__ == OrgGeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER) {
    (void) [codeBeginDoc_ appendWithNSString:@"\\begin{frame}\n"];
  }
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_initUnitAndVariable(self);
  (void) [codeBeginPic_ appendWithNSString:@"\\begin{pspicture*}("];
  (void) [codeBeginPic_ appendWithNSString:[self formatWithDouble:xmin_]];
  (void) [codeBeginPic_ appendWithNSString:@","];
  (void) [codeBeginPic_ appendWithNSString:[self formatWithDouble:ymin_]];
  (void) [codeBeginPic_ appendWithNSString:@")("];
  (void) [codeBeginPic_ appendWithNSString:[self formatWithDouble:xmax_]];
  (void) [codeBeginPic_ appendWithNSString:@","];
  (void) [codeBeginPic_ appendWithNSString:[self formatWithDouble:ymax_]];
  (void) [codeBeginPic_ appendWithNSString:@")\n"];
  if ([((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getShowGrid]) {
    OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawGrid(self);
  }
  if ([euclidianView_ getShowXaxis] || [euclidianView_ getShowYaxis]) {
    OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawAxis(self);
  }
  [self drawAllElements];
  if ([codePoint_ length] != 0) {
    (void) [codePoint_ insertWithInt:0 withNSString:@"\\begin{scriptsize}\n"];
    (void) [codePoint_ appendWithNSString:@"\\end{scriptsize}\n"];
  }
  (void) [code_ appendWithJavaLangCharSequence:codePoint_];
  (void) [code_ appendWithNSString:@"\\end{pspicture*}\n"];
  (void) [code_ insertWithInt:0 withNSString:JreStrcat("@", codeFilledObject_)];
  (void) [code_ insertWithInt:0 withNSString:JreStrcat("@", codeBeginPic_)];
  (void) [code_ insertWithInt:0 withNSString:JreStrcat("@", codeBeginDoc_)];
  (void) [code_ insertWithInt:0 withNSString:JreStrcat("@", codePreamble_)];
  if (format__ == OrgGeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER) {
    (void) [code_ appendWithNSString:@"\\end{frame}\n"];
  }
  (void) [code_ appendWithNSString:@"\\end{document}"];
  [frame_ writeWithJavaLangStringBuilder:code_];
}

- (void)drawLocusWithOrgGeogebraCommonKernelGeosGeoLocus:(OrgGeogebraCommonKernelGeosGeoLocus *)g {
  JavaUtilArrayList *ll = [((OrgGeogebraCommonKernelGeosGeoLocus *) nil_chk(g)) getPoints];
  id<JavaUtilIterator> it = [((JavaUtilArrayList *) nil_chk(ll)) iterator];
  [self startBeamerWithJavaLangStringBuilder:code_];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\pscustom"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:g withBoolean:YES]];
  (void) [code_ appendWithNSString:@"{"];
  jboolean first = YES;
  jboolean out = NO;
  while ([((id<JavaUtilIterator>) nil_chk(it)) hasNext]) {
    OrgGeogebraCommonKernelMyPoint *mp = [it next];
    if (((OrgGeogebraCommonKernelMyPoint *) nil_chk(mp))->x_ > xmin_ && mp->x_ < xmax_ && mp->y_ > ymin_ && mp->y_ < ymax_) {
      NSString *x = [self formatWithDouble:mp->x_];
      NSString *y = [self formatWithDouble:mp->y_];
      jboolean b = mp->lineTo_;
      if (first) {
        (void) [code_ appendWithNSString:@"\\moveto("];
        first = NO;
      }
      else if (b) (void) [code_ appendWithNSString:@"\\lineto("];
      else (void) [code_ appendWithNSString:@"\\moveto("];
      (void) [code_ appendWithNSString:x];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:y];
      (void) [code_ appendWithNSString:@")\n"];
      out = NO;
    }
    else if (!first && mp->lineTo_ && !out) {
      out = YES;
      NSString *x = [self formatWithDouble:mp->x_];
      NSString *y = [self formatWithDouble:mp->y_];
      (void) [code_ appendWithNSString:@"\\lineto("];
      (void) [code_ appendWithNSString:x];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:y];
      (void) [code_ appendWithNSString:@")\n"];
    }
    else {
      first = YES;
      out = NO;
    }
  }
  (void) [code_ appendWithNSString:@"}\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawBoxPlotWithOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)geo {
  OrgGeogebraCommonKernelAlgosAlgoBoxPlot *algo = ((OrgGeogebraCommonKernelAlgosAlgoBoxPlot *) check_class_cast([((OrgGeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [OrgGeogebraCommonKernelAlgosAlgoBoxPlot class]));
  jdouble y = [((id<OrgGeogebraCommonKernelArithmeticNumberValue>) nil_chk([((OrgGeogebraCommonKernelAlgosAlgoBoxPlot *) nil_chk(algo)) getA])) getDouble];
  jdouble height = [((id<OrgGeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble];
  IOSDoubleArray *lf = [algo getLeftBorders];
  jdouble min = IOSDoubleArray_Get(nil_chk(lf), 0);
  jdouble q1 = IOSDoubleArray_Get(lf, 1);
  jdouble med = IOSDoubleArray_Get(lf, 2);
  jdouble q3 = IOSDoubleArray_Get(lf, 3);
  jdouble max = IOSDoubleArray_Get(lf, 4);
  [self startBeamerWithJavaLangStringBuilder:code_];
  [self drawLineWithDouble:min withDouble:y - height withDouble:min withDouble:y + height withOrgGeogebraCommonKernelGeosGeoElement:geo];
  [self drawLineWithDouble:max withDouble:y - height withDouble:max withDouble:y + height withOrgGeogebraCommonKernelGeosGeoElement:geo];
  [self drawLineWithDouble:med withDouble:y - height withDouble:med withDouble:y + height withOrgGeogebraCommonKernelGeosGeoElement:geo];
  [self drawLineWithDouble:min withDouble:y withDouble:q1 withDouble:y withOrgGeogebraCommonKernelGeosGeoElement:geo];
  [self drawLineWithDouble:q3 withDouble:y withDouble:max withDouble:y withOrgGeogebraCommonKernelGeosGeoElement:geo];
  [self endBeamerWithJavaLangStringBuilder:code_];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\psframe"];
  (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  (void) [codeFilledObject_ appendWithNSString:@"("];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:q1]];
  (void) [codeFilledObject_ appendWithNSString:@","];
  (void) [codeFilledObject_ appendWithDouble:y - height];
  (void) [codeFilledObject_ appendWithNSString:@")("];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:q3]];
  (void) [codeFilledObject_ appendWithNSString:@","];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:y + height]];
  (void) [codeFilledObject_ appendWithNSString:@")\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawSumTrapezoidalWithOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)geo {
  OrgGeogebraCommonKernelAlgosAlgoFunctionAreaSums *algo = (OrgGeogebraCommonKernelAlgosAlgoFunctionAreaSums *) check_class_cast([((OrgGeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [OrgGeogebraCommonKernelAlgosAlgoFunctionAreaSums class]);
  jint n = [((OrgGeogebraCommonKernelAlgosAlgoFunctionAreaSums *) nil_chk(algo)) getIntervals];
  IOSDoubleArray *y = [algo getValues];
  IOSDoubleArray *x = [algo getLeftBorder];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  for (jint i = 0; i < n; i++) {
    (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pspolygon"];
    (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    (void) [codeFilledObject_ appendWithNSString:@"("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(x), i)]];
    (void) [codeFilledObject_ appendWithNSString:@",0)("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1)]];
    (void) [codeFilledObject_ appendWithNSString:@",0)("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1)]];
    (void) [codeFilledObject_ appendWithNSString:@","];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(y), i + 1)]];
    (void) [codeFilledObject_ appendWithNSString:@")("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i)]];
    (void) [codeFilledObject_ appendWithNSString:@","];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(y, i)]];
    (void) [codeFilledObject_ appendWithNSString:@")\n"];
    if (i != n - 1 && isBeamer_) (void) [codeFilledObject_ appendWithNSString:@"  "];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawSumUpperLowerWithOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)geo {
  OrgGeogebraCommonKernelAlgosAlgoFunctionAreaSums *algo = (OrgGeogebraCommonKernelAlgosAlgoFunctionAreaSums *) check_class_cast([((OrgGeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [OrgGeogebraCommonKernelAlgosAlgoFunctionAreaSums class]);
  jint n = [((OrgGeogebraCommonKernelAlgosAlgoFunctionAreaSums *) nil_chk(algo)) getIntervals];
  jdouble step = [algo getStep];
  IOSDoubleArray *y = [algo getValues];
  IOSDoubleArray *x = [algo getLeftBorder];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  for (jint i = 0; i < n; i++) {
    (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\psframe"];
    (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    (void) [codeFilledObject_ appendWithNSString:@"("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(x), i)]];
    (void) [codeFilledObject_ appendWithNSString:@",0)("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i) + step]];
    (void) [codeFilledObject_ appendWithNSString:@","];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(y), i)]];
    (void) [codeFilledObject_ appendWithNSString:@")\n"];
    if (i != n - 1 && isBeamer_) (void) [codeFilledObject_ appendWithNSString:@"  "];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawIntegralFunctionsWithOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)geo {
  OrgGeogebraCommonKernelCasAlgoIntegralFunctions *algo = (OrgGeogebraCommonKernelCasAlgoIntegralFunctions *) check_class_cast([((OrgGeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [OrgGeogebraCommonKernelCasAlgoIntegralFunctions class]);
  OrgGeogebraCommonKernelGeosGeoFunction *f = [((OrgGeogebraCommonKernelCasAlgoIntegralFunctions *) nil_chk(algo)) getF];
  OrgGeogebraCommonKernelGeosGeoFunction *g = [algo getG];
  jdouble a = [((id<OrgGeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getA])) getDouble];
  jdouble b = [((id<OrgGeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble];
  NSString *sa = [self formatWithDouble:a];
  NSString *sb = [self formatWithDouble:b];
  NSString *valueF = [((OrgGeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) toValueStringWithOrgGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  valueF = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(OrgGeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(valueF, YES));
  NSString *valueG = [((OrgGeogebraCommonKernelGeosGeoFunction *) nil_chk(g)) toValueStringWithOrgGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  valueG = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(OrgGeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(valueG, YES));
  NSString *fa = [self formatWithDouble:[f evaluateWithDouble:a]];
  NSString *gb = [self formatWithDouble:[g evaluateWithDouble:b]];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pscustom"];
  (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  (void) [codeFilledObject_ appendWithNSString:@"{\\psplot{"];
  (void) [codeFilledObject_ appendWithNSString:sa];
  (void) [codeFilledObject_ appendWithNSString:@"}{"];
  (void) [codeFilledObject_ appendWithNSString:sb];
  (void) [codeFilledObject_ appendWithNSString:@"}{"];
  (void) [codeFilledObject_ appendWithNSString:valueF];
  (void) [codeFilledObject_ appendWithNSString:@"}\\lineto("];
  (void) [codeFilledObject_ appendWithNSString:sb];
  (void) [codeFilledObject_ appendWithNSString:@","];
  (void) [codeFilledObject_ appendWithNSString:gb];
  (void) [codeFilledObject_ appendWithNSString:@")\\psplot{"];
  (void) [codeFilledObject_ appendWithNSString:sb];
  (void) [codeFilledObject_ appendWithNSString:@"}{"];
  (void) [codeFilledObject_ appendWithNSString:sa];
  (void) [codeFilledObject_ appendWithNSString:@"}{"];
  (void) [codeFilledObject_ appendWithNSString:valueG];
  (void) [codeFilledObject_ appendWithNSString:@"}\\lineto("];
  (void) [codeFilledObject_ appendWithNSString:sa];
  (void) [codeFilledObject_ appendWithNSString:@","];
  (void) [codeFilledObject_ appendWithNSString:fa];
  (void) [codeFilledObject_ appendWithNSString:@")\\closepath}\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawIntegralWithOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)geo {
  OrgGeogebraCommonKernelCasAlgoIntegralDefinite *algo = (OrgGeogebraCommonKernelCasAlgoIntegralDefinite *) check_class_cast([((OrgGeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getParentAlgorithm], [OrgGeogebraCommonKernelCasAlgoIntegralDefinite class]);
  OrgGeogebraCommonKernelGeosGeoFunction *f = [((OrgGeogebraCommonKernelCasAlgoIntegralDefinite *) nil_chk(algo)) getFunction];
  NSString *a = [self formatWithDouble:[((id<OrgGeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getA])) getDouble]];
  NSString *b = [self formatWithDouble:[((id<OrgGeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble]];
  NSString *value = [((OrgGeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) toValueStringWithOrgGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  value = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(OrgGeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(value, YES));
  if ([((NSString *) nil_chk([a substring:((jint) [((NSString *) nil_chk(a)) length]) - 1])) isEqual:JreStrcat("C", OrgGeogebraCommonUtilUnicode_INFINITY)]) {
    a = [self formatWithDouble:xmin_];
  }
  if ([((NSString *) nil_chk([b substring:((jint) [((NSString *) nil_chk(b)) length]) - 1])) isEqual:JreStrcat("C", OrgGeogebraCommonUtilUnicode_INFINITY)]) {
    b = [self formatWithDouble:xmax_];
  }
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  if (![self isLatexFunctionWithNSString:[f toValueStringWithOrgGeogebraCommonKernelStringTemplate:OrgGeogebraCommonKernelStringTemplate_get_noLocalDefault_()]]) {
    jdouble af = xmin_;
    jdouble bf = xmax_;
    if ([f hasInterval]) {
      af = [f getIntervalMin];
      bf = [f getIntervalMax];
    }
    [f setIntervalWithDouble:[((OrgGeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((OrgGeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:a] withDouble:[((OrgGeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) evaluateToDoubleWithNSString:b]];
    (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\pscustom"];
    [f setIntervalWithDouble:[((id<OrgGeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getA])) getDouble] withDouble:[((id<OrgGeogebraCommonKernelArithmeticNumberValue>) nil_chk([algo getB])) getDouble]];
    [self drawFunctionWithOrgGeogebraCommonKernelGeosGeoFunction:f withBoolean:YES withOrgGeogebraCommonKernelGeosGeoNumeric:geo];
    [f setIntervalWithDouble:af withDouble:bf];
    if ([f isEuclidianVisible]) {
      [self drawFunctionWithOrgGeogebraCommonKernelGeosGeoFunction:f withBoolean:NO withOrgGeogebraCommonKernelGeosGeoNumeric:geo];
    }
  }
  else {
    (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pscustom"];
    (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    (void) [codeFilledObject_ appendWithNSString:@"{\\psplot{"];
    (void) [codeFilledObject_ appendWithNSString:a];
    (void) [codeFilledObject_ appendWithNSString:@"}{"];
    (void) [codeFilledObject_ appendWithNSString:b];
    (void) [codeFilledObject_ appendWithNSString:@"}{"];
    (void) [codeFilledObject_ appendWithNSString:value];
    (void) [codeFilledObject_ appendWithNSString:@"}\\lineto("];
    (void) [codeFilledObject_ appendWithNSString:b];
    (void) [codeFilledObject_ appendWithNSString:@",0)\\lineto("];
    (void) [codeFilledObject_ appendWithNSString:a];
    (void) [codeFilledObject_ appendWithNSString:@",0)\\closepath}\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawSlopeWithOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)geo {
  jint slopeTriangleSize = [((OrgGeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) getSlopeTriangleSize];
  jdouble rwHeight = [geo getValue] * slopeTriangleSize;
  jdouble height = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getYscale] * rwHeight;
  IOSDoubleArray *coords = [IOSDoubleArray newArrayWithLength:2];
  if (JavaLangMath_absWithDouble_(height) > JavaLangFloat_MAX_VALUE) {
    return;
  }
  OrgGeogebraCommonKernelGeosGeoLine *g = [((OrgGeogebraCommonKernelAlgosAlgoSlope *) nil_chk(((OrgGeogebraCommonKernelAlgosAlgoSlope *) check_class_cast([geo getParentAlgorithm], [OrgGeogebraCommonKernelAlgosAlgoSlope class])))) getg];
  [((OrgGeogebraCommonKernelGeosGeoLine *) nil_chk(g)) getInhomPointOnLineWithDoubleArray:coords];
  jfloat x = (jfloat) IOSDoubleArray_Get(coords, 0);
  jfloat y = (jfloat) IOSDoubleArray_Get(coords, 1);
  jfloat xright = x + slopeTriangleSize;
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pspolygon"];
  (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  (void) [codeFilledObject_ appendWithNSString:@"("];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:x]];
  (void) [codeFilledObject_ appendWithNSString:@","];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:y]];
  (void) [codeFilledObject_ appendWithNSString:@")"];
  (void) [codeFilledObject_ appendWithNSString:@"("];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:xright]];
  (void) [codeFilledObject_ appendWithNSString:@","];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:y]];
  (void) [codeFilledObject_ appendWithNSString:@")"];
  (void) [codeFilledObject_ appendWithNSString:@"("];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:xright]];
  (void) [codeFilledObject_ appendWithNSString:@","];
  (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:y + rwHeight]];
  (void) [codeFilledObject_ appendWithNSString:@")"];
  (void) [codeFilledObject_ appendWithNSString:@"\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
  jfloat xLabelHor = (x + xright) / 2;
  jfloat yLabelHor = y - (jfloat) (([((OrgGeogebraCommonAwtGFont *) nil_chk([euclidianView_ getFont])) getSize] + 2) / [euclidianView_ getYscale]);
  OrgGeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
  [self startBeamerWithJavaLangStringBuilder:codePoint_];
  (void) [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\rput[bl]("];
  (void) [codePoint_ appendWithNSString:[self formatWithDouble:xLabelHor]];
  (void) [codePoint_ appendWithNSString:@","];
  (void) [codePoint_ appendWithNSString:[self formatWithDouble:yLabelHor]];
  (void) [codePoint_ appendWithNSString:@"){"];
  if (![((OrgGeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
    (void) [codePoint_ appendWithNSString:@"\\"];
    [self ColorCodeWithOrgGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:codePoint_];
    (void) [codePoint_ appendWithNSString:@"{"];
  }
  (void) [codePoint_ appendWithInt:slopeTriangleSize];
  if (![geocolor isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
    (void) [codePoint_ appendWithNSString:@"}"];
  }
  (void) [codePoint_ appendWithNSString:@"}\n"];
  [self endBeamerWithJavaLangStringBuilder:codePoint_];
}

- (void)drawAngleWithOrgGeogebraCommonKernelGeosGeoAngle:(OrgGeogebraCommonKernelGeosGeoAngle *)geo {
  jint arcSize = [((OrgGeogebraCommonKernelGeosGeoAngle *) nil_chk(geo)) getArcSize];
  OrgGeogebraCommonKernelAlgosAlgoElement *algo = [geo getParentAlgorithm];
  id<OrgGeogebraCommonKernelKernelNDGeoPointND> vertex, point;
  id<OrgGeogebraCommonKernelKernelNDGeoVectorND> v;
  OrgGeogebraCommonKernelGeosGeoLine *line, *line2;
  OrgGeogebraCommonKernelGeosGeoPoint *tempPoint = new_OrgGeogebraCommonKernelGeosGeoPoint_initWithOrgGeogebraCommonKernelConstruction_(construction_);
  [tempPoint setCoordsWithDouble:0.0 withDouble:0.0 withDouble:1.0];
  IOSDoubleArray *firstVec = [IOSDoubleArray newArrayWithLength:2];
  IOSDoubleArray *m = [IOSDoubleArray newArrayWithLength:2];
  if ([algo isKindOfClass:[OrgGeogebraCommonKernelAlgosAlgoAnglePoints class]]) {
    OrgGeogebraCommonKernelAlgosAlgoAnglePoints *pa = (OrgGeogebraCommonKernelAlgosAlgoAnglePoints *) check_class_cast(algo, [OrgGeogebraCommonKernelAlgosAlgoAnglePoints class]);
    vertex = [((OrgGeogebraCommonKernelAlgosAlgoAnglePoints *) nil_chk(pa)) getB];
    point = [pa getA];
    [((id<OrgGeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    OrgGeogebraCommonKernelMatrixCoords *coords = [((id<OrgGeogebraCommonKernelKernelNDGeoPointND>) nil_chk(point)) getInhomCoordsInD3];
    *IOSDoubleArray_GetRef(firstVec, 0) = [((OrgGeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX] - IOSDoubleArray_Get(m, 0);
    *IOSDoubleArray_GetRef(firstVec, 1) = [coords getY] - IOSDoubleArray_Get(m, 1);
  }
  else if ([algo isKindOfClass:[OrgGeogebraCommonKernelAlgosAlgoAngleVectors class]]) {
    OrgGeogebraCommonKernelAlgosAlgoAngleVectors *va = (OrgGeogebraCommonKernelAlgosAlgoAngleVectors *) check_class_cast(algo, [OrgGeogebraCommonKernelAlgosAlgoAngleVectors class]);
    v = [((OrgGeogebraCommonKernelAlgosAlgoAngleVectors *) nil_chk(va)) getv];
    vertex = [((id<OrgGeogebraCommonKernelKernelNDGeoVectorND>) nil_chk(v)) getStartPoint];
    if (vertex == nil) vertex = tempPoint;
    [((id<OrgGeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    [v getInhomCoordsWithDoubleArray:firstVec];
  }
  else if ([algo isKindOfClass:[OrgGeogebraCommonKernelAlgosAlgoAngleLines class]]) {
    OrgGeogebraCommonKernelAlgosAlgoAngleLines *la = (OrgGeogebraCommonKernelAlgosAlgoAngleLines *) check_class_cast(algo, [OrgGeogebraCommonKernelAlgosAlgoAngleLines class]);
    vertex = tempPoint;
    [((OrgGeogebraCommonKernelAlgosAlgoAngleLines *) nil_chk(la)) updateDrawInfoWithDoubleArray:m withDoubleArray:firstVec withOrgGeogebraCommonEuclidianDrawDrawAngle:nil];
  }
  else if ([algo isKindOfClass:[OrgGeogebraCommonKernelAlgosAlgoAngleVector class]]) {
    OrgGeogebraCommonKernelAlgosAlgoAngleVector *va = (OrgGeogebraCommonKernelAlgosAlgoAngleVector *) check_class_cast(algo, [OrgGeogebraCommonKernelAlgosAlgoAngleVector class]);
    OrgGeogebraCommonKernelGeosGeoVec3D *vec = [((OrgGeogebraCommonKernelAlgosAlgoAngleVector *) nil_chk(va)) getVec3D];
    if ([vec isKindOfClass:[OrgGeogebraCommonKernelGeosGeoVector class]]) {
      v = (OrgGeogebraCommonKernelGeosGeoVector *) check_class_cast(vec, [OrgGeogebraCommonKernelGeosGeoVector class]);
      vertex = [((id<OrgGeogebraCommonKernelKernelNDGeoVectorND>) nil_chk(v)) getStartPoint];
      if (vertex == nil) vertex = tempPoint;
      [((id<OrgGeogebraCommonKernelKernelNDGeoPointND>) nil_chk(vertex)) getInhomCoordsWithDoubleArray:m];
    }
    else if ([vec isKindOfClass:[OrgGeogebraCommonKernelGeosGeoPoint class]]) {
      point = (OrgGeogebraCommonKernelGeosGeoPoint *) check_class_cast(vec, [OrgGeogebraCommonKernelGeosGeoPoint class]);
      vertex = tempPoint;
      [vertex getInhomCoordsWithDoubleArray:m];
    }
    *IOSDoubleArray_GetRef(firstVec, 0) = 1;
    *IOSDoubleArray_GetRef(firstVec, 1) = 0;
  }
  [tempPoint remove];
  jdouble angSt = JavaLangMath_atan2WithDouble_withDouble_(IOSDoubleArray_Get(firstVec, 1), IOSDoubleArray_Get(firstVec, 0));
  jdouble angExt = [geo getRawAngle];
  if (angExt > JavaLangMath_PI * 2) angExt -= JavaLangMath_PI * 2;
  if ([geo getAngleStyle] == OrgGeogebraCommonKernelGeosGeoAngle_AngleStyleEnum_get_NOTREFLEX()) {
    if (angExt > JavaLangMath_PI) {
      angSt += angExt;
      angExt = 2.0 * JavaLangMath_PI - angExt;
    }
  }
  if ([geo getAngleStyle] == OrgGeogebraCommonKernelGeosGeoAngle_AngleStyleEnum_get_ISREFLEX()) {
    if (angExt < JavaLangMath_PI) {
      angSt += angExt;
      angExt = 2.0 * JavaLangMath_PI - angExt;
    }
  }
  angExt += angSt;
  jdouble r = arcSize / [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXscale];
  if (OrgGeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([geo getValue], OrgGeogebraCommonKernelKernel_PI_HALF) && [geo isEmphasizeRightAngle] && [euclidianView_ getRightAngleStyle] == OrgGeogebraCommonPluginEuclidianStyleConstants_RIGHT_ANGLE_STYLE_SQUARE) {
    r = r / JavaLangMath_sqrtWithDouble_(2);
    IOSDoubleArray *x = [IOSDoubleArray newArrayWithLength:8];
    *IOSDoubleArray_GetRef(x, 0) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_cosWithDouble_(angSt);
    *IOSDoubleArray_GetRef(x, 1) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sinWithDouble_(angSt);
    *IOSDoubleArray_GetRef(x, 2) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_sqrtWithDouble_(2) * JavaLangMath_cosWithDouble_(angSt + OrgGeogebraCommonKernelKernel_PI_HALF / 2);
    *IOSDoubleArray_GetRef(x, 3) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sqrtWithDouble_(2) * JavaLangMath_sinWithDouble_(angSt + OrgGeogebraCommonKernelKernel_PI_HALF / 2);
    *IOSDoubleArray_GetRef(x, 4) = IOSDoubleArray_Get(m, 0) + r * JavaLangMath_cosWithDouble_(angSt + OrgGeogebraCommonKernelKernel_PI_HALF);
    *IOSDoubleArray_GetRef(x, 5) = IOSDoubleArray_Get(m, 1) + r * JavaLangMath_sinWithDouble_(angSt + OrgGeogebraCommonKernelKernel_PI_HALF);
    *IOSDoubleArray_GetRef(x, 6) = IOSDoubleArray_Get(m, 0);
    *IOSDoubleArray_GetRef(x, 7) = IOSDoubleArray_Get(m, 1);
    [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
    (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pspolygon"];
    (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    for (jint i = 0; i < 4; i++) {
      (void) [codeFilledObject_ appendWithNSString:@"("];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, 2 * i)]];
      (void) [codeFilledObject_ appendWithNSString:@","];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, 2 * i + 1)]];
      (void) [codeFilledObject_ appendWithNSString:@")"];
    }
    (void) [codeFilledObject_ appendWithNSString:@"\n"];
    [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
  }
  else {
    OrgGeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
    [self startBeamerWithJavaLangStringBuilder:code_];
    if (![((OrgGeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
      (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\pscustom"];
      (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      (void) [code_ appendWithNSString:@"{\n"];
    }
    (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\parametricplot{"];
    (void) [code_ appendWithDouble:angSt];
    (void) [code_ appendWithNSString:@"}{"];
    (void) [code_ appendWithDouble:angExt];
    (void) [code_ appendWithNSString:@"}{"];
    (void) [code_ appendWithNSString:[self formatWithDouble:r]];
    (void) [code_ appendWithNSString:@"*cos(t)+"];
    (void) [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(m, 0)]];
    (void) [code_ appendWithNSString:@"|"];
    (void) [code_ appendWithNSString:[self formatWithDouble:r]];
    (void) [code_ appendWithNSString:@"*sin(t)+"];
    (void) [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(m, 1)]];
    (void) [code_ appendWithNSString:@"}\n"];
    if (![geocolor isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
      (void) [code_ appendWithNSString:@"\\lineto("];
      (void) [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(m, 0)]];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(m, 1)]];
      (void) [code_ appendWithNSString:@")\\closepath}\n"];
    }
    [self endBeamerWithJavaLangStringBuilder:code_];
    if (OrgGeogebraCommonKernelKernel_isEqualWithDouble_withDouble_([geo getValue], OrgGeogebraCommonKernelKernel_PI_HALF) && [geo isEmphasizeRightAngle] && [euclidianView_ getRightAngleStyle] == OrgGeogebraCommonPluginEuclidianStyleConstants_RIGHT_ANGLE_STYLE_DOT) {
      jdouble diameter = geo->lineThickness_ / [euclidianView_ getXscale];
      jdouble radius = arcSize / [euclidianView_ getXscale] / 1.7;
      jdouble labelAngle = (angSt + angExt) / 2.0;
      jdouble x1 = IOSDoubleArray_Get(m, 0) + radius * JavaLangMath_cosWithDouble_(labelAngle);
      jdouble x2 = IOSDoubleArray_Get(m, 1) + radius * JavaLangMath_sinWithDouble_(labelAngle);
      [self startBeamerWithJavaLangStringBuilder:code_];
      (void) [code_ appendWithNSString:@"\\psellipse*"];
      (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      (void) [code_ appendWithNSString:@"("];
      (void) [code_ appendWithNSString:[self formatWithDouble:x1]];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:[self formatWithDouble:x2]];
      (void) [code_ appendWithNSString:@")("];
      (void) [code_ appendWithNSString:[self formatWithDouble:diameter]];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:[self formatWithDouble:diameter]];
      (void) [code_ appendWithNSString:@")\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
    }
  }
  jint deco = geo->decorationType_;
  if (deco != OrgGeogebraCommonKernelGeosGeoElement_DECORATION_NONE) {
    [self startBeamerWithJavaLangStringBuilder:code_];
    [self markAngleWithOrgGeogebraCommonKernelGeosGeoAngle:geo withDouble:r withDoubleArray:m withDouble:angSt withDouble:angExt];
    [self endBeamerWithJavaLangStringBuilder:code_];
  }
}

- (void)drawArrowArcWithOrgGeogebraCommonKernelGeosGeoAngle:(OrgGeogebraCommonKernelGeosGeoAngle *)geo
                                            withDoubleArray:(IOSDoubleArray *)vertex
                                                 withDouble:(jdouble)angSt
                                                 withDouble:(jdouble)angEnd
                                                 withDouble:(jdouble)r
                                                withBoolean:(jboolean)anticlockwise {
  jdouble arrowHeight = (((OrgGeogebraCommonKernelGeosGeoAngle *) nil_chk(geo))->lineThickness_ * 0.8 + 3) * 1.4 * 3 / 4;
  jdouble angle = JavaLangMath_asinWithDouble_(arrowHeight / 2 / [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXscale] / r);
  angEnd = angEnd - angle;
  [self startBeamerWithJavaLangStringBuilder:code_];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psellipticarc"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO]];
  if (anticlockwise) (void) [code_ appendWithNSString:@"{->}("];
  else (void) [code_ appendWithNSString:@"{<-}("];
  (void) [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(vertex), 0)]];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(vertex, 1)]];
  (void) [code_ appendWithNSString:@")("];
  (void) [code_ appendWithNSString:[self formatWithDouble:r]];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:[self formatWithDouble:r]];
  (void) [code_ appendWithNSString:@"){"];
  (void) [code_ appendWithNSString:[self formatWithDouble:JavaLangMath_toDegreesWithDouble_(angSt)]];
  (void) [code_ appendWithNSString:@"}{"];
  (void) [code_ appendWithNSString:[self formatWithDouble:JavaLangMath_toDegreesWithDouble_(angEnd)]];
  (void) [code_ appendWithNSString:@"}\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawArcWithOrgGeogebraCommonKernelGeosGeoAngle:(OrgGeogebraCommonKernelGeosGeoAngle *)geo
                                       withDoubleArray:(IOSDoubleArray *)vertex
                                            withDouble:(jdouble)angSt
                                            withDouble:(jdouble)angEnd
                                            withDouble:(jdouble)r {
  if (isBeamer_) (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\parametricplot"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO]];
  (void) [code_ appendWithNSString:@"{"];
  (void) [code_ appendWithDouble:angSt];
  (void) [code_ appendWithNSString:@"}{"];
  (void) [code_ appendWithDouble:angEnd];
  (void) [code_ appendWithNSString:@"}{"];
  (void) [code_ appendWithNSString:[self formatWithDouble:r]];
  (void) [code_ appendWithNSString:@"*cos(t)+"];
  (void) [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(vertex), 0)]];
  (void) [code_ appendWithNSString:@"|"];
  (void) [code_ appendWithNSString:[self formatWithDouble:r]];
  (void) [code_ appendWithNSString:@"*sin(t)+"];
  (void) [code_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(vertex, 1)]];
  (void) [code_ appendWithNSString:@"}\n"];
}

- (void)drawTickWithOrgGeogebraCommonKernelGeosGeoAngle:(OrgGeogebraCommonKernelGeosGeoAngle *)geo
                                        withDoubleArray:(IOSDoubleArray *)vertex
                                             withDouble:(jdouble)angle {
  angle = -angle;
  jdouble radius = [((OrgGeogebraCommonKernelGeosGeoAngle *) nil_chk(geo)) getArcSize];
  jdouble diff = 2.5 + geo->lineThickness_ / 4.0;
  jdouble x1 = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:IOSDoubleArray_Get(nil_chk(vertex), 0) + (radius - diff) * JavaLangMath_cosWithDouble_(angle)];
  jdouble x2 = [euclidianView_ toRealWorldCoordXWithDouble:IOSDoubleArray_Get(vertex, 0) + (radius + diff) * JavaLangMath_cosWithDouble_(angle)];
  jdouble y1 = [euclidianView_ toRealWorldCoordYWithDouble:IOSDoubleArray_Get(vertex, 1) + (radius - diff) * JavaLangMath_sinWithDouble_(angle) * [euclidianView_ getScaleRatio]];
  jdouble y2 = [euclidianView_ toRealWorldCoordYWithDouble:IOSDoubleArray_Get(vertex, 1) + (radius + diff) * JavaLangMath_sinWithDouble_(angle) * [euclidianView_ getScaleRatio]];
  if (isBeamer_) (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:NO]];
  (void) [code_ appendWithNSString:@"("];
  (void) [code_ appendWithNSString:[self formatWithDouble:x1]];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:[self formatWithDouble:y1]];
  (void) [code_ appendWithNSString:@")("];
  (void) [code_ appendWithNSString:[self formatWithDouble:x2]];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:[self formatWithDouble:y2]];
  (void) [code_ appendWithNSString:@")\n"];
}

- (void)drawSliderWithOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)geo {
  jboolean horizontal = [((OrgGeogebraCommonKernelGeosGeoNumeric *) nil_chk(geo)) isSliderHorizontal];
  jdouble max = [geo getIntervalMax];
  jdouble min = [geo getIntervalMin];
  jdouble value = [geo getValue];
  jdouble width = [geo getSliderWidth];
  jdouble x = [geo getSliderX];
  jdouble y = [geo getSliderY];
  if ([geo isAbsoluteScreenLocActive]) {
    x = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:x];
    y = [euclidianView_ toRealWorldCoordYWithDouble:y];
    width = horizontal ? width / [euclidianView_ getXscale] : width / [euclidianView_ getYscale];
  }
  OrgGeogebraCommonKernelGeosGeoPoint *geoPoint = new_OrgGeogebraCommonKernelGeosGeoPoint_initWithOrgGeogebraCommonKernelConstruction_(construction_);
  [geoPoint setObjColorWithOrgGeogebraCommonAwtGColor:[geo getObjectColor]];
  NSString *label = OrgGeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_([geo getLabelDescription], YES);
  [geoPoint setLabelWithNSString:label];
  jdouble param = (value - min) / (max - min);
  [geoPoint setPointSizeWithInt:2 + (geo->lineThickness_ + 1) / 3];
  [geoPoint setLabelVisibleWithBoolean:[geo isLabelVisible]];
  if (horizontal) [geoPoint setCoordsWithDouble:x + width * param withDouble:y withDouble:1.0];
  else [geoPoint setCoordsWithDouble:x withDouble:y + width * param withDouble:1.0];
  OrgGeogebraCommonEuclidianDrawDrawPoint *drawPoint = new_OrgGeogebraCommonEuclidianDrawDrawPoint_initWithOrgGeogebraCommonEuclidianEuclidianView_withOrgGeogebraCommonKernelKernelNDGeoPointND_(euclidianView_, geoPoint);
  [drawPoint setGeoElementWithOrgGeogebraCommonKernelGeosGeoElement:geo];
  if ([geo isLabelVisible]) {
    if (horizontal) {
      drawPoint->xLabel_ -= 15;
      drawPoint->yLabel_ -= 5;
    }
    else {
      drawPoint->xLabel_ += 5;
      drawPoint->yLabel_ += 2 * [geoPoint getPointSize] + 4;
    }
  }
  [self drawGeoPointWithOrgGeogebraCommonKernelGeosGeoPoint:geoPoint];
  [self drawLabelWithOrgGeogebraCommonKernelGeosGeoElement:geoPoint withOrgGeogebraCommonEuclidianDrawableND:drawPoint];
  [geoPoint remove];
  [self startBeamerWithJavaLangStringBuilder:code_];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  (void) [code_ appendWithNSString:@"("];
  (void) [code_ appendWithNSString:[self formatWithDouble:x]];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:[self formatWithDouble:y]];
  (void) [code_ appendWithNSString:@")("];
  if (horizontal) x += width;
  else y += width;
  (void) [code_ appendWithNSString:[self formatWithDouble:x]];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:[self formatWithDouble:y]];
  (void) [code_ appendWithNSString:@")\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawPolygonWithOrgGeogebraCommonKernelGeosGeoPolygon:(OrgGeogebraCommonKernelGeosGeoPolygon *)geo {
  jfloat alpha = [((OrgGeogebraCommonKernelGeosGeoPolygon *) nil_chk(geo)) getAlphaValue];
  if (alpha == 0.0f && [geo getFillType] == OrgGeogebraCommonKernelGeosGeoElement_FillTypeEnum_get_IMAGE()) return;
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\pspolygon"];
  (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  IOSObjectArray *points = [geo getPoints];
  for (jint i = 0; i < ((IOSObjectArray *) nil_chk(points))->size_; i++) {
    OrgGeogebraCommonKernelMatrixCoords *coords = [((id<OrgGeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(points, i))) getCoordsInD2];
    jdouble x = [((OrgGeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX], y = [coords getY], z = [coords getZ];
    x = x / z;
    y = y / z;
    (void) [codeFilledObject_ appendWithNSString:@"("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:x]];
    (void) [codeFilledObject_ appendWithNSString:@","];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:y]];
    (void) [codeFilledObject_ appendWithNSString:@")"];
  }
  (void) [codeFilledObject_ appendWithNSString:@"\n"];
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawTextWithOrgGeogebraCommonKernelGeosGeoText:(OrgGeogebraCommonKernelGeosGeoText *)geo {
  jboolean isLatex = [((OrgGeogebraCommonKernelGeosGeoText *) nil_chk(geo)) isLaTeX];
  NSString *st = [geo getTextString];
  OrgGeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
  jint style = [geo getFontStyle];
  jint size = J2ObjCFpToInt(([geo getFontSizeMultiplier] * [((OrgGeogebraCommonMainApp *) nil_chk([self getApp])) getFontSize]));
  OrgGeogebraCommonKernelGeosGeoPoint *gp;
  jdouble x, y;
  if ([geo isAbsoluteScreenLocActive]) {
    x = [geo getAbsoluteScreenLocX];
    y = [geo getAbsoluteScreenLocY];
  }
  else {
    gp = (OrgGeogebraCommonKernelGeosGeoPoint *) check_class_cast([geo getStartPoint], [OrgGeogebraCommonKernelGeosGeoPoint class]);
    if (gp == nil) {
      x = J2ObjCFpToInt([((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getXZero]);
      y = J2ObjCFpToInt([euclidianView_ getYZero]);
    }
    else {
      if (![gp isDefined]) {
        return;
      }
      x = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordXWithDouble:gp->inhomX_];
      y = [euclidianView_ toScreenCoordYWithDouble:gp->inhomY_];
    }
    x += geo->labelOffsetX_;
    y += geo->labelOffsetY_;
  }
  x = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:x];
  y = [euclidianView_ toRealWorldCoordYWithDouble:y - [((OrgGeogebraCommonAwtGFont *) nil_chk([euclidianView_ getFont])) getSize]];
  jint id_ = [((NSString *) nil_chk(st)) indexOfString:@"\n"];
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (id_ == -1) {
    (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput[tl]("];
    (void) [code_ appendWithNSString:[self formatWithDouble:x]];
    (void) [code_ appendWithNSString:@","];
    (void) [code_ appendWithNSString:[self formatWithDouble:y]];
    (void) [code_ appendWithNSString:@"){"];
    OrgGeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withOrgGeogebraCommonAwtGColor_(self, st, isLatex, style, geocolor);
    (void) [code_ appendWithNSString:@"}\n"];
  }
  else {
    JavaLangStringBuilder *sb = new_JavaLangStringBuilder_init();
    OrgGeogebraCommonUtilGStringTokenizer *stk = new_OrgGeogebraCommonUtilGStringTokenizer_initWithNSString_withChar_(st, 0x000a);
    jint width = 0;
    OrgGeogebraCommonAwtGFont *font = [((OrgGeogebraCommonFactoriesAwtFactory *) nil_chk(OrgGeogebraCommonFactoriesAwtFactory_get_prototype_())) newFontWithNSString:[geo isSerifFont] ? @"Serif" : @"SansSerif" withInt:style withInt:size];
    while ([stk hasMoreTokens]) {
      NSString *line = [stk nextToken];
      width = JavaLangMath_maxWithInt_withInt_(width, J2ObjCFpToInt(JavaLangMath_ceilWithDouble_([((OrgGeogebraCommonUtilStringUtil *) nil_chk(OrgGeogebraCommonUtilStringUtil_get_prototype_())) estimateLengthWithNSString:line withOrgGeogebraCommonAwtGFont:font])));
      (void) [sb appendWithNSString:line];
      if ([stk hasMoreTokens]) (void) [sb appendWithNSString:@" \\\\ "];
    }
    (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput[lt]("];
    (void) [code_ appendWithNSString:[self formatWithDouble:x]];
    (void) [code_ appendWithNSString:@","];
    (void) [code_ appendWithNSString:[self formatWithDouble:y]];
    (void) [code_ appendWithNSString:@"){\\parbox{"];
    (void) [code_ appendWithNSString:[self formatWithDouble:width * (xmax_ - xmin_) * xunit_ / [euclidianView_ getWidth] + 1]];
    (void) [code_ appendWithNSString:@" cm}{"];
    OrgGeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withOrgGeogebraCommonAwtGColor_(self, [NSString stringWithJavaLangStringBuilder:sb], isLatex, style, geocolor);
    (void) [code_ appendWithNSString:@"}}\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawGeoConicPartWithOrgGeogebraCommonKernelGeosGeoConicPart:(OrgGeogebraCommonKernelGeosGeoConicPart *)geo {
  jdouble r1 = IOSDoubleArray_Get(nil_chk([((OrgGeogebraCommonKernelGeosGeoConicPart *) nil_chk(geo)) getHalfAxes]), 0);
  jdouble r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
  jdouble startAngle = [geo getParameterStart];
  jdouble endAngle = [geo getParameterEnd];
  id<OrgGeogebraCommonAwtGAffineTransform> af = [geo getAffineTransform];
  jdouble m11 = [((id<OrgGeogebraCommonAwtGAffineTransform>) nil_chk(af)) getScaleX];
  jdouble m22 = [af getScaleY];
  jdouble m12 = [af getShearX];
  jdouble m21 = [af getShearY];
  jdouble tx = [af getTranslateX];
  jdouble ty = [af getTranslateY];
  [self startBeamerWithJavaLangStringBuilder:code_];
  if ([geo getConicPartType] == OrgGeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR) {
    (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\pscustom"];
    (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    (void) [code_ appendWithNSString:@"{\\parametricplot{"];
  }
  else if ([geo getConicPartType] == OrgGeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_ARC) {
    (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\parametricplot"];
    (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    (void) [code_ appendWithNSString:@"{"];
  }
  if (startAngle > endAngle) {
    startAngle -= JavaLangMath_PI * 2;
  }
  JavaLangStringBuilder *sb1 = new_JavaLangStringBuilder_init();
  (void) [sb1 appendWithNSString:[self formatWithDouble:r1]];
  (void) [sb1 appendWithNSString:@"*cos(t)"];
  JavaLangStringBuilder *sb2 = new_JavaLangStringBuilder_init();
  (void) [sb2 appendWithNSString:[self formatWithDouble:r2]];
  (void) [sb2 appendWithNSString:@"*sin(t)"];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithDouble:startAngle];
  (void) [code_ appendWithNSString:@"}{"];
  (void) [code_ appendWithDouble:endAngle];
  (void) [code_ appendWithNSString:@"}{"];
  (void) [code_ appendWithNSString:[self formatWithDouble:m11]];
  (void) [code_ appendWithNSString:@"*"];
  (void) [code_ appendWithJavaLangCharSequence:sb1];
  (void) [code_ appendWithNSString:@"+"];
  (void) [code_ appendWithNSString:[self formatWithDouble:m12]];
  (void) [code_ appendWithNSString:@"*"];
  (void) [code_ appendWithJavaLangCharSequence:sb2];
  (void) [code_ appendWithNSString:@"+"];
  (void) [code_ appendWithNSString:[self formatWithDouble:tx]];
  (void) [code_ appendWithNSString:@"|"];
  (void) [code_ appendWithNSString:[self formatWithDouble:m21]];
  (void) [code_ appendWithNSString:@"*"];
  (void) [code_ appendWithJavaLangCharSequence:sb1];
  (void) [code_ appendWithNSString:@"+"];
  (void) [code_ appendWithNSString:[self formatWithDouble:m22]];
  (void) [code_ appendWithNSString:@"*"];
  (void) [code_ appendWithJavaLangCharSequence:sb2];
  (void) [code_ appendWithNSString:@"+"];
  (void) [code_ appendWithNSString:[self formatWithDouble:ty]];
  (void) [code_ appendWithNSString:@"}"];
  if ([geo getConicPartType] == OrgGeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PART_SECTOR) {
    (void) [code_ appendWithNSString:@"\\lineto("];
    (void) [code_ appendWithNSString:[self formatWithDouble:tx]];
    (void) [code_ appendWithNSString:@","];
    (void) [code_ appendWithNSString:[self formatWithDouble:ty]];
    (void) [code_ appendWithNSString:@")\\closepath}"];
  }
  (void) [code_ appendWithNSString:@"\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawSingleCurveCartesianWithOrgGeogebraCommonKernelGeosGeoCurveCartesian:(OrgGeogebraCommonKernelGeosGeoCurveCartesian *)geo
                                                                     withBoolean:(jboolean)trasparency {
  jdouble start = [((OrgGeogebraCommonKernelGeosGeoCurveCartesian *) nil_chk(geo)) getMinParameter];
  jdouble end = [geo getMaxParameter];
  NSString *fx = [geo getFunXWithOrgGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  fx = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(OrgGeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(fx, YES));
  NSString *fy = [geo getFunYWithOrgGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  fy = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(OrgGeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(fy, YES));
  NSString *variable = [geo getVarStringWithOrgGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  jboolean warning = !([((NSString *) nil_chk(variable)) isEqual:@"t"]);
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (warning) (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"% WARNING: You have to use the special variable t in parametric plot"];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\parametricplot"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:trasparency]];
  jint index = [code_ lastIndexOfWithNSString:@"]"];
  if (index == [code_ length] - 1) {
    (void) [code_ deleteCharAtWithInt:index];
    (void) [code_ appendWithNSString:@"]{"];
  }
  else (void) [code_ appendWithNSString:@"{"];
  (void) [code_ appendWithDouble:start];
  (void) [code_ appendWithNSString:@"}{"];
  (void) [code_ appendWithDouble:end];
  (void) [code_ appendWithNSString:@"}{"];
  (void) [code_ appendWithNSString:fx];
  (void) [code_ appendWithNSString:@"|"];
  (void) [code_ appendWithNSString:fy];
  (void) [code_ appendWithNSString:@"}\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawFunctionWithOrgGeogebraCommonKernelGeosGeoFunction:(OrgGeogebraCommonKernelGeosGeoFunction *)geo {
  [self drawFunctionWithOrgGeogebraCommonKernelGeosGeoFunction:geo withBoolean:NO withOrgGeogebraCommonKernelGeosGeoNumeric:nil];
}

- (void)drawFunctionWithOrgGeogebraCommonKernelGeosGeoFunction:(OrgGeogebraCommonKernelGeosGeoFunction *)geo
                                                   withBoolean:(jboolean)integral
                     withOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)geo1 {
  JavaLangStringBuilder *line = new_JavaLangStringBuilder_init();
  OrgGeogebraCommonKernelArithmeticFunction *f = [((OrgGeogebraCommonKernelGeosGeoFunction *) nil_chk(geo)) getFunction];
  if (nil == f) return;
  NSString *value = [((OrgGeogebraCommonKernelArithmeticFunction *) nil_chk(f)) toValueStringWithOrgGeogebraCommonKernelStringTemplate:[self getStringTemplate]];
  value = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(OrgGeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_(value, YES));
  jdouble a = xmin_;
  jdouble b = xmax_;
  if ([geo hasInterval]) {
    a = JavaLangMath_maxWithDouble_withDouble_(a, [geo getIntervalMin]);
    b = JavaLangMath_minWithDouble_withDouble_(b, [geo getIntervalMax]);
  }
  jdouble xrangemax = a, xrangemin = a;
  while (xrangemax < b) {
    xrangemin = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, geo, a, b);
    if (xrangemin == b) break;
    xrangemax = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, geo, xrangemin, b);
    [self startBeamerWithJavaLangStringBuilder:code_];
    (void) [line appendWithNSString:@"\\psplot"];
    NSString *liopco = [self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES];
    jint index = [((NSString *) nil_chk(liopco)) lastIndexOfString:@"]"];
    if (index != -1 && index == ((jint) [liopco length]) - 1) {
      liopco = [liopco substring:0 endIndex:((jint) [liopco length]) - 1];
      liopco = JreStrcat("$$", liopco, @",plotpoints=200]{");
    }
    else liopco = JreStrcat("$$", liopco, @"[plotpoints=200]{");
    (void) [line appendWithNSString:liopco];
    (void) [line appendWithDouble:xrangemin];
    (void) [line appendWithNSString:@"}{"];
    (void) [line appendWithDouble:xrangemax];
    (void) [line appendWithNSString:@"}{"];
    (void) [line appendWithNSString:value];
    (void) [line appendWithNSString:@"}\n"];
    xrangemax += PRECISION_XRANGE_FUNCTION_;
    NSString *s = [line description];
    if (![self isLatexFunctionWithNSString:[f toValueStringWithOrgGeogebraCommonKernelStringTemplate:OrgGeogebraCommonKernelStringTemplate_get_noLocalDefault_()]]) {
      liopco = [((NSString *) nil_chk(liopco)) replace:@",plotpoints=200]{" withSequence:@"]"];
      liopco = [((NSString *) nil_chk(liopco)) replace:@"[plotpoints=200]{" withSequence:@""];
      NSString *pre = @"";
      NSString *post = @"";
      NSString *template_ = JreStrcat("$$$", @"\\psline", liopco, @"(%0,%1)(%2,%3)\n");
      JavaLangStringBuilder *lineBuilder = [self drawNoLatexFunctionWithOrgGeogebraCommonKernelGeosGeoFunction:geo withDouble:xrangemax withDouble:xrangemin withInt:200 withNSString:template_];
      s = [((JavaLangStringBuilder *) nil_chk(lineBuilder)) description];
      if (integral) {
        (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo1 withBoolean:YES]];
        pre = @"{";
        NSString *end = [s substring:[((NSString *) nil_chk(s)) lastIndexOfString:@"("]];
        post = JreStrcat("CDCD$D$", '(', b, ',', [f evaluateWithDouble:b], @")(", b, @",0)\n");
        post = JreStrcat("$$", post, JreStrcat("CD$D$", '(', b, @",0)(", a, @",0)\n"));
        post = JreStrcat("$$", post, JreStrcat("CD$DCD$", '(', a, @",0)(", a, ',', [f evaluateWithDouble:a], @")}\n"));
      }
      s = JreStrcat("$$$", pre, s, post);
      (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:s];
    }
    else {
      (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:line];
    }
    a = xrangemax;
    [self endBeamerWithJavaLangStringBuilder:code_];
  }
}

+ (NSString *)killSpaceWithNSString:(NSString *)name {
  return OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(name);
}

+ (void)renameFuncWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                               withNSString:(NSString *)nameFunc
                               withNSString:(NSString *)nameNew {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, nameFunc, nameNew);
}

- (jdouble)maxDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction:(OrgGeogebraCommonKernelGeosGeoFunction *)f
                                                          withDouble:(jdouble)a
                                                          withDouble:(jdouble)b {
  return OrgGeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, a, b);
}

- (jdouble)firstDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction:(OrgGeogebraCommonKernelGeosGeoFunction *)f
                                                            withDouble:(jdouble)a
                                                            withDouble:(jdouble)b {
  return OrgGeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, a, b);
}

- (void)drawGeoVectorWithOrgGeogebraCommonKernelGeosGeoVector:(OrgGeogebraCommonKernelGeosGeoVector *)geo {
  id<OrgGeogebraCommonKernelKernelNDGeoPointND> pointStart = [((OrgGeogebraCommonKernelGeosGeoVector *) nil_chk(geo)) getStartPoint];
  NSString *x1, *y1;
  if (nil == pointStart) {
    x1 = @"0";
    y1 = @"0";
  }
  else {
    OrgGeogebraCommonKernelMatrixCoords *c = [pointStart getCoords];
    x1 = [self formatWithDouble:[((OrgGeogebraCommonKernelMatrixCoords *) nil_chk(c)) getX] / [c getZ]];
    y1 = [self formatWithDouble:[c getY] / [c getZ]];
  }
  IOSDoubleArray *coord = [IOSDoubleArray newArrayWithLength:3];
  [geo getCoordsWithDoubleArray:coord];
  NSString *x2 = [self formatWithDouble:IOSDoubleArray_Get(coord, 0) + [((OrgGeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((OrgGeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:x1]];
  NSString *y2 = [self formatWithDouble:IOSDoubleArray_Get(coord, 1) + [((OrgGeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([kernel_ getAlgebraProcessor])) evaluateToDoubleWithNSString:y1]];
  [self startBeamerWithJavaLangStringBuilder:code_];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  (void) [code_ appendWithNSString:@"{->}("];
  (void) [code_ appendWithNSString:x1];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:y1];
  (void) [code_ appendWithNSString:@")("];
  (void) [code_ appendWithNSString:x2];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:y2];
  (void) [code_ appendWithNSString:@")\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawCircleWithOrgGeogebraCommonKernelGeosGeoConic:(OrgGeogebraCommonKernelGeosGeoConic *)geo {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawCircleWithOrgGeogebraCommonKernelGeosGeoConic_(self, geo);
}

- (void)drawGeoConicWithOrgGeogebraCommonKernelGeosGeoConic:(OrgGeogebraCommonKernelGeosGeoConic *)geo {
  {
    id<OrgGeogebraCommonAwtGAffineTransform> at;
    jdouble eigenvecX;
    jdouble eigenvecY;
    jdouble x1;
    jdouble y1;
    jdouble r1;
    jdouble r2;
    jdouble angle;
    jdouble p;
    jdouble x0;
    jint i;
    jint k2;
    switch ([((OrgGeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getType]) {
      case OrgGeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_CIRCLE:
      OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawCircleWithOrgGeogebraCommonKernelGeosGeoConic_(self, geo);
      break;
      case OrgGeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_ELLIPSE:
      at = [geo getAffineTransform];
      eigenvecX = [((id<OrgGeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
      r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX));
      [self startBeamerWithJavaLangStringBuilder:code_];
      (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput{"];
      (void) [code_ appendWithNSString:[self formatWithDouble:angle]];
      (void) [code_ appendWithNSString:@"}("];
      (void) [code_ appendWithNSString:[self formatWithDouble:x1]];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:[self formatWithDouble:y1]];
      (void) [code_ appendWithNSString:@"){\\psellipse"];
      (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      (void) [code_ appendWithNSString:@"(0,0)("];
      (void) [code_ appendWithNSString:[self formatWithDouble:r1]];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:[self formatWithDouble:r2]];
      (void) [code_ appendWithNSString:@")}\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
      case OrgGeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_PARABOLA:
      p = geo->p_;
      at = [geo getAffineTransform];
      eigenvecX = [((id<OrgGeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      x0 = JavaLangMath_maxWithDouble_withDouble_(JavaLangMath_absWithDouble_(x1 - xmin_), JavaLangMath_absWithDouble_(x1 - xmax_));
      x0 = JavaLangMath_maxWithDouble_withDouble_(x0, JavaLangMath_absWithDouble_(y1 - ymin_));
      x0 = JavaLangMath_maxWithDouble_withDouble_(x0, JavaLangMath_absWithDouble_(y1 - ymax_));
      x0 = 4 * x0 / p;
      i = 4;
      k2 = 16;
      while (k2 < x0) {
        i += 2;
        k2 = i * i;
      }
      x0 = i * p;
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX)) - 90;
      [self startBeamerWithJavaLangStringBuilder:code_];
      (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput{"];
      (void) [code_ appendWithNSString:[self formatWithDouble:angle]];
      (void) [code_ appendWithNSString:@"}("];
      (void) [code_ appendWithNSString:[self formatWithDouble:x1]];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:[self formatWithDouble:y1]];
      (void) [code_ appendWithNSString:@"){\\psplot"];
      (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      (void) [code_ appendWithNSString:@"{"];
      (void) [code_ appendWithNSString:[self formatWithDouble:-x0]];
      (void) [code_ appendWithNSString:@"}{"];
      (void) [code_ appendWithNSString:[self formatWithDouble:x0]];
      (void) [code_ appendWithNSString:@"}"];
      (void) [code_ appendWithNSString:@"{x^2/2/"];
      (void) [code_ appendWithNSString:[self formatWithDouble:p]];
      (void) [code_ appendWithNSString:@"}}\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
      case OrgGeogebraCommonKernelKernelNDGeoConicNDConstants_CONIC_HYPERBOLA:
      at = [geo getAffineTransform];
      eigenvecX = [((id<OrgGeogebraCommonAwtGAffineTransform>) nil_chk(at)) getScaleX];
      eigenvecY = [at getShearY];
      x1 = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getX];
      y1 = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
      r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
      r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
      angle = JavaLangMath_toDegreesWithDouble_(JavaLangMath_atan2WithDouble_withDouble_(eigenvecY, eigenvecX));
      [self startBeamerWithJavaLangStringBuilder:code_];
      (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\rput{"];
      (void) [code_ appendWithNSString:[self formatWithDouble:angle]];
      (void) [code_ appendWithNSString:@"}("];
      (void) [code_ appendWithNSString:[self formatWithDouble:x1]];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:[self formatWithDouble:y1]];
      (void) [code_ appendWithNSString:@"){\\parametricplot"];
      (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      (void) [code_ appendWithNSString:@"{-0.99}{0.99}{"];
      (void) [code_ appendWithNSString:[self formatWithDouble:r1]];
      (void) [code_ appendWithNSString:@"*(1+t^2)/(1-t^2)|"];
      (void) [code_ appendWithNSString:[self formatWithDouble:r2]];
      (void) [code_ appendWithNSString:@"*2*t/(1-t^2)"];
      (void) [code_ appendWithNSString:@"}}\n"];
      (void) [code_ appendWithNSString:@"\\rput{"];
      (void) [code_ appendWithNSString:[self formatWithDouble:angle]];
      (void) [code_ appendWithNSString:@"}("];
      (void) [code_ appendWithNSString:[self formatWithDouble:x1]];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:[self formatWithDouble:y1]];
      (void) [code_ appendWithNSString:@"){\\parametricplot"];
      (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
      (void) [code_ appendWithNSString:@"{-0.99}{0.99}{"];
      (void) [code_ appendWithNSString:[self formatWithDouble:r1]];
      (void) [code_ appendWithNSString:@"*(-1-t^2)/(1-t^2)|"];
      (void) [code_ appendWithNSString:[self formatWithDouble:r2]];
      (void) [code_ appendWithNSString:@"*(-2)*t/(1-t^2)"];
      (void) [code_ appendWithNSString:@"}}\n"];
      [self endBeamerWithJavaLangStringBuilder:code_];
      break;
    }
  }
}

- (void)drawGeoPointWithOrgGeogebraCommonKernelGeosGeoPoint:(OrgGeogebraCommonKernelGeosGeoPoint *)gp {
  if ([((id<OrgGeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) getExportPointSymbol]) {
    [self startBeamerWithJavaLangStringBuilder:codePoint_];
    jdouble x = [((OrgGeogebraCommonKernelGeosGeoPoint *) nil_chk(gp)) getX];
    jdouble y = [gp getY];
    jdouble z = [gp getZ];
    x = x / z;
    y = y / z;
    (void) [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\psdots"];
    OrgGeogebraCommonExportPstricksGeoGebraToPstricks_PointOptionCodeWithOrgGeogebraCommonKernelGeosGeoPoint_(self, gp);
    (void) [codePoint_ appendWithNSString:@"("];
    (void) [codePoint_ appendWithNSString:[self formatWithDouble:x]];
    (void) [codePoint_ appendWithNSString:@","];
    (void) [codePoint_ appendWithNSString:[self formatWithDouble:y]];
    (void) [codePoint_ appendWithNSString:@")\n"];
    [self endBeamerWithJavaLangStringBuilder:codePoint_];
  }
  if ([((OrgGeogebraCommonKernelGeosGeoPoint *) nil_chk(gp)) getShowTrimmedIntersectionLines]) {
    OrgGeogebraCommonKernelAlgosAlgoElement *algo = [gp getParentAlgorithm];
    if ([algo isKindOfClass:[OrgGeogebraCommonKernelAlgosAlgoIntersectAbstract class]]) {
      IOSObjectArray *geos = [((OrgGeogebraCommonKernelAlgosAlgoElement *) nil_chk(algo)) getInput];
      jdouble x1 = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toScreenCoordXdWithDouble:[gp getInhomX]];
      jdouble y1 = [euclidianView_ toScreenCoordYdWithDouble:[gp getInhomY]];
      jdouble x2 = [euclidianView_ toScreenCoordXdWithDouble:[gp getInhomX]] + 30;
      jdouble y2 = [euclidianView_ toScreenCoordYdWithDouble:[gp getInhomY]] + 30;
      x1 = [euclidianView_ toRealWorldCoordXWithDouble:x1];
      x2 = [euclidianView_ toRealWorldCoordXWithDouble:x2];
      y1 = [euclidianView_ toRealWorldCoordYWithDouble:y1];
      y2 = [euclidianView_ toRealWorldCoordYWithDouble:y2];
      jdouble r1 = JavaLangMath_absWithDouble_(x2 - x1);
      jdouble r2 = JavaLangMath_absWithDouble_(y2 - y1);
      JavaLangStringBuilder *s = new_JavaLangStringBuilder_initWithNSString_(@"\\psclip{\\psellipse[linestyle=none](");
      (void) [s appendWithNSString:[self formatWithDouble:x1]];
      (void) [s appendWithNSString:@","];
      (void) [s appendWithNSString:[self formatWithDouble:y1]];
      (void) [s appendWithNSString:@")("];
      (void) [s appendWithNSString:[self formatWithDouble:r1]];
      (void) [s appendWithNSString:@","];
      (void) [s appendWithNSString:[self formatWithDouble:r2]];
      (void) [s appendWithNSString:@")}\n"];
      NSString *end = @"\\endpsclip\n";
      jboolean fill1 = NO;
      jboolean draw = ![((OrgGeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(nil_chk(geos), 0))) isEuclidianVisible];
      if (draw) {
        fill1 = ([((OrgGeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 0))) isFillable] && [((OrgGeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 0))) getAlphaValue] > 0.0f);
        if (fill1) (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
        else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
        [self drawGeoElementWithOrgGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 0) withBoolean:NO withBoolean:YES];
      }
      if (geos->size_ > 1 && ![((OrgGeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) isEuclidianVisible]) {
        jboolean fill2 = [((OrgGeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) isFillable] && ([((OrgGeogebraCommonKernelGeosGeoElement *) nil_chk(IOSObjectArray_Get(geos, 1))) getAlphaValue] > 0.0f);
        if (draw) {
          if (fill1 == fill2) {
            [self drawGeoElementWithOrgGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
            if (fill1) (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
          }
          else {
            if (fill1) (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
            if (fill2) (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
            else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
            [self drawGeoElementWithOrgGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
            if (fill2) (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
            else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
          }
        }
        else {
          if (fill2) (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithJavaLangCharSequence:s];
          else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:s];
          [self drawGeoElementWithOrgGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(geos, 1) withBoolean:NO withBoolean:YES];
          if (fill2) (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
          else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
        }
      }
      else if (draw) {
        if (fill1) (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:end];
        else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:end];
      }
    }
  }
}

- (void)drawGeoLineWithOrgGeogebraCommonKernelGeosGeoLine:(OrgGeogebraCommonKernelGeosGeoLine *)geo {
  jdouble x = [((OrgGeogebraCommonKernelGeosGeoLine *) nil_chk(geo)) getX];
  jdouble y = [geo getY];
  jdouble z = [geo getZ];
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (y != 0) (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psplot"];
  else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  if (y != 0) {
    (void) [code_ appendWithNSString:@"{"];
    (void) [code_ appendWithNSString:[self formatWithDouble:xmin_]];
    (void) [code_ appendWithNSString:@"}{"];
    (void) [code_ appendWithNSString:[self formatWithDouble:xmax_]];
    (void) [code_ appendWithNSString:@"}{(-"];
    (void) [code_ appendWithNSString:[self formatWithDouble:z]];
    (void) [code_ appendWithNSString:@"-"];
    (void) [code_ appendWithNSString:[self formatWithDouble:x]];
    (void) [code_ appendWithNSString:@"*x)/"];
    NSString *tmpy = [self formatWithDouble:y];
    if ([((OrgGeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((OrgGeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpy] != 0) (void) [code_ appendWithNSString:tmpy];
    else (void) [code_ appendWithDouble:y];
    (void) [code_ appendWithNSString:@"}\n"];
  }
  else {
    NSString *s = [self formatWithDouble:-z / x];
    (void) [code_ appendWithNSString:@"("];
    (void) [code_ appendWithNSString:s];
    (void) [code_ appendWithNSString:@","];
    (void) [code_ appendWithNSString:[self formatWithDouble:ymin_]];
    (void) [code_ appendWithNSString:@")("];
    (void) [code_ appendWithNSString:s];
    (void) [code_ appendWithNSString:@","];
    (void) [code_ appendWithNSString:[self formatWithDouble:ymax_]];
    (void) [code_ appendWithNSString:@")\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawGeoSegmentWithOrgGeogebraCommonKernelGeosGeoSegment:(OrgGeogebraCommonKernelGeosGeoSegment *)geo {
  IOSDoubleArray *A = [IOSDoubleArray newArrayWithLength:2];
  IOSDoubleArray *B = [IOSDoubleArray newArrayWithLength:2];
  OrgGeogebraCommonKernelGeosGeoPoint *pointStart = ((OrgGeogebraCommonKernelGeosGeoPoint *) [((OrgGeogebraCommonKernelGeosGeoSegment *) nil_chk(geo)) getStartPoint]);
  OrgGeogebraCommonKernelGeosGeoPoint *pointEnd = ((OrgGeogebraCommonKernelGeosGeoPoint *) [geo getEndPoint]);
  [((OrgGeogebraCommonKernelGeosGeoPoint *) nil_chk(pointStart)) getInhomCoordsWithDoubleArray:A];
  [((OrgGeogebraCommonKernelGeosGeoPoint *) nil_chk(pointEnd)) getInhomCoordsWithDoubleArray:B];
  NSString *x1 = [self formatWithDouble:IOSDoubleArray_Get(A, 0)];
  NSString *y1 = [self formatWithDouble:IOSDoubleArray_Get(A, 1)];
  NSString *x2 = [self formatWithDouble:IOSDoubleArray_Get(B, 0)];
  NSString *y2 = [self formatWithDouble:IOSDoubleArray_Get(B, 1)];
  [self startBeamerWithJavaLangStringBuilder:code_];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  (void) [code_ appendWithNSString:@"("];
  (void) [code_ appendWithNSString:x1];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:y1];
  (void) [code_ appendWithNSString:@")("];
  (void) [code_ appendWithNSString:x2];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:y2];
  (void) [code_ appendWithNSString:@")\n"];
  jint deco = geo->decorationType_;
  if (deco != OrgGeogebraCommonKernelGeosGeoElement_DECORATION_NONE) [self markWithDoubleArray:A withDoubleArray:B withInt:deco withOrgGeogebraCommonKernelGeosGeoElement:geo];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawLineWithDouble:(jdouble)x1
                withDouble:(jdouble)y1
                withDouble:(jdouble)x2
                withDouble:(jdouble)y2
withOrgGeogebraCommonKernelGeosGeoElement:(OrgGeogebraCommonKernelGeosGeoElement *)geo {
  NSString *sx1 = [self formatWithDouble:x1];
  NSString *sy1 = [self formatWithDouble:y1];
  NSString *sx2 = [self formatWithDouble:x2];
  NSString *sy2 = [self formatWithDouble:y2];
  if (isBeamer_) (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"  "];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  (void) [code_ appendWithNSString:@"("];
  (void) [code_ appendWithNSString:sx1];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:sy1];
  (void) [code_ appendWithNSString:@")("];
  (void) [code_ appendWithNSString:sx2];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithNSString:sy2];
  (void) [code_ appendWithNSString:@")\n"];
}

- (void)drawGeoRayWithOrgGeogebraCommonKernelGeosGeoRay:(OrgGeogebraCommonKernelGeosGeoRay *)geo {
  OrgGeogebraCommonKernelGeosGeoPoint *pointStart = ((OrgGeogebraCommonKernelGeosGeoPoint *) [((OrgGeogebraCommonKernelGeosGeoRay *) nil_chk(geo)) getStartPoint]);
  jdouble x1 = [((OrgGeogebraCommonKernelGeosGeoPoint *) nil_chk(pointStart)) getX];
  jdouble z1 = [pointStart getZ];
  x1 = x1 / z1;
  NSString *y1 = [self formatWithDouble:[pointStart getY] / z1];
  jdouble x = [geo getX];
  jdouble y = [geo getY];
  jdouble z = [geo getZ];
  [self startBeamerWithJavaLangStringBuilder:code_];
  if (y != 0) (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psplot"];
  else (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  jdouble inf = xmin_, sup = xmax_;
  if (y > 0) {
    inf = x1;
  }
  else {
    sup = x1;
  }
  if (y != 0) {
    (void) [code_ appendWithNSString:@"{"];
    (void) [code_ appendWithNSString:[self formatWithDouble:inf]];
    (void) [code_ appendWithNSString:@"}{"];
    (void) [code_ appendWithNSString:[self formatWithDouble:sup]];
    (void) [code_ appendWithNSString:@"}{(-"];
    (void) [code_ appendWithNSString:[self formatWithDouble:z]];
    (void) [code_ appendWithNSString:@"-"];
    (void) [code_ appendWithNSString:[self formatWithDouble:x]];
    (void) [code_ appendWithNSString:@"*x)/"];
    NSString *tmpy = [self formatWithDouble:y];
    if ([((OrgGeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((OrgGeogebraCommonKernelKernel *) nil_chk(kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpy] != 0) (void) [code_ appendWithNSString:tmpy];
    else (void) [code_ appendWithDouble:y];
    (void) [code_ appendWithNSString:@"}\n"];
  }
  else {
    if (-x > 0) sup = ymax_;
    else sup = ymin_;
    (void) [code_ appendWithNSString:@"("];
    (void) [code_ appendWithNSString:[self formatWithDouble:x1]];
    (void) [code_ appendWithNSString:@","];
    (void) [code_ appendWithNSString:y1];
    (void) [code_ appendWithNSString:@")("];
    (void) [code_ appendWithNSString:[self formatWithDouble:x1]];
    (void) [code_ appendWithNSString:@","];
    (void) [code_ appendWithNSString:[self formatWithDouble:sup]];
    (void) [code_ appendWithNSString:@")\n"];
  }
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)initUnitAndVariable {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_initUnitAndVariable(self);
}

- (void)drawLabelWithOrgGeogebraCommonKernelGeosGeoElement:(OrgGeogebraCommonKernelGeosGeoElement *)geo
                  withOrgGeogebraCommonEuclidianDrawableND:(OrgGeogebraCommonEuclidianDrawableND *)drawGeo {
  @try {
    if ([((OrgGeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) isLabelVisible]) {
      NSString *name = [geo getLabelDescription];
      if ([geo getLabelMode] == OrgGeogebraCommonKernelGeosGeoElement_LABEL_CAPTION) {
        NSString *nameSym = name;
        for (jint i = 0; i < ((jint) [((NSString *) nil_chk(name)) length]); i++) {
          NSString *uCode = JreStrcat("C", [name charAtWithInt:i]);
          if ([((JavaUtilHashMap *) nil_chk(OrgGeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
            nameSym = [((NSString *) nil_chk(nameSym)) replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$$", @"\\$\\\\", [((JavaUtilHashMap *) nil_chk(OrgGeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode], @"\\$")];
          }
        }
        nameSym = [((NSString *) nil_chk(nameSym)) replace:@"$\\euro$" withSequence:@"\\euro"];
        name = nameSym;
        if (!eurosym_ && [((NSString *) nil_chk(name)) contains:@"\\euro"]) (void) [((JavaLangStringBuilder *) nil_chk(codePreamble_)) appendWithNSString:@"\\usepackage{eurosym}\n"];
        if ([((NSString *) nil_chk(name)) contains:@"_"]) {
          name = JreStrcat("C$C", '$', name, '$');
        }
      }
      else {
        name = JreStrcat("C$C", '$', OrgGeogebraCommonUtilStringUtil_toLaTeXStringWithNSString_withBoolean_([geo getLabelDescription], YES), '$');
      }
      if ([((NSString *) nil_chk(name)) indexOfString:OrgGeogebraCommonUtilUnicode_get_DEGREE_()] != -1) {
        name = [name replaceAll:OrgGeogebraCommonUtilUnicode_get_DEGREE_() withReplacement:@"\\\\textrm{\\\\degre}"];
        if ([((JavaLangStringBuilder *) nil_chk(codePreamble_)) indexOfWithNSString:@"\\degre"] == -1) (void) [codePreamble_ appendWithNSString:@"\\newcommand{\\degre}{\\ensuremath{^\\circ}}\n"];
      }
      if (nil == drawGeo) drawGeo = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) getDrawableForWithOrgGeogebraCommonKernelGeosGeoElement:geo];
      jdouble xLabel = [((OrgGeogebraCommonEuclidianDrawableND *) nil_chk(drawGeo)) getxLabel];
      jdouble yLabel = [drawGeo getyLabel];
      xLabel = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordXWithDouble:JavaLangMath_roundWithDouble_(xLabel)];
      yLabel = [euclidianView_ toRealWorldCoordYWithDouble:JavaLangMath_roundWithDouble_(yLabel)];
      OrgGeogebraCommonAwtGColor *geocolor = [geo getObjectColor];
      [self startBeamerWithJavaLangStringBuilder:codePoint_];
      (void) [((JavaLangStringBuilder *) nil_chk(codePoint_)) appendWithNSString:@"\\rput[bl]("];
      (void) [codePoint_ appendWithNSString:[self formatWithDouble:xLabel]];
      (void) [codePoint_ appendWithNSString:@","];
      (void) [codePoint_ appendWithNSString:[self formatWithDouble:yLabel]];
      (void) [codePoint_ appendWithNSString:@"){"];
      if (![((OrgGeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
        (void) [codePoint_ appendWithNSString:@"\\"];
        [self ColorCodeWithOrgGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:codePoint_];
        (void) [codePoint_ appendWithNSString:@"{"];
      }
      (void) [codePoint_ appendWithNSString:name];
      if (![geocolor isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
        (void) [codePoint_ appendWithNSString:@"}"];
      }
      (void) [codePoint_ appendWithNSString:@"}\n"];
      [self endBeamerWithJavaLangStringBuilder:codePoint_];
    }
  }
  @catch (JavaLangNullPointerException *e) {
  }
}

- (void)drawGrid {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawGrid(self);
}

- (void)drawAxis {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawAxis(self);
}

- (void)PointOptionCodeWithOrgGeogebraCommonKernelGeosGeoPoint:(OrgGeogebraCommonKernelGeosGeoPoint *)geo {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_PointOptionCodeWithOrgGeogebraCommonKernelGeosGeoPoint_(self, geo);
}

- (NSString *)LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:(OrgGeogebraCommonKernelGeosGeoElement *)geo
                                                          withBoolean:(jboolean)transparency {
  JavaLangStringBuilder *sb = new_JavaLangStringBuilder_init();
  jint linethickness = [((OrgGeogebraCommonKernelGeosGeoElement *) nil_chk(geo)) getLineThickness];
  jint linestyle = [geo getLineType];
  OrgGeogebraCommonExportPstricksGeoGebraExport_Info *info = new_OrgGeogebraCommonExportPstricksGeoGebraExport_Info_initWithOrgGeogebraCommonExportPstricksGeoGebraExport_withOrgGeogebraCommonKernelGeosGeoElement_(self, geo);
  jboolean coma = NO;
  jboolean bracket = NO;
  if (linethickness != OrgGeogebraCommonPluginEuclidianStyleConstants_DEFAULT_LINE_THICKNESS) {
    coma = YES;
    bracket = YES;
    (void) [sb appendWithNSString:@"[linewidth="];
    (void) [sb appendWithNSString:[self formatWithDouble:linethickness / 2.0 * 0.8]];
    (void) [sb appendWithNSString:@"pt"];
  }
  if (linestyle != OrgGeogebraCommonPluginEuclidianStyleConstants_DEFAULT_LINE_TYPE) {
    if (coma) (void) [sb appendWithNSString:@","];
    else coma = YES;
    if (!bracket) (void) [sb appendWithNSString:@"["];
    bracket = YES;
    OrgGeogebraCommonExportPstricksGeoGebraToPstricks_LinestyleCodeWithInt_withJavaLangStringBuilder_(self, linestyle, sb);
  }
  if (![((OrgGeogebraCommonAwtGColor *) nil_chk([info getLinecolor])) isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
    if (coma) (void) [sb appendWithNSString:@","];
    else coma = YES;
    if (!bracket) (void) [sb appendWithNSString:@"["];
    bracket = YES;
    (void) [sb appendWithNSString:@"linecolor="];
    [self ColorCodeWithOrgGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
  }
  if ([geo isFillable] && transparency) {
    jboolean dotted = NO;
    NSString *style = @",fillstyle=hlines,hatchangle=";
    {
      jdouble y0;
      jdouble y;
      switch ([[info getFillType] ordinal]) {
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_STANDARD:
        if ([info getAlpha] > 0.0f) {
          if (coma) (void) [sb appendWithNSString:@","];
          else coma = YES;
          if (!bracket) (void) [sb appendWithNSString:@"["];
          bracket = YES;
          (void) [sb appendWithNSString:@"fillcolor="];
          [self ColorCodeWithOrgGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
          (void) [sb appendWithNSString:@",fillstyle=solid,opacity="];
          (void) [sb appendWithFloat:[info getAlpha]];
        }
        break;
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_SYMBOLS:
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_CHESSBOARD:
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_HONEYCOMB:
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_BRICK:
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_WEAVING:
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_DOTTED:
        dotted = YES;
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_CROSSHATCHED:
        style = @",fillstyle=crosshatch,hatchangle=";
        case OrgGeogebraCommonKernelGeosGeoElement_FillType_HATCH:
        if (coma) (void) [sb appendWithNSString:@","];
        else coma = YES;
        if (!bracket) (void) [sb appendWithNSString:@"["];
        bracket = YES;
        (void) [sb appendWithNSString:@"hatchcolor="];
        [self ColorCodeWithOrgGeogebraCommonAwtGColor:[info getLinecolor] withJavaLangStringBuilder:sb];
        if (dotted) {
          style = @",fillstyle=dots*,hatchangle=";
        }
        (void) [sb appendWithNSString:style];
        (void) [sb appendWithDouble:[info getAngle]];
        (void) [sb appendWithNSString:@",hatchsep="];
        y0 = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(euclidianView_)) toRealWorldCoordYWithDouble:0];
        y = [euclidianView_ toRealWorldCoordYWithDouble:[info getY]];
        (void) [sb appendWithNSString:[self formatWithDouble:JavaLangMath_absWithDouble_((y - y0))]];
        break;
      }
    }
  }
  if (bracket) (void) [sb appendWithNSString:@"]"];
  return [NSString stringWithJavaLangStringBuilder:sb];
}

- (void)LinestyleCodeWithInt:(jint)linestyle
   withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_LinestyleCodeWithInt_withJavaLangStringBuilder_(self, linestyle, sb);
}

- (void)ColorCodeWithOrgGeogebraCommonAwtGColor:(OrgGeogebraCommonAwtGColor *)c
                      withJavaLangStringBuilder:(JavaLangStringBuilder *)sb {
  if ([((id<OrgGeogebraCommonExportPstricksExportSettings>) nil_chk(frame_)) isGrayscale]) {
    NSString *colorname = @"";
    jint red = [((OrgGeogebraCommonAwtGColor *) nil_chk(c)) getRed];
    jint green = [c getGreen];
    jint blue = [c getBlue];
    jint grayscale = (red + green + blue) / 3;
    c = [((OrgGeogebraCommonFactoriesAwtFactory *) nil_chk(OrgGeogebraCommonFactoriesAwtFactory_get_prototype_())) newColorWithInt:grayscale withInt:grayscale withInt:grayscale];
    if ([((JavaUtilHashMap *) nil_chk(CustomColor_)) containsKeyWithId:c]) {
      colorname = [((NSString *) nil_chk([CustomColor_ getWithId:c])) description];
    }
    else {
      colorname = [self createCustomColorWithInt:grayscale withInt:grayscale withInt:grayscale];
      (void) [((JavaLangStringBuilder *) nil_chk(codeBeginDoc_)) appendWithNSString:JreStrcat("$$$$C$C$$", @"\\newrgbcolor{", colorname, @"}{", [self formatWithDouble:grayscale / 255.0], ' ', [self formatWithDouble:grayscale / 255.0], ' ', [self formatWithDouble:grayscale / 255.0], @"}\n")];
      (void) [CustomColor_ putWithId:c withId:colorname];
    }
    if ([((OrgGeogebraCommonAwtGColor *) nil_chk(c)) isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"black"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_DARK_GRAY_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"darkgray"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_GRAY_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"gray"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_LIGHT_GRAY_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"lightgray"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_WHITE_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"white"];
    else (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:colorname];
  }
  else {
    if ([((OrgGeogebraCommonAwtGColor *) nil_chk(c)) isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"black"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_DARK_GRAY_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"darkgray"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_GRAY_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"gray"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_LIGHT_GRAY_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"lightgray"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_WHITE_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"white"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_RED_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"red"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_GREEN_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"green"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_BLUE_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"blue"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_CYAN_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"cyan"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_MAGENTA_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"magenta"];
    else if ([c isEqual:OrgGeogebraCommonAwtGColor_get_YELLOW_()]) (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"yellow"];
    else {
      NSString *colorname = @"";
      if ([((JavaUtilHashMap *) nil_chk(CustomColor_)) containsKeyWithId:c]) {
        colorname = [((NSString *) nil_chk([CustomColor_ getWithId:c])) description];
      }
      else {
        jint red = [c getRed];
        jint green = [c getGreen];
        jint blue = [c getBlue];
        colorname = [self createCustomColorWithInt:red withInt:green withInt:blue];
        (void) [((JavaLangStringBuilder *) nil_chk(codeBeginDoc_)) appendWithNSString:JreStrcat("$$$$C$C$$", @"\\newrgbcolor{", colorname, @"}{", [self formatWithDouble:red / 255.0], ' ', [self formatWithDouble:green / 255.0], ' ', [self formatWithDouble:blue / 255.0], @"}\n")];
        (void) [CustomColor_ putWithId:c withId:colorname];
      }
      (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:colorname];
    }
  }
}

- (void)addTextWithNSString:(NSString *)st
                withBoolean:(jboolean)isLatex
                    withInt:(jint)style
withOrgGeogebraCommonAwtGColor:(OrgGeogebraCommonAwtGColor *)geocolor {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withOrgGeogebraCommonAwtGColor_(self, st, isLatex, style, geocolor);
}

- (void)drawImplicitPolyWithOrgGeogebraCommonKernelImplicitGeoImplicitPoly:(OrgGeogebraCommonKernelImplicitGeoImplicitPoly *)geo {
  if ([((JavaLangStringBuilder *) nil_chk(codePreamble_)) indexOfWithNSString:@"pst-func"] == -1) {
    (void) [codePreamble_ appendWithNSString:@"\\usepackage{pst-func}\n"];
  }
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psplotImp"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  (void) [code_ appendWithNSString:@"("];
  (void) [code_ appendWithDouble:JavaLangMath_floorWithDouble_(xmin_) - 1];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithDouble:JavaLangMath_floorWithDouble_(ymin_) - 1];
  (void) [code_ appendWithNSString:@")("];
  (void) [code_ appendWithDouble:JavaLangMath_floorWithDouble_(xmax_) + 1];
  (void) [code_ appendWithNSString:@","];
  (void) [code_ appendWithDouble:JavaLangMath_floorWithDouble_(ymax_) + 1];
  (void) [code_ appendWithNSString:@"){"];
  (void) [code_ appendWithNSString:[self getImplicitExprWithOrgGeogebraCommonKernelImplicitGeoImplicitPoly:geo]];
  (void) [code_ appendWithNSString:@"}\n"];
}

- (void)drawPolyLineWithOrgGeogebraCommonKernelGeosGeoPolyLine:(OrgGeogebraCommonKernelGeosGeoPolyLine *)geo {
  IOSObjectArray *path = [((OrgGeogebraCommonKernelGeosGeoPolyLine *) nil_chk(geo)) getPoints];
  if (((IOSObjectArray *) nil_chk(path))->size_ < 2) return;
  [self startBeamerWithJavaLangStringBuilder:code_];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:@"\\psline"];
  (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
  for (jint i = 0; i < path->size_; i++) {
    OrgGeogebraCommonKernelMatrixCoords *coords = [((id<OrgGeogebraCommonKernelKernelNDGeoPointND>) nil_chk(IOSObjectArray_Get(path, i))) getInhomCoords];
    NSString *x1 = [self formatWithDouble:[((OrgGeogebraCommonKernelMatrixCoords *) nil_chk(coords)) getX]];
    NSString *y1 = [self formatWithDouble:[coords getY]];
    if ([((NSString *) nil_chk(x1)) contains:@"?"] || [((NSString *) nil_chk(y1)) contains:@"?"]) {
      (void) [code_ appendWithNSString:@"\n\\psline"];
      (void) [code_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    }
    else {
      (void) [code_ appendWithNSString:@"("];
      (void) [code_ appendWithNSString:x1];
      (void) [code_ appendWithNSString:@","];
      (void) [code_ appendWithNSString:y1];
      (void) [code_ appendWithNSString:@")"];
    }
  }
  (void) [code_ appendWithNSString:@"\n"];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (void)drawHistogramOrBarChartBoxWithDoubleArray:(IOSDoubleArray *)y
                                  withDoubleArray:(IOSDoubleArray *)x
                                          withInt:(jint)length
                                       withDouble:(jdouble)width
        withOrgGeogebraCommonKernelGeosGeoNumeric:(OrgGeogebraCommonKernelGeosGeoNumeric *)g {
  NSString *command = [((OrgGeogebraCommonKernelGeosGeoNumeric *) nil_chk(g)) getCommandDescriptionWithOrgGeogebraCommonKernelStringTemplate:OrgGeogebraCommonKernelStringTemplate_get_noLocalDefault_()];
  [self startBeamerWithJavaLangStringBuilder:codeFilledObject_];
  if ([((NSString *) nil_chk(command)) contains:@"Binomial"] && [command contains:@"true"]) {
    (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\psline"];
    (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:g withBoolean:YES]];
    (void) [codeFilledObject_ appendWithNSString:@"("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(x), 0) + width / 2]];
    (void) [codeFilledObject_ appendWithNSString:@",0)("];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, 0) + width / 2]];
    (void) [codeFilledObject_ appendWithNSString:@","];
    (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(y), 0)]];
    (void) [codeFilledObject_ appendWithNSString:@")\n"];
    for (jint i = 0; i < length - 1; i++) {
      (void) [codeFilledObject_ appendWithNSString:@"\\psline"];
      (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:g withBoolean:YES]];
      (void) [codeFilledObject_ appendWithNSString:@"("];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i) + width / 2]];
      (void) [codeFilledObject_ appendWithNSString:JreStrcat("C$$", ',', [self formatWithDouble:IOSDoubleArray_Get(y, i)], @")(")];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1) + width / 2]];
      (void) [codeFilledObject_ appendWithNSString:@","];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(y, i)]];
      (void) [codeFilledObject_ appendWithNSString:@")\n"];
      if (i != x->size_ - 2 && isBeamer_) (void) [codeFilledObject_ appendWithNSString:@"  "];
      (void) [codeFilledObject_ appendWithNSString:@"\\psline"];
      (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:g withBoolean:YES]];
      (void) [codeFilledObject_ appendWithNSString:@"("];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1) + width / 2]];
      (void) [codeFilledObject_ appendWithNSString:@","];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(y, i)]];
      (void) [codeFilledObject_ appendWithNSString:@")"];
      (void) [codeFilledObject_ appendWithNSString:@"("];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1) + width / 2]];
      (void) [codeFilledObject_ appendWithNSString:@","];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(y, i + 1)]];
      (void) [codeFilledObject_ appendWithNSString:@")\n"];
    }
  }
  else {
    for (jint i = 0; i < length; i++) {
      barNumber_ = i + 1;
      (void) [((JavaLangStringBuilder *) nil_chk(codeFilledObject_)) appendWithNSString:@"\\psframe"];
      (void) [codeFilledObject_ appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:g withBoolean:YES]];
      (void) [codeFilledObject_ appendWithNSString:@"("];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(x), i)]];
      (void) [codeFilledObject_ appendWithNSString:@",0)("];
      if (x->size_ == length) {
        (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i) + width]];
      }
      else {
        (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(x, i + 1)]];
      }
      (void) [codeFilledObject_ appendWithNSString:@","];
      (void) [codeFilledObject_ appendWithNSString:[self formatWithDouble:IOSDoubleArray_Get(nil_chk(y), i)]];
      (void) [codeFilledObject_ appendWithNSString:@")\n"];
      if (i != x->size_ - 2 && isBeamer_) (void) [codeFilledObject_ appendWithNSString:@"  "];
    }
  }
  [self endBeamerWithJavaLangStringBuilder:codeFilledObject_];
}

- (void)drawNyquistWithOrgGeogebraCommonKernelGeosGeoTransferFunction:(OrgGeogebraCommonKernelGeosGeoTransferFunction *)g {
  [self startBeamerWithJavaLangStringBuilder:code_];
  NSString *liopco = [self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:g withBoolean:YES];
  NSString *template_ = JreStrcat("$$C$C$", @"\\psline", liopco, OrgGeogebraCommonUtilUnicode_SECTION_SIGN, @"arrows", OrgGeogebraCommonUtilUnicode_SECTION_SIGN, @"(%0,%1)(%2,%3)\n");
  JavaLangStringBuilder *lineBuilder = [self drawNyquistDiagramWithOrgGeogebraCommonKernelGeosGeoTransferFunction:g withNSString:template_ withNSString:JreStrcat("C$C", OrgGeogebraCommonUtilUnicode_SECTION_SIGN, @"arrows", OrgGeogebraCommonUtilUnicode_SECTION_SIGN) withNSString:@"{<-}" withNSString:@"{->}"];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithNSString:[((JavaLangStringBuilder *) nil_chk(lineBuilder)) description]];
  [self endBeamerWithJavaLangStringBuilder:code_];
}

- (jboolean)fillSplineWithOrgGeogebraCommonKernelGeosGeoCurveCartesianArray:(IOSObjectArray *)curves {
  NSString *liopco = [self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:IOSObjectArray_Get(nil_chk(curves), 0) withBoolean:YES];
  if (![((NSString *) nil_chk(liopco)) contains:@"fill"]) {
    return NO;
  }
  JavaLangStringBuilder *fill = new_JavaLangStringBuilder_initWithNSString_(@"\\pscustom");
  (void) [fill appendWithNSString:liopco];
  (void) [fill appendWithNSString:@"\n{\n"];
  (void) [((JavaLangStringBuilder *) nil_chk(code_)) appendWithJavaLangCharSequence:fill];
  for (jint i = 0; i < curves->size_; i++) [self drawSingleCurveCartesianWithOrgGeogebraCommonKernelGeosGeoCurveCartesian:IOSObjectArray_Get(curves, i) withBoolean:NO];
  (void) [code_ appendWithNSString:@"}\n"];
  return YES;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithOrgGeogebraCommonMainApp:", "GeoGebraToPstricks", NULL, 0x1, NULL, NULL },
    { "generateAllCode", NULL, "V", 0x1, NULL, NULL },
    { "drawLocusWithOrgGeogebraCommonKernelGeosGeoLocus:", "drawLocus", "V", 0x4, NULL, NULL },
    { "drawBoxPlotWithOrgGeogebraCommonKernelGeosGeoNumeric:", "drawBoxPlot", "V", 0x4, NULL, NULL },
    { "drawSumTrapezoidalWithOrgGeogebraCommonKernelGeosGeoNumeric:", "drawSumTrapezoidal", "V", 0x4, NULL, NULL },
    { "drawSumUpperLowerWithOrgGeogebraCommonKernelGeosGeoNumeric:", "drawSumUpperLower", "V", 0x4, NULL, NULL },
    { "drawIntegralFunctionsWithOrgGeogebraCommonKernelGeosGeoNumeric:", "drawIntegralFunctions", "V", 0x4, NULL, NULL },
    { "drawIntegralWithOrgGeogebraCommonKernelGeosGeoNumeric:", "drawIntegral", "V", 0x4, NULL, NULL },
    { "drawSlopeWithOrgGeogebraCommonKernelGeosGeoNumeric:", "drawSlope", "V", 0x4, NULL, NULL },
    { "drawAngleWithOrgGeogebraCommonKernelGeosGeoAngle:", "drawAngle", "V", 0x4, NULL, NULL },
    { "drawArrowArcWithOrgGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:withDouble:withDouble:withBoolean:", "drawArrowArc", "V", 0x4, NULL, NULL },
    { "drawArcWithOrgGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:withDouble:withDouble:", "drawArc", "V", 0x4, NULL, NULL },
    { "drawTickWithOrgGeogebraCommonKernelGeosGeoAngle:withDoubleArray:withDouble:", "drawTick", "V", 0x4, NULL, NULL },
    { "drawSliderWithOrgGeogebraCommonKernelGeosGeoNumeric:", "drawSlider", "V", 0x4, NULL, NULL },
    { "drawPolygonWithOrgGeogebraCommonKernelGeosGeoPolygon:", "drawPolygon", "V", 0x4, NULL, NULL },
    { "drawTextWithOrgGeogebraCommonKernelGeosGeoText:", "drawText", "V", 0x4, NULL, NULL },
    { "drawGeoConicPartWithOrgGeogebraCommonKernelGeosGeoConicPart:", "drawGeoConicPart", "V", 0x4, NULL, NULL },
    { "drawSingleCurveCartesianWithOrgGeogebraCommonKernelGeosGeoCurveCartesian:withBoolean:", "drawSingleCurveCartesian", "V", 0x4, NULL, NULL },
    { "drawFunctionWithOrgGeogebraCommonKernelGeosGeoFunction:", "drawFunction", "V", 0x4, NULL, NULL },
    { "drawFunctionWithOrgGeogebraCommonKernelGeosGeoFunction:withBoolean:withOrgGeogebraCommonKernelGeosGeoNumeric:", "drawFunction", "V", 0x4, NULL, NULL },
    { "killSpaceWithNSString:", "killSpace", "Ljava.lang.String;", 0xa, NULL, NULL },
    { "renameFuncWithJavaLangStringBuilder:withNSString:withNSString:", "renameFunc", "V", 0xa, NULL, NULL },
    { "maxDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction:withDouble:withDouble:", "maxDefinedValue", "D", 0x2, NULL, NULL },
    { "firstDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction:withDouble:withDouble:", "firstDefinedValue", "D", 0x2, NULL, NULL },
    { "drawGeoVectorWithOrgGeogebraCommonKernelGeosGeoVector:", "drawGeoVector", "V", 0x4, NULL, NULL },
    { "drawCircleWithOrgGeogebraCommonKernelGeosGeoConic:", "drawCircle", "V", 0x2, NULL, NULL },
    { "drawGeoConicWithOrgGeogebraCommonKernelGeosGeoConic:", "drawGeoConic", "V", 0x4, NULL, NULL },
    { "drawGeoPointWithOrgGeogebraCommonKernelGeosGeoPoint:", "drawGeoPoint", "V", 0x4, NULL, NULL },
    { "drawGeoLineWithOrgGeogebraCommonKernelGeosGeoLine:", "drawGeoLine", "V", 0x4, NULL, NULL },
    { "drawGeoSegmentWithOrgGeogebraCommonKernelGeosGeoSegment:", "drawGeoSegment", "V", 0x4, NULL, NULL },
    { "drawLineWithDouble:withDouble:withDouble:withDouble:withOrgGeogebraCommonKernelGeosGeoElement:", "drawLine", "V", 0x4, NULL, NULL },
    { "drawGeoRayWithOrgGeogebraCommonKernelGeosGeoRay:", "drawGeoRay", "V", 0x4, NULL, NULL },
    { "initUnitAndVariable", NULL, "V", 0x2, NULL, NULL },
    { "drawLabelWithOrgGeogebraCommonKernelGeosGeoElement:withOrgGeogebraCommonEuclidianDrawableND:", "drawLabel", "V", 0x4, NULL, NULL },
    { "drawGrid", NULL, "V", 0x2, NULL, NULL },
    { "drawAxis", NULL, "V", 0x2, NULL, NULL },
    { "PointOptionCodeWithOrgGeogebraCommonKernelGeosGeoPoint:", "PointOptionCode", "V", 0x2, NULL, NULL },
    { "LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:withBoolean:", "LineOptionCode", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "LinestyleCodeWithInt:withJavaLangStringBuilder:", "LinestyleCode", "V", 0x2, NULL, NULL },
    { "ColorCodeWithOrgGeogebraCommonAwtGColor:withJavaLangStringBuilder:", "ColorCode", "V", 0x4, NULL, NULL },
    { "addTextWithNSString:withBoolean:withInt:withOrgGeogebraCommonAwtGColor:", "addText", "V", 0x2, NULL, NULL },
    { "drawImplicitPolyWithOrgGeogebraCommonKernelImplicitGeoImplicitPoly:", "drawImplicitPoly", "V", 0x4, NULL, NULL },
    { "drawPolyLineWithOrgGeogebraCommonKernelGeosGeoPolyLine:", "drawPolyLine", "V", 0x4, NULL, NULL },
    { "drawHistogramOrBarChartBoxWithDoubleArray:withDoubleArray:withInt:withDouble:withOrgGeogebraCommonKernelGeosGeoNumeric:", "drawHistogramOrBarChartBox", "V", 0x4, NULL, NULL },
    { "drawNyquistWithOrgGeogebraCommonKernelGeosGeoTransferFunction:", "drawNyquist", "V", 0x4, NULL, NULL },
    { "fillSplineWithOrgGeogebraCommonKernelGeosGeoCurveCartesianArray:", "fillSpline", "Z", 0x4, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "eurosym_", NULL, 0x2, "Z", NULL, NULL,  },
    { "FORMAT_BEAMER_", NULL, 0x1a, "I", NULL, NULL, .constantValue.asInt = OrgGeogebraCommonExportPstricksGeoGebraToPstricks_FORMAT_BEAMER },
    { "codeBeginPic_", NULL, 0x2, "Ljava.lang.StringBuilder;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _OrgGeogebraCommonExportPstricksGeoGebraToPstricks = { 2, "GeoGebraToPstricks", "org.geogebra.common.export.pstricks", NULL, 0x401, 46, methods, 3, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgGeogebraCommonExportPstricksGeoGebraToPstricks;
}

@end

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_initWithOrgGeogebraCommonMainApp_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonMainApp *app) {
  (void) OrgGeogebraCommonExportPstricksGeoGebraExport_initWithOrgGeogebraCommonMainApp_(self, app);
  self->eurosym_ = NO;
}

NSString *OrgGeogebraCommonExportPstricksGeoGebraToPstricks_killSpaceWithNSString_(NSString *name) {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_initialize();
  JavaLangStringBuilder *sb = new_JavaLangStringBuilder_init();
  jboolean operand = NO;
  jboolean space = NO;
  for (jint i = 0; i < ((jint) [((NSString *) nil_chk(name)) length]); i++) {
    jchar c = [name charAtWithInt:i];
    if ([@"*/+-" indexOf:c] != -1) {
      (void) [sb appendWithChar:c];
      operand = YES;
      space = NO;
    }
    else if (c == ' ') {
      if (!operand) space = YES;
      else {
        space = NO;
        operand = NO;
      }
    }
    else {
      if (space && ![name contains:@"If"]) (void) [sb appendWithNSString:@"*"];
      (void) [sb appendWithChar:c];
      space = NO;
      operand = NO;
    }
  }
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, OrgGeogebraCommonUtilUnicode_get_EULER_STRING_(), @"2.718281828");
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(sb, @"\\pi", @"PI");
  return [NSString stringWithJavaLangStringBuilder:sb];
}

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_renameFuncWithJavaLangStringBuilder_withNSString_withNSString_(JavaLangStringBuilder *sb, NSString *nameFunc, NSString *nameNew) {
  OrgGeogebraCommonExportPstricksGeoGebraToPstricks_initialize();
  jint ind = [((JavaLangStringBuilder *) nil_chk(sb)) indexOfWithNSString:nameFunc];
  while (ind > -1) {
    (void) [sb replaceWithInt:ind withInt:ind + ((jint) [((NSString *) nil_chk(nameFunc)) length]) withNSString:nameNew];
    ind = [sb indexOfWithNSString:nameFunc];
  }
}

jdouble OrgGeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b) {
  jdouble x = a;
  jdouble step = (b - a) / 100;
  while (x <= b) {
    jdouble y = [((OrgGeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) evaluateWithDouble:x];
    if (JavaLangDouble_isNaNWithDouble_(y)) {
      if (step < self->PRECISION_XRANGE_FUNCTION_) return x - step;
      return OrgGeogebraCommonExportPstricksGeoGebraToPstricks_maxDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, x - step, x);
    }
    x += step;
  }
  return b;
}

jdouble OrgGeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonKernelGeosGeoFunction *f, jdouble a, jdouble b) {
  jdouble x = a;
  jdouble step = (b - a) / 100;
  while (x <= b) {
    jdouble y = [((OrgGeogebraCommonKernelGeosGeoFunction *) nil_chk(f)) evaluateWithDouble:x];
    if (!JavaLangDouble_isNaNWithDouble_(y)) {
      if (x == a) return a;
      else if (step < self->PRECISION_XRANGE_FUNCTION_) return x;
      else return OrgGeogebraCommonExportPstricksGeoGebraToPstricks_firstDefinedValueWithOrgGeogebraCommonKernelGeosGeoFunction_withDouble_withDouble_(self, f, x - step, x);
    }
    x += step;
  }
  return b;
}

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawCircleWithOrgGeogebraCommonKernelGeosGeoConic_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonKernelGeosGeoConic *geo) {
  JavaLangStringBuilder *s = new_JavaLangStringBuilder_init();
  if (self->xunit_ == self->yunit_) {
    jdouble x = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([((OrgGeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getTranslationVector])) getX];
    jdouble y = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
    jdouble r = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
    [self startBeamerWithJavaLangStringBuilder:s];
    (void) [s appendWithNSString:@"\\pscircle"];
    (void) [s appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    (void) [s appendWithNSString:@"("];
    (void) [s appendWithNSString:[self formatWithDouble:x]];
    (void) [s appendWithNSString:@","];
    (void) [s appendWithNSString:[self formatWithDouble:y]];
    (void) [s appendWithNSString:@"){"];
    NSString *tmpr = [self formatWithDouble:r * self->xunit_];
    if ([((OrgGeogebraCommonKernelCommandsAlgebraProcessor *) nil_chk([((OrgGeogebraCommonKernelKernel *) nil_chk(self->kernel_)) getAlgebraProcessor])) evaluateToDoubleWithNSString:tmpr] != 0) (void) [s appendWithNSString:tmpr];
    else (void) [s appendWithDouble:r];
    (void) [s appendWithNSString:@"}\n"];
    [self endBeamerWithJavaLangStringBuilder:s];
  }
  else {
    jdouble x1 = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([((OrgGeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getTranslationVector])) getX];
    jdouble y1 = [((OrgGeogebraCommonKernelGeosGeoVec2D *) nil_chk([geo getTranslationVector])) getY];
    jdouble r1 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 0);
    jdouble r2 = IOSDoubleArray_Get(nil_chk([geo getHalfAxes]), 1);
    [self startBeamerWithJavaLangStringBuilder:s];
    (void) [s appendWithNSString:@"\\psellipse"];
    (void) [s appendWithNSString:[self LineOptionCodeWithOrgGeogebraCommonKernelGeosGeoElement:geo withBoolean:YES]];
    (void) [s appendWithNSString:@"("];
    (void) [s appendWithNSString:[self formatWithDouble:x1]];
    (void) [s appendWithNSString:@","];
    (void) [s appendWithNSString:[self formatWithDouble:y1]];
    (void) [s appendWithNSString:@")("];
    (void) [s appendWithNSString:[self formatWithDouble:r1]];
    (void) [s appendWithNSString:@","];
    (void) [s appendWithNSString:[self formatWithDouble:r2]];
    (void) [s appendWithNSString:@")\n"];
    [self endBeamerWithJavaLangStringBuilder:s];
  }
  if ([((OrgGeogebraCommonKernelGeosGeoConic *) nil_chk(geo)) getAlphaValue] > 0.0f) (void) [((JavaLangStringBuilder *) nil_chk(self->codeFilledObject_)) appendWithJavaLangCharSequence:s];
  else (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithJavaLangCharSequence:s];
}

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_initUnitAndVariable(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self) {
  (void) [((JavaLangStringBuilder *) nil_chk(self->codeBeginPic_)) appendWithNSString:@"\\psset{xunit="];
  (void) [self->codeBeginPic_ appendWithNSString:[self sci2decWithDouble:self->xunit_]];
  (void) [self->codeBeginPic_ appendWithNSString:@"cm,yunit="];
  (void) [self->codeBeginPic_ appendWithNSString:[self sci2decWithDouble:self->yunit_]];
  (void) [self->codeBeginPic_ appendWithNSString:@"cm,algebraic=true,dimen=middle,dotstyle=o,dotsize="];
  (void) [self->codeBeginPic_ appendWithInt:OrgGeogebraCommonPluginEuclidianStyleConstants_DEFAULT_POINT_SIZE];
  (void) [self->codeBeginPic_ appendWithNSString:@"pt 0"];
  (void) [self->codeBeginPic_ appendWithNSString:@",linewidth="];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:OrgGeogebraCommonPluginEuclidianStyleConstants_DEFAULT_LINE_THICKNESS / 2 * 0.8]];
  (void) [self->codeBeginPic_ appendWithNSString:@"pt,arrowsize=3pt 2,arrowinset=0.25}\n"];
}

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawGrid(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self) {
  OrgGeogebraCommonAwtGColor *GridCol = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(self->euclidianView_)) getGridColor];
  IOSDoubleArray *GridDist = [self->euclidianView_ getGridDistances];
  jdouble myx = self->xmin_;
  jlong truncx = J2ObjCFpToLong(myx);
  jdouble myy = self->ymin_;
  jlong truncy = J2ObjCFpToLong(myy);
  jdouble RX = JavaLangMath_absWithDouble_(self->xmax_ - self->xmin_) / IOSDoubleArray_Get(nil_chk(GridDist), 0) + 1;
  jlong repx = J2ObjCFpToLong(RX);
  jdouble RY = JavaLangMath_absWithDouble_(self->ymax_ - self->ymin_) / IOSDoubleArray_Get(GridDist, 1) + 1;
  jlong repy = J2ObjCFpToLong(RY);
  (void) [((JavaLangStringBuilder *) nil_chk(self->codeBeginPic_)) appendWithNSString:@"\\multips(0,"];
  (void) [self->codeBeginPic_ appendWithLong:truncy];
  (void) [self->codeBeginPic_ appendWithNSString:@")(0,"];
  (void) [self->codeBeginPic_ appendWithNSString:[self sci2decWithDouble:IOSDoubleArray_Get(GridDist, 1)]];
  (void) [self->codeBeginPic_ appendWithNSString:@"){"];
  (void) [self->codeBeginPic_ appendWithLong:repy];
  (void) [self->codeBeginPic_ appendWithNSString:@"}{\\psline[linestyle=dashed,linecap=1,dash=1.5pt 1.5pt,linewidth=0.4pt,linecolor="];
  [self ColorCodeWithOrgGeogebraCommonAwtGColor:GridCol withJavaLangStringBuilder:self->codeBeginPic_];
  (void) [self->codeBeginPic_ appendWithNSString:@"]{c-c}("];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->xmin_]];
  (void) [self->codeBeginPic_ appendWithNSString:@",0)("];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->xmax_]];
  (void) [self->codeBeginPic_ appendWithNSString:@",0)}\n"];
  (void) [self->codeBeginPic_ appendWithNSString:@"\\multips("];
  (void) [self->codeBeginPic_ appendWithLong:truncx];
  (void) [self->codeBeginPic_ appendWithNSString:@",0)("];
  (void) [self->codeBeginPic_ appendWithNSString:[self sci2decWithDouble:IOSDoubleArray_Get(GridDist, 0)]];
  (void) [self->codeBeginPic_ appendWithNSString:@",0){"];
  (void) [self->codeBeginPic_ appendWithLong:repx];
  (void) [self->codeBeginPic_ appendWithNSString:@"}{\\psline[linestyle=dashed,linecap=1,dash=1.5pt 1.5pt,linewidth=0.4pt,linecolor="];
  [self ColorCodeWithOrgGeogebraCommonAwtGColor:GridCol withJavaLangStringBuilder:self->codeBeginPic_];
  (void) [self->codeBeginPic_ appendWithNSString:@"]{c-c}(0,"];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->ymin_]];
  (void) [self->codeBeginPic_ appendWithNSString:@")(0,"];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->ymax_]];
  (void) [self->codeBeginPic_ appendWithNSString:@")}\n"];
}

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_drawAxis(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self) {
  IOSBooleanArray *positiveOnly = [((OrgGeogebraCommonEuclidianEuclidianView *) nil_chk(self->euclidianView_)) getPositiveAxes];
  jboolean xAxis = [self->euclidianView_ getShowXaxis];
  jboolean yAxis = [self->euclidianView_ getShowYaxis];
  jdouble Dx = IOSDoubleArray_Get(nil_chk([self->euclidianView_ getAxesNumberingDistances]), 0);
  jdouble Dy = IOSDoubleArray_Get(nil_chk([self->euclidianView_ getAxesNumberingDistances]), 1);
  IOSObjectArray *label = [self->euclidianView_ getAxesLabelsWithBoolean:NO];
  NSString *styleAx = @"";
  if (([self->euclidianView_ getAxesLineStyle] & OrgGeogebraCommonPluginEuclidianStyleConstants_AXES_BOLD) == OrgGeogebraCommonPluginEuclidianStyleConstants_AXES_BOLD) {
    styleAx = @"linewidth=1.4pt,";
  }
  (void) [((JavaLangStringBuilder *) nil_chk(self->codeBeginPic_)) appendWithNSString:JreStrcat("$$$", @"\\psaxes[", styleAx, @"labelFontSize=\\scriptstyle,xAxis=")];
  (void) [self->codeBeginPic_ appendWithBoolean:xAxis];
  (void) [self->codeBeginPic_ appendWithNSString:@",yAxis="];
  (void) [self->codeBeginPic_ appendWithBoolean:yAxis];
  (void) [self->codeBeginPic_ appendWithChar:','];
  jboolean bx = IOSBooleanArray_Get(nil_chk([self->euclidianView_ getShowAxesNumbers]), 0);
  jboolean by = IOSBooleanArray_Get(nil_chk([self->euclidianView_ getShowAxesNumbers]), 1);
  if (!bx && !by) (void) [self->codeBeginPic_ appendWithNSString:@"labels=none,"];
  else if (bx && !by) (void) [self->codeBeginPic_ appendWithNSString:@"labels=x,"];
  else if (!bx && by) (void) [self->codeBeginPic_ appendWithNSString:@"labels=y,"];
  (void) [self->codeBeginPic_ appendWithNSString:@"Dx="];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:Dx]];
  (void) [self->codeBeginPic_ appendWithNSString:@",Dy="];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:Dy]];
  (void) [self->codeBeginPic_ appendWithNSString:@",ticksize=-2pt 0,subticks=2]{"];
  styleAx = @"";
  if (([self->euclidianView_ getAxesLineStyle] & OrgGeogebraCommonPluginEuclidianStyleConstants_AXES_RIGHT_ARROW) == OrgGeogebraCommonPluginEuclidianStyleConstants_AXES_RIGHT_ARROW) {
    styleAx = @"->";
  }
  if (([self->euclidianView_ getAxesLineStyle] & OrgGeogebraCommonPluginEuclidianStyleConstants_AXES_LEFT_ARROW) == OrgGeogebraCommonPluginEuclidianStyleConstants_AXES_LEFT_ARROW) {
    styleAx = JreStrcat("C$", '<', styleAx);
    ;
  }
  (void) [self->codeBeginPic_ appendWithNSString:styleAx];
  (void) [self->codeBeginPic_ appendWithNSString:@"}(0,0)("];
  jdouble assignMin = self->xmin_;
  if (IOSBooleanArray_Get(nil_chk(positiveOnly), 0)) {
    assignMin = 0;
  }
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:assignMin]];
  (void) [self->codeBeginPic_ appendWithNSString:@","];
  assignMin = self->ymin_;
  if (IOSBooleanArray_Get(positiveOnly, 0)) {
    assignMin = 0;
  }
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:assignMin]];
  (void) [self->codeBeginPic_ appendWithNSString:@")("];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->xmax_]];
  (void) [self->codeBeginPic_ appendWithNSString:@","];
  (void) [self->codeBeginPic_ appendWithNSString:[self formatWithDouble:self->ymax_]];
  (void) [self->codeBeginPic_ appendWithNSString:@")"];
  if (nil != IOSObjectArray_Get(nil_chk(label), 0) || nil != IOSObjectArray_Get(label, 1)) {
    (void) [self->codeBeginPic_ appendWithNSString:@"["];
    if (nil != IOSObjectArray_Get(label, 0)) (void) [self->codeBeginPic_ appendWithNSString:IOSObjectArray_Get(label, 0)];
    (void) [self->codeBeginPic_ appendWithNSString:@",140] ["];
    if (nil != IOSObjectArray_Get(label, 1)) (void) [self->codeBeginPic_ appendWithNSString:IOSObjectArray_Get(label, 1)];
    (void) [self->codeBeginPic_ appendWithNSString:@",-40]"];
  }
  (void) [self->codeBeginPic_ appendWithNSString:@"\n"];
}

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_PointOptionCodeWithOrgGeogebraCommonKernelGeosGeoPoint_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, OrgGeogebraCommonKernelGeosGeoPoint *geo) {
  OrgGeogebraCommonAwtGColor *dotcolor = [((OrgGeogebraCommonKernelGeosGeoPoint *) nil_chk(geo)) getObjectColor];
  jint dotsize = [geo getPointSize];
  jint dotstyle = [geo getPointStyle];
  if (dotstyle == -1) {
    dotstyle = OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_DOT;
  }
  jboolean coma = NO;
  jboolean bracket = NO;
  if (dotsize != OrgGeogebraCommonPluginEuclidianStyleConstants_DEFAULT_POINT_SIZE) {
    coma = YES;
    bracket = YES;
    (void) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"[dotsize="];
    (void) [self->codePoint_ appendWithInt:dotsize];
    (void) [self->codePoint_ appendWithNSString:@"pt 0"];
  }
  if (dotstyle != OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_CIRCLE) {
    if (coma) (void) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@","];
    if (!bracket) (void) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"["];
    coma = YES;
    bracket = YES;
    (void) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"dotstyle="];
    switch (dotstyle) {
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_CROSS:
      (void) [self->codePoint_ appendWithNSString:@"x"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_DOT:
      (void) [self->codePoint_ appendWithNSString:@"*"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_EMPTY_DIAMOND:
      (void) [self->codePoint_ appendWithNSString:@"square,dotangle=45"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_FILLED_DIAMOND:
      (void) [self->codePoint_ appendWithNSString:@"square*,dotangle=45"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_PLUS:
      (void) [self->codePoint_ appendWithNSString:@"+"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_EAST:
      (void) [self->codePoint_ appendWithNSString:@"triangle*,dotangle=270"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_NORTH:
      (void) [self->codePoint_ appendWithNSString:@"triangle*"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_SOUTH:
      (void) [self->codePoint_ appendWithNSString:@"triangle*,dotangle=180"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_POINT_STYLE_TRIANGLE_WEST:
      (void) [self->codePoint_ appendWithNSString:@"triangle*,dotangle=90"];
      break;
      default:
      (void) [self->codePoint_ appendWithNSString:@"*"];
      break;
    }
  }
  if (![((OrgGeogebraCommonAwtGColor *) nil_chk(dotcolor)) isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
    if (coma) (void) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@","];
    if (!bracket) (void) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"["];
    bracket = YES;
    (void) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"linecolor="];
    [self ColorCodeWithOrgGeogebraCommonAwtGColor:dotcolor withJavaLangStringBuilder:self->codePoint_];
  }
  if (bracket) (void) [((JavaLangStringBuilder *) nil_chk(self->codePoint_)) appendWithNSString:@"]"];
}

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_LinestyleCodeWithInt_withJavaLangStringBuilder_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, jint linestyle, JavaLangStringBuilder *sb) {
  {
    jint size;
    jint size1;
    jint size2;
    jint size3;
    switch (linestyle) {
      case OrgGeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DOTTED:
      (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"linestyle=dotted"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_SHORT:
      (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"linestyle=dashed,dash="];
      size = [self resizePtWithInt:4];
      (void) [sb appendWithInt:size];
      (void) [sb appendWithNSString:@"pt "];
      (void) [sb appendWithInt:size];
      (void) [sb appendWithNSString:@"pt"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_LONG:
      (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"linestyle=dashed,dash="];
      size = [self resizePtWithInt:8];
      (void) [sb appendWithInt:size];
      (void) [sb appendWithNSString:@"pt "];
      (void) [sb appendWithInt:size];
      (void) [sb appendWithNSString:@"pt"];
      break;
      case OrgGeogebraCommonPluginEuclidianStyleConstants_LINE_TYPE_DASHED_DOTTED:
      (void) [((JavaLangStringBuilder *) nil_chk(sb)) appendWithNSString:@"linestyle=dashed,dash="];
      size1 = [self resizePtWithInt:1];
      size2 = [self resizePtWithInt:4];
      size3 = [self resizePtWithInt:8];
      (void) [sb appendWithInt:size1];
      (void) [sb appendWithNSString:@"pt "];
      (void) [sb appendWithInt:size2];
      (void) [sb appendWithNSString:@"pt "];
      (void) [sb appendWithInt:size3];
      (void) [sb appendWithNSString:@"pt "];
      (void) [sb appendWithInt:size2];
      (void) [sb appendWithNSString:@"pt "];
      break;
    }
  }
}

void OrgGeogebraCommonExportPstricksGeoGebraToPstricks_addTextWithNSString_withBoolean_withInt_withOrgGeogebraCommonAwtGColor_(OrgGeogebraCommonExportPstricksGeoGebraToPstricks *self, NSString *st, jboolean isLatex, jint style, OrgGeogebraCommonAwtGColor *geocolor) {
  if (isLatex) {
    if (![((NSString *) nil_chk(st)) hasPrefix:@"$"]) (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"$"];
    NSString *stSym = st;
    for (jint i = 0; i < ((jint) [st length]); i++) {
      NSString *uCode = JreStrcat("C", [st charAtWithInt:i]);
      if ([((JavaUtilHashMap *) nil_chk(OrgGeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
        [self addTextPackage];
        stSym = [stSym replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$C", @"\\\\", [((JavaUtilHashMap *) nil_chk(OrgGeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode], ' ')];
      }
    }
    st = stSym;
  }
  else {
    st = [((NSString *) nil_chk(st)) replaceAll:@"\\\\" withReplacement:@"\\\\textbackslash "];
    NSString *stSym = st;
    for (jint i = 0; i < ((jint) [((NSString *) nil_chk(st)) length]); i++) {
      NSString *uCode = JreStrcat("C", [st charAtWithInt:i]);
      if ([((JavaUtilHashMap *) nil_chk(OrgGeogebraCommonExportPstricksUnicodeTeX_getMap())) containsKeyWithId:uCode]) {
        [self addTextPackage];
        stSym = [((NSString *) nil_chk(stSym)) replaceAll:JreStrcat("C$", '\\', uCode) withReplacement:JreStrcat("$$$", @"\\$\\\\", [((JavaUtilHashMap *) nil_chk(OrgGeogebraCommonExportPstricksUnicodeTeX_getMap())) getWithId:uCode], @"\\$ ")];
      }
    }
    st = stSym;
    if (!self->eurosym_ && [((NSString *) nil_chk(st)) contains:@"$\\euro$"]) {
      (void) [((JavaLangStringBuilder *) nil_chk(self->codePreamble_)) appendWithNSString:@"\\usepackage{eurosym}\n"];
      st = [st replace:@"$\\euro$" withSequence:@"\\euro"];
    }
  }
  switch (style) {
    case 1:
    if (isLatex) (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathbf{"];
    else (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textbf{"];
    break;
    case 2:
    if (isLatex) (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathit{"];
    else (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textit{"];
    break;
    case 3:
    if (isLatex) (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\mathit{\\mathbf{"];
    else (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\textit{\\textbf{"];
    break;
  }
  if (![((OrgGeogebraCommonAwtGColor *) nil_chk(geocolor)) isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
    (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:@"\\"];
    [self ColorCodeWithOrgGeogebraCommonAwtGColor:geocolor withJavaLangStringBuilder:self->code_];
    (void) [self->code_ appendWithNSString:@"{"];
  }
  (void) [((JavaLangStringBuilder *) nil_chk(self->code_)) appendWithNSString:st];
  if (![geocolor isEqual:OrgGeogebraCommonAwtGColor_get_BLACK_()]) {
    (void) [self->code_ appendWithNSString:@"}"];
  }
  switch (style) {
    case 1:
    case 2:
    (void) [self->code_ appendWithNSString:@"}"];
    break;
    case 3:
    (void) [self->code_ appendWithNSString:@"}}"];
    break;
  }
  if (isLatex && ![((NSString *) nil_chk(st)) hasSuffix:@"$"]) (void) [self->code_ appendWithNSString:@"$"];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgGeogebraCommonExportPstricksGeoGebraToPstricks)
