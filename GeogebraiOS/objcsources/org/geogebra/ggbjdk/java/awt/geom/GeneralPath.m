//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeogebraiOS/GeogebraiOS/sources/org/geogebra/ggbjdk/java/awt/geom/GeneralPath.java
//


#include "IOSClass.h"
#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/System.h"
#include "org/geogebra/common/awt/GAffineTransform.h"
#include "org/geogebra/common/awt/GPathIterator.h"
#include "org/geogebra/common/awt/GPoint2D.h"
#include "org/geogebra/common/awt/GRectangle.h"
#include "org/geogebra/common/awt/GRectangle2D.h"
#include "org/geogebra/common/awt/GShape.h"
#include "org/geogebra/ggbjdk/java/awt/geom/GeneralPath.h"
#include "org/geogebra/ggbjdk/java/awt/geom/GeneralPathIterator.h"
#include "org/geogebra/ggbjdk/java/awt/geom/IllegalPathStateException.h"
#include "org/geogebra/ggbjdk/java/awt/geom/PathIterator.h"
#include "org/geogebra/ggbjdk/java/awt/geom/Point2D.h"
#include "org/geogebra/ggbjdk/java/awt/geom/Rectangle2D.h"
#include "org/geogebra/ggbjdk/java/awt/geom/Shape.h"
#include "org/geogebra/ggbjdk/sun/awt/geom/Crossings.h"
#include "org/geogebra/ggbjdk/sun/awt/geom/Curve.h"

#define OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_MOVETO 0
#define OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_LINETO 1
#define OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_QUADTO 2
#define OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CUBICTO 3
#define OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CLOSE 4

@interface OrgGeogebraGgbjdkJavaAwtGeomGeneralPath ()

- (void)needRoomWithInt:(jint)newTypes
                withInt:(jint)newCoords
            withBoolean:(jboolean)needMove;

@end

J2OBJC_STATIC_FIELD_GETTER(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath, SEG_MOVETO, jbyte)

J2OBJC_STATIC_FIELD_GETTER(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath, SEG_LINETO, jbyte)

J2OBJC_STATIC_FIELD_GETTER(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath, SEG_QUADTO, jbyte)

J2OBJC_STATIC_FIELD_GETTER(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath, SEG_CUBICTO, jbyte)

J2OBJC_STATIC_FIELD_GETTER(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath, SEG_CLOSE, jbyte)

__attribute__((unused)) static void OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_needRoomWithInt_withInt_withBoolean_(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self, jint newTypes, jint newCoords, jboolean needMove);

@implementation OrgGeogebraGgbjdkJavaAwtGeomGeneralPath

- (instancetype)init {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_init(self);
  return self;
}

- (instancetype)initWithInt:(jint)rule {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_(self, rule);
  return self;
}

- (instancetype)initWithInt:(jint)rule
                    withInt:(jint)initialCapacity {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_(self, rule, initialCapacity);
  return self;
}

- (instancetype)initWithOrgGeogebraGgbjdkJavaAwtGeomShape:(id<OrgGeogebraGgbjdkJavaAwtGeomShape>)s {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithOrgGeogebraGgbjdkJavaAwtGeomShape_(self, s);
  return self;
}

- (instancetype)initWithInt:(jint)windingRule
              withByteArray:(IOSByteArray *)pointTypes
                    withInt:(jint)numTypes
             withFloatArray:(IOSFloatArray *)pointCoords
                    withInt:(jint)numCoords {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withByteArray_withInt_withFloatArray_withInt_(self, windingRule, pointTypes, numTypes, pointCoords, numCoords);
  return self;
}

- (instancetype)initWithInt:(jint)rule
                    withInt:(jint)initialTypes
                    withInt:(jint)initialCoords {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_withInt_(self, rule, initialTypes, initialCoords);
  return self;
}

- (void)appendWithOrgGeogebraCommonAwtGPathIterator:(id<OrgGeogebraCommonAwtGPathIterator>)pi
                                        withBoolean:(jboolean)connect {
  IOSFloatArray *coords = [IOSFloatArray arrayWithLength:6];
  while (![((id<OrgGeogebraCommonAwtGPathIterator>) nil_chk(pi)) isDone]) {
    switch ([pi currentSegmentWithFloatArray:coords]) {
      case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_MOVETO:
      if (!connect || numTypes_ < 1 || numCoords_ < 2) {
        [self moveToWithFloat:IOSFloatArray_Get(coords, 0) withFloat:IOSFloatArray_Get(coords, 1)];
        break;
      }
      if (IOSByteArray_Get(nil_chk(pointTypes_), numTypes_ - 1) != OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CLOSE && IOSFloatArray_Get(nil_chk(pointCoords_), numCoords_ - 2) == IOSFloatArray_Get(coords, 0) && IOSFloatArray_Get(pointCoords_, numCoords_ - 1) == IOSFloatArray_Get(coords, 1)) {
        break;
      }
      case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_LINETO:
      [self lineToWithFloat:IOSFloatArray_Get(coords, 0) withFloat:IOSFloatArray_Get(coords, 1)];
      break;
      case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_QUADTO:
      [self quadToWithFloat:IOSFloatArray_Get(coords, 0) withFloat:IOSFloatArray_Get(coords, 1) withFloat:IOSFloatArray_Get(coords, 2) withFloat:IOSFloatArray_Get(coords, 3)];
      break;
      case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CUBICTO:
      [self curveToWithFloat:IOSFloatArray_Get(coords, 0) withFloat:IOSFloatArray_Get(coords, 1) withFloat:IOSFloatArray_Get(coords, 2) withFloat:IOSFloatArray_Get(coords, 3) withFloat:IOSFloatArray_Get(coords, 4) withFloat:IOSFloatArray_Get(coords, 5)];
      break;
      case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CLOSE:
      [self closePath];
      break;
    }
    [pi next];
    connect = NO;
  }
}

- (void)appendWithOrgGeogebraCommonAwtGShape:(id<OrgGeogebraCommonAwtGShape>)s
                                 withBoolean:(jboolean)connect {
  id<OrgGeogebraCommonAwtGPathIterator> pi = [((id<OrgGeogebraCommonAwtGShape>) nil_chk(s)) getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:nil];
  [self appendWithOrgGeogebraCommonAwtGPathIterator:pi withBoolean:connect];
}

- (id)clone {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *clone = [new_OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithOrgGeogebraGgbjdkJavaAwtGeomShape_(self) autorelease];
  return clone;
}

- (void)closePath {
  if (numTypes_ == 0 || IOSByteArray_Get(nil_chk(pointTypes_), numTypes_ - 1) != OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CLOSE) {
    OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_needRoomWithInt_withInt_withBoolean_(self, 1, 0, YES);
    *IOSByteArray_GetRef(nil_chk(pointTypes_), numTypes_++) = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CLOSE;
  }
}

- (jboolean)containsWithDouble:(jdouble)x
                    withDouble:(jdouble)y {
  if (numTypes_ < 2) {
    return NO;
  }
  jint cross = OrgGeogebraGgbjdkSunAwtGeomCurve_crossingsForPathWithOrgGeogebraGgbjdkJavaAwtGeomPathIterator_withDouble_withDouble_([self getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:nil], x, y);
  if (windingRule_ == OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_WIND_NON_ZERO) {
    return (cross != 0);
  }
  else {
    return ((cross & 1) != 0);
  }
}

- (jboolean)containsWithInt:(jint)x
                    withInt:(jint)y {
  if (numTypes_ < 2) {
    return NO;
  }
  jint cross = OrgGeogebraGgbjdkSunAwtGeomCurve_crossingsForPathWithOrgGeogebraGgbjdkJavaAwtGeomPathIterator_withDouble_withDouble_([self getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:nil], x, y);
  if (windingRule_ == OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_WIND_NON_ZERO) {
    return (cross != 0);
  }
  else {
    return ((cross & 1) != 0);
  }
}

- (jboolean)containsWithDouble:(jdouble)x
                    withDouble:(jdouble)y
                    withDouble:(jdouble)w
                    withDouble:(jdouble)h {
  OrgGeogebraGgbjdkSunAwtGeomCrossings *c = OrgGeogebraGgbjdkSunAwtGeomCrossings_findCrossingsWithOrgGeogebraGgbjdkJavaAwtGeomPathIterator_withDouble_withDouble_withDouble_withDouble_([self getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:nil], x, y, x + w, y + h);
  return (c != nil && [c coversWithDouble:y withDouble:y + h]);
}

- (jboolean)containsWithOrgGeogebraCommonAwtGPoint2D:(OrgGeogebraCommonAwtGPoint2D *)p {
  return [self containsWithDouble:[((OrgGeogebraCommonAwtGPoint2D *) nil_chk(p)) getX] withDouble:[p getY]];
}

- (jboolean)containsWithOrgGeogebraCommonAwtGRectangle2D:(id<OrgGeogebraCommonAwtGRectangle2D>)r {
  return [self containsWithDouble:[((id<OrgGeogebraCommonAwtGRectangle2D>) nil_chk(r)) getX] withDouble:[r getY] withDouble:[r getWidth] withDouble:[r getHeight]];
}

- (id<OrgGeogebraGgbjdkJavaAwtGeomShape>)createTransformedShapeWithOrgGeogebraCommonAwtGAffineTransform:(id<OrgGeogebraCommonAwtGAffineTransform>)at {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *gp = (OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *) check_class_cast([self clone], [OrgGeogebraGgbjdkJavaAwtGeomGeneralPath class]);
  if (at != nil) {
    [((OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *) nil_chk(gp)) transformWithOrgGeogebraCommonAwtGAffineTransform:at];
  }
  return gp;
}

- (void)curveToWithFloat:(jfloat)x1
               withFloat:(jfloat)y1
               withFloat:(jfloat)x2
               withFloat:(jfloat)y2
               withFloat:(jfloat)x3
               withFloat:(jfloat)y3 {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_needRoomWithInt_withInt_withBoolean_(self, 1, 6, YES);
  *IOSByteArray_GetRef(nil_chk(pointTypes_), numTypes_++) = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CUBICTO;
  *IOSFloatArray_GetRef(nil_chk(pointCoords_), numCoords_++) = x1;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = y1;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = x2;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = y2;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = x3;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = y3;
}

- (id<OrgGeogebraCommonAwtGRectangle>)getBounds {
  return [((OrgGeogebraGgbjdkJavaAwtGeomRectangle2D *) nil_chk([self getBounds2D])) getBounds];
}

- (OrgGeogebraGgbjdkJavaAwtGeomRectangle2D *)getBounds2D {
  jfloat x1, y1, x2, y2;
  jint i = numCoords_;
  if (i > 0) {
    y1 = y2 = IOSFloatArray_Get(nil_chk(pointCoords_), --i);
    x1 = x2 = IOSFloatArray_Get(pointCoords_, --i);
    while (i > 0) {
      jfloat y = IOSFloatArray_Get(pointCoords_, --i);
      jfloat x = IOSFloatArray_Get(pointCoords_, --i);
      if (x < x1) x1 = x;
      if (y < y1) y1 = y;
      if (x > x2) x2 = x;
      if (y > y2) y2 = y;
    }
  }
  else {
    x1 = y1 = x2 = y2 = 0.0f;
  }
  return [new_OrgGeogebraGgbjdkJavaAwtGeomRectangle2D_Float_initWithFloat_withFloat_withFloat_withFloat_(x1, y1, x2 - x1, y2 - y1) autorelease];
}

- (OrgGeogebraGgbjdkJavaAwtGeomPoint2D *)getCurrentPoint {
  if (numTypes_ < 1 || numCoords_ < 2) {
    return nil;
  }
  jint index = numCoords_;
  if (IOSByteArray_Get(nil_chk(pointTypes_), numTypes_ - 1) == OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CLOSE) {
    for (jint i = numTypes_ - 2; i > 0; i--) {
      switch (IOSByteArray_Get(pointTypes_, i)) {
        case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_MOVETO:
        goto break_loop;
        case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_LINETO:
        index -= 2;
        break;
        case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_QUADTO:
        index -= 4;
        break;
        case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CUBICTO:
        index -= 6;
        break;
        case OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CLOSE:
        break;
      }
    }
    break_loop: ;
  }
  return [new_OrgGeogebraGgbjdkJavaAwtGeomPoint2D_Float_initWithFloat_withFloat_(IOSFloatArray_Get(nil_chk(pointCoords_), index - 2), IOSFloatArray_Get(pointCoords_, index - 1)) autorelease];
}

- (id<OrgGeogebraGgbjdkJavaAwtGeomPathIterator>)getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:(id<OrgGeogebraCommonAwtGAffineTransform>)at {
  return [new_OrgGeogebraGgbjdkJavaAwtGeomGeneralPathIterator_initWithOrgGeogebraGgbjdkJavaAwtGeomGeneralPath_withOrgGeogebraCommonAwtGAffineTransform_(self, at) autorelease];
}

- (jint)getWindingRule {
  return windingRule_;
}

- (jboolean)intersectsWithDouble:(jdouble)x
                      withDouble:(jdouble)y
                      withDouble:(jdouble)w
                      withDouble:(jdouble)h {
  OrgGeogebraGgbjdkSunAwtGeomCrossings *c = OrgGeogebraGgbjdkSunAwtGeomCrossings_findCrossingsWithOrgGeogebraGgbjdkJavaAwtGeomPathIterator_withDouble_withDouble_withDouble_withDouble_([self getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:nil], x, y, x + w, y + h);
  return (c == nil || ![c isEmpty]);
}

- (jboolean)intersectsWithInt:(jint)x
                      withInt:(jint)y
                      withInt:(jint)w
                      withInt:(jint)h {
  OrgGeogebraGgbjdkSunAwtGeomCrossings *c = OrgGeogebraGgbjdkSunAwtGeomCrossings_findCrossingsWithOrgGeogebraGgbjdkJavaAwtGeomPathIterator_withDouble_withDouble_withDouble_withDouble_([self getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:nil], x, y, x + w, y + h);
  return (c == nil || ![c isEmpty]);
}

- (jboolean)intersectsWithOrgGeogebraCommonAwtGRectangle2D:(id<OrgGeogebraCommonAwtGRectangle2D>)r {
  return [self intersectsWithDouble:[((id<OrgGeogebraCommonAwtGRectangle2D>) nil_chk(r)) getX] withDouble:[r getY] withDouble:[r getWidth] withDouble:[r getHeight]];
}

- (void)lineToWithFloat:(jfloat)x
              withFloat:(jfloat)y {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_needRoomWithInt_withInt_withBoolean_(self, 1, 2, YES);
  *IOSByteArray_GetRef(nil_chk(pointTypes_), numTypes_++) = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_LINETO;
  *IOSFloatArray_GetRef(nil_chk(pointCoords_), numCoords_++) = x;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = y;
}

- (void)moveToWithFloat:(jfloat)x
              withFloat:(jfloat)y {
  if (numTypes_ > 0 && IOSByteArray_Get(nil_chk(pointTypes_), numTypes_ - 1) == OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_MOVETO) {
    *IOSFloatArray_GetRef(nil_chk(pointCoords_), numCoords_ - 2) = x;
    *IOSFloatArray_GetRef(pointCoords_, numCoords_ - 1) = y;
  }
  else {
    OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_needRoomWithInt_withInt_withBoolean_(self, 1, 2, NO);
    *IOSByteArray_GetRef(nil_chk(pointTypes_), numTypes_++) = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_MOVETO;
    *IOSFloatArray_GetRef(nil_chk(pointCoords_), numCoords_++) = x;
    *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = y;
  }
}

- (void)quadToWithFloat:(jfloat)x1
              withFloat:(jfloat)y1
              withFloat:(jfloat)x2
              withFloat:(jfloat)y2 {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_needRoomWithInt_withInt_withBoolean_(self, 1, 4, YES);
  *IOSByteArray_GetRef(nil_chk(pointTypes_), numTypes_++) = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_QUADTO;
  *IOSFloatArray_GetRef(nil_chk(pointCoords_), numCoords_++) = x1;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = y1;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = x2;
  *IOSFloatArray_GetRef(pointCoords_, numCoords_++) = y2;
}

- (void)reset {
  numTypes_ = numCoords_ = 0;
}

- (void)setWindingRuleWithInt:(jint)rule {
  if (rule != OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_WIND_EVEN_ODD && rule != OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_WIND_NON_ZERO) {
    @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"winding rule must be WIND_EVEN_ODD or WIND_NON_ZERO") autorelease];
  }
  windingRule_ = rule;
}

- (void)transformWithOrgGeogebraCommonAwtGAffineTransform:(id<OrgGeogebraCommonAwtGAffineTransform>)at {
  [((id<OrgGeogebraCommonAwtGAffineTransform>) nil_chk(at)) transformWithFloatArray:pointCoords_ withInt:0 withFloatArray:pointCoords_ withInt:0 withInt:numCoords_ / 2];
}

- (void)needRoomWithInt:(jint)newTypes
                withInt:(jint)newCoords
            withBoolean:(jboolean)needMove {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_needRoomWithInt_withInt_withBoolean_(self, newTypes, newCoords, needMove);
}

- (void)dealloc {
  RELEASE_(pointTypes_);
  RELEASE_(pointCoords_);
  [super dealloc];
}

- (id)copyWithZone:(NSZone *)zone {
  return [[self clone] retain];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "GeneralPath", NULL, 0x1, NULL, NULL },
    { "initWithInt:", "GeneralPath", NULL, 0x1, NULL, NULL },
    { "initWithInt:withInt:", "GeneralPath", NULL, 0x1, NULL, NULL },
    { "initWithOrgGeogebraGgbjdkJavaAwtGeomShape:", "GeneralPath", NULL, 0x1, NULL, NULL },
    { "initWithInt:withByteArray:withInt:withFloatArray:withInt:", "GeneralPath", NULL, 0x0, NULL, NULL },
    { "initWithInt:withInt:withInt:", "GeneralPath", NULL, 0x0, NULL, NULL },
    { "appendWithOrgGeogebraCommonAwtGPathIterator:withBoolean:", "append", "V", 0x1, NULL, NULL },
    { "appendWithOrgGeogebraCommonAwtGShape:withBoolean:", "append", "V", 0x1, NULL, NULL },
    { "clone", NULL, "Ljava.lang.Object;", 0x1, NULL, NULL },
    { "closePath", NULL, "V", 0x1, NULL, NULL },
    { "containsWithDouble:withDouble:", "contains", "Z", 0x1, NULL, NULL },
    { "containsWithInt:withInt:", "contains", "Z", 0x1, NULL, NULL },
    { "containsWithDouble:withDouble:withDouble:withDouble:", "contains", "Z", 0x1, NULL, NULL },
    { "containsWithOrgGeogebraCommonAwtGPoint2D:", "contains", "Z", 0x1, NULL, NULL },
    { "containsWithOrgGeogebraCommonAwtGRectangle2D:", "contains", "Z", 0x1, NULL, NULL },
    { "createTransformedShapeWithOrgGeogebraCommonAwtGAffineTransform:", "createTransformedShape", "Lorg.geogebra.ggbjdk.java.awt.geom.Shape;", 0x1, NULL, NULL },
    { "curveToWithFloat:withFloat:withFloat:withFloat:withFloat:withFloat:", "curveTo", "V", 0x1, NULL, NULL },
    { "getBounds", NULL, "Lorg.geogebra.common.awt.GRectangle;", 0x1, NULL, NULL },
    { "getBounds2D", NULL, "Lorg.geogebra.ggbjdk.java.awt.geom.Rectangle2D;", 0x1, NULL, NULL },
    { "getCurrentPoint", NULL, "Lorg.geogebra.ggbjdk.java.awt.geom.Point2D;", 0x1, NULL, NULL },
    { "getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:", "getPathIterator", "Lorg.geogebra.ggbjdk.java.awt.geom.PathIterator;", 0x1, NULL, NULL },
    { "getWindingRule", NULL, "I", 0x1, NULL, NULL },
    { "intersectsWithDouble:withDouble:withDouble:withDouble:", "intersects", "Z", 0x1, NULL, NULL },
    { "intersectsWithInt:withInt:withInt:withInt:", "intersects", "Z", 0x1, NULL, NULL },
    { "intersectsWithOrgGeogebraCommonAwtGRectangle2D:", "intersects", "Z", 0x1, NULL, NULL },
    { "lineToWithFloat:withFloat:", "lineTo", "V", 0x1, NULL, NULL },
    { "moveToWithFloat:withFloat:", "moveTo", "V", 0x1, NULL, NULL },
    { "quadToWithFloat:withFloat:withFloat:withFloat:", "quadTo", "V", 0x1, NULL, NULL },
    { "reset", NULL, "V", 0x1, NULL, NULL },
    { "setWindingRuleWithInt:", "setWindingRule", "V", 0x1, NULL, NULL },
    { "transformWithOrgGeogebraCommonAwtGAffineTransform:", "transform", "V", 0x1, NULL, NULL },
    { "needRoomWithInt:withInt:withBoolean:", "needRoom", "V", 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "WIND_EVEN_ODD_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_WIND_EVEN_ODD },
    { "WIND_NON_ZERO_", NULL, 0x19, "I", NULL, NULL, .constantValue.asInt = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_WIND_NON_ZERO },
    { "SEG_MOVETO_", NULL, 0x1a, "B", NULL, NULL, .constantValue.asChar = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_MOVETO },
    { "SEG_LINETO_", NULL, 0x1a, "B", NULL, NULL, .constantValue.asChar = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_LINETO },
    { "SEG_QUADTO_", NULL, 0x1a, "B", NULL, NULL, .constantValue.asChar = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_QUADTO },
    { "SEG_CUBICTO_", NULL, 0x1a, "B", NULL, NULL, .constantValue.asChar = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CUBICTO },
    { "SEG_CLOSE_", NULL, 0x1a, "B", NULL, NULL, .constantValue.asChar = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_SEG_CLOSE },
    { "pointTypes_", NULL, 0x0, "[B", NULL, NULL,  },
    { "pointCoords_", NULL, 0x0, "[F", NULL, NULL,  },
    { "numTypes_", NULL, 0x0, "I", NULL, NULL,  },
    { "numCoords_", NULL, 0x0, "I", NULL, NULL,  },
    { "windingRule_", NULL, 0x0, "I", NULL, NULL,  },
    { "INIT_SIZE_", NULL, 0x18, "I", NULL, NULL, .constantValue.asInt = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_INIT_SIZE },
    { "EXPAND_MAX_", NULL, 0x18, "I", NULL, NULL, .constantValue.asInt = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_EXPAND_MAX },
  };
  static const J2ObjcClassInfo _OrgGeogebraGgbjdkJavaAwtGeomGeneralPath = { 2, "GeneralPath", "org.geogebra.ggbjdk.java.awt.geom", NULL, 0x11, 32, methods, 14, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgGeogebraGgbjdkJavaAwtGeomGeneralPath;
}

@end

void OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_init(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_withInt_(self, OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_WIND_NON_ZERO, OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_INIT_SIZE, OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_INIT_SIZE);
}

OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *new_OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_init() {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self = [OrgGeogebraGgbjdkJavaAwtGeomGeneralPath alloc];
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_init(self);
  return self;
}

void OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self, jint rule) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_withInt_(self, rule, OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_INIT_SIZE, OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_INIT_SIZE);
}

OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *new_OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_(jint rule) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self = [OrgGeogebraGgbjdkJavaAwtGeomGeneralPath alloc];
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_(self, rule);
  return self;
}

void OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self, jint rule, jint initialCapacity) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_withInt_(self, rule, initialCapacity, initialCapacity);
}

OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *new_OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_(jint rule, jint initialCapacity) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self = [OrgGeogebraGgbjdkJavaAwtGeomGeneralPath alloc];
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_(self, rule, initialCapacity);
  return self;
}

void OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithOrgGeogebraGgbjdkJavaAwtGeomShape_(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self, id<OrgGeogebraGgbjdkJavaAwtGeomShape> s) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_withInt_(self, OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_WIND_NON_ZERO, OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_INIT_SIZE, OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_INIT_SIZE);
  id<OrgGeogebraGgbjdkJavaAwtGeomPathIterator> pi = [((id<OrgGeogebraGgbjdkJavaAwtGeomShape>) nil_chk(s)) getPathIteratorWithOrgGeogebraCommonAwtGAffineTransform:nil];
  [self setWindingRuleWithInt:[((id<OrgGeogebraGgbjdkJavaAwtGeomPathIterator>) nil_chk(pi)) getWindingRule]];
  [self appendWithOrgGeogebraCommonAwtGPathIterator:pi withBoolean:NO];
}

OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *new_OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithOrgGeogebraGgbjdkJavaAwtGeomShape_(id<OrgGeogebraGgbjdkJavaAwtGeomShape> s) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self = [OrgGeogebraGgbjdkJavaAwtGeomGeneralPath alloc];
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithOrgGeogebraGgbjdkJavaAwtGeomShape_(self, s);
  return self;
}

void OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withByteArray_withInt_withFloatArray_withInt_(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self, jint windingRule, IOSByteArray *pointTypes, jint numTypes, IOSFloatArray *pointCoords, jint numCoords) {
  NSObject_init(self);
  self->windingRule_ = windingRule;
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_set_pointTypes_(self, pointTypes);
  self->numTypes_ = numTypes;
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_set_pointCoords_(self, pointCoords);
  self->numCoords_ = numCoords;
}

OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *new_OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withByteArray_withInt_withFloatArray_withInt_(jint windingRule, IOSByteArray *pointTypes, jint numTypes, IOSFloatArray *pointCoords, jint numCoords) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self = [OrgGeogebraGgbjdkJavaAwtGeomGeneralPath alloc];
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withByteArray_withInt_withFloatArray_withInt_(self, windingRule, pointTypes, numTypes, pointCoords, numCoords);
  return self;
}

void OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_withInt_(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self, jint rule, jint initialTypes, jint initialCoords) {
  NSObject_init(self);
  [self setWindingRuleWithInt:rule];
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_setAndConsume_pointTypes_(self, [IOSByteArray newArrayWithLength:initialTypes]);
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_setAndConsume_pointCoords_(self, [IOSFloatArray newArrayWithLength:initialCoords * 2]);
}

OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *new_OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_withInt_(jint rule, jint initialTypes, jint initialCoords) {
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self = [OrgGeogebraGgbjdkJavaAwtGeomGeneralPath alloc];
  OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_initWithInt_withInt_withInt_(self, rule, initialTypes, initialCoords);
  return self;
}

void OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_needRoomWithInt_withInt_withBoolean_(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath *self, jint newTypes, jint newCoords, jboolean needMove) {
  if (needMove && self->numTypes_ == 0) {
    @throw [new_OrgGeogebraGgbjdkJavaAwtGeomIllegalPathStateException_initWithNSString_(@"missing initial moveto in path definition") autorelease];
  }
  jint size = ((IOSFloatArray *) nil_chk(self->pointCoords_))->size_;
  if (self->numCoords_ + newCoords > size) {
    jint grow = size;
    if (grow > OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_EXPAND_MAX * 2) {
      grow = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_EXPAND_MAX * 2;
    }
    if (grow < newCoords) {
      grow = newCoords;
    }
    IOSFloatArray *arr = [IOSFloatArray arrayWithLength:size + grow];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->pointCoords_, 0, arr, 0, self->numCoords_);
    OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_set_pointCoords_(self, arr);
  }
  size = ((IOSByteArray *) nil_chk(self->pointTypes_))->size_;
  if (self->numTypes_ + newTypes > size) {
    jint grow = size;
    if (grow > OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_EXPAND_MAX) {
      grow = OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_EXPAND_MAX;
    }
    if (grow < newTypes) {
      grow = newTypes;
    }
    IOSByteArray *arr = [IOSByteArray arrayWithLength:size + grow];
    JavaLangSystem_arraycopyWithId_withInt_withId_withInt_withInt_(self->pointTypes_, 0, arr, 0, self->numTypes_);
    OrgGeogebraGgbjdkJavaAwtGeomGeneralPath_set_pointTypes_(self, arr);
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgGeogebraGgbjdkJavaAwtGeomGeneralPath)
