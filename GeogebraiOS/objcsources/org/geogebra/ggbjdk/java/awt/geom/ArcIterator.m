//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeoGebraiOSARC/GeoGebraiOSARC/javasources/org/geogebra/ggbjdk/java/awt/geom/ArcIterator.java
//


#include "IOSPrimitiveArray.h"
#include "J2ObjC_source.h"
#include "java/lang/Math.h"
#include "java/util/NoSuchElementException.h"
#include "org/geogebra/common/awt/GAffineTransform.h"
#include "org/geogebra/ggbjdk/java/awt/geom/Arc2D.h"
#include "org/geogebra/ggbjdk/java/awt/geom/ArcIterator.h"
#include "org/geogebra/ggbjdk/java/awt/geom/PathIterator.h"

@interface OrgGeogebraGgbjdkJavaAwtGeomArcIterator ()

+ (jdouble)btanWithDouble:(jdouble)increment;

@end

__attribute__((unused)) static jdouble OrgGeogebraGgbjdkJavaAwtGeomArcIterator_btanWithDouble_(jdouble increment);

@implementation OrgGeogebraGgbjdkJavaAwtGeomArcIterator

- (instancetype)initWithOrgGeogebraGgbjdkJavaAwtGeomArc2D:(OrgGeogebraGgbjdkJavaAwtGeomArc2D *)a
                 withOrgGeogebraCommonAwtGAffineTransform:(id<OrgGeogebraCommonAwtGAffineTransform>)at {
  OrgGeogebraGgbjdkJavaAwtGeomArcIterator_initWithOrgGeogebraGgbjdkJavaAwtGeomArc2D_withOrgGeogebraCommonAwtGAffineTransform_(self, a, at);
  return self;
}

- (jint)getWindingRule {
  return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_WIND_NON_ZERO;
}

- (jboolean)isDone {
  return index_ > arcSegs_ + lineSegs_;
}

- (void)next {
  index_++;
}

+ (jdouble)btanWithDouble:(jdouble)increment {
  return OrgGeogebraGgbjdkJavaAwtGeomArcIterator_btanWithDouble_(increment);
}

- (jint)currentSegmentWithFloatArray:(IOSFloatArray *)coords {
  if ([self isDone]) {
    @throw new_JavaUtilNoSuchElementException_initWithNSString_(@"arc iterator out of bounds");
  }
  jdouble angle = angStRad_;
  if (index_ == 0) {
    *IOSFloatArray_GetRef(nil_chk(coords), 0) = (jfloat) (x_ + JavaLangMath_cosWithDouble_(angle) * w_);
    *IOSFloatArray_GetRef(coords, 1) = (jfloat) (y_ + JavaLangMath_sinWithDouble_(angle) * h_);
    if (affine_ != nil) {
      [affine_ transformWithFloatArray:coords withInt:0 withFloatArray:coords withInt:0 withInt:1];
    }
    return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_SEG_MOVETO;
  }
  if (index_ > arcSegs_) {
    if (index_ == arcSegs_ + lineSegs_) {
      return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_SEG_CLOSE;
    }
    *IOSFloatArray_GetRef(nil_chk(coords), 0) = (jfloat) x_;
    *IOSFloatArray_GetRef(coords, 1) = (jfloat) y_;
    if (affine_ != nil) {
      [affine_ transformWithFloatArray:coords withInt:0 withFloatArray:coords withInt:0 withInt:1];
    }
    return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_SEG_LINETO;
  }
  angle += increment_ * (index_ - 1);
  jdouble relx = JavaLangMath_cosWithDouble_(angle);
  jdouble rely = JavaLangMath_sinWithDouble_(angle);
  *IOSFloatArray_GetRef(nil_chk(coords), 0) = (jfloat) (x_ + (relx - cv_ * rely) * w_);
  *IOSFloatArray_GetRef(coords, 1) = (jfloat) (y_ + (rely + cv_ * relx) * h_);
  angle += increment_;
  relx = JavaLangMath_cosWithDouble_(angle);
  rely = JavaLangMath_sinWithDouble_(angle);
  *IOSFloatArray_GetRef(coords, 2) = (jfloat) (x_ + (relx + cv_ * rely) * w_);
  *IOSFloatArray_GetRef(coords, 3) = (jfloat) (y_ + (rely - cv_ * relx) * h_);
  *IOSFloatArray_GetRef(coords, 4) = (jfloat) (x_ + relx * w_);
  *IOSFloatArray_GetRef(coords, 5) = (jfloat) (y_ + rely * h_);
  if (affine_ != nil) {
    [affine_ transformWithFloatArray:coords withInt:0 withFloatArray:coords withInt:0 withInt:3];
  }
  return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_SEG_CUBICTO;
}

- (jint)currentSegmentWithDoubleArray:(IOSDoubleArray *)coords {
  if ([self isDone]) {
    @throw new_JavaUtilNoSuchElementException_initWithNSString_(@"arc iterator out of bounds");
  }
  jdouble angle = angStRad_;
  if (index_ == 0) {
    *IOSDoubleArray_GetRef(nil_chk(coords), 0) = x_ + JavaLangMath_cosWithDouble_(angle) * w_;
    *IOSDoubleArray_GetRef(coords, 1) = y_ + JavaLangMath_sinWithDouble_(angle) * h_;
    if (affine_ != nil) {
      [affine_ transformWithDoubleArray:coords withInt:0 withDoubleArray:coords withInt:0 withInt:1];
    }
    return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_SEG_MOVETO;
  }
  if (index_ > arcSegs_) {
    if (index_ == arcSegs_ + lineSegs_) {
      return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_SEG_CLOSE;
    }
    *IOSDoubleArray_GetRef(nil_chk(coords), 0) = x_;
    *IOSDoubleArray_GetRef(coords, 1) = y_;
    if (affine_ != nil) {
      [affine_ transformWithDoubleArray:coords withInt:0 withDoubleArray:coords withInt:0 withInt:1];
    }
    return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_SEG_LINETO;
  }
  angle += increment_ * (index_ - 1);
  jdouble relx = JavaLangMath_cosWithDouble_(angle);
  jdouble rely = JavaLangMath_sinWithDouble_(angle);
  *IOSDoubleArray_GetRef(nil_chk(coords), 0) = x_ + (relx - cv_ * rely) * w_;
  *IOSDoubleArray_GetRef(coords, 1) = y_ + (rely + cv_ * relx) * h_;
  angle += increment_;
  relx = JavaLangMath_cosWithDouble_(angle);
  rely = JavaLangMath_sinWithDouble_(angle);
  *IOSDoubleArray_GetRef(coords, 2) = x_ + (relx + cv_ * rely) * w_;
  *IOSDoubleArray_GetRef(coords, 3) = y_ + (rely - cv_ * relx) * h_;
  *IOSDoubleArray_GetRef(coords, 4) = x_ + relx * w_;
  *IOSDoubleArray_GetRef(coords, 5) = y_ + rely * h_;
  if (affine_ != nil) {
    [affine_ transformWithDoubleArray:coords withInt:0 withDoubleArray:coords withInt:0 withInt:3];
  }
  return OrgGeogebraGgbjdkJavaAwtGeomPathIterator_SEG_CUBICTO;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithOrgGeogebraGgbjdkJavaAwtGeomArc2D:withOrgGeogebraCommonAwtGAffineTransform:", "ArcIterator", NULL, 0x0, NULL, NULL },
    { "getWindingRule", NULL, "I", 0x1, NULL, NULL },
    { "isDone", NULL, "Z", 0x1, NULL, NULL },
    { "next", NULL, "V", 0x1, NULL, NULL },
    { "btanWithDouble:", "btan", "D", 0xa, NULL, NULL },
    { "currentSegmentWithFloatArray:", "currentSegment", "I", 0x1, NULL, NULL },
    { "currentSegmentWithDoubleArray:", "currentSegment", "I", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "x_", NULL, 0x0, "D", NULL, NULL,  },
    { "y_", NULL, 0x0, "D", NULL, NULL,  },
    { "w_", NULL, 0x0, "D", NULL, NULL,  },
    { "h_", NULL, 0x0, "D", NULL, NULL,  },
    { "angStRad_", NULL, 0x0, "D", NULL, NULL,  },
    { "increment_", NULL, 0x0, "D", NULL, NULL,  },
    { "cv_", NULL, 0x0, "D", NULL, NULL,  },
    { "affine_", NULL, 0x0, "Lorg.geogebra.common.awt.GAffineTransform;", NULL, NULL,  },
    { "index_", NULL, 0x0, "I", NULL, NULL,  },
    { "arcSegs_", NULL, 0x0, "I", NULL, NULL,  },
    { "lineSegs_", NULL, 0x0, "I", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _OrgGeogebraGgbjdkJavaAwtGeomArcIterator = { 2, "ArcIterator", "org.geogebra.ggbjdk.java.awt.geom", NULL, 0x0, 7, methods, 11, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_OrgGeogebraGgbjdkJavaAwtGeomArcIterator;
}

@end

void OrgGeogebraGgbjdkJavaAwtGeomArcIterator_initWithOrgGeogebraGgbjdkJavaAwtGeomArc2D_withOrgGeogebraCommonAwtGAffineTransform_(OrgGeogebraGgbjdkJavaAwtGeomArcIterator *self, OrgGeogebraGgbjdkJavaAwtGeomArc2D *a, id<OrgGeogebraCommonAwtGAffineTransform> at) {
  (void) NSObject_init(self);
  self->w_ = [((OrgGeogebraGgbjdkJavaAwtGeomArc2D *) nil_chk(a)) getWidth] / 2;
  self->h_ = [a getHeight] / 2;
  self->x_ = [a getX] + self->w_;
  self->y_ = [a getY] + self->h_;
  self->angStRad_ = -JavaLangMath_toRadiansWithDouble_([a getAngleStart]);
  self->affine_ = at;
  jdouble ext = -[a getAngleExtent];
  if (ext >= 360.0 || ext <= -360) {
    self->arcSegs_ = 4;
    self->increment_ = JavaLangMath_PI / 2;
    self->cv_ = 0.5522847498307933;
    if (ext < 0) {
      self->increment_ = -self->increment_;
      self->cv_ = -self->cv_;
    }
  }
  else {
    self->arcSegs_ = J2ObjCFpToInt(JavaLangMath_ceilWithDouble_(JavaLangMath_absWithDouble_(ext) / 90.0));
    self->increment_ = JavaLangMath_toRadiansWithDouble_(ext / self->arcSegs_);
    self->cv_ = OrgGeogebraGgbjdkJavaAwtGeomArcIterator_btanWithDouble_(self->increment_);
    if (self->cv_ == 0) {
      self->arcSegs_ = 0;
    }
  }
  switch ([a getArcType]) {
    case OrgGeogebraGgbjdkJavaAwtGeomArc2D_OPEN:
    self->lineSegs_ = 0;
    break;
    case OrgGeogebraGgbjdkJavaAwtGeomArc2D_CHORD:
    self->lineSegs_ = 1;
    break;
    case OrgGeogebraGgbjdkJavaAwtGeomArc2D_PIE:
    self->lineSegs_ = 2;
    break;
  }
  if (self->w_ < 0 || self->h_ < 0) {
    self->arcSegs_ = self->lineSegs_ = -1;
  }
}

OrgGeogebraGgbjdkJavaAwtGeomArcIterator *new_OrgGeogebraGgbjdkJavaAwtGeomArcIterator_initWithOrgGeogebraGgbjdkJavaAwtGeomArc2D_withOrgGeogebraCommonAwtGAffineTransform_(OrgGeogebraGgbjdkJavaAwtGeomArc2D *a, id<OrgGeogebraCommonAwtGAffineTransform> at) {
  OrgGeogebraGgbjdkJavaAwtGeomArcIterator *self = [OrgGeogebraGgbjdkJavaAwtGeomArcIterator alloc];
  OrgGeogebraGgbjdkJavaAwtGeomArcIterator_initWithOrgGeogebraGgbjdkJavaAwtGeomArc2D_withOrgGeogebraCommonAwtGAffineTransform_(self, a, at);
  return self;
}

jdouble OrgGeogebraGgbjdkJavaAwtGeomArcIterator_btanWithDouble_(jdouble increment) {
  OrgGeogebraGgbjdkJavaAwtGeomArcIterator_initialize();
  increment /= 2.0;
  return 4.0 / 3.0 * JavaLangMath_sinWithDouble_(increment) / (1.0 + JavaLangMath_cosWithDouble_(increment));
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(OrgGeogebraGgbjdkJavaAwtGeomArcIterator)
