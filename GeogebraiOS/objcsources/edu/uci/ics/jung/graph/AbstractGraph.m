//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeogebraiOS/GeogebraiOS/sources/edu/uci/ics/jung/graph/AbstractGraph.java
//


#include "J2ObjC_source.h"
#include "edu/uci/ics/jung/graph/AbstractGraph.h"
#include "edu/uci/ics/jung/graph/Graph.h"
#include "edu/uci/ics/jung/graph/Hypergraph.h"
#include "edu/uci/ics/jung/graph/util/EdgeType.h"
#include "edu/uci/ics/jung/graph/util/Pair.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/StringBuffer.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/Collections.h"
#include "java/util/Iterator.h"

#pragma clang diagnostic ignored "-Wprotocol"

@implementation EduUciIcsJungGraphAbstractGraph

- (jboolean)addEdgeWithId:(id)edge
   withJavaUtilCollection:(id<JavaUtilCollection>)vertices {
  return [self addEdgeWithId:edge withJavaUtilCollection:vertices withEduUciIcsJungGraphUtilEdgeTypeEnum:[self getDefaultEdgeType]];
}

- (jboolean)addEdgeWithId:(id)edge
   withJavaUtilCollection:(id<JavaUtilCollection>)vertices
withEduUciIcsJungGraphUtilEdgeTypeEnum:(EduUciIcsJungGraphUtilEdgeTypeEnum *)edgeType {
  if (vertices == nil) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"'vertices' parameter must not be null") autorelease];
  if ([((id<JavaUtilCollection>) nil_chk(vertices)) size] == 2) return [self addEdgeWithId:edge withEduUciIcsJungGraphUtilPair:[vertices isKindOfClass:[EduUciIcsJungGraphUtilPair class]] ? (EduUciIcsJungGraphUtilPair *) check_class_cast(vertices, [EduUciIcsJungGraphUtilPair class]) : [new_EduUciIcsJungGraphUtilPair_initWithJavaUtilCollection_(vertices) autorelease] withEduUciIcsJungGraphUtilEdgeTypeEnum:edgeType];
  else if ([vertices size] == 1) {
    id vertex = [((id<JavaUtilIterator>) nil_chk([vertices iterator])) next];
    return [self addEdgeWithId:edge withEduUciIcsJungGraphUtilPair:[new_EduUciIcsJungGraphUtilPair_initWithId_withId_(vertex, vertex) autorelease] withEduUciIcsJungGraphUtilEdgeTypeEnum:edgeType];
  }
  else @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$I", @"Graph objects connect 1 or 2 vertices; vertices arg has ", [vertices size])) autorelease];
}

- (jboolean)addEdgeWithId:(id)e
                   withId:(id)v1
                   withId:(id)v2 {
  return [self addEdgeWithId:e withId:v1 withId:v2 withEduUciIcsJungGraphUtilEdgeTypeEnum:[self getDefaultEdgeType]];
}

- (jboolean)addEdgeWithId:(id)e
                   withId:(id)v1
                   withId:(id)v2
withEduUciIcsJungGraphUtilEdgeTypeEnum:(EduUciIcsJungGraphUtilEdgeTypeEnum *)edge_type {
  return [self addEdgeWithId:e withEduUciIcsJungGraphUtilPair:[new_EduUciIcsJungGraphUtilPair_initWithId_withId_(v1, v2) autorelease] withEduUciIcsJungGraphUtilEdgeTypeEnum:edge_type];
}

- (jboolean)addEdgeWithId:(id)edge
withEduUciIcsJungGraphUtilPair:(EduUciIcsJungGraphUtilPair *)endpoints {
  return [self addEdgeWithId:edge withEduUciIcsJungGraphUtilPair:endpoints withEduUciIcsJungGraphUtilEdgeTypeEnum:[self getDefaultEdgeType]];
}

- (jboolean)addEdgeWithId:(id)edge
withEduUciIcsJungGraphUtilPair:(EduUciIcsJungGraphUtilPair *)endpoints
withEduUciIcsJungGraphUtilEdgeTypeEnum:(EduUciIcsJungGraphUtilEdgeTypeEnum *)edgeType {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (EduUciIcsJungGraphUtilPair *)getValidatedEndpointsWithId:(id)edge
                             withEduUciIcsJungGraphUtilPair:(EduUciIcsJungGraphUtilPair *)endpoints {
  if (edge == nil) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"input edge may not be null") autorelease];
  if (endpoints == nil) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"endpoints may not be null") autorelease];
  EduUciIcsJungGraphUtilPair *new_endpoints = [new_EduUciIcsJungGraphUtilPair_initWithId_withId_([((EduUciIcsJungGraphUtilPair *) nil_chk(endpoints)) getFirst], [endpoints getSecond]) autorelease];
  if ([self containsEdgeWithId:edge]) {
    EduUciIcsJungGraphUtilPair *existing_endpoints = [self getEndpointsWithId:edge];
    if (![((EduUciIcsJungGraphUtilPair *) nil_chk(existing_endpoints)) isEqual:new_endpoints]) {
      @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@$@", @"edge ", edge, @" already exists in this graph with endpoints ", existing_endpoints, @" and cannot be added with endpoints ", endpoints)) autorelease];
    }
    else {
      return nil;
    }
  }
  return new_endpoints;
}

- (jint)inDegreeWithId:(id)vertex {
  return [((id<JavaUtilCollection>) nil_chk([self getInEdgesWithId:vertex])) size];
}

- (jint)outDegreeWithId:(id)vertex {
  return [((id<JavaUtilCollection>) nil_chk([self getOutEdgesWithId:vertex])) size];
}

- (jboolean)isPredecessorWithId:(id)v1
                         withId:(id)v2 {
  return [((id<JavaUtilCollection>) nil_chk([self getPredecessorsWithId:v1])) containsWithId:v2];
}

- (jboolean)isSuccessorWithId:(id)v1
                       withId:(id)v2 {
  return [((id<JavaUtilCollection>) nil_chk([self getSuccessorsWithId:v1])) containsWithId:v2];
}

- (jint)getPredecessorCountWithId:(id)vertex {
  return [((id<JavaUtilCollection>) nil_chk([self getPredecessorsWithId:vertex])) size];
}

- (jint)getSuccessorCountWithId:(id)vertex {
  return [((id<JavaUtilCollection>) nil_chk([self getSuccessorsWithId:vertex])) size];
}

- (jboolean)isNeighborWithId:(id)v1
                      withId:(id)v2 {
  if (![self containsVertexWithId:v1] || ![self containsVertexWithId:v2]) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"At least one of these not in this graph: ", v1, @", ", v2)) autorelease];
  return [((id<JavaUtilCollection>) nil_chk([self getNeighborsWithId:v1])) containsWithId:v2];
}

- (jboolean)isIncidentWithId:(id)vertex
                      withId:(id)edge {
  if (![self containsVertexWithId:vertex] || ![self containsEdgeWithId:edge]) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("$@$@", @"At least one of these not in this graph: ", vertex, @", ", edge)) autorelease];
  return [((id<JavaUtilCollection>) nil_chk([self getIncidentEdgesWithId:vertex])) containsWithId:edge];
}

- (jint)getNeighborCountWithId:(id)vertex {
  if (![self containsVertexWithId:vertex]) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("@$", vertex, @" is not a vertex in this graph")) autorelease];
  return [((id<JavaUtilCollection>) nil_chk([self getNeighborsWithId:vertex])) size];
}

- (jint)degreeWithId:(id)vertex {
  if (![self containsVertexWithId:vertex]) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("@$", vertex, @" is not a vertex in this graph")) autorelease];
  return [((id<JavaUtilCollection>) nil_chk([self getIncidentEdgesWithId:vertex])) size];
}

- (jint)getIncidentCountWithId:(id)edge {
  EduUciIcsJungGraphUtilPair *incident = [self getEndpointsWithId:edge];
  if (incident == nil) return 0;
  if ([((EduUciIcsJungGraphUtilPair *) nil_chk(incident)) getFirst] == [incident getSecond]) return 1;
  else return 2;
}

- (id)getOppositeWithId:(id)vertex
                 withId:(id)edge {
  EduUciIcsJungGraphUtilPair *incident = [self getEndpointsWithId:edge];
  id first = [((EduUciIcsJungGraphUtilPair *) nil_chk(incident)) getFirst];
  id second = [incident getSecond];
  if ([nil_chk(vertex) isEqual:first]) return second;
  else if ([vertex isEqual:second]) return first;
  else @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("@$@$", vertex, @" is not incident to ", edge, @" in this graph")) autorelease];
}

- (id)findEdgeWithId:(id)v1
              withId:(id)v2 {
  for (id __strong e in nil_chk([self getOutEdgesWithId:v1])) {
    if ([nil_chk([self getOppositeWithId:v1 withId:e]) isEqual:v2]) return e;
  }
  return nil;
}

- (id<JavaUtilCollection>)findEdgeSetWithId:(id)v1
                                     withId:(id)v2 {
  if (![((id<JavaUtilCollection>) nil_chk([self getVertices])) containsWithId:v1]) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("@$", v1, @" is not an element of this graph")) autorelease];
  if (![((id<JavaUtilCollection>) nil_chk([self getVertices])) containsWithId:v2]) @throw [new_JavaLangIllegalArgumentException_initWithNSString_(JreStrcat("@$", v2, @" is not an element of this graph")) autorelease];
  id<JavaUtilCollection> edges = [new_JavaUtilArrayList_init() autorelease];
  for (id __strong e in nil_chk([self getOutEdgesWithId:v1])) {
    if ([nil_chk([self getOppositeWithId:v1 withId:e]) isEqual:v2]) [edges addWithId:e];
  }
  return JavaUtilCollections_unmodifiableCollectionWithJavaUtilCollection_(edges);
}

- (id<JavaUtilCollection>)getIncidentVerticesWithId:(id)edge {
  EduUciIcsJungGraphUtilPair *endpoints = [self getEndpointsWithId:edge];
  id<JavaUtilCollection> incident = [new_JavaUtilArrayList_init() autorelease];
  [incident addWithId:[((EduUciIcsJungGraphUtilPair *) nil_chk(endpoints)) getFirst]];
  [incident addWithId:[endpoints getSecond]];
  return JavaUtilCollections_unmodifiableCollectionWithJavaUtilCollection_(incident);
}

- (NSString *)description {
  JavaLangStringBuffer *sb = [new_JavaLangStringBuffer_initWithNSString_(@"Vertices:") autorelease];
  for (id __strong v in nil_chk([self getVertices])) {
    [sb appendWithNSString:JreStrcat("@C", v, ',')];
  }
  [sb setLengthWithInt:[sb length] - 1];
  [sb appendWithNSString:@"\nEdges:"];
  for (id __strong e in nil_chk([self getEdges])) {
    EduUciIcsJungGraphUtilPair *ep = [self getEndpointsWithId:e];
    [sb appendWithNSString:JreStrcat("@C@C@$", e, '[', [((EduUciIcsJungGraphUtilPair *) nil_chk(ep)) getFirst], ',', [ep getSecond], @"] ")];
  }
  return [sb description];
}

- (instancetype)init {
  EduUciIcsJungGraphAbstractGraph_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "addEdgeWithId:withJavaUtilCollection:", "addEdge", "Z", 0x1, NULL, "(TE;Ljava/util/Collection<+TV;>;)Z" },
    { "addEdgeWithId:withJavaUtilCollection:withEduUciIcsJungGraphUtilEdgeTypeEnum:", "addEdge", "Z", 0x1, NULL, "(TE;Ljava/util/Collection<+TV;>;Ledu/uci/ics/jung/graph/util/EdgeType;)Z" },
    { "addEdgeWithId:withId:withId:", "addEdge", "Z", 0x1, NULL, "(TE;TV;TV;)Z" },
    { "addEdgeWithId:withId:withId:withEduUciIcsJungGraphUtilEdgeTypeEnum:", "addEdge", "Z", 0x1, NULL, "(TE;TV;TV;Ledu/uci/ics/jung/graph/util/EdgeType;)Z" },
    { "addEdgeWithId:withEduUciIcsJungGraphUtilPair:", "addEdge", "Z", 0x1, NULL, "(TE;Ledu/uci/ics/jung/graph/util/Pair<+TV;>;)Z" },
    { "addEdgeWithId:withEduUciIcsJungGraphUtilPair:withEduUciIcsJungGraphUtilEdgeTypeEnum:", "addEdge", "Z", 0x401, NULL, "(TE;Ledu/uci/ics/jung/graph/util/Pair<+TV;>;Ledu/uci/ics/jung/graph/util/EdgeType;)Z" },
    { "getValidatedEndpointsWithId:withEduUciIcsJungGraphUtilPair:", "getValidatedEndpoints", "Ledu.uci.ics.jung.graph.util.Pair;", 0x4, NULL, "(TE;Ledu/uci/ics/jung/graph/util/Pair<+TV;>;)Ledu/uci/ics/jung/graph/util/Pair<TV;>;" },
    { "inDegreeWithId:", "inDegree", "I", 0x1, NULL, "(TV;)I" },
    { "outDegreeWithId:", "outDegree", "I", 0x1, NULL, "(TV;)I" },
    { "isPredecessorWithId:withId:", "isPredecessor", "Z", 0x1, NULL, "(TV;TV;)Z" },
    { "isSuccessorWithId:withId:", "isSuccessor", "Z", 0x1, NULL, "(TV;TV;)Z" },
    { "getPredecessorCountWithId:", "getPredecessorCount", "I", 0x1, NULL, "(TV;)I" },
    { "getSuccessorCountWithId:", "getSuccessorCount", "I", 0x1, NULL, "(TV;)I" },
    { "isNeighborWithId:withId:", "isNeighbor", "Z", 0x1, NULL, "(TV;TV;)Z" },
    { "isIncidentWithId:withId:", "isIncident", "Z", 0x1, NULL, "(TV;TE;)Z" },
    { "getNeighborCountWithId:", "getNeighborCount", "I", 0x1, NULL, "(TV;)I" },
    { "degreeWithId:", "degree", "I", 0x1, NULL, "(TV;)I" },
    { "getIncidentCountWithId:", "getIncidentCount", "I", 0x1, NULL, "(TE;)I" },
    { "getOppositeWithId:withId:", "getOpposite", "TV;", 0x1, NULL, "(TV;TE;)TV;" },
    { "findEdgeWithId:withId:", "findEdge", "TE;", 0x1, NULL, "(TV;TV;)TE;" },
    { "findEdgeSetWithId:withId:", "findEdgeSet", "Ljava.util.Collection;", 0x1, NULL, "(TV;TV;)Ljava/util/Collection<TE;>;" },
    { "getIncidentVerticesWithId:", "getIncidentVertices", "Ljava.util.Collection;", 0x1, NULL, "(TE;)Ljava/util/Collection<TV;>;" },
    { "description", "toString", "Ljava.lang.String;", 0x1, NULL, NULL },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcClassInfo _EduUciIcsJungGraphAbstractGraph = { 2, "AbstractGraph", "edu.uci.ics.jung.graph", NULL, 0x401, 24, methods, 0, NULL, 0, NULL, 0, NULL, NULL, "<V:Ljava/lang/Object;E:Ljava/lang/Object;>Ljava/lang/Object;Ledu/uci/ics/jung/graph/Graph<TV;TE;>;Ljava/io/Serializable;" };
  return &_EduUciIcsJungGraphAbstractGraph;
}

@end

void EduUciIcsJungGraphAbstractGraph_init(EduUciIcsJungGraphAbstractGraph *self) {
  NSObject_init(self);
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduUciIcsJungGraphAbstractGraph)
