//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeogebraiOS/GeogebraiOS/sources/edu/uci/ics/jung/algorithms/blockmodel/StructurallyEquivalent.java
//


#include "J2ObjC_source.h"
#include "edu/uci/ics/jung/algorithms/blockmodel/StructurallyEquivalent.h"
#include "edu/uci/ics/jung/algorithms/blockmodel/VertexPartition.h"
#include "edu/uci/ics/jung/graph/Graph.h"
#include "edu/uci/ics/jung/graph/util/Pair.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/Collections.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/ListIterator.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "org/apache/commons/collections15/CollectionUtils.h"

@implementation EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent

- (EduUciIcsJungAlgorithmsBlockmodelVertexPartition *)transformWithId:(id<EduUciIcsJungGraphGraph>)g {
  id<JavaUtilSet> vertex_pairs = [self getEquivalentPairsWithEduUciIcsJungGraphGraph:g];
  id<JavaUtilSet> rv = [new_JavaUtilHashSet_init() autorelease];
  id<JavaUtilMap> intermediate = [new_JavaUtilHashMap_init() autorelease];
  for (EduUciIcsJungGraphUtilPair * __strong p in nil_chk(vertex_pairs)) {
    id<JavaUtilSet> res = [intermediate getWithId:[((EduUciIcsJungGraphUtilPair *) nil_chk(p)) getFirst]];
    if (res == nil) res = [intermediate getWithId:[p getSecond]];
    if (res == nil) res = [new_JavaUtilHashSet_init() autorelease];
    [((id<JavaUtilSet>) nil_chk(res)) addWithId:[p getFirst]];
    [res addWithId:[p getSecond]];
    [intermediate putWithId:[p getFirst] withId:res];
    [intermediate putWithId:[p getSecond] withId:res];
  }
  [rv addAllWithJavaUtilCollection:[intermediate values]];
  id<JavaUtilCollection> singletons = OrgApacheCommonsCollections15CollectionUtils_subtractWithJavaUtilCollection_withJavaLangIterable_([((id<EduUciIcsJungGraphGraph>) nil_chk(g)) getVertices], [intermediate keySet]);
  for (id __strong v in nil_chk(singletons)) {
    id<JavaUtilSet> v_set = JavaUtilCollections_singletonWithId_(v);
    [intermediate putWithId:v withId:v_set];
    [rv addWithId:v_set];
  }
  return [new_EduUciIcsJungAlgorithmsBlockmodelVertexPartition_initWithEduUciIcsJungGraphGraph_withJavaUtilMap_withJavaUtilCollection_(g, intermediate, rv) autorelease];
}

- (id<JavaUtilSet>)getEquivalentPairsWithEduUciIcsJungGraphGraph:(id<EduUciIcsJungGraphGraph>)g {
  id<JavaUtilSet> rv = [new_JavaUtilHashSet_init() autorelease];
  id<JavaUtilSet> alreadyEquivalent = [new_JavaUtilHashSet_init() autorelease];
  id<JavaUtilList> l = [new_JavaUtilArrayList_initWithJavaUtilCollection_([((id<EduUciIcsJungGraphGraph>) nil_chk(g)) getVertices]) autorelease];
  for (id __strong v1 in l) {
    if ([alreadyEquivalent containsWithId:v1]) continue;
    for (id<JavaUtilIterator> iterator = [l listIteratorWithInt:[l indexOfWithId:v1] + 1]; [((id<JavaUtilIterator>) nil_chk(iterator)) hasNext]; ) {
      id v2 = [iterator next];
      if ([alreadyEquivalent containsWithId:v2]) continue;
      if (![self canPossiblyCompareWithId:v1 withId:v2]) continue;
      if ([self isStructurallyEquivalentWithEduUciIcsJungGraphGraph:g withId:v1 withId:v2]) {
        EduUciIcsJungGraphUtilPair *p = [new_EduUciIcsJungGraphUtilPair_initWithId_withId_(v1, v2) autorelease];
        [alreadyEquivalent addWithId:v2];
        [rv addWithId:p];
      }
    }
  }
  return rv;
}

- (jboolean)isStructurallyEquivalentWithEduUciIcsJungGraphGraph:(id<EduUciIcsJungGraphGraph>)g
                                                         withId:(id)v1
                                                         withId:(id)v2 {
  if ([((id<EduUciIcsJungGraphGraph>) nil_chk(g)) degreeWithId:v1] != [g degreeWithId:v2]) {
    return NO;
  }
  id<JavaUtilSet> n1 = [new_JavaUtilHashSet_initWithJavaUtilCollection_([g getPredecessorsWithId:v1]) autorelease];
  [n1 removeWithId:v2];
  [n1 removeWithId:v1];
  id<JavaUtilSet> n2 = [new_JavaUtilHashSet_initWithJavaUtilCollection_([g getPredecessorsWithId:v2]) autorelease];
  [n2 removeWithId:v1];
  [n2 removeWithId:v2];
  id<JavaUtilSet> o1 = [new_JavaUtilHashSet_initWithJavaUtilCollection_([g getSuccessorsWithId:v1]) autorelease];
  id<JavaUtilSet> o2 = [new_JavaUtilHashSet_initWithJavaUtilCollection_([g getSuccessorsWithId:v2]) autorelease];
  [o1 removeWithId:v1];
  [o1 removeWithId:v2];
  [o2 removeWithId:v1];
  [o2 removeWithId:v2];
  jboolean b = ([n1 isEqual:n2] && [o1 isEqual:o2]);
  if (!b) return b;
  b &= ([g isSuccessorWithId:v1 withId:v2] == [g isSuccessorWithId:v2 withId:v1]);
  b &= ([g isSuccessorWithId:v1 withId:v1] == [g isSuccessorWithId:v2 withId:v2]);
  return b;
}

- (jboolean)canPossiblyCompareWithId:(id)v1
                              withId:(id)v2 {
  return YES;
}

- (instancetype)init {
  EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent_init(self);
  return self;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "transformWithId:", "transform", "Ledu.uci.ics.jung.algorithms.blockmodel.VertexPartition;", 0x1, NULL, NULL },
    { "getEquivalentPairsWithEduUciIcsJungGraphGraph:", "getEquivalentPairs", "Ljava.util.Set;", 0x4, NULL, NULL },
    { "isStructurallyEquivalentWithEduUciIcsJungGraphGraph:withId:withId:", "isStructurallyEquivalent", "Z", 0x4, NULL, "(Ledu/uci/ics/jung/graph/Graph<TV;*>;TV;TV;)Z" },
    { "canPossiblyCompareWithId:withId:", "canPossiblyCompare", "Z", 0x4, NULL, "(TV;TV;)Z" },
    { "init", NULL, NULL, 0x1, NULL, NULL },
  };
  static const J2ObjcClassInfo _EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent = { 2, "StructurallyEquivalent", "edu.uci.ics.jung.algorithms.blockmodel", NULL, 0x1, 5, methods, 0, NULL, 0, NULL, 0, NULL, NULL, "<V:Ljava/lang/Object;E:Ljava/lang/Object;>Ljava/lang/Object;Lorg/apache/commons/collections15/Transformer<Ledu/uci/ics/jung/graph/Graph<TV;TE;>;Ledu/uci/ics/jung/algorithms/blockmodel/VertexPartition<TV;TE;>;>;" };
  return &_EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent;
}

@end

void EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent_init(EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent *self) {
  NSObject_init(self);
}

EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent *new_EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent_init() {
  EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent *self = [EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent alloc];
  EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent_init(self);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduUciIcsJungAlgorithmsBlockmodelStructurallyEquivalent)
