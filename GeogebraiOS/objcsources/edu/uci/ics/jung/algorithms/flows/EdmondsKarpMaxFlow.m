//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeogebraiOS/GeogebraiOS/sources/edu/uci/ics/jung/algorithms/flows/EdmondsKarpMaxFlow.java
//


#include "J2ObjC_source.h"
#include "edu/uci/ics/jung/algorithms/flows/EdmondsKarpMaxFlow.h"
#include "edu/uci/ics/jung/algorithms/util/IterativeProcess.h"
#include "edu/uci/ics/jung/graph/DirectedGraph.h"
#include "edu/uci/ics/jung/graph/Graph.h"
#include "edu/uci/ics/jung/graph/util/EdgeType.h"
#include "java/lang/Exception.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/Math.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/HashMap.h"
#include "java/util/HashSet.h"
#include "java/util/List.h"
#include "java/util/Map.h"
#include "java/util/Set.h"
#include "org/apache/commons/collections15/Buffer.h"
#include "org/apache/commons/collections15/Factory.h"
#include "org/apache/commons/collections15/Transformer.h"
#include "org/apache/commons/collections15/buffer/UnboundedFifoBuffer.h"

@interface EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow () {
 @public
  id<EduUciIcsJungGraphDirectedGraph> mFlowGraph_;
  id<EduUciIcsJungGraphDirectedGraph> mOriginalGraph_;
  id source_;
  id target_;
  jint mMaxFlow_;
  id<JavaUtilSet> mSourcePartitionNodes_;
  id<JavaUtilSet> mSinkPartitionNodes_;
  id<JavaUtilSet> mMinCutEdges_;
  id<JavaUtilMap> residualCapacityMap_;
  id<JavaUtilMap> parentMap_;
  id<JavaUtilMap> parentCapacityMap_;
  id<OrgApacheCommonsCollections15Transformer> edgeCapacityTransformer_;
  id<JavaUtilMap> edgeFlowMap_;
  id<OrgApacheCommonsCollections15Factory> edgeFactory_;
}

- (void)clearParentValues;

- (void)computeMinCut;

- (void)updateResidualCapacities;

@end

J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, mFlowGraph_, id<EduUciIcsJungGraphDirectedGraph>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, mOriginalGraph_, id<EduUciIcsJungGraphDirectedGraph>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, source_, id)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, target_, id)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, mSourcePartitionNodes_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, mSinkPartitionNodes_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, mMinCutEdges_, id<JavaUtilSet>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, residualCapacityMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, parentMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, parentCapacityMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, edgeCapacityTransformer_, id<OrgApacheCommonsCollections15Transformer>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, edgeFlowMap_, id<JavaUtilMap>)
J2OBJC_FIELD_SETTER(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow, edgeFactory_, id<OrgApacheCommonsCollections15Factory>)

__attribute__((unused)) static void EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_clearParentValues(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *self);

__attribute__((unused)) static void EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_computeMinCut(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *self);

__attribute__((unused)) static void EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_updateResidualCapacities(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *self);

@implementation EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow

- (instancetype)initWithEduUciIcsJungGraphDirectedGraph:(id<EduUciIcsJungGraphDirectedGraph>)directedGraph
                                                 withId:(id)source
                                                 withId:(id)sink
           withOrgApacheCommonsCollections15Transformer:(id<OrgApacheCommonsCollections15Transformer>)edgeCapacityTransformer
                                        withJavaUtilMap:(id<JavaUtilMap>)edgeFlowMap
               withOrgApacheCommonsCollections15Factory:(id<OrgApacheCommonsCollections15Factory>)edgeFactory {
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_initWithEduUciIcsJungGraphDirectedGraph_withId_withId_withOrgApacheCommonsCollections15Transformer_withJavaUtilMap_withOrgApacheCommonsCollections15Factory_(self, directedGraph, source, sink, edgeCapacityTransformer, edgeFlowMap, edgeFactory);
  return self;
}

- (void)clearParentValues {
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_clearParentValues(self);
}

- (jboolean)hasAugmentingPath {
  [((id<JavaUtilSet>) nil_chk(mSinkPartitionNodes_)) clear];
  [((id<JavaUtilSet>) nil_chk(mSourcePartitionNodes_)) clear];
  [mSinkPartitionNodes_ addAllWithJavaUtilCollection:[((id<EduUciIcsJungGraphDirectedGraph>) nil_chk(mFlowGraph_)) getVertices]];
  id<JavaUtilSet> visitedEdgesMap = [new_JavaUtilHashSet_init() autorelease];
  id<OrgApacheCommonsCollections15Buffer> queue = [new_OrgApacheCommonsCollections15BufferUnboundedFifoBuffer_init() autorelease];
  [queue addWithId:source_];
  while (![queue isEmpty]) {
    id currentVertex = [queue remove];
    [mSinkPartitionNodes_ removeWithId:currentVertex];
    [mSourcePartitionNodes_ addWithId:currentVertex];
    NSNumber *currentCapacity = [((id<JavaUtilMap>) nil_chk(parentCapacityMap_)) getWithId:currentVertex];
    id<JavaUtilCollection> neighboringEdges = [mFlowGraph_ getOutEdgesWithId:currentVertex];
    for (id __strong neighboringEdge in nil_chk(neighboringEdges)) {
      id neighboringVertex = [mFlowGraph_ getDestWithId:neighboringEdge];
      NSNumber *residualCapacity = [((id<JavaUtilMap>) nil_chk(residualCapacityMap_)) getWithId:neighboringEdge];
      if ([((NSNumber *) nil_chk(residualCapacity)) intValue] <= 0 || [visitedEdgesMap containsWithId:neighboringEdge]) continue;
      id neighborsParent = [((id<JavaUtilMap>) nil_chk(parentMap_)) getWithId:neighboringVertex];
      NSNumber *neighborCapacity = [parentCapacityMap_ getWithId:neighboringVertex];
      jint newCapacity = JavaLangMath_minWithInt_withInt_([residualCapacity intValue], [((NSNumber *) nil_chk(currentCapacity)) intValue]);
      if ((neighborsParent == nil) || newCapacity > [((NSNumber *) nil_chk(neighborCapacity)) intValue]) {
        [parentMap_ putWithId:neighboringVertex withId:currentVertex];
        [parentCapacityMap_ putWithId:neighboringVertex withId:[new_JavaLangInteger_initWithInt_(newCapacity) autorelease]];
        [visitedEdgesMap addWithId:neighboringEdge];
        if (neighboringVertex != target_) {
          [queue addWithId:neighboringVertex];
        }
      }
    }
  }
  jboolean hasAugmentingPath = NO;
  NSNumber *targetsParentCapacity = [((id<JavaUtilMap>) nil_chk(parentCapacityMap_)) getWithId:target_];
  if (targetsParentCapacity != nil && [targetsParentCapacity intValue] > 0) {
    EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_updateResidualCapacities(self);
    hasAugmentingPath = YES;
  }
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_clearParentValues(self);
  return hasAugmentingPath;
}

- (void)step {
  while ([self hasAugmentingPath]) {
  }
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_computeMinCut(self);
}

- (void)computeMinCut {
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_computeMinCut(self);
}

- (jint)getMaxFlow {
  return mMaxFlow_;
}

- (id<JavaUtilSet>)getNodesInSinkPartition {
  return mSinkPartitionNodes_;
}

- (id<JavaUtilSet>)getNodesInSourcePartition {
  return mSourcePartitionNodes_;
}

- (id<JavaUtilSet>)getMinCutEdges {
  return mMinCutEdges_;
}

- (id<EduUciIcsJungGraphDirectedGraph>)getFlowGraph {
  return mFlowGraph_;
}

- (void)initializeIterations {
  [((id<JavaUtilMap>) nil_chk(parentCapacityMap_)) putWithId:source_ withId:JavaLangInteger_valueOfWithInt_(JavaLangInteger_MAX_VALUE)];
  [((id<JavaUtilMap>) nil_chk(parentMap_)) putWithId:source_ withId:source_];
  id<JavaUtilList> edgeList = [new_JavaUtilArrayList_initWithJavaUtilCollection_([((id<EduUciIcsJungGraphDirectedGraph>) nil_chk(mFlowGraph_)) getEdges]) autorelease];
  for (jint eIdx = 0; eIdx < [edgeList size]; eIdx++) {
    id edge = [edgeList getWithInt:eIdx];
    NSNumber *capacity = [((id<OrgApacheCommonsCollections15Transformer>) nil_chk(edgeCapacityTransformer_)) transformWithId:edge];
    if (capacity == nil) {
      @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"Edge capacities must be provided in Transformer passed to constructor") autorelease];
    }
    [((id<JavaUtilMap>) nil_chk(residualCapacityMap_)) putWithId:edge withId:capacity];
    id source = [mFlowGraph_ getSourceWithId:edge];
    id destination = [mFlowGraph_ getDestWithId:edge];
    if ([mFlowGraph_ isPredecessorWithId:source withId:destination] == NO) {
      id backEdge = [((id<OrgApacheCommonsCollections15Factory>) nil_chk(edgeFactory_)) create];
      [mFlowGraph_ addEdgeWithId:backEdge withId:destination withId:source withEduUciIcsJungGraphUtilEdgeTypeEnum:EduUciIcsJungGraphUtilEdgeTypeEnum_get_DIRECTED()];
      [residualCapacityMap_ putWithId:backEdge withId:JavaLangInteger_valueOfWithInt_(0)];
    }
  }
}

- (void)finalizeIterations {
  for (id __strong currentEdge in nil_chk([((id<EduUciIcsJungGraphDirectedGraph>) nil_chk(mFlowGraph_)) getEdges])) {
    NSNumber *capacity = [((id<OrgApacheCommonsCollections15Transformer>) nil_chk(edgeCapacityTransformer_)) transformWithId:currentEdge];
    NSNumber *residualCapacity = [((id<JavaUtilMap>) nil_chk(residualCapacityMap_)) getWithId:currentEdge];
    if (capacity != nil) {
      JavaLangInteger *flowValue = [new_JavaLangInteger_initWithInt_([capacity intValue] - [((NSNumber *) nil_chk(residualCapacity)) intValue]) autorelease];
      [((id<JavaUtilMap>) nil_chk(self->edgeFlowMap_)) putWithId:currentEdge withId:flowValue];
    }
  }
  id<JavaUtilSet> backEdges = [new_JavaUtilHashSet_init() autorelease];
  for (id __strong currentEdge in nil_chk([mFlowGraph_ getEdges])) {
    if ([((id<OrgApacheCommonsCollections15Transformer>) nil_chk(edgeCapacityTransformer_)) transformWithId:currentEdge] == nil) {
      [backEdges addWithId:currentEdge];
    }
    else {
      [((id<JavaUtilMap>) nil_chk(residualCapacityMap_)) removeWithId:currentEdge];
    }
  }
  for (id __strong e in backEdges) {
    [mFlowGraph_ removeEdgeWithId:e];
  }
}

- (void)updateResidualCapacities {
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_updateResidualCapacities(self);
}

- (void)dealloc {
  RELEASE_(mFlowGraph_);
  RELEASE_(mOriginalGraph_);
  RELEASE_(source_);
  RELEASE_(target_);
  RELEASE_(mSourcePartitionNodes_);
  RELEASE_(mSinkPartitionNodes_);
  RELEASE_(mMinCutEdges_);
  RELEASE_(residualCapacityMap_);
  RELEASE_(parentMap_);
  RELEASE_(parentCapacityMap_);
  RELEASE_(edgeCapacityTransformer_);
  RELEASE_(edgeFlowMap_);
  RELEASE_(edgeFactory_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithEduUciIcsJungGraphDirectedGraph:withId:withId:withOrgApacheCommonsCollections15Transformer:withJavaUtilMap:withOrgApacheCommonsCollections15Factory:", "EdmondsKarpMaxFlow", NULL, 0x1, NULL, "(Ledu/uci/ics/jung/graph/DirectedGraph<TV;TE;>;TV;TV;Lorg/apache/commons/collections15/Transformer<TE;Ljava/lang/Number;>;Ljava/util/Map<TE;Ljava/lang/Number;>;Lorg/apache/commons/collections15/Factory<TE;>;)V" },
    { "clearParentValues", NULL, "V", 0x2, NULL, NULL },
    { "hasAugmentingPath", NULL, "Z", 0x4, NULL, NULL },
    { "step", NULL, "V", 0x1, NULL, NULL },
    { "computeMinCut", NULL, "V", 0x2, NULL, NULL },
    { "getMaxFlow", NULL, "I", 0x1, NULL, NULL },
    { "getNodesInSinkPartition", NULL, "Ljava.util.Set;", 0x1, NULL, NULL },
    { "getNodesInSourcePartition", NULL, "Ljava.util.Set;", 0x1, NULL, NULL },
    { "getMinCutEdges", NULL, "Ljava.util.Set;", 0x1, NULL, NULL },
    { "getFlowGraph", NULL, "Ledu.uci.ics.jung.graph.DirectedGraph;", 0x1, NULL, NULL },
    { "initializeIterations", NULL, "V", 0x4, NULL, NULL },
    { "finalizeIterations", NULL, "V", 0x4, NULL, NULL },
    { "updateResidualCapacities", NULL, "V", 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "mFlowGraph_", NULL, 0x2, "Ledu.uci.ics.jung.graph.DirectedGraph;", NULL, "Ledu/uci/ics/jung/graph/DirectedGraph<TV;TE;>;",  },
    { "mOriginalGraph_", NULL, 0x2, "Ledu.uci.ics.jung.graph.DirectedGraph;", NULL, "Ledu/uci/ics/jung/graph/DirectedGraph<TV;TE;>;",  },
    { "source_", NULL, 0x2, "TV;", NULL, "TV;",  },
    { "target_", NULL, 0x2, "TV;", NULL, "TV;",  },
    { "mMaxFlow_", NULL, 0x2, "I", NULL, NULL,  },
    { "mSourcePartitionNodes_", NULL, 0x2, "Ljava.util.Set;", NULL, "Ljava/util/Set<TV;>;",  },
    { "mSinkPartitionNodes_", NULL, 0x2, "Ljava.util.Set;", NULL, "Ljava/util/Set<TV;>;",  },
    { "mMinCutEdges_", NULL, 0x2, "Ljava.util.Set;", NULL, "Ljava/util/Set<TE;>;",  },
    { "residualCapacityMap_", NULL, 0x2, "Ljava.util.Map;", NULL, "Ljava/util/Map<TE;Ljava/lang/Number;>;",  },
    { "parentMap_", NULL, 0x2, "Ljava.util.Map;", NULL, "Ljava/util/Map<TV;TV;>;",  },
    { "parentCapacityMap_", NULL, 0x2, "Ljava.util.Map;", NULL, "Ljava/util/Map<TV;Ljava/lang/Number;>;",  },
    { "edgeCapacityTransformer_", NULL, 0x2, "Lorg.apache.commons.collections15.Transformer;", NULL, "Lorg/apache/commons/collections15/Transformer<TE;Ljava/lang/Number;>;",  },
    { "edgeFlowMap_", NULL, 0x2, "Ljava.util.Map;", NULL, "Ljava/util/Map<TE;Ljava/lang/Number;>;",  },
    { "edgeFactory_", NULL, 0x2, "Lorg.apache.commons.collections15.Factory;", NULL, "Lorg/apache/commons/collections15/Factory<TE;>;",  },
  };
  static const J2ObjcClassInfo _EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow = { 2, "EdmondsKarpMaxFlow", "edu.uci.ics.jung.algorithms.flows", NULL, 0x1, 13, methods, 14, fields, 0, NULL, 0, NULL, NULL, "<V:Ljava/lang/Object;E:Ljava/lang/Object;>Ledu/uci/ics/jung/algorithms/util/IterativeProcess;" };
  return &_EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow;
}

@end

void EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_initWithEduUciIcsJungGraphDirectedGraph_withId_withId_withOrgApacheCommonsCollections15Transformer_withJavaUtilMap_withOrgApacheCommonsCollections15Factory_(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *self, id<EduUciIcsJungGraphDirectedGraph> directedGraph, id source, id sink, id<OrgApacheCommonsCollections15Transformer> edgeCapacityTransformer, id<JavaUtilMap> edgeFlowMap, id<OrgApacheCommonsCollections15Factory> edgeFactory) {
  EduUciIcsJungAlgorithmsUtilIterativeProcess_init(self);
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_setAndConsume_residualCapacityMap_(self, new_JavaUtilHashMap_init());
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_setAndConsume_parentMap_(self, new_JavaUtilHashMap_init());
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_setAndConsume_parentCapacityMap_(self, new_JavaUtilHashMap_init());
  if ([((id<JavaUtilCollection>) nil_chk([((id<EduUciIcsJungGraphDirectedGraph>) nil_chk(directedGraph)) getVertices])) containsWithId:source] == NO || [((id<JavaUtilCollection>) nil_chk([directedGraph getVertices])) containsWithId:sink] == NO) {
    @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"source and sink vertices must be elements of the specified graph") autorelease];
  }
  if ([nil_chk(source) isEqual:sink]) {
    @throw [new_JavaLangIllegalArgumentException_initWithNSString_(@"source and sink vertices must be distinct") autorelease];
  }
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_set_mOriginalGraph_(self, directedGraph);
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_set_source_(self, source);
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_set_target_(self, sink);
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_set_edgeFlowMap_(self, edgeFlowMap);
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_set_edgeCapacityTransformer_(self, edgeCapacityTransformer);
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_set_edgeFactory_(self, edgeFactory);
  @try {
    EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_set_mFlowGraph_(self, (id<EduUciIcsJungGraphDirectedGraph>) check_protocol_cast([directedGraph newInstance], @protocol(EduUciIcsJungGraphDirectedGraph)));
    for (id __strong e in nil_chk([self->mOriginalGraph_ getEdges])) {
      [((id<EduUciIcsJungGraphDirectedGraph>) nil_chk(self->mFlowGraph_)) addEdgeWithId:e withId:[self->mOriginalGraph_ getSourceWithId:e] withId:[self->mOriginalGraph_ getDestWithId:e] withEduUciIcsJungGraphUtilEdgeTypeEnum:EduUciIcsJungGraphUtilEdgeTypeEnum_get_DIRECTED()];
    }
    for (id __strong v in nil_chk([self->mOriginalGraph_ getVertices])) {
      [((id<EduUciIcsJungGraphDirectedGraph>) nil_chk(self->mFlowGraph_)) addVertexWithId:v];
    }
  }
  @catch (JavaLangException *e) {
    [((JavaLangException *) nil_chk(e)) printStackTrace];
  }
  self->mMaxFlow_ = 0;
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_setAndConsume_mSinkPartitionNodes_(self, new_JavaUtilHashSet_init());
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_setAndConsume_mSourcePartitionNodes_(self, new_JavaUtilHashSet_init());
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_setAndConsume_mMinCutEdges_(self, new_JavaUtilHashSet_init());
}

EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *new_EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_initWithEduUciIcsJungGraphDirectedGraph_withId_withId_withOrgApacheCommonsCollections15Transformer_withJavaUtilMap_withOrgApacheCommonsCollections15Factory_(id<EduUciIcsJungGraphDirectedGraph> directedGraph, id source, id sink, id<OrgApacheCommonsCollections15Transformer> edgeCapacityTransformer, id<JavaUtilMap> edgeFlowMap, id<OrgApacheCommonsCollections15Factory> edgeFactory) {
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *self = [EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow alloc];
  EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_initWithEduUciIcsJungGraphDirectedGraph_withId_withId_withOrgApacheCommonsCollections15Transformer_withJavaUtilMap_withOrgApacheCommonsCollections15Factory_(self, directedGraph, source, sink, edgeCapacityTransformer, edgeFlowMap, edgeFactory);
  return self;
}

void EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_clearParentValues(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *self) {
  [((id<JavaUtilMap>) nil_chk(self->parentMap_)) clear];
  [((id<JavaUtilMap>) nil_chk(self->parentCapacityMap_)) clear];
  [self->parentCapacityMap_ putWithId:self->source_ withId:JavaLangInteger_valueOfWithInt_(JavaLangInteger_MAX_VALUE)];
  [self->parentMap_ putWithId:self->source_ withId:self->source_];
}

void EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_computeMinCut(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *self) {
  for (id __strong e in nil_chk([((id<EduUciIcsJungGraphDirectedGraph>) nil_chk(self->mOriginalGraph_)) getEdges])) {
    id source = [self->mOriginalGraph_ getSourceWithId:e];
    id destination = [self->mOriginalGraph_ getDestWithId:e];
    if ([((id<JavaUtilSet>) nil_chk(self->mSinkPartitionNodes_)) containsWithId:source] && [self->mSinkPartitionNodes_ containsWithId:destination]) {
      continue;
    }
    if ([((id<JavaUtilSet>) nil_chk(self->mSourcePartitionNodes_)) containsWithId:source] && [self->mSourcePartitionNodes_ containsWithId:destination]) {
      continue;
    }
    if ([self->mSinkPartitionNodes_ containsWithId:source] && [self->mSourcePartitionNodes_ containsWithId:destination]) {
      continue;
    }
    [((id<JavaUtilSet>) nil_chk(self->mMinCutEdges_)) addWithId:e];
  }
}

void EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow_updateResidualCapacities(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow *self) {
  NSNumber *augmentingPathCapacity = [((id<JavaUtilMap>) nil_chk(self->parentCapacityMap_)) getWithId:self->target_];
  self->mMaxFlow_ += [((NSNumber *) nil_chk(augmentingPathCapacity)) intValue];
  id currentVertex = self->target_;
  id parentVertex = nil;
  while ((parentVertex = [((id<JavaUtilMap>) nil_chk(self->parentMap_)) getWithId:currentVertex]) != currentVertex) {
    id currentEdge = [((id<EduUciIcsJungGraphDirectedGraph>) nil_chk(self->mFlowGraph_)) findEdgeWithId:parentVertex withId:currentVertex];
    NSNumber *residualCapacity = [((id<JavaUtilMap>) nil_chk(self->residualCapacityMap_)) getWithId:currentEdge];
    residualCapacity = JavaLangInteger_valueOfWithInt_([((NSNumber *) nil_chk(residualCapacity)) intValue] - [augmentingPathCapacity intValue]);
    [self->residualCapacityMap_ putWithId:currentEdge withId:residualCapacity];
    id backEdge = [self->mFlowGraph_ findEdgeWithId:currentVertex withId:parentVertex];
    residualCapacity = [self->residualCapacityMap_ getWithId:backEdge];
    residualCapacity = JavaLangInteger_valueOfWithInt_([((NSNumber *) nil_chk(residualCapacity)) intValue] + [augmentingPathCapacity intValue]);
    [self->residualCapacityMap_ putWithId:backEdge withId:residualCapacity];
    currentVertex = parentVertex;
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(EduUciIcsJungAlgorithmsFlowsEdmondsKarpMaxFlow)
