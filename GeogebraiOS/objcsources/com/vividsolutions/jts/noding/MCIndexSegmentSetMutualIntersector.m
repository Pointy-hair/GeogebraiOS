//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeogebraiOS/GeogebraiOS/sources/com/vividsolutions/jts/noding/MCIndexSegmentSetMutualIntersector.java
//


#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/vividsolutions/jts/geom/Envelope.h"
#include "com/vividsolutions/jts/index/SpatialIndex.h"
#include "com/vividsolutions/jts/index/chain/MonotoneChain.h"
#include "com/vividsolutions/jts/index/chain/MonotoneChainBuilder.h"
#include "com/vividsolutions/jts/index/chain/MonotoneChainOverlapAction.h"
#include "com/vividsolutions/jts/index/strtree/STRtree.h"
#include "com/vividsolutions/jts/noding/MCIndexSegmentSetMutualIntersector.h"
#include "com/vividsolutions/jts/noding/SegmentIntersector.h"
#include "com/vividsolutions/jts/noding/SegmentSetMutualIntersector.h"
#include "com/vividsolutions/jts/noding/SegmentString.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"

@interface ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector () {
 @public
  id<JavaUtilList> monoChains_;
  id<ComVividsolutionsJtsIndexSpatialIndex> index_;
  jint indexCounter_;
  jint processCounter_;
  jint nOverlaps_;
}

- (void)addToIndexWithComVividsolutionsJtsNodingSegmentString:(id<ComVividsolutionsJtsNodingSegmentString>)segStr;

- (void)intersectChains;

- (void)addToMonoChainsWithComVividsolutionsJtsNodingSegmentString:(id<ComVividsolutionsJtsNodingSegmentString>)segStr;

@end

J2OBJC_FIELD_SETTER(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector, monoChains_, id<JavaUtilList>)
J2OBJC_FIELD_SETTER(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector, index_, id<ComVividsolutionsJtsIndexSpatialIndex>)

__attribute__((unused)) static void ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_addToIndexWithComVividsolutionsJtsNodingSegmentString_(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *self, id<ComVividsolutionsJtsNodingSegmentString> segStr);

__attribute__((unused)) static void ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_intersectChains(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *self);

__attribute__((unused)) static void ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_addToMonoChainsWithComVividsolutionsJtsNodingSegmentString_(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *self, id<ComVividsolutionsJtsNodingSegmentString> segStr);

@interface ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction () {
 @public
  id<ComVividsolutionsJtsNodingSegmentIntersector> si_;
}

@end

J2OBJC_FIELD_SETTER(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction, si_, id<ComVividsolutionsJtsNodingSegmentIntersector>)

@implementation ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector

- (instancetype)init {
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_init(self);
  return self;
}

- (id<JavaUtilList>)getMonotoneChains {
  return monoChains_;
}

- (id<ComVividsolutionsJtsIndexSpatialIndex>)getIndex {
  return index_;
}

- (void)setBaseSegmentsWithJavaUtilCollection:(id<JavaUtilCollection>)segStrings {
  for (id<JavaUtilIterator> i = [((id<JavaUtilCollection>) nil_chk(segStrings)) iterator]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
    ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_addToIndexWithComVividsolutionsJtsNodingSegmentString_(self, (id<ComVividsolutionsJtsNodingSegmentString>) check_protocol_cast([i next], @protocol(ComVividsolutionsJtsNodingSegmentString)));
  }
}

- (void)addToIndexWithComVividsolutionsJtsNodingSegmentString:(id<ComVividsolutionsJtsNodingSegmentString>)segStr {
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_addToIndexWithComVividsolutionsJtsNodingSegmentString_(self, segStr);
}

- (void)processWithJavaUtilCollection:(id<JavaUtilCollection>)segStrings {
  processCounter_ = indexCounter_ + 1;
  nOverlaps_ = 0;
  [((id<JavaUtilList>) nil_chk(monoChains_)) clear];
  for (id<JavaUtilIterator> i = [((id<JavaUtilCollection>) nil_chk(segStrings)) iterator]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
    ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_addToMonoChainsWithComVividsolutionsJtsNodingSegmentString_(self, (id<ComVividsolutionsJtsNodingSegmentString>) check_protocol_cast([i next], @protocol(ComVividsolutionsJtsNodingSegmentString)));
  }
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_intersectChains(self);
}

- (void)intersectChains {
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_intersectChains(self);
}

- (void)addToMonoChainsWithComVividsolutionsJtsNodingSegmentString:(id<ComVividsolutionsJtsNodingSegmentString>)segStr {
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_addToMonoChainsWithComVividsolutionsJtsNodingSegmentString_(self, segStr);
}

- (void)dealloc {
  RELEASE_(monoChains_);
  RELEASE_(index_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "init", "MCIndexSegmentSetMutualIntersector", NULL, 0x1, NULL, NULL },
    { "getMonotoneChains", NULL, "Ljava.util.List;", 0x1, NULL, NULL },
    { "getIndex", NULL, "Lcom.vividsolutions.jts.index.SpatialIndex;", 0x1, NULL, NULL },
    { "setBaseSegmentsWithJavaUtilCollection:", "setBaseSegments", "V", 0x1, NULL, NULL },
    { "addToIndexWithComVividsolutionsJtsNodingSegmentString:", "addToIndex", "V", 0x2, NULL, NULL },
    { "processWithJavaUtilCollection:", "process", "V", 0x1, NULL, NULL },
    { "intersectChains", NULL, "V", 0x2, NULL, NULL },
    { "addToMonoChainsWithComVividsolutionsJtsNodingSegmentString:", "addToMonoChains", "V", 0x2, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "monoChains_", NULL, 0x2, "Ljava.util.List;", NULL, NULL,  },
    { "index_", NULL, 0x2, "Lcom.vividsolutions.jts.index.SpatialIndex;", NULL, NULL,  },
    { "indexCounter_", NULL, 0x2, "I", NULL, NULL,  },
    { "processCounter_", NULL, 0x2, "I", NULL, NULL,  },
    { "nOverlaps_", NULL, 0x2, "I", NULL, NULL,  },
  };
  static const char *inner_classes[] = {"Lcom.vividsolutions.jts.noding.MCIndexSegmentSetMutualIntersector$SegmentOverlapAction;"};
  static const J2ObjcClassInfo _ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector = { 2, "MCIndexSegmentSetMutualIntersector", "com.vividsolutions.jts.noding", NULL, 0x1, 8, methods, 5, fields, 0, NULL, 1, inner_classes, NULL, NULL };
  return &_ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector;
}

@end

void ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_init(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *self) {
  ComVividsolutionsJtsNodingSegmentSetMutualIntersector_init(self);
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_setAndConsume_monoChains_(self, new_JavaUtilArrayList_init());
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_setAndConsume_index_(self, new_ComVividsolutionsJtsIndexStrtreeSTRtree_init());
  self->indexCounter_ = 0;
  self->processCounter_ = 0;
  self->nOverlaps_ = 0;
}

ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *new_ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_init() {
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *self = [ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector alloc];
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_init(self);
  return self;
}

void ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_addToIndexWithComVividsolutionsJtsNodingSegmentString_(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *self, id<ComVividsolutionsJtsNodingSegmentString> segStr) {
  id<JavaUtilList> segChains = ComVividsolutionsJtsIndexChainMonotoneChainBuilder_getChainsWithComVividsolutionsJtsGeomCoordinateArray_withId_([((id<ComVividsolutionsJtsNodingSegmentString>) nil_chk(segStr)) getCoordinates], segStr);
  for (id<JavaUtilIterator> i = [((id<JavaUtilList>) nil_chk(segChains)) iterator]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
    ComVividsolutionsJtsIndexChainMonotoneChain *mc = (ComVividsolutionsJtsIndexChainMonotoneChain *) check_class_cast([i next], [ComVividsolutionsJtsIndexChainMonotoneChain class]);
    [((ComVividsolutionsJtsIndexChainMonotoneChain *) nil_chk(mc)) setIdWithInt:self->indexCounter_++];
    [((id<ComVividsolutionsJtsIndexSpatialIndex>) nil_chk(self->index_)) insertWithComVividsolutionsJtsGeomEnvelope:[mc getEnvelope] withId:mc];
  }
}

void ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_intersectChains(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *self) {
  ComVividsolutionsJtsIndexChainMonotoneChainOverlapAction *overlapAction = [new_ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction_initWithComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_withComVividsolutionsJtsNodingSegmentIntersector_(self, self->segInt_) autorelease];
  for (id<JavaUtilIterator> i = [((id<JavaUtilList>) nil_chk(self->monoChains_)) iterator]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
    ComVividsolutionsJtsIndexChainMonotoneChain *queryChain = (ComVividsolutionsJtsIndexChainMonotoneChain *) check_class_cast([i next], [ComVividsolutionsJtsIndexChainMonotoneChain class]);
    id<JavaUtilList> overlapChains = [((id<ComVividsolutionsJtsIndexSpatialIndex>) nil_chk(self->index_)) queryWithComVividsolutionsJtsGeomEnvelope:[((ComVividsolutionsJtsIndexChainMonotoneChain *) nil_chk(queryChain)) getEnvelope]];
    for (id<JavaUtilIterator> j = [((id<JavaUtilList>) nil_chk(overlapChains)) iterator]; [((id<JavaUtilIterator>) nil_chk(j)) hasNext]; ) {
      ComVividsolutionsJtsIndexChainMonotoneChain *testChain = (ComVividsolutionsJtsIndexChainMonotoneChain *) check_class_cast([j next], [ComVividsolutionsJtsIndexChainMonotoneChain class]);
      [queryChain computeOverlapsWithComVividsolutionsJtsIndexChainMonotoneChain:testChain withComVividsolutionsJtsIndexChainMonotoneChainOverlapAction:overlapAction];
      self->nOverlaps_++;
      if ([((id<ComVividsolutionsJtsNodingSegmentIntersector>) nil_chk(self->segInt_)) isDone]) return;
    }
  }
}

void ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_addToMonoChainsWithComVividsolutionsJtsNodingSegmentString_(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *self, id<ComVividsolutionsJtsNodingSegmentString> segStr) {
  id<JavaUtilList> segChains = ComVividsolutionsJtsIndexChainMonotoneChainBuilder_getChainsWithComVividsolutionsJtsGeomCoordinateArray_withId_([((id<ComVividsolutionsJtsNodingSegmentString>) nil_chk(segStr)) getCoordinates], segStr);
  for (id<JavaUtilIterator> i = [((id<JavaUtilList>) nil_chk(segChains)) iterator]; [((id<JavaUtilIterator>) nil_chk(i)) hasNext]; ) {
    ComVividsolutionsJtsIndexChainMonotoneChain *mc = (ComVividsolutionsJtsIndexChainMonotoneChain *) check_class_cast([i next], [ComVividsolutionsJtsIndexChainMonotoneChain class]);
    [((ComVividsolutionsJtsIndexChainMonotoneChain *) nil_chk(mc)) setIdWithInt:self->processCounter_++];
    [((id<JavaUtilList>) nil_chk(self->monoChains_)) addWithId:mc];
  }
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector)

@implementation ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction

- (instancetype)initWithComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector:(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *)outer$
                                    withComVividsolutionsJtsNodingSegmentIntersector:(id<ComVividsolutionsJtsNodingSegmentIntersector>)si {
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction_initWithComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_withComVividsolutionsJtsNodingSegmentIntersector_(self, outer$, si);
  return self;
}

- (void)overlapWithComVividsolutionsJtsIndexChainMonotoneChain:(ComVividsolutionsJtsIndexChainMonotoneChain *)mc1
                                                       withInt:(jint)start1
               withComVividsolutionsJtsIndexChainMonotoneChain:(ComVividsolutionsJtsIndexChainMonotoneChain *)mc2
                                                       withInt:(jint)start2 {
  id<ComVividsolutionsJtsNodingSegmentString> ss1 = (id<ComVividsolutionsJtsNodingSegmentString>) check_protocol_cast([((ComVividsolutionsJtsIndexChainMonotoneChain *) nil_chk(mc1)) getContext], @protocol(ComVividsolutionsJtsNodingSegmentString));
  id<ComVividsolutionsJtsNodingSegmentString> ss2 = (id<ComVividsolutionsJtsNodingSegmentString>) check_protocol_cast([((ComVividsolutionsJtsIndexChainMonotoneChain *) nil_chk(mc2)) getContext], @protocol(ComVividsolutionsJtsNodingSegmentString));
  [((id<ComVividsolutionsJtsNodingSegmentIntersector>) nil_chk(si_)) processIntersectionsWithComVividsolutionsJtsNodingSegmentString:ss1 withInt:start1 withComVividsolutionsJtsNodingSegmentString:ss2 withInt:start2];
}

- (void)dealloc {
  RELEASE_(si_);
  [super dealloc];
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "initWithComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector:withComVividsolutionsJtsNodingSegmentIntersector:", "SegmentOverlapAction", NULL, 0x1, NULL, NULL },
    { "overlapWithComVividsolutionsJtsIndexChainMonotoneChain:withInt:withComVividsolutionsJtsIndexChainMonotoneChain:withInt:", "overlap", "V", 0x1, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "si_", NULL, 0x2, "Lcom.vividsolutions.jts.noding.SegmentIntersector;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction = { 2, "SegmentOverlapAction", "com.vividsolutions.jts.noding", "MCIndexSegmentSetMutualIntersector", 0x1, 2, methods, 1, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction;
}

@end

void ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction_initWithComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_withComVividsolutionsJtsNodingSegmentIntersector_(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction *self, ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *outer$, id<ComVividsolutionsJtsNodingSegmentIntersector> si) {
  ComVividsolutionsJtsIndexChainMonotoneChainOverlapAction_init(self);
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction_set_si_(self, nil);
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction_set_si_(self, si);
}

ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction *new_ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction_initWithComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_withComVividsolutionsJtsNodingSegmentIntersector_(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector *outer$, id<ComVividsolutionsJtsNodingSegmentIntersector> si) {
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction *self = [ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction alloc];
  ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction_initWithComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_withComVividsolutionsJtsNodingSegmentIntersector_(self, outer$, si);
  return self;
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComVividsolutionsJtsNodingMCIndexSegmentSetMutualIntersector_SegmentOverlapAction)
