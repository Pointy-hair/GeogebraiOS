//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/jacky/GSoC/GeoGebraiOSARC/GeoGebraiOSARC/javasources/com/vividsolutions/jts/index/bintree/NodeBase.java
//


#include "IOSObjectArray.h"
#include "J2ObjC_source.h"
#include "com/vividsolutions/jts/index/bintree/Interval.h"
#include "com/vividsolutions/jts/index/bintree/Node.h"
#include "com/vividsolutions/jts/index/bintree/NodeBase.h"
#include "java/util/ArrayList.h"
#include "java/util/Collection.h"
#include "java/util/List.h"

@implementation ComVividsolutionsJtsIndexBintreeNodeBase

+ (jint)getSubnodeIndexWithComVividsolutionsJtsIndexBintreeInterval:(ComVividsolutionsJtsIndexBintreeInterval *)interval
                                                         withDouble:(jdouble)centre {
  return ComVividsolutionsJtsIndexBintreeNodeBase_getSubnodeIndexWithComVividsolutionsJtsIndexBintreeInterval_withDouble_(interval, centre);
}

- (instancetype)init {
  ComVividsolutionsJtsIndexBintreeNodeBase_init(self);
  return self;
}

- (id<JavaUtilList>)getItems {
  return items_;
}

- (void)addWithId:(id)item {
  [((id<JavaUtilList>) nil_chk(items_)) addWithId:item];
}

- (id<JavaUtilList>)addAllItemsWithJavaUtilList:(id<JavaUtilList>)items {
  [((id<JavaUtilList>) nil_chk(items)) addAllWithJavaUtilCollection:self->items_];
  for (jint i = 0; i < 2; i++) {
    if (IOSObjectArray_Get(nil_chk(subnode_), i) != nil) {
      (void) [((ComVividsolutionsJtsIndexBintreeNode *) nil_chk(IOSObjectArray_Get(subnode_, i))) addAllItemsWithJavaUtilList:items];
    }
  }
  return items;
}

- (jboolean)isSearchMatchWithComVividsolutionsJtsIndexBintreeInterval:(ComVividsolutionsJtsIndexBintreeInterval *)interval {
  // can't call an abstract method
  [self doesNotRecognizeSelector:_cmd];
  return 0;
}

- (id<JavaUtilList>)addAllItemsFromOverlappingWithComVividsolutionsJtsIndexBintreeInterval:(ComVividsolutionsJtsIndexBintreeInterval *)interval
                                                                    withJavaUtilCollection:(id<JavaUtilCollection>)resultItems {
  if (![self isSearchMatchWithComVividsolutionsJtsIndexBintreeInterval:interval]) return items_;
  [((id<JavaUtilCollection>) nil_chk(resultItems)) addAllWithJavaUtilCollection:items_];
  for (jint i = 0; i < 2; i++) {
    if (IOSObjectArray_Get(nil_chk(subnode_), i) != nil) {
      (void) [((ComVividsolutionsJtsIndexBintreeNode *) nil_chk(IOSObjectArray_Get(subnode_, i))) addAllItemsFromOverlappingWithComVividsolutionsJtsIndexBintreeInterval:interval withJavaUtilCollection:resultItems];
    }
  }
  return items_;
}

- (jint)depth {
  jint maxSubDepth = 0;
  for (jint i = 0; i < 2; i++) {
    if (IOSObjectArray_Get(nil_chk(subnode_), i) != nil) {
      jint sqd = [((ComVividsolutionsJtsIndexBintreeNode *) nil_chk(IOSObjectArray_Get(subnode_, i))) depth];
      if (sqd > maxSubDepth) maxSubDepth = sqd;
    }
  }
  return maxSubDepth + 1;
}

- (jint)size {
  jint subSize = 0;
  for (jint i = 0; i < 2; i++) {
    if (IOSObjectArray_Get(nil_chk(subnode_), i) != nil) {
      subSize += [((ComVividsolutionsJtsIndexBintreeNode *) nil_chk(IOSObjectArray_Get(subnode_, i))) size];
    }
  }
  return subSize + [((id<JavaUtilList>) nil_chk(items_)) size];
}

- (jint)nodeSize {
  jint subSize = 0;
  for (jint i = 0; i < 2; i++) {
    if (IOSObjectArray_Get(nil_chk(subnode_), i) != nil) {
      subSize += [((ComVividsolutionsJtsIndexBintreeNode *) nil_chk(IOSObjectArray_Get(subnode_, i))) nodeSize];
    }
  }
  return subSize + 1;
}

+ (const J2ObjcClassInfo *)__metadata {
  static const J2ObjcMethodInfo methods[] = {
    { "getSubnodeIndexWithComVividsolutionsJtsIndexBintreeInterval:withDouble:", "getSubnodeIndex", "I", 0x9, NULL, NULL },
    { "init", "NodeBase", NULL, 0x1, NULL, NULL },
    { "getItems", NULL, "Ljava.util.List;", 0x1, NULL, NULL },
    { "addWithId:", "add", "V", 0x1, NULL, NULL },
    { "addAllItemsWithJavaUtilList:", "addAllItems", "Ljava.util.List;", 0x1, NULL, NULL },
    { "isSearchMatchWithComVividsolutionsJtsIndexBintreeInterval:", "isSearchMatch", "Z", 0x404, NULL, NULL },
    { "addAllItemsFromOverlappingWithComVividsolutionsJtsIndexBintreeInterval:withJavaUtilCollection:", "addAllItemsFromOverlapping", "Ljava.util.List;", 0x1, NULL, NULL },
    { "depth", NULL, "I", 0x0, NULL, NULL },
    { "size", NULL, "I", 0x0, NULL, NULL },
    { "nodeSize", NULL, "I", 0x0, NULL, NULL },
  };
  static const J2ObjcFieldInfo fields[] = {
    { "items_", NULL, 0x4, "Ljava.util.List;", NULL, NULL,  },
    { "subnode_", NULL, 0x4, "[Lcom.vividsolutions.jts.index.bintree.Node;", NULL, NULL,  },
  };
  static const J2ObjcClassInfo _ComVividsolutionsJtsIndexBintreeNodeBase = { 2, "NodeBase", "com.vividsolutions.jts.index.bintree", NULL, 0x401, 10, methods, 2, fields, 0, NULL, 0, NULL, NULL, NULL };
  return &_ComVividsolutionsJtsIndexBintreeNodeBase;
}

@end

jint ComVividsolutionsJtsIndexBintreeNodeBase_getSubnodeIndexWithComVividsolutionsJtsIndexBintreeInterval_withDouble_(ComVividsolutionsJtsIndexBintreeInterval *interval, jdouble centre) {
  ComVividsolutionsJtsIndexBintreeNodeBase_initialize();
  jint subnodeIndex = -1;
  if (((ComVividsolutionsJtsIndexBintreeInterval *) nil_chk(interval))->min_ >= centre) subnodeIndex = 1;
  if (interval->max_ <= centre) subnodeIndex = 0;
  return subnodeIndex;
}

void ComVividsolutionsJtsIndexBintreeNodeBase_init(ComVividsolutionsJtsIndexBintreeNodeBase *self) {
  (void) NSObject_init(self);
  self->items_ = new_JavaUtilArrayList_init();
  self->subnode_ = [IOSObjectArray newArrayWithLength:2 type:ComVividsolutionsJtsIndexBintreeNode_class_()];
}

J2OBJC_CLASS_TYPE_LITERAL_SOURCE(ComVividsolutionsJtsIndexBintreeNodeBase)
