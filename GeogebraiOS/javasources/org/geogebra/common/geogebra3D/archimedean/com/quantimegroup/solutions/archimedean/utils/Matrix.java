/*
Archimedean 1.1, a 3D applet/application for visualizing, building, 
transforming and analyzing Archimedean solids and their derivatives.
Copyright 1998, 2011 Raffi J. Kasparian, www.raffikasparian.com.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package org.geogebra.common.geogebra3D.archimedean.com.quantimegroup.solutions.archimedean.utils;public class Matrix {	public double[][] mat;	Matrix() {	}	Matrix(int numRow, int numCol) {		mat = new double[numRow][numCol];	}	Matrix(OrderedTriple X, OrderedTriple Y, OrderedTriple Z) {		double[] mx = {				X.x, Y.x, Z.x };		double[] my = {				X.y, Y.y, Z.y };		double[] mz = {				X.z, Y.z, Z.z };		double[][] m = {				mx, my, mz };		mat = m;	}	Matrix(double[][] m) {		mat = m;	}	static Matrix identity(int r) {		Matrix M = new Matrix(r, r);		for (int i = 0; i < r; ++i) {			M.mat[i][i] = 1;		}		return M;	}	Matrix(Matrix m) {		this(m.numRows(), m.numColumns());		for (int i = 0; i < numColumns(); ++i) {			System.arraycopy(m.mat[i], 0, mat[i], 0, numRows());		}	}	int numRows() {		return mat.length;	}	int numColumns() {		return mat[0].length;	}	double[][] mat() {		return mat;	}	Matrix times(double x) {		Matrix A = new Matrix(numRows(), numColumns());		for (int r = 0; r < numRows(); ++r) {			for (int c = 0; c < numColumns(); ++c) {				A.mat[r][c] = mat[r][c] * x;			}		}		return A;	}	void timesEquals(double x) {		Matrix A = new Matrix(numRows(), numColumns());		for (int r = 0; r < numRows(); ++r) {			for (int c = 0; c < numColumns(); ++c) {				A.mat[r][c] = mat[r][c] * x;			}		}		mat = A.mat;	}	Matrix dividedBy(double x) {		return times(1 / x);	}	void dividedByEquals(double x) {		timesEquals(1 / x);	}	Matrix plus(Matrix B) {		// A + B = C		Matrix A = this;		if (B.numRows() != A.numRows() || B.numColumns() != A.numColumns())			return null;		Matrix C = new Matrix(A.numRows(), A.numColumns());		for (int r = 0; r < C.numRows(); ++r) {			for (int c = 0; c < C.numColumns(); ++c) {				C.mat[r][c] = A.mat[r][c] + B.mat[r][c];			}		}		return C;	}	Matrix minus(Matrix B) {		return plus(B.times(-1));	}	OrderedTriple times(OrderedTriple p) {		// rotates a point around the origin		// Convert the point to Matrix format		Matrix M = new Matrix();		double[] mx = { p.x };		double[] my = { p.y };		double[] mz = { p.z };		double[][] m = {				mx, my, mz };		M.mat = m;		// Perform the multiplication		M.timesEquals(this);		// Return the result in OrderedTriple format		return new OrderedTriple(M.mat[0][0], M.mat[1][0], M.mat[2][0]);	}	protected Matrix times(Matrix B) {		// A * B = C		Matrix A = this;		if (B.numRows() != A.numColumns())			return null;		Matrix C = new Matrix(A.numRows(), B.numColumns());		for (int r = 0; r < C.numRows(); ++r) {			for (int c = 0; c < C.numColumns(); ++c) {				for (int x = 0; x < A.numColumns(); ++x) {					C.mat[r][c] += A.mat[r][x] * B.mat[x][c];				}			}		}		return C;	}	void timesEquals(Matrix B) {		// this = B * this		mat = B.times(this).mat;	}	Matrix dividedBy(Matrix B) {		// A * B = C		try {			return times(B.inverse());		} catch (Exception e) {			return null;		}	}	double determinant() throws Exception {		if (numRows() != numColumns())			throw new Exception("numRows != numColumns");		double result = 0;		if (numRows() == 2) {			result = mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];		} else {			for (int j = 0; j < numRows(); ++j) {				Matrix M = minor(0, j);				result += mat[0][j] * (j % 2 == 0 ? M.determinant() : -M.determinant());			}		}		return result;	}	Matrix minor(int r, int c) {		if (numRows() != numColumns())			return null;		Matrix M = new Matrix(numRows() - 1, numColumns() - 1);		for (int i = 0, Mi = 0; i < numRows(); ++i) {			if (i == r)				continue;			for (int j = 0, Mj = 0; j < numColumns(); ++j) {				if (j == c)					continue;				M.mat[Mi][Mj] = mat[i][j];				Mj++;			}			Mi++;		}		return M;	}	Matrix adjoint() {		if (numRows() != numColumns())			return null;		Matrix A = new Matrix(numRows(), numColumns());		for (int r = 0; r < A.numRows(); ++r) {			for (int c = 0; c < A.numColumns(); ++c) {				try {					A.mat[c][r] = (r + c) % 2 == 0 ? minor(r, c).determinant() : -minor(r, c).determinant();				} catch (Exception e) {					return null;				}			}		}		return A;	}	Matrix transpose() {		Matrix T = new Matrix(numColumns(), numRows());		for (int r = 0; r < T.numRows(); ++r) {			for (int c = 0; c < T.numColumns(); ++c) {				T.mat[r][c] = mat[c][r];			}		}		return T;	}	Matrix inverse() {		if (numRows() != numColumns())			return null;		try {			return adjoint().dividedBy(determinant());		} catch (Exception e) {			return null;		}	}	boolean equals(Matrix m) {		for (int i = 0; i < numRows(); ++i) {			for (int j = 0; j < numColumns(); ++j) {				if (mat[i][j] != m.mat[i][j])					return false;			}		}		return true;	}}