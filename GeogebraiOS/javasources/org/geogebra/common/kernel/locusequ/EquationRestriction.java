/**
 * 
 */
package org.geogebra.common.kernel.locusequ;

import org.geogebra.common.kernel.algos.AlgoElement;
import org.geogebra.common.kernel.geos.GeoElement;
import org.geogebra.common.kernel.geos.GeoPoint;

/**
 * @author sergio
 * A restriction is a special kind of EquationElement.
 * In general, an EquationElement retrieves a list of
 * equations given a point. A EquationRestriction has
 * a GeoElement that is itself a point so it can generate
 * a list of equations without any other point.
 * 
 * The resst of EquationElements are there just for help.
 * 
 * Example:
 * 
 * When building a circle, the important part is the conic
 * and it does not generate any kind of restriction in the locus.
 * A point in that conic is generated by AlgoIntersectConic,
 * and the important part of that construction is the algo, not
 * the geo (always a point).
 */
public abstract class EquationRestriction extends EquationElement {

	private AlgoElement algo;
	private EquationList equationList;
	
	/**
	 * Empty constructor in case any subclass needs it.
	 */
	protected EquationRestriction() {}
	
	/**
	 * General constructor.
	 * @param element {@link GeoElement}
	 * @param algo {@link AlgoElement}
	 * @param scope {@link EquationScope}
	 */
	public EquationRestriction(final GeoElement element, final AlgoElement algo, final EquationScope scope) {
		super(element, scope);
		this.algo = algo;
	}
	
	/**
	 * @return parent algorithm
	 */
	public AlgoElement getAlgo() {
		return algo;
	}

	/**
	 * Sets parent algorithm. This should not be used unless strictly necessary.
	 * @param algo new {@link AlgoElement}
	 */
	protected void setAlgo(final AlgoElement algo) {
		this.algo = algo;
	}
	
	/**
	 * @param list the new equation list.
	 */
	protected void setEquationList(final EquationList list) {
		this.equationList = new EquationList(list);
	}
	
	/**
	 * @return the equation list for this restriction.
	 */
	public EquationList getEquationList() {
		if(this.equationList == null) {
			this.computeEquationList();
		}
		
		return this.equationList;
	}
	
	/**
	 * Computes and sets the equation list for this restriction.
	 * Though, it is encourage just to override forPointImpl.
	 */
	protected void computeEquationList() {
		EquationList list = new EquationList();
		
		AlgoElement element = this.getAlgo();
		
		GeoElement[] output = element.getOutput();
		
		for(GeoElement out : output){
			if(out.isGeoPoint()) {
				list.addAll(this.forPoint(this.getScope().getPoint((GeoPoint) out)));
			}
		}
		
		this.setEquationList(list);
	}
	
	@Override
	public GeoPoint getResult() {
		return (GeoPoint) super.getResult();
	}

	@Override
	public boolean isRestriction() { return true; }

	public static EquationElement getEmptyRestriction() {
		return new EquationRestriction() {
			
			@Override
			public boolean isAlgebraic() {
				return true;
			}
			
			@Override
			protected EquationList forPointImpl(EquationPoint p) {
				return EquationList.getEmptyList();
			}
			
			@Override
			public void computeEquationList() {
				this.setEquationList(EquationList.getEmptyList());
			}
		};
	}
}
